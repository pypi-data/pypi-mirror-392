"""网络请求的相关功能"""

import requests
import urllib3
import re
from enum import StrEnum
from typing import IO
from requests.adapters import HTTPAdapter
from pathlib import Path
from dataclasses import dataclass
from .rand import ua
from .log import get_logger
from http.client import HTTPConnection
from http.client import HTTPSConnection
from http.client import HTTPResponse


__all__ = ["ContentType", "UploadFile", "URL", "ExpAdapter", "no_warn", "get_session", "save", "raw_request"]

type FileContent = IO[str | bytes] | str | bytes
URL_PATTERN = r'^(https?)://([^/]+)(/.*)?$'

logger = get_logger()


class ContentType(StrEnum):
    """在这里可以找到常见的 Content-Type 选项"""
    plain           = "text/plain"
    html            = "text/html"
    xml             = "text/xml"
    form            = "application/x-www-form-urlencoded"
    json            = "application/json"
    octet_stream    = "application/octet-stream"
    multipart       = "multipart/form-data"
    jpg             = "image/jpeg"
    png             = "image/png"
    gif             = "image/gif"


@dataclass
class UploadFile():
    name: str
    content: FileContent
    type: ContentType | str

    def to_tuple(self) -> tuple[str, FileContent, str]:
        return (self.name, self.content, str(self.type))


class URL():
    def __init__(self, url: str) -> None:
        m = re.match(URL_PATTERN, url)
        if not m:
            raise ValueError(f"{url} is not a url")
        self._protocol: str = m.group(1)
        self._address: str = m.group(2)
        self._route: Path = Path("/") / (m.group(3) or '')
    
    @property
    def protocol(self) -> str:
        """协议"""
        return self._protocol
    
    @property
    def address(self) -> str:
        """地址"""
        return self._address
    
    @property
    def route(self) -> str:
        """路由"""
        return self._route.as_posix()

    @property
    def root(self) -> "URL":
        """根路由"""
        return URL(f"{self.protocol}://{self.address}")
    
    @property
    def url(self) -> str:
        """完整路径"""
        return f"{self.protocol}://{self.address}{self.route}"
    
    def __str__(self) -> str:
        return self.url
    
    def __repr__(self) -> str:
        return f"URL(protocol={self.protocol}, address={self.address}, route={self.route})"
    
    def __truediv__(self, other: str) -> "URL":
        if not isinstance(other, str):
            raise TypeError()
        new_url = f"{self.protocol}://{self.address}{(self._route / other).as_posix()}"
        return URL(url=new_url)
    
    def __eq__(self, value: "URL") -> bool:
        return self.url == value.url
    
    def as_path(self) -> str:
        """转换为文件路径"""
        return self.url.replace("://", "_").replace(":", "_").replace("/", "_")


class ExpAdapter(HTTPAdapter):
    """
    专为编写 exp 设计的 http 适配器

    随机 UA 头, 5s 超时, 关闭 SSL 证书验证
    """
    def __init__(
            self,
            pool_size: int = 20,
            max_retries: int = 0,
            pool_block: bool = False,
            timeout: float = 5.0
        ) -> None:
        self.timeout = timeout
        super().__init__(
            pool_connections=pool_size,
            pool_maxsize=pool_size,
            max_retries=max_retries,
            pool_block=pool_block,
        )
    
    def send(self, request: requests.PreparedRequest, **kwargs):
        request.headers.setdefault("User-Agent", ua.random)
        if kwargs.get("timeout") is None:
            kwargs["timeout"] = self.timeout
        return super().send(request, **kwargs)


def no_warn() -> None:
    """禁用所有 HTTP 警告"""
    urllib3.disable_warnings(urllib3.exceptions.HTTPWarning)


def get_session(pool_size: int = 20, timeout: float = 5.0) -> requests.Session:
    """获取一个专门配置过的 session 对象"""
    adapter = ExpAdapter(pool_size=pool_size, timeout=timeout)

    session = requests.Session()
    session.verify = False
    session.mount("http://", adapter)
    session.mount("https://", adapter)

    return session


def save(
        resp: requests.Response,
        save_path: Path | str,
        ok_msg: str = "",
        err_msg: str = "",
    ) -> bool:
    """保存响应到指定位置, 可用于下载文件, 自动处理流式传输, 注意: 非线程安全"""
    try:
        with open(save_path, "wb") as file:
            for chunk in resp.iter_content(chunk_size=1024):
                file.write(chunk)
        logger.ok(ok_msg.format({"url": resp.url, "save_path": save_path})
                  or f"{resp.url} saved to {save_path}")
        return True
    except Exception as e:
        logger.error(err_msg.format({"url": resp.url, "err": e})
                     or f"{resp.url} download fail, error: {e}")
        return False


def raw_request(
        method: str,
        url: URL,
        headers: dict | None = None,
        body: str | None = None,
        timeout: float = 5.0,
    ) -> HTTPResponse:
    """使用 `http.client` 发起 HTTP 请求, 不会对报文内容进行 URL 编码, 所有编码操作需要你自己完成"""
    if headers is None:
        headers = {}
    
    port = 443 if url.protocol == "https" else 80
    address = url.address.split(':')
    if len(address) == 2:
        port = address[1]
    config = {
        "host": address[0],
        "port": port,
        "timeout": timeout,
    }
    conn = HTTPSConnection(**config) if url.protocol == "https" else HTTPConnection(**config)

    headers.setdefault("User-Agent", ua.random)
    conn.request(method, url.route, body, headers)

    return conn.getresponse()
