"""封装了执行系统命令相关的操作"""

import subprocess
import re


__all__ = ["BadReturnCode", "StdErr", "BadOutput", "Command", "run"]


class BadReturnCode(ValueError):
    def __init__(self, rc: int, *args) -> None:
        super().__init__(rc, *args)
        self.rc = rc


class StdErr(ValueError):
    def __init__(self, err: bytes, *args) -> None:
        super().__init__(err[:50], *args)
        self.err = err


class BadOutput(ValueError):
    def __init__(self, text: str, *args) -> None:
        super().__init__(text, *args)
        self.text = text


class Command():
    def __init__(self):
        self._rc: int = -1
        self._stdout: str | bytes = ""
        self._stderr: str | bytes = ""
    
    @property
    def rc(self) -> int:
        """退出码"""
        return self._rc
    
    @property
    def stdout(self) -> str | bytes:
        """标准输出"""
        return self._stdout

    @property
    def stderr(self) -> str | bytes:
        """标准错误"""
        return self._stderr
    
    def run(self, args: list[str], **options) -> "Command":
        """本地执行系统命令, 默认捕获文本输出"""
        options.setdefault("capture_output", True)
        options.setdefault("text", True)

        result = subprocess.run(args, **options)

        self._rc = result.returncode
        self._stdout = result.stdout
        self._stderr = result.stderr

        return self

    def raise_rc(self, *rc: int) -> "Command":
        """捕获特定退出码, 抛出 `BadReturnCode` 异常"""        
        if self._rc in rc:
            raise BadReturnCode(self._rc)
        return self

    def raise_err(self) -> "Command":
        """存在错误输出时抛出 `StdErr` 异常"""
        if self._stderr:
            raise StdErr(self._stderr)
        return self

    def raise_match(self, pattern: str, encoding: str = "utf-8") -> "Command":
        """捕获标准输出与错误输出中的特定模式, 抛出 `BadOutput` 异常"""
        stdout = self._stdout if isinstance(self._stdout, str) else self._stdout.decode(encoding)
        if m := re.search(pattern, stdout):
            raise BadOutput(m.group(0))
        
        stderr = self._stderr if isinstance(self._stderr, str) else self._stderr.decode(encoding)
        if m := re.search(pattern, stderr):
            raise BadOutput(m.group(0))

        return self


def run(cmd: list[str], **options) -> Command:
    """本地执行系统命令, 默认捕获文本输出"""
    return Command().run(cmd, **options)
