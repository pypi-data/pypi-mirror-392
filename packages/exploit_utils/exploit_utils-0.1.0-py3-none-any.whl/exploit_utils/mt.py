"""封装了多线程有关的功能"""

import threading
import queue
import functools
import tqdm
from typing import Iterable, Any, Mapping, Callable
from concurrent.futures import ThreadPoolExecutor as ThreadPool
from concurrent.futures import wait, as_completed, Future
from .misc import TqdmThemes


__all__ = [
    "ThreadPool", "wait", "STOP", "ThreadGroup", "create_threads",
    "consumer", "handle_fs"
]


STOP = object()
"""消费者停止信号"""


class ThreadGroup():
    """一组线程"""
    def __init__(self, threads: list[threading.Thread]):
        self._threads = threads

    def run(self) -> "ThreadGroup":
        """启动所有线程"""
        for t in self._threads:
            t.start()
        return self
    
    def join(self) -> None:
        """等待所有线程"""
        for t in self._threads:
            t.join()

    def __add__(self, other: "ThreadGroup") -> "ThreadGroup":
        if not isinstance(other, ThreadGroup):
            raise TypeError(f"unsupported operand type(s) for +: 'ThreadGroup' and '{type(other).__name__}'")
        return ThreadGroup(self._threads + other._threads)


def create_threads(
        target: Callable,
        args: Iterable[Any] = (),
        kwargs: Mapping[str, Any] | None = None,
        n: int = 1,
    ) -> ThreadGroup:
    """批量创建线程"""
    threads: list[threading.Thread] = []

    for _ in range(n):
        t = threading.Thread(target=target, args=args, kwargs=kwargs)
        threads.append(t)

    return ThreadGroup(threads)


def consumer(func: Callable) -> Callable:
    """
    快速实现 消费者 的装饰器, 关于该功能有三个约定:

    1. 装饰后函数的 "第一个位置参数" 为一个 `queue.Queue`, 运行时会从该队列获取任务
    2. 被装饰函数的 "第一个位置参数" 用于接收获取的任务
    3. 只能使用 `expliot_utils.mthread.STOP` 作为停止信号

    example:
    ```
    task_queue = queue.Queue()
    @consumer
    # attack 函数的第一个参数 url 用于接收 queue.Queue.get()
    def attack(url: str, debug: bool) -> None:
        ...
    # task_queue 必须在 args 的第一位
    threading.Thread(target=attack, args=(task_queue,), kwargs={"debug": False})
    threading.Thread(target=attack, args=(task_queue, False))
    ```
    """
    @functools.wraps(func)
    def wrap(*args, **kwargs) -> None:
        q: queue.Queue = args[0]
        while True:
            item = q.get()
            if item == STOP:
                q.put(STOP)
                break
            func(item, *args, **kwargs)
    
    return wrap


def handle_fs(
        fs: Iterable[Future],
        func: Callable[[Future], Any] = None,
        theme: dict = TqdmThemes.classic
    ) -> None:
    """
    对 future 集合处理方法的封装
    
    为 future 的完成情况添加进度条  
    在完成后会使用入参 `func` 进行处理
    """
    for f in tqdm.tqdm(as_completed(fs), total=len(fs), **theme):
        if func:
            func(f)
