"""封装了对于文件系统的操作"""

import os
import tempfile
import sys
import json
import threading
import logging
from pathlib import Path
from typing import Any, Callable, Iterator
from http.server import SimpleHTTPRequestHandler
from http.server import ThreadingHTTPServer
from .log import get_logger
from contextlib import contextmanager


__all__ = [
    "ExpHTTPRequestHandler", "FileSystem", "get_root_path", "get_user_path", "parse_lines",
    "parse_lines_iter", "parse_json", "load_config", "temp_dir",
]


logger = get_logger()
__user_path = Path(os.path.abspath(os.getcwd()))


class ExpHTTPRequestHandler(SimpleHTTPRequestHandler):
    """集成了 log 的 http 请求处理器"""
    def __init__(
            self,
            request,
            client_address,
            server,
            *,
            dir: str | Path = ".",
            logger: logging.Logger = None
        ) -> None:
        self._logger = logger
        super().__init__(request, client_address, server, directory=dir)
    
    @staticmethod
    def factory(
            dir: str | Path = ".",
            logger: logging.Logger = None
        ) -> Callable[..., "ExpHTTPRequestHandler"]:
        return lambda *args, **kwargs: ExpHTTPRequestHandler(
            dir=dir,
            logger=logger,
            *args, **kwargs
        )

    def log_message(self, format, *args) -> None:
        if self._logger:
            self._logger.debug(f"{self.address_string()} => {format % args}")


class FileServer():
    """
    集成了 log 的文件服务器

    手动控制生命周期:
    ```
    f = FileServer(dir="files")
    f.run()
    ...
    f.close()
    ```
    使用 with 语法控制生命周期:
    ```
    with FileServer(dir="files"):
        ...
    ```
    """
    def __init__(
            self,
            host: str = "0.0.0.0",
            port: int = 8080,
            dir: str | Path = ".",
            logger: logging.Logger = logger,
        ) -> None:
        self._host = host
        self._port = port
        self._is_runing: bool = False
        self._logger = logger
        self._server = ThreadingHTTPServer(
            (host, port), ExpHTTPRequestHandler.factory(dir, logger))
    
    @property
    def is_running(self) -> bool:
        return self._is_runing

    def _run(self) -> None:
        with self._server:
            self._server.serve_forever()

    def run(self) -> None:
        """启动文件服务器"""
        if self._is_runing:
            raise Exception("file server is running")
        self._is_runing = True
        self._logger.info(f"file server running on {self._host}:{self._port} ...")
        threading.Thread(target=self._run).start()

    def close(self) -> None:
        """关闭文件服务器"""
        if self._is_runing:
            self._server.shutdown()
            self._logger.info(f"file server stop")
            self._is_runing = False

    def __enter__(self):
        self.run()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


def get_root_path() -> Path:
    """获取 入口文件所在目录"""
    return Path(os.path.dirname(os.path.abspath(sys.modules["__main__"].__file__)))


def get_user_path() -> Path:
    """获取 运行脚本时 用户所在目录"""
    return __user_path


def rget(filepath: Path | str) -> Path:
    """以 入口文件所在目录 为根目录, 获取文件完整路径"""
    return get_root_path() / filepath


def uget(filepath: Path | str) -> Path:
    """以 运行脚本时用户所在目录 为根目录, 获取文件完整路径"""
    return get_user_path() / filepath


def parse_lines(
        filepath: Path,
        encoding: str = "utf-8",
        parser: Callable[[str], Any] = str
    ) -> list:
    """按行解析文件数据, 会丢弃空行和结尾换行"""
    with open(filepath, "r", encoding=encoding) as file:
        return [parser(i.rstrip("\r\n")) for i in file if i.rstrip("\r\n")]


def parse_lines_iter(
        filepath: Path,
        encoding: str = "utf-8",
        parser: Callable[[str], Any] = str
    ) -> Iterator[Any]:
    """按行解析文件数据, 会丢弃空行和结尾换行; 该函数是惰性的, 适用于大文件"""
    with open(filepath, "r", encoding=encoding) as file:
        for i in file:
            if i.rstrip("\r\n"):
                yield parser(i.rstrip("\r\n")) 


def parse_json(filepath: Path, encoding: str = "utf-8") -> Any:
    """解析 JSON 文件, 返回解析后的 python 对象"""
    with open(filepath, "r", encoding=encoding) as file:
        return json.load(file)


def load_config(name: Path | str, encoding: str = "utf-8") -> Any:
    """加载配置文件"""
    return parse_json(rget(name), encoding=encoding)


@contextmanager
def temp_dir(
        suffix: str | None = None,
        prefix: str | None = None,
        dir: str | Path | None = None,
        ignore_cleanup_errors: bool = False,
        *,
        delete: bool = True
    ) -> Iterator[Path]:
    """创建临时文件夹上下文"""
    with tempfile.TemporaryDirectory(
        suffix, prefix, dir, ignore_cleanup_errors, delete=delete
    ) as temp_dir:
        yield Path(temp_dir)
