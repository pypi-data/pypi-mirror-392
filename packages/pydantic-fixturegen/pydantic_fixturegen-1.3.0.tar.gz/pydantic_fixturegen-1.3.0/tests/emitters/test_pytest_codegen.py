from __future__ import annotations

import datetime
from pathlib import Path

import pytest
from pydantic import BaseModel, Field, model_validator
from pydantic_fixturegen.core.errors import EmitError
from pydantic_fixturegen.core.path_template import OutputTemplate, OutputTemplateContext
from pydantic_fixturegen.emitters.pytest_codegen import PytestEmitConfig, emit_pytest_fixtures


class Address(BaseModel):
    street: str = Field(min_length=5)
    city: str


class User(BaseModel):
    name: str = Field(pattern="^User", min_length=5)
    age: int
    address: Address


class InvalidUser(BaseModel):
    name: str

    @model_validator(mode="after")
    def always_fail(self) -> InvalidUser:
        raise ValueError("nope")


def test_emit_pytest_fixtures_model_return(tmp_path: Path) -> None:
    output = tmp_path / "conftest.py"
    result = emit_pytest_fixtures(
        [User],
        output_path=output,
        config=PytestEmitConfig(seed=7, scope="function", return_type="model"),
    )

    assert result.wrote is True
    text = output.read_text(encoding="utf-8")
    assert "Generated by pydantic-fixturegen" in text
    assert "import pytest" in text
    assert "from __future__ import annotations" in text
    assert f"from {User.__module__} import User" in text
    assert "return User.model_validate(data)" in text
    assert "User" in text

    second = emit_pytest_fixtures(
        [User],
        output_path=output,
        config=PytestEmitConfig(seed=7, scope="function", return_type="model"),
    )
    assert second.skipped is True


def test_emit_pytest_fixtures_dict_return(tmp_path: Path) -> None:
    output = tmp_path / "fixtures.py"
    result = emit_pytest_fixtures(
        [User],
        output_path=output,
        config=PytestEmitConfig(seed=11, return_type="dict"),
    )
    assert result.wrote is True
    text = output.read_text(encoding="utf-8")
    assert "-> dict[str, Any]" in text
    assert "from typing import Any" in text
    assert "return dict(" in text


def test_emit_pytest_fixtures_multiple_cases(tmp_path: Path) -> None:
    output = tmp_path / "multi.py"
    result = emit_pytest_fixtures(
        [User],
        output_path=output,
        config=PytestEmitConfig(seed=21, cases=2),
    )

    assert result.wrote is True
    text = output.read_text(encoding="utf-8")
    assert "params=" in text
    assert "def user(request)" in text


def test_emit_pytest_fixtures_records_time_anchor(tmp_path: Path) -> None:
    output = tmp_path / "anchored.py"
    anchor = datetime.datetime(2024, 7, 1, 9, 30, tzinfo=datetime.timezone.utc)
    result = emit_pytest_fixtures(
        [User],
        output_path=output,
        config=PytestEmitConfig(seed=5, time_anchor=anchor),
    )

    assert result.metadata is not None
    assert result.metadata.get("time_anchor") == anchor.isoformat()
    header = output.read_text(encoding="utf-8").splitlines()[2]
    assert f"time_anchor={anchor.isoformat()}" in header


def test_emit_pytest_fixtures_with_template(tmp_path: Path) -> None:
    template = OutputTemplate(tmp_path / "{model}" / "fixtures-{timestamp}.py")
    context = OutputTemplateContext(
        model="User",
        timestamp=datetime.datetime(2024, 7, 21, 11, 15, tzinfo=datetime.timezone.utc),
    )
    result = emit_pytest_fixtures(
        [User],
        output_path=template.raw,
        config=PytestEmitConfig(seed=13),
        template=template,
        template_context=context,
    )

    assert result.wrote is True
    assert result.path.parent.name == "User"
    assert result.path.name.startswith("fixtures-20240721")


def test_emit_pytest_fixtures_validator_failure(tmp_path: Path) -> None:
    output = tmp_path / "invalid.py"
    with pytest.raises(EmitError) as excinfo:
        emit_pytest_fixtures(
            [InvalidUser],
            output_path=output,
            config=PytestEmitConfig(seed=99),
        )

    details = excinfo.value.details
    assert "validator_failure" in details
    assert details["validator_failure"]["message"]
