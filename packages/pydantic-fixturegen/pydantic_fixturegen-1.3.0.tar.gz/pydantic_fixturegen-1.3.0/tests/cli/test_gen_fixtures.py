from __future__ import annotations

import textwrap
from pathlib import Path
from typing import Any

import pytest
from pydantic_fixturegen.api.models import ConfigSnapshot, FixturesGenerationResult
from pydantic_fixturegen.cli import app as cli_app
from pydantic_fixturegen.cli.gen import fixtures as fixtures_mod
from pydantic_fixturegen.core.config import ConfigError
from pydantic_fixturegen.core.errors import DiscoveryError, EmitError, WatchError
from pydantic_fixturegen.core.path_template import OutputTemplate
from tests._cli import create_cli_runner

runner = create_cli_runner()


class FakeLogger:
    def __init__(self) -> None:
        self.debug_calls: list[tuple[str, dict[str, object]]] = []
        self.info_calls: list[tuple[str, dict[str, object]]] = []
        self.warn_calls: list[tuple[str, dict[str, object]]] = []
        self.config = type("Cfg", (), {"json": False})()

    def debug(self, message: str, **kwargs: object) -> None:  # noqa: D401
        self.debug_calls.append((message, kwargs))

    def info(self, message: str, **kwargs: object) -> None:
        self.info_calls.append((message, kwargs))

    def warn(self, message: str, **kwargs: object) -> None:
        self.warn_calls.append((message, kwargs))


def _write_module(tmp_path: Path, name: str = "models") -> Path:
    module_path = tmp_path / f"{name}.py"
    module_path.write_text(
        """
from pydantic import BaseModel, Field


class Address(BaseModel):
    city: str
    postcode: str = Field(min_length=3)


class User(BaseModel):
    name: str
    age: int
    address: Address


class Order(BaseModel):
    order_id: str
    total: float
""",
        encoding="utf-8",
    )
    return module_path


def _write_relative_import_package(tmp_path: Path) -> Path:
    package_root = tmp_path / "lib" / "models"
    package_root.mkdir(parents=True)

    (tmp_path / "lib" / "__init__.py").write_text("", encoding="utf-8")
    (package_root / "__init__.py").write_text("", encoding="utf-8")

    (package_root / "shared_model.py").write_text(
        textwrap.dedent(
            """
            from pydantic import BaseModel


            class SharedPayload(BaseModel):
                path: str
                size: int
            """
        ),
        encoding="utf-8",
    )

    target_module = package_root / "example_model.py"
    target_module.write_text(
        textwrap.dedent(
            """
            from pydantic import BaseModel

            from .shared_model import SharedPayload


            class ExampleRequest(BaseModel):
                project_id: str
                payload: SharedPayload
            """
        ),
        encoding="utf-8",
    )

    return target_module


def test_gen_fixtures_basic_functions_style(tmp_path: Path) -> None:
    module_path = _write_module(tmp_path)
    output = tmp_path / "conftest.py"

    output.write_text("sentinel", encoding="utf-8")

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--include",
            "models.User",
        ],
    )

    assert result.exit_code == 0, f"stdout: {result.stdout}\nstderr: {result.stderr}"
    text = output.read_text(encoding="utf-8")
    assert "def user(" in text
    assert "Generated by pydantic-fixturegen" in text

    rerun = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--include",
            "models.User",
        ],
    )
    assert rerun.exit_code == 0


def test_gen_fixtures_supports_dataclasses(tmp_path: Path) -> None:
    module_path = tmp_path / "analytics.py"
    module_path.write_text(
        textwrap.dedent(
            """
            from dataclasses import dataclass


            @dataclass
            class Metric:
                name: str
                value: int
            """
        ),
        encoding="utf-8",
    )
    output = tmp_path / "analytics_fixtures.py"

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--include",
            "analytics.Metric",
        ],
    )

    assert result.exit_code == 0, result.stdout
    text = output.read_text(encoding="utf-8")
    assert "from analytics import Metric" in text
    assert "def metric(" in text


def test_gen_fixtures_with_now(tmp_path: Path) -> None:
    module_path = _write_module(tmp_path)
    output = tmp_path / "anchored.py"

    now_value = "2024-09-10T12:34:56Z"

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--now",
            now_value,
        ],
    )

    assert result.exit_code == 0, result.stderr
    text = output.read_text(encoding="utf-8")
    assert f"time_anchor={now_value.replace('Z', '+00:00')}" in text


def test_gen_fixtures_validator_flags_forwarded(
    tmp_path: Path, monkeypatch: pytest.MonkeyPatch
) -> None:
    module_path = _write_module(tmp_path)
    output = tmp_path / "validators.py"
    captured: dict[str, Any] = {}

    def fake_generate(**kwargs: Any) -> FixturesGenerationResult:
        captured.update(kwargs)
        return FixturesGenerationResult(
            path=output,
            base_output=output,
            models=(),
            config=ConfigSnapshot(seed=None, include=(), exclude=(), time_anchor=None),
            metadata={},
            warnings=(),
            constraint_summary=None,
            skipped=False,
            delegated=False,
            style="functions",
            scope="function",
            return_type="model",
            cases=1,
        )

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        fake_generate,
    )

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--respect-validators",
            "--validator-max-retries",
            "4",
        ],
    )

    assert result.exit_code == 0
    assert captured["respect_validators"] is True
    assert captured["validator_max_retries"] == 4


def test_gen_fixtures_factory_dict(tmp_path: Path) -> None:
    module_path = _write_module(tmp_path)
    output = tmp_path / "factories.py"

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--include",
            "models.User",
            "--style",
            "factory",
            "--return-type",
            "dict",
            "--cases",
            "2",
        ],
    )

    assert result.exit_code == 0, f"stdout: {result.stdout}\nstderr: {result.stderr}"
    text = output.read_text(encoding="utf-8")
    assert "def user_factory(" in text
    assert "def builder(" in text
    assert "return dict(" in text


def test_gen_fixtures_out_template(tmp_path: Path) -> None:
    module_path = _write_module(tmp_path)
    template = tmp_path / "generated" / "{model}" / "fixtures-{timestamp}.py"

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(template),
            "--include",
            "models.User",
        ],
    )

    assert result.exit_code == 0, f"stdout: {result.stdout}\nstderr: {result.stderr}"
    generated_dir = tmp_path / "generated" / "User"
    files = list(generated_dir.glob("fixtures-*.py"))
    assert len(files) == 1
    content = files[0].read_text(encoding="utf-8")
    assert "def user(" in content


def test_gen_fixtures_invalid_template_reports_error(tmp_path: Path) -> None:
    module_path = _write_module(tmp_path)
    template = tmp_path / "{unknown}" / "fixtures.py"

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(template),
        ],
    )

    assert result.exit_code == 30
    assert "Unsupported template variable" in result.stderr


def test_gen_fixtures_class_style_scope(tmp_path: Path) -> None:
    module_path = _write_module(tmp_path)
    output = tmp_path / "class_style.py"

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--style",
            "class",
            "--scope",
            "module",
        ],
    )

    assert result.exit_code == 0, f"stdout: {result.stdout}\nstderr: {result.stderr}"
    text = output.read_text(encoding="utf-8")
    assert "class AddressFactory" in text
    assert '@pytest.fixture(scope="module")' in text


def test_gen_fixtures_emit_artifact_short_circuit(
    tmp_path: Path, monkeypatch: pytest.MonkeyPatch
) -> None:
    module_path = _write_module(tmp_path)
    output = tmp_path / "fixtures.py"

    delegated = FixturesGenerationResult(
        path=None,
        base_output=output,
        models=(),
        config=ConfigSnapshot(seed=None, include=(), exclude=(), time_anchor=None),
        metadata={},
        warnings=(),
        constraint_summary=None,
        skipped=False,
        delegated=True,
        style="functions",
        scope="function",
        return_type="model",
        cases=1,
    )

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        lambda **_: delegated,
    )

    output.write_text("sentinel", encoding="utf-8")

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--include",
            "models.User",
        ],
    )

    assert result.exit_code == 0
    assert output.exists()
    assert output.read_text(encoding="utf-8") == "sentinel"


def test_gen_fixtures_emit_error(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
    module_path = _write_module(tmp_path)
    output = tmp_path / "fixtures.py"

    error = EmitError(
        "fail",
        details={
            "config": {
                "seed": None,
                "include": ["models.User"],
                "exclude": [],
                "time_anchor": None,
            },
            "warnings": [],
            "base_output": str(output),
            "constraint_summary": {
                "models": [
                    {
                        "model": "models.User",
                        "attempts": 1,
                        "successes": 0,
                        "fields": [],
                    }
                ]
            },
        },
    )

    def raise_error(**_: Any) -> FixturesGenerationResult:
        raise error

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        raise_error,
    )

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--include",
            "models.User",
        ],
    )

    assert result.exit_code == 30
    assert "fail" in result.stderr


def test_gen_fixtures_config_error(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
    module_path = _write_module(tmp_path)
    output = tmp_path / "fixtures.py"

    def raise_config(**_: Any) -> FixturesGenerationResult:
        raise ConfigError("broken")

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        raise_config,
    )

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--include",
            "models.User",
        ],
    )

    assert result.exit_code == 10
    assert "broken" in result.stderr


def test_execute_fixtures_command_warnings(
    tmp_path: Path,
    monkeypatch: pytest.MonkeyPatch,
    capsys: pytest.CaptureFixture[str],
) -> None:
    out_path = tmp_path / "fixtures.py"
    result = FixturesGenerationResult(
        path=out_path,
        base_output=out_path,
        models=(),
        config=ConfigSnapshot(seed=123, include=("pkg.User",), exclude=(), time_anchor=None),
        metadata={},
        warnings=("warn",),
        constraint_summary=None,
        skipped=True,
        delegated=False,
        style="factory",
        scope="module",
        return_type="model",
        cases=2,
    )

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        lambda **_: result,
    )

    fixtures_mod._execute_fixtures_command(
        target="module",
        output_template=OutputTemplate(str(out_path)),
        style="factory",
        scope="module",
        cases=2,
        return_type="model",
        seed=123,
        now=None,
        p_none=0.2,
        include="pkg.User",
        exclude=None,
        freeze_seeds=False,
        freeze_seeds_file=None,
        preset=None,
    )

    captured = capsys.readouterr()
    assert "warn" in captured.err
    assert str(out_path) + " (unchanged)" in captured.out


def test_execute_fixtures_command_errors(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
    def raise_discovery(**_: Any) -> FixturesGenerationResult:
        raise DiscoveryError("boom")

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        raise_discovery,
    )

    with pytest.raises(DiscoveryError):
        fixtures_mod._execute_fixtures_command(
            target="module",
            output_template=OutputTemplate(str(tmp_path / "out.py")),
            style=None,
            scope=None,
            cases=1,
            return_type=None,
            seed=None,
            now=None,
            p_none=None,
            include=None,
            exclude=None,
            freeze_seeds=False,
            freeze_seeds_file=None,
            preset=None,
        )


def test_execute_fixtures_command_path_checks(tmp_path: Path) -> None:
    missing = tmp_path / "missing.py"
    with pytest.raises(DiscoveryError):
        fixtures_mod._execute_fixtures_command(
            target=str(missing),
            output_template=OutputTemplate(str(missing)),
            style=None,
            scope=None,
            cases=1,
            return_type=None,
            seed=None,
            now=None,
            p_none=None,
            include=None,
            exclude=None,
            freeze_seeds=False,
            freeze_seeds_file=None,
            preset=None,
        )

    directory = tmp_path / "dir"
    directory.mkdir()
    with pytest.raises(DiscoveryError):
        fixtures_mod._execute_fixtures_command(
            target=str(directory),
            output_template=OutputTemplate(str(directory)),
            style=None,
            scope=None,
            cases=1,
            return_type=None,
            seed=None,
            now=None,
            p_none=None,
            include=None,
            exclude=None,
            freeze_seeds=False,
            freeze_seeds_file=None,
            preset=None,
        )


def test_execute_fixtures_command_emit_error(
    tmp_path: Path, monkeypatch: pytest.MonkeyPatch
) -> None:
    error = EmitError(
        "fail",
        details={
            "config": {
                "seed": None,
                "include": [],
                "exclude": [],
                "time_anchor": None,
            },
            "warnings": [],
            "base_output": str(tmp_path / "out.py"),
        },
    )

    def raise_error(**_: Any) -> FixturesGenerationResult:
        raise error

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        raise_error,
    )

    with pytest.raises(EmitError):
        fixtures_mod._execute_fixtures_command(
            target="module",
            output_template=OutputTemplate(str(tmp_path / "out.py")),
            style=None,
            scope=None,
            cases=1,
            return_type=None,
            seed=None,
            now=None,
            p_none=None,
            include=None,
            exclude=None,
            freeze_seeds=False,
            freeze_seeds_file=None,
            preset=None,
        )


def test_execute_fixtures_command_applies_preset(
    tmp_path: Path, monkeypatch: pytest.MonkeyPatch
) -> None:
    out_path = tmp_path / "fixtures.py"
    captured: dict[str, Any] = {}

    def fake_generate(**kwargs: Any) -> FixturesGenerationResult:
        captured.update(kwargs)
        return FixturesGenerationResult(
            path=out_path,
            base_output=out_path,
            models=(),
            config=ConfigSnapshot(seed=None, include=(), exclude=(), time_anchor=None),
            metadata={},
            warnings=(),
            constraint_summary=None,
            skipped=False,
            delegated=False,
            style="functions",
            scope="function",
            return_type="model",
            cases=1,
        )

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        fake_generate,
    )

    fixtures_mod._execute_fixtures_command(
        target="module",
        output_template=OutputTemplate(str(out_path)),
        style=None,
        scope=None,
        cases=1,
        return_type=None,
        seed=None,
        now=None,
        p_none=None,
        include=None,
        exclude=None,
        freeze_seeds=False,
        freeze_seeds_file=None,
        preset="boundary",
    )

    assert captured["preset"] == "boundary"


def test_gen_fixtures_handles_relative_imports(tmp_path: Path) -> None:
    target_module = _write_relative_import_package(tmp_path)
    output = tmp_path / "fixtures.py"

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(target_module),
            "--out",
            str(output),
            "--include",
            "lib.models.example_model.ExampleRequest",
        ],
    )

    assert result.exit_code == 0, f"stdout: {result.stdout}\nstderr: {result.stderr}"
    assert output.exists()
    text = output.read_text(encoding="utf-8")
    assert "example_request" in text


def test_gen_fixtures_watch_mode_handles_errors(
    tmp_path: Path,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    module_path = _write_module(tmp_path)
    output = tmp_path / "fixtures.py"
    logger = FakeLogger()
    monkeypatch.setattr(fixtures_mod, "get_logger", lambda: logger)

    invoked: dict[str, int] = {"count": 0}

    def fake_execute(**_: object) -> None:  # noqa: ANN001
        invoked["count"] += 1

    monkeypatch.setattr(fixtures_mod, "_execute_fixtures_command", fake_execute)
    monkeypatch.setattr(
        fixtures_mod,
        "gather_default_watch_paths",
        lambda *args, **kwargs: [tmp_path],  # noqa: ARG005
    )

    def fake_run_with_watch(callback: object, watch_paths: list[Path], debounce: float) -> None:
        assert watch_paths == [tmp_path]
        assert debounce == 0.5
        callback()
        raise WatchError("watch failed")

    monkeypatch.setattr(fixtures_mod, "run_with_watch", fake_run_with_watch)

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output),
            "--watch",
        ],
    )

    assert result.exit_code == 60
    assert invoked["count"] == 1
    assert logger.debug_calls and logger.debug_calls[0][0] == "Entering watch loop"


def test_handle_fixtures_error_logs(monkeypatch: pytest.MonkeyPatch) -> None:
    logger = FakeLogger()
    constraint_calls: list[dict[str, object]] = []
    monkeypatch.setattr(
        fixtures_mod,
        "emit_constraint_summary",
        lambda summary, **kwargs: constraint_calls.append({"summary": summary, **kwargs}),
    )
    error = EmitError(
        "bad",
        details={
            "config": {
                "seed": 1,
                "include": ["A"],
                "exclude": [],
                "time_anchor": "2024-01-01T00:00:00+00:00",
            },
            "warnings": ["warn"],
            "constraint_summary": {"fields": 1},
        },
    )

    fixtures_mod._handle_fixtures_error(logger, error)

    assert logger.debug_calls
    assert any(call[1].get("event") == "temporal_anchor_set" for call in logger.info_calls)
    assert logger.warn_calls and logger.warn_calls[0][0] == "warn"
    assert constraint_calls and constraint_calls[0]["summary"] == {"fields": 1}


def test_coerce_helpers_validate_inputs() -> None:
    assert fixtures_mod._coerce_style("Functions") == "functions"
    assert fixtures_mod._coerce_scope("module") == "module"
    assert fixtures_mod._coerce_return_type("dict") == "dict"

    with pytest.raises(DiscoveryError):
        fixtures_mod._coerce_style("bad")
    with pytest.raises(DiscoveryError):
        fixtures_mod._coerce_scope("invalid")
    with pytest.raises(DiscoveryError):
        fixtures_mod._coerce_return_type("bad")


def test_gen_fixtures_field_hints_forwarded(
    tmp_path: Path,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    module_path = _write_module(tmp_path)
    output_path = tmp_path / "fixtures.py"

    captured: dict[str, Any] = {}

    def fake_generate(**kwargs: Any) -> FixturesGenerationResult:
        captured.update(kwargs)
        return FixturesGenerationResult(
            path=output_path,
            base_output=output_path,
            models=(),
            config=ConfigSnapshot(seed=None, include=(), exclude=(), time_anchor=None),
            metadata=None,
            warnings=(),
            constraint_summary=None,
            skipped=False,
            delegated=False,
            style="functions",
            scope="function",
            return_type="model",
            cases=1,
        )

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        fake_generate,
    )

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output_path),
            "--field-hints",
            "examples",
        ],
    )

    assert result.exit_code == 0
    assert captured["field_hints"] == "examples"


def test_gen_fixtures_locale_forwarded(
    tmp_path: Path,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    module_path = _write_module(tmp_path)
    output_path = tmp_path / "fixtures.py"
    captured: dict[str, Any] = {}

    def fake_generate(**kwargs: Any) -> FixturesGenerationResult:
        captured.update(kwargs)
        return FixturesGenerationResult(
            path=output_path,
            base_output=output_path,
            models=(),
            config=ConfigSnapshot(seed=None, include=(), exclude=(), time_anchor=None),
            metadata={},
            warnings=(),
            constraint_summary=None,
            skipped=False,
            delegated=False,
            style="functions",
            scope="function",
            return_type="model",
            cases=1,
        )

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        fake_generate,
    )

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output_path),
            "--locale",
            "fr_FR",
        ],
    )

    assert result.exit_code == 0
    assert captured["locale"] == "fr_FR"


def test_gen_fixtures_locale_map_forwarded(
    tmp_path: Path,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    module_path = _write_module(tmp_path)
    output_path = tmp_path / "fixtures.py"
    captured: dict[str, Any] = {}

    def fake_generate(**kwargs: Any) -> FixturesGenerationResult:
        captured.update(kwargs)
        return FixturesGenerationResult(
            path=output_path,
            base_output=output_path,
            models=(),
            config=ConfigSnapshot(seed=None, include=(), exclude=(), time_anchor=None),
            metadata={},
            warnings=(),
            constraint_summary=None,
            skipped=False,
            delegated=False,
            style="functions",
            scope="function",
            return_type="model",
            cases=1,
        )

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        fake_generate,
    )

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output_path),
            "--locale-map",
            "*.Address=sv_SE",
            "--locale-map",
            "*.User=en_GB",
        ],
    )

    assert result.exit_code == 0
    assert captured["locale_overrides"] == {"*.Address": "sv_SE", "*.User": "en_GB"}


def test_gen_fixtures_collection_flags_forwarded(
    tmp_path: Path,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    module_path = _write_module(tmp_path)
    output_path = tmp_path / "fixtures.py"

    captured: dict[str, Any] = {}

    def fake_generate(**kwargs: Any) -> FixturesGenerationResult:
        captured.update(kwargs)
        return FixturesGenerationResult(
            path=output_path,
            base_output=output_path,
            models=(),
            config=ConfigSnapshot(seed=None, include=(), exclude=(), time_anchor=None),
            metadata=None,
            warnings=(),
            constraint_summary=None,
            skipped=False,
            delegated=False,
            style="functions",
            scope="function",
            return_type="model",
            cases=1,
        )

    monkeypatch.setattr(
        "pydantic_fixturegen.cli.gen.fixtures.generate_fixtures_artifacts",
        fake_generate,
    )

    result = runner.invoke(
        cli_app,
        [
            "gen",
            "fixtures",
            str(module_path),
            "--out",
            str(output_path),
            "--collection-min-items",
            "0",
            "--collection-max-items",
            "2",
            "--collection-distribution",
            "uniform",
        ],
    )

    assert result.exit_code == 0
    assert captured["collection_min_items"] == 0
    assert captured["collection_max_items"] == 2
    assert captured["collection_distribution"] == "uniform"
