# FastAPI marketplace example

A fully wired demo service that ships Pydantic models, FastAPI routers, fixturegen configuration, deterministic snapshots, and a GitHub Actions recipe. Use it to explore `pfg gen`, `pfg snapshot verify`, Polyfactory delegation, and CI-friendly workflows without stitching multiple repos together.

### What this example demonstrates

- **Multi-module discovery.** Models are split across `shared`, `catalog`, `customer`, `payment`, `notification`, and `order` packages so you can see how safe-import discovery stitches relative imports and shared value objects together.
- **Deterministic inputs.** The Makefile and CI workflow reuse a committed `.pfg-seeds.json` plus a fixed `--now` anchor. Every run produces byte-identical JSON/pytest fixtures, making diffs meaningful.
- **Cross-emitter parity.** The same configuration (field hints, presets, relation hints) feeds JSON, pytest fixtures, and `pfg snapshot verify`, illustrating how a single config block powers multiple emitters.
- **CI ready wiring.** `.github/workflows/snapshot-verify.yml` shows how to cache installs, read the freeze file, run `pfg snapshot verify`, and (optionally) auto-refresh when drift is expected.
- **Polyfactory migration surface.** `pyproject.toml` pulls in Polyfactory, enabling `pfg gen polyfactory` or delegation to existing `ModelFactory` classes without forfeiting CLI determinism.
- **FastAPI integration.** The `app/api/routes` illustrate how mock routers can hydrate deterministic payloads generated by fixturegen, mirroring docs + smoke test recipes from the main project.

## Project layout

```
fastapi-marketplace/
├── app/
│   ├── api/routes/*.py         # FastAPI routers with in-memory storage
│   ├── config.py               # Settings model injected into the API
│   └── models/*.py             # Shared/catalog/customer/payment/order/notification models
├── snapshots/                  # Checked-in JSON + schema artifacts
├── tests/fixtures/             # Pytest fixtures emitted by fixturegen
├── .pfg-seeds.json             # Freeze file committed to the repo
├── Makefile                    # Single entrypoint for generation + verification
├── pyproject.toml              # Declares dependencies + fixturegen config
└── .github/workflows/          # Snapshot verification workflow you can copy into real repos
```

Models intentionally live across multiple modules (`shared`, `catalog`, `customer`, `order`) to mirror production services that rely on relative imports and shared value objects. Fixturegen handles the sprawl automatically via safe-import discovery.

## Run the walkthrough

```bash
cd docs/example-projects/fastapi-marketplace
make install            # creates .venv, installs pydantic-fixturegen from the repo root
make list               # tree view of discovered models
make snapshots          # regenerates JSON + fixture snapshots with frozen seeds and a fixed NOW anchor
make snapshot-verify    # replays generation in-memory (auto-updates snapshots by default)
make run-api            # optional FastAPI server backed by the generated data
```

Key commands:

- `pfg gen json app/models/order.py --include app.models.order.OrderEnvelope --out snapshots/orders.json --seed 7337 --freeze-seeds --now 2025-01-01T00:00:00Z` regenerates deterministic payloads that include nested `CustomerProfile` data and payment history.
- `pfg gen fixtures ... --include app.models.order.OrderEnvelope` emits pytest fixtures for order workflows while guaranteeing linked customer data and shares the same freeze file to keep seeds aligned.
- `pfg snapshot verify` re-runs generation in CI to confirm the committed artifacts match the repo.

## Deterministic knobs & artifacts

- **Freeze file** — `.pfg-seeds.json` is committed and already contains every nested model (shared value objects, catalog variants, payment intents, etc.). Regeneration reuses those seeds so IDs, slugs, and nested payloads remain stable.
- **Temporal anchor** — all Makefile/CI commands pass `--now 2025-01-01T00:00:00Z`, so timestamps inside models (orders, audit events, fulfillment windows) do not fluctuate between machines.
- **Artifacts** — `snapshots/orders.json` holds bundled JSON samples (`OrderEnvelope` + related models) while `tests/fixtures/test_orders.py` mirrors the same dataset as pytest factories. Regenerate both via `make snapshots` and inspect the diff to understand how fixturegen normalizes output templates.
- **Config reuse** — `pyproject.toml` sets `preset = "ci"`, field hints, collection limits, and watch-friendly logging (`log_format = "json"`). CLI runs, CI, and optional Polyfactory exports all inherit the same deterministic surface.

## GitHub Actions wiring

`.github/workflows/snapshot-verify.yml` mirrors the docs recipe: it installs the repo (editable), restores the `.pfg-seeds.json` freeze file, and runs `pfg snapshot verify` against both JSON and fixture artifacts. Copy the file into your own projects or extend it with dataset/schema checks.

## Polyfactory delegation

The `pyproject.toml` enables Polyfactory in dev dependencies so you can experiment with `pfg gen polyfactory app/models/order.py --out factories.py --prefer-fixturegen`. Because the models live in their own package, fixturegen can detect any `ModelFactory` subclasses you add under `app/factories.py` and delegate selectively while keeping CLI determinism. The shared `seed`, `preset` and `field_hints` settings mean CLI runs achieve the same shape as the snapshots generated by `make snapshots`.

## What to explore next

- Switch the preset to `boundary` or `adversarial` to see frozen seeds combine with aggressive heuristics.
- Run `pfg gen strategies app/models/order.py --include app.models.order.OrderEnvelope --out strategies/test_orders.py` to share the same heuristics with Hypothesis.
- Use the example freeze file as a template for your own `.pfg-seeds.json` (see [docs/seeds.md](../../seeds.md)).
- `make snapshot-verify` runs `pfg snapshot verify` and, when drift is detected, automatically falls back to `pfg snapshot write` before verifying again so the example always stays runnable. In your own services drop the write fallback so CI fails loudly when artifacts change.
- Inspect the generated fixtures in `tests/fixtures/test_orders.py` to understand how provider hints, optional relations, and collection policies surface in pytest code.
