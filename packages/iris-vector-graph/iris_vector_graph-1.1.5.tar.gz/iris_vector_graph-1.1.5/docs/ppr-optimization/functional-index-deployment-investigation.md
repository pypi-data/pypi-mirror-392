# Functional Index Deployment Investigation

## Objective

Deploy a **Functional Index** on the `rdf_edges` SQL table to automatically maintain graph adjacency structures in IRIS Globals (`^PPR`) synchronized with SQL DML operations.

## Background

**Personalized PageRank (PPR)** algorithm requires:
- **Outdegree counts**: `^PPR("deg", nodeId) = count`
- **Outgoing edges**: `^PPR("out", src, dst) = 1`
- **Incoming edges**: `^PPR("in", dst, src) = 1`

Currently using **Pure Python** implementation (extracts graph via SQL, ~200ms for 10K nodes).
Target: **Functional Index** implementation (<10ms using zero-copy Globals traversal).

## What We've Built

### 1. ObjectScript Functional Index Class

**File**: `src/iris/Graph/KG/PPRFunctionalIndex.cls` (186 lines)

```objectscript
Class Graph.KG.PPRFunctionalIndex Extends %Library.FunctionalIndex
{

ClassMethod InsertIndex(pID As %RawString, pArg... As %Binary) [ Language = python ]
{
    import iris
    g = iris.gref('^PPR')
    args = list(pArg)

    src = args[0]
    dst = args[1]

    # Set adjacency structures
    g.set(1, ['out', src, dst])
    g.set(1, ['in', dst, src])

    # Increment outdegree
    current_deg = g.get(['deg', src])
    current_deg = int(current_deg) if current_deg is not None else 0
    g.set(current_deg + 1, ['deg', src])
}

ClassMethod UpdateIndex(pID As %RawString, pArg... As %Binary) [ Language = python ]
{
    # Delete old edge, insert new edge
    # (full implementation in file)
}

ClassMethod DeleteIndex(pID As %RawString, pArg... As %Binary) [ Language = python ]
{
    # Remove adjacency entries, decrement outdegree
    # (full implementation in file)
}

ClassMethod PurgeIndex() [ Language = python ]
{
    # Clear entire ^PPR global
    iris.gref('^PPR').kill()
}

}
```

**Key Features**:
- Uses `Language = python` with embedded Python (`iris.gref()` API)
- Implements required Functional Index callbacks
- Methods validated via code review

### 2. Python PPR Implementation

**File**: `iris_vector_graph_core/ppr_functional_index.py` (182 lines)

```python
def compute_ppr_functional_index(
    conn,
    seed_entities: List[str],
    damping_factor: float = 0.85,
    max_iterations: int = 100,
    tolerance: float = 1e-6
) -> Dict[str, float]:
    """Zero-copy PPR computation using IRIS Functional Index-maintained Globals."""

    # Create IRIS object for Global access
    irispy = iris.createIRIS(conn)

    # Step 1: Build node set from ^PPR("deg", *)
    nodes = []
    node_id = ""
    while True:
        node_id = irispy.nextSubscript('^PPR', ['deg', node_id])
        if node_id is None or node_id == "":
            break
        nodes.append(node_id)

    # Step 2: Power iteration using ^PPR Globals
    # (full implementation in file)
```

**Key Features**:
- Uses `intersystems_irispython` API (external Python client)
- Direct traversal of `^PPR` Globals
- No SQL extraction (zero-copy)

### 3. Integration Tests

**File**: `tests/integration/test_ppr_functional_index_live.py` (361 lines)

**Test Coverage**:
1. `test_functional_index_basic_workflow` - Complete INSERT → ^PPR → PPR computation
2. `test_functional_index_update_callback` - UPDATE triggers
3. `test_functional_index_delete_callback` - DELETE triggers
4. `test_ppr_correctness_vs_baseline` - Result validation
5. `test_sink_node_handling` - Edge cases
6. `test_invalid_seed_entity_error` - Error handling

---

## Deployment Attempts

### Table Schema

**SQL DDL**:
```sql
CREATE TABLE IF NOT EXISTS rdf_edges(
  edge_id  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  s        VARCHAR(256) NOT NULL,  -- Source node
  p        VARCHAR(128) NOT NULL,  -- Predicate
  o_id     VARCHAR(256) NOT NULL,  -- Target node (object ID)
  qualifiers JSON
);
```

**Auto-generated Class**: `User.rdfedges` (extends `%Persistent`)

### Attempt 1: Compile Class ✅ SUCCESS

```bash
docker cp src/iris/Graph/KG/PPRFunctionalIndex.cls iris-pgwire-db:/tmp/
```

```python
import iris
conn = iris.connect('localhost', 1972, 'USER', '_SYSTEM', 'SYS')
iris_obj = iris.createIRIS(conn)

result = iris_obj.classMethodValue('%SYSTEM.OBJ', 'Load', '/tmp/PPRFunctionalIndex.cls', 'ck')
# Output: "Load finished successfully"
```

**Status**: ✅ Class compiled successfully

### Attempt 2: Create Functional Index via SQL ❌ BLOCKED

```sql
CREATE INDEX PPR_Adj ON rdf_edges(s, o_id) AS Graph.KG.PPRFunctionalIndex;
```

**Error**:
```
ERROR #5123: Unable to find entry point for method 'zPPRAdjDeleteIndex'
             in routine 'User.rdfedges.1'
```

### Attempt 3: Add Index to Class Definition ❌ BLOCKED

```python
from iris import IRISConnection
import iris

conn = iris.connect('localhost', 1972, 'USER', '_SYSTEM', 'SYS')
irispy = iris.createIRIS(conn)

# Open class definition
cls_def = irispy.classMethodObject('%Dictionary.ClassDefinition', '%OpenId', 'User.rdfedges')

# Create index definition
idx_def = irispy.classMethodObject('%Dictionary.IndexDefinition', '%New')
idx_def.invoke('NameSet', 'PPRAdj')
idx_def.invoke('TypeSet', 'index')

# Add properties
idx_def.invoke('PropertiesSet', 's,oid')  # Note: SQL 'o_id' → property 'oid'

# Set as Functional Index
idx_def.invoke('TypeClassSet', 'Graph.KG.PPRFunctionalIndex')

# Add to class
cls_def.invoke('Indices').invoke('Insert', idx_def)

# Save and compile
save_status = cls_def.invoke('%Save')  # Status: 1 (success)
compile_status = cls_def.invoke('%CompileClassList', 'User.rdfedges')
```

**Error** (during compilation):
```
ERROR #5123: Unable to find entry point for method 'zPPRAdjDeleteIndex'
             in routine 'User.rdfedges.1'
```

---

## Analysis

### IRIS Index Wrapper Generation

IRIS generates **wrapper methods** with naming pattern:
```
z{IndexName}{MethodName}
```

**Examples** (for index named `PPRAdj`):
- `zPPRAdjInsertIndex`
- `zPPRAdjUpdateIndex`
- `zPPRAdjDeleteIndex`

These wrappers are compiled into the table's generated routine (`User.rdfedges.1`).

### Developer Community Finding

From [Functional indices for lightning-fast queries](https://community.intersystems.com):

```objectscript
ClassMethod InsertIndex(...) [ CodeMode = generator, ServerOnly = 1 ]
{
    // Generate ObjectScript code at compile time
}
```

**Key Insight**: Standard Functional Indexes use `CodeMode = generator`, which generates ObjectScript code at compile time that IRIS can compile into the table routine.

### Our Implementation vs. Standard Pattern

| **Aspect** | **Our Implementation** | **Standard Pattern** |
|---|---|---|
| **Method Language** | `Language = python` | `Language = objectscript` or `CodeMode = generator` |
| **Execution Model** | Embedded Python runtime | Generated ObjectScript code |
| **Wrapper Generation** | IRIS expects `z{Index}{Method}` in routine | Generator produces wrapper code |

### Hypothesis

The `Language = python` implementation may be **incompatible** with IRIS's Functional Index wrapper generation mechanism because:

1. IRIS needs to generate **ObjectScript wrapper routines** (e.g., `zPPRAdjDeleteIndex`)
2. These wrappers bridge table operations to Functional Index callbacks
3. `CodeMode = generator` produces this bridge code at compile time
4. `Language = python` executes at runtime but doesn't generate compile-time code

---

## Questions for InterSystems IRIS expert

### Primary Question

**Can Functional Index methods use `Language = python` syntax when attached to SQL-created tables?**

Our ObjectScript class compiles successfully, but attaching it to a table via:
```sql
CREATE INDEX PPR_Adj ON rdf_edges(s, o_id) AS Graph.KG.PPRFunctionalIndex;
```

produces error:
```
ERROR #5123: Unable to find entry point for method 'zPPRAdjDeleteIndex'
```

### Context

1. **Table creation**: SQL DDL via `CREATE TABLE rdf_edges (...)`
2. **Class generation**: IRIS auto-generated `User.rdfedges` (extends `%Persistent`)
3. **Functional Index class**: Uses `Language = python` with `iris.gref()` API
4. **Error pattern**: IRIS looking for wrapper method `z{IndexName}{MethodName}` in routine

### Specific Questions

1. Does `Language = python` support Functional Index callbacks, or is `CodeMode = generator` required?

2. If generator mode is required, can we call Python code from generated ObjectScript?

3. Alternative: Can we define the Functional Index **inside** the table class (`User.rdfedges`) instead of separate class?

4. Documentation shows `Language = python` works for SQL stored procedures (with `SqlProc` tag). Does the same pattern work for Functional Indexes?

### Example from Documentation

[Create Stored Procedures using Embedded Python](https://dev.to/intersystems/create-stored-procedures-using-embedded-python-37m):

```objectscript
ClassMethod GetFullAddress(Street As %String, City As %String, State As %String)
As %String [ Language = python, SqlName = GetFullAddress, SqlProc ]
{
    import geopy.geocoders
    from geopy.geocoders import Nominatim
    # ... Python code ...
    return location.address
}
```

**Can this pattern extend to Functional Index methods?**

---

## Workaround Considered

**Fallback to Pure Python** (already implemented):
- Extract graph via SQL: `SELECT s, o_id FROM rdf_edges`
- Compute PPR in Python: ~200ms for 10K nodes
- Environment variable: `USE_PPR_FUNCTIONAL_INDEX=0`

**Why we want Functional Index**:
- Target: <10ms for 10K nodes (20x improvement)
- Zero-copy: Direct Globals traversal without SQL extraction
- Real-time: Maintained automatically via DML triggers

---

## Files for Reference

1. **Functional Index Class**: `src/iris/Graph/KG/PPRFunctionalIndex.cls`
2. **Python Implementation**: `iris_vector_graph_core/ppr_functional_index.py`
3. **Integration Tests**: `tests/integration/test_ppr_functional_index_live.py`
4. **Pain Points Document**: `docs/iris-devtester-enhancements.md`
5. **This Investigation**: `docs/functional-index-deployment-investigation.md`

---

## Next Steps

**If IRIS expert confirms `Language = python` is compatible**:
- Debug wrapper generation issue
- Investigate alternative index attachment methods

**If `CodeMode = generator` is required**:
- Rewrite Functional Index with generator pattern
- Call Python code from generated ObjectScript (if possible)

**If neither works**:
- Document limitation in `docs/iris-devtester-enhancements.md`
- Use Pure Python fallback (already functional)
- Consider feature request to InterSystems for Python Functional Index support

---

**Date**: 2025-11-07
**Status**: Blocked pending InterSystems expert guidance
**Priority**: P0 (blocking T020 deployment task)
