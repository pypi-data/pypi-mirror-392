# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-11-13T05:32:01+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, Field


class Agent(BaseModel):
    field_type: str = Field(
        ...,
        alias='@type',
        description='Type of agent, e.g., "Search Agent" or "Analytics Agent". (required)',
    )
    agentSpec: Dict[str, Any] = Field(
        ...,
        description='Agent specification - structure will depend on agent type (required)',
    )


class ResponseType(Enum):
    Answer = 'Answer'
    Elicitation = 'Elicitation'
    Promise = 'Promise'


class AskResponseMeta(BaseModel):
    conversation_id: Optional[str] = Field(
        None,
        description='Conversational identifier - pass-through only when there are simultaneous conversations to track (optional)',
    )
    response_type: Optional[ResponseType] = Field(
        None,
        description='Describes the type of response being sent.  Answer responds to the user query.  Elicitation allows the server to request additional information to carry out the task, and Promise allows for async task status checks. (optional)',
    )
    request_id: Optional[str] = Field(
        None, description='Request ID for tracking asynchronous responses (optional)'
    )
    version: Optional[str] = Field(None, description='protocol version (optional)')


class Context(BaseModel):
    prev: Optional[List[str]] = Field(
        None, description='Array of previous queries in the conversation.  (optional)'
    )
    text: Optional[str] = Field(
        None,
        description='Free-form text paragraph describing the broader context (optional)',
    )
    memory: Optional[List[str]] = Field(
        None,
        description="Persistent information about the user's preferences, constraints, or characteristics",
    )


class Meta(BaseModel):
    conversation_id: Optional[str] = Field(
        None,
        description='Identifier for tracking the conversation across multiple queries. (optional)',
    )
    api_version: Optional[str] = Field(
        None, description='API version number being used (optional)'
    )
    request_id: Optional[str] = Field(
        None,
        description='Request ID to check status of a previous Promise response. Only used when polling for async results. (optional)',
    )


class Query(BaseModel):
    text: str = Field(..., description='Natural language query from user.  (required)')
    site: Optional[List[str]] = Field(
        None,
        description='Website or domain to search. May include one or many. (optional)',
    )
    location: Optional[str] = Field(
        None, description='Geographic constraint of query (optional)'
    )
    price: Optional[str] = Field(
        None, description='price range or constraint (optional)'
    )
    type: Optional[str] = Field(
        None, description='Type of item requested (e.g., movie, recipe, customer, etc.)'
    )


class Resource(BaseModel):
    uri: Optional[str] = Field(
        None,
        description='Resource identifier/template reference, e.g., ui://widget/restaurant-card.html (optional)',
    )
    mimeType: Optional[str] = Field(
        None,
        description='MIME type, e.g., text/html+skybridge for ChatGPT Apps. (optional)',
    )
    text: Optional[str] = Field(
        None, description='Raw content, typically HTML for widget rendering (optional)'
    )
    data: Union[Dict[str, Any], List[Dict[str, Any]]] = Field(
        ...,
        description='Structured data payload.\nCan be a single object or an array of objects, potentially of different types.\n(required)',
    )


class ResourceContent(BaseModel):
    type: Literal['resource'] = Field(..., description='must be "resource"')
    resource: Resource = Field(..., description='Resource details')


class ClientType(Enum):
    mobile = 'mobile'
    desktop = 'desktop'
    tablet = 'tablet'
    web = 'web'


class ReturnResponse(BaseModel):
    streaming: Optional[bool] = Field(
        True,
        description='Boolean indicating whether streaming response is desired. Defaults to true. (true or false)',
    )
    format: Optional[str] = Field(
        None,
        description='Response format specification, e.g., chatgpt_app, etc. (optional)',
    )
    mode: Optional[str] = Field(
        None, description='Response mode such as list, summarize, etc. (optional)'
    )
    lang: Optional[str] = Field(
        None,
        description='Language code (e.g., en, fr, es) for the response. (optional)',
    )
    client_type: Optional[ClientType] = Field(
        None,
        description='Type of client making the request, for example, mobile, desktop, etc. (optional)',
    )


class TextContent(BaseModel):
    type: Literal['text'] = Field(..., description='Must be "text" (required)')
    text: str = Field(..., description='Natural language content (required)')


class WhoRequest(BaseModel):
    query: str = Field(
        ..., description='Natural language query for agent discovery (required)'
    )
    streaming: Optional[bool] = Field(
        True, description='Enable streaming response.  Defaults to true. (optional)'
    )
    conversation_id: Optional[str] = Field(
        None,
        description='Conversational identifier - pass-through only when there are simultaneous conversations to track (optional)',
    )
    constr: Optional[Dict[str, Any]] = Field(
        None, description='Additional Constraints (filters, capabilities, etc.)'
    )


class WhoResponseMeta(BaseModel):
    conversation_id: Optional[str] = Field(
        None,
        description='conversational identifier - pass-through only when there are simultaneous conversations to track (optional)',
    )
    version: Optional[str] = Field(None, description='protocol version (optional)')


class AskRequest(BaseModel):
    query: Query = Field(
        ...,
        description="Specifies the user's current request and associated query parameters in natural language. (required)",
    )
    context: Optional[Context] = Field(
        None,
        description='Provides contextual information about the query to help the agent better understand and respond to the request.  Context can be communicated in multiple ways depending on what information is available and relevant. (optional)',
    )
    return_response: Optional[ReturnResponse] = Field(
        None,
        description='Specifies expectations and requirements for how the return response should be formatted and delivered. (optional)',
    )
    meta: Optional[Meta] = Field(
        None,
        description='Contains metadata about the request itself, including requested version number of the protocol and tracking information.',
    )


class AskResponse(BaseModel):
    field_meta: AskResponseMeta = Field(
        ..., alias='_meta', description='Metadata about the response'
    )
    content: List[Union[TextContent, ResourceContent]] = Field(
        ...,
        description='Array of content items (text and/or resource).\n\nConstraints:\n- Must contain at least one item\n- Must contain at least one TextContent item\n- May contain multiple items of each type in any order\n\nNote:  The requirement for at least one TextContent item must be validated by implementations, as this constraint cannot be expressed in the type system.',
        min_length=1,
    )


class WhoResponse(BaseModel):
    field_meta: WhoResponseMeta = Field(
        ..., alias='_meta', description='Metadata about the response'
    )
    content: List[Union[TextContent, ResourceContent]] = Field(
        ...,
        description='Array of content items containing agent descriptions.\n\nConstraints:\n- Must contain at least one item\n- Typically contains ResourceContent with Agent data\n- May include TextContent for descriptions',
        min_length=1,
    )
