"""Manifest - CLI Output Formatters (SAP-043)

Output formatting utilities for CLI responses. Supports JSON, table,
and YAML formats.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

import json
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List
from uuid import UUID

import click


# ============================================================================
# Output Format Enum
# ============================================================================


class OutputFormat(str, Enum):
    """Supported output formats."""

    JSON = "json"
    TABLE = "table"
    YAML = "yaml"


# ============================================================================
# JSON Encoder
# ============================================================================


class ManifestJSONEncoder(json.JSONEncoder):
    """Custom JSON encoder for Manifest types."""

    def default(self, obj):
        """Encode special types."""
        if isinstance(obj, datetime):
            return obj.isoformat()
        if isinstance(obj, UUID):
            return str(obj)
        if isinstance(obj, Enum):
            return obj.value
        return super().default(obj)


# ============================================================================
# Formatters
# ============================================================================


def format_json(data: Any, pretty: bool = True) -> str:
    """Format data as JSON.

    Args:
        data: Data to format
        pretty: Whether to pretty-print JSON

    Returns:
        JSON string
    """
    indent = 2 if pretty else None
    return json.dumps(
        data,
        cls=ManifestJSONEncoder,
        indent=indent,
        ensure_ascii=False
    )


def format_table(
    data: List[Dict[str, Any]],
    columns: List[str],
    headers: Dict[str, str]
) -> str:
    """Format data as ASCII table.

    Args:
        data: List of dictionaries to format
        columns: Column keys to display
        headers: Mapping of column keys to display headers

    Returns:
        Formatted table string
    """
    if not data:
        return "(no results)"

    # Calculate column widths
    col_widths = {}
    for col in columns:
        header_width = len(headers.get(col, col))
        max_data_width = max(
            len(str(row.get(col, ""))) for row in data
        )
        col_widths[col] = max(header_width, max_data_width)

    # Build header
    header_parts = []
    separator_parts = []
    for col in columns:
        width = col_widths[col]
        header_parts.append(headers.get(col, col).ljust(width))
        separator_parts.append("-" * width)

    lines = []
    lines.append("  ".join(header_parts))
    lines.append("  ".join(separator_parts))

    # Build rows
    for row in data:
        row_parts = []
        for col in columns:
            value = row.get(col, "")
            # Format datetime objects
            if isinstance(value, datetime):
                value = value.strftime("%Y-%m-%d %H:%M:%S")
            # Format UUID objects
            elif isinstance(value, UUID):
                value = str(value)[:8] + "..."
            # Format enum objects
            elif isinstance(value, Enum):
                value = value.value

            row_parts.append(str(value).ljust(col_widths[col]))
        lines.append("  ".join(row_parts))

    return "\n".join(lines)


def format_yaml(data: Any) -> str:
    """Format data as YAML.

    Args:
        data: Data to format

    Returns:
        YAML string

    Note:
        This is a simple YAML formatter. For production use,
        consider using PyYAML library.
    """
    def _format_value(value: Any, indent: int = 0) -> str:
        """Recursively format value as YAML."""
        spacing = "  " * indent

        if isinstance(value, dict):
            lines = []
            for k, v in value.items():
                if isinstance(v, (dict, list)):
                    lines.append(f"{spacing}{k}:")
                    lines.append(_format_value(v, indent + 1))
                else:
                    formatted_v = _format_scalar(v)
                    lines.append(f"{spacing}{k}: {formatted_v}")
            return "\n".join(lines)

        elif isinstance(value, list):
            if not value:
                return f"{spacing}[]"
            lines = []
            for item in value:
                if isinstance(item, (dict, list)):
                    lines.append(f"{spacing}-")
                    lines.append(_format_value(item, indent + 1))
                else:
                    formatted_item = _format_scalar(item)
                    lines.append(f"{spacing}- {formatted_item}")
            return "\n".join(lines)

        else:
            return f"{spacing}{_format_scalar(value)}"

    def _format_scalar(value: Any) -> str:
        """Format scalar value."""
        if isinstance(value, datetime):
            return value.isoformat()
        elif isinstance(value, UUID):
            return str(value)
        elif isinstance(value, Enum):
            return value.value
        elif isinstance(value, str):
            # Quote strings with special characters
            if any(c in value for c in [":", "{", "}", "[", "]", ",", "&", "*", "#", "?", "|", "-", "<", ">", "=", "!", "%", "@"]):
                return f'"{value}"'
            return value
        elif value is None:
            return "null"
        elif isinstance(value, bool):
            return "true" if value else "false"
        else:
            return str(value)

    return _format_value(data)


# ============================================================================
# High-Level Formatting
# ============================================================================


def format_output(data: Any, format: OutputFormat) -> str:
    """Format data according to specified format.

    Args:
        data: Data to format
        format: Output format

    Returns:
        Formatted string
    """
    if format == OutputFormat.JSON:
        return format_json(data)
    elif format == OutputFormat.YAML:
        return format_yaml(data)
    elif format == OutputFormat.TABLE:
        # For table format, data should be list of dicts
        if isinstance(data, list) and data and isinstance(data[0], dict):
            # Auto-detect columns from first item
            columns = list(data[0].keys())
            headers = {col: col.replace("_", " ").title() for col in columns}
            return format_table(data, columns, headers)
        else:
            # Fall back to JSON for non-tabular data
            return format_json(data)
    else:
        return format_json(data)


def print_output(data: Any, format: OutputFormat):
    """Print formatted output to terminal.

    Args:
        data: Data to print
        format: Output format
    """
    output = format_output(data, format)
    click.echo(output)


def print_success(message: str, format: OutputFormat = OutputFormat.TABLE):
    """Print success message.

    Args:
        message: Success message
        format: Output format
    """
    if format == OutputFormat.JSON:
        click.echo(format_json({"success": True, "message": message}))
    else:
        click.secho(f"✓ {message}", fg="green")


def print_error(message: str, format: OutputFormat = OutputFormat.TABLE):
    """Print error message.

    Args:
        message: Error message
        format: Output format
    """
    if format == OutputFormat.JSON:
        click.echo(format_json({"success": False, "error": message}))
    else:
        click.secho(f"✗ {message}", fg="red", err=True)


def print_warning(message: str, format: OutputFormat = OutputFormat.TABLE):
    """Print warning message.

    Args:
        message: Warning message
        format: Output format
    """
    if format == OutputFormat.JSON:
        click.echo(format_json({"warning": message}))
    else:
        click.secho(f"⚠ {message}", fg="yellow")


def print_entity(entity: Dict[str, Any], format: OutputFormat):
    """Print single entity.

    Args:
        entity: Entity dictionary
        format: Output format
    """
    if format == OutputFormat.TABLE:
        # Print as key-value pairs
        for key, value in entity.items():
            formatted_key = key.replace("_", " ").title()
            if isinstance(value, datetime):
                value = value.strftime("%Y-%m-%d %H:%M:%S")
            elif isinstance(value, UUID):
                value = str(value)
            elif isinstance(value, Enum):
                value = value.value
            click.echo(f"{formatted_key}: {value}")
    else:
        print_output(entity, format)


def print_entity_list(
    entities: List[Dict[str, Any]],
    format: OutputFormat,
    columns: List[str] = None
):
    """Print list of entities.

    Args:
        entities: List of entity dictionaries
        format: Output format
        columns: Optional columns to display (for table format)
    """
    if format == OutputFormat.TABLE and columns:
        headers = {col: col.replace("_", " ").title() for col in columns}
        output = format_table(entities, columns, headers)
        click.echo(output)
    else:
        print_output(entities, format)