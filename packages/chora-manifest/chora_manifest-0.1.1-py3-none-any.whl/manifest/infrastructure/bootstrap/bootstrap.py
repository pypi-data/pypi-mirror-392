"""Manifest - Bootstrap Implementation (SAP-045)

Dependency-ordered component startup with failure handling and rollback.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

import asyncio
from datetime import datetime
from enum import Enum
from typing import Any, Callable, Dict, List, Optional

from pydantic import BaseModel, Field


# ============================================================================
# Bootstrap Phase Enum
# ============================================================================


class BootstrapPhase(str, Enum):
    """Bootstrap lifecycle phases."""

    INITIALIZING = "initializing"
    STARTING = "starting"
    READY = "ready"
    STOPPING = "stopping"
    STOPPED = "stopped"
    FAILED = "failed"


# ============================================================================
# Component Definition
# ============================================================================


class Component(BaseModel):
    """Service component with lifecycle hooks."""

    name: str = Field(
        ...,
        description="Component name"
    )

    dependencies: List[str] = Field(
        default_factory=list,
        description="Names of components this depends on"
    )

    startup_fn: Optional[Callable] = Field(
        None,
        description="Async function to call during startup",
        exclude=True
    )

    shutdown_fn: Optional[Callable] = Field(
        None,
        description="Async function to call during shutdown",
        exclude=True
    )

    health_check_fn: Optional[Callable] = Field(
        None,
        description="Async function to check component health",
        exclude=True
    )

    timeout_seconds: int = Field(
        30,
        description="Startup timeout in seconds"
    )

    critical: bool = Field(
        True,
        description="Whether failure of this component is critical"
    )

    model_config = {
        "arbitrary_types_allowed": True
    }


# ============================================================================
# Bootstrap Result
# ============================================================================


class BootstrapResult(BaseModel):
    """Result of bootstrap operation."""

    success: bool = Field(
        ...,
        description="Whether bootstrap succeeded"
    )

    phase: BootstrapPhase = Field(
        ...,
        description="Current bootstrap phase"
    )

    started_components: List[str] = Field(
        default_factory=list,
        description="Components that started successfully"
    )

    failed_components: Dict[str, str] = Field(
        default_factory=dict,
        description="Components that failed (name -> error message)"
    )

    duration_seconds: float = Field(
        0.0,
        description="Total bootstrap duration"
    )

    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        description="Bootstrap timestamp"
    )


# ============================================================================
# Bootstrap Orchestrator
# ============================================================================


class Bootstrap:
    """Bootstrap orchestrator for dependency-ordered startup.

    Manages component lifecycle with proper dependency resolution,
    timeout handling, and rollback on failure.
    """

    def __init__(self):
        """Initialize bootstrap orchestrator."""
        self._components: Dict[str, Component] = {}
        self._phase = BootstrapPhase.INITIALIZING
        self._started_components: List[str] = []

    def register_component(self, component: Component):
        """Register a component.

        Args:
            component: Component to register

        Raises:
            ValueError: If component already registered
        """
        if component.name in self._components:
            raise ValueError(f"Component '{component.name}' already registered")

        self._components[component.name] = component

    async def start(self) -> BootstrapResult:
        """Start all components in dependency order.

        Returns:
            Bootstrap result

        Raises:
            RuntimeError: If bootstrap already started
        """
        if self._phase not in (BootstrapPhase.INITIALIZING, BootstrapPhase.STOPPED):
            raise RuntimeError(f"Cannot start from phase {self._phase}")

        start_time = datetime.utcnow()
        self._phase = BootstrapPhase.STARTING
        failed_components = {}

        try:
            # Resolve startup order
            startup_order = self._resolve_dependencies()

            # Start components in order
            for component_name in startup_order:
                component = self._components[component_name]

                try:
                    await self._start_component(component)
                    self._started_components.append(component_name)

                except Exception as e:
                    error_msg = f"Failed to start: {str(e)}"
                    failed_components[component_name] = error_msg

                    if component.critical:
                        # Critical component failed - rollback
                        self._phase = BootstrapPhase.FAILED
                        await self._rollback()

                        duration = (datetime.utcnow() - start_time).total_seconds()
                        return BootstrapResult(
                            success=False,
                            phase=self._phase,
                            started_components=self._started_components,
                            failed_components=failed_components,
                            duration_seconds=duration
                        )

            # All components started successfully
            self._phase = BootstrapPhase.READY
            duration = (datetime.utcnow() - start_time).total_seconds()

            return BootstrapResult(
                success=True,
                phase=self._phase,
                started_components=self._started_components,
                failed_components=failed_components,
                duration_seconds=duration
            )

        except Exception as e:
            # Unexpected error during bootstrap
            self._phase = BootstrapPhase.FAILED
            await self._rollback()

            duration = (datetime.utcnow() - start_time).total_seconds()
            return BootstrapResult(
                success=False,
                phase=self._phase,
                started_components=self._started_components,
                failed_components={"_bootstrap": str(e)},
                duration_seconds=duration
            )

    async def stop(self) -> BootstrapResult:
        """Stop all components in reverse order.

        Returns:
            Bootstrap result
        """
        if self._phase not in (BootstrapPhase.READY, BootstrapPhase.FAILED):
            raise RuntimeError(f"Cannot stop from phase {self._phase}")

        start_time = datetime.utcnow()
        self._phase = BootstrapPhase.STOPPING
        failed_components = {}

        # Stop in reverse order
        for component_name in reversed(self._started_components):
            component = self._components[component_name]

            try:
                await self._stop_component(component)
            except Exception as e:
                failed_components[component_name] = f"Failed to stop: {str(e)}"

        self._phase = BootstrapPhase.STOPPED
        self._started_components = []

        duration = (datetime.utcnow() - start_time).total_seconds()
        return BootstrapResult(
            success=len(failed_components) == 0,
            phase=self._phase,
            started_components=[],
            failed_components=failed_components,
            duration_seconds=duration
        )

    async def health_check(self) -> Dict[str, Any]:
        """Check health of all started components.

        Returns:
            Health status for each component
        """
        health_status = {}

        for component_name in self._started_components:
            component = self._components[component_name]

            if component.health_check_fn:
                try:
                    result = await component.health_check_fn()
                    health_status[component_name] = {
                        "status": "healthy",
                        "details": result
                    }
                except Exception as e:
                    health_status[component_name] = {
                        "status": "unhealthy",
                        "error": str(e)
                    }
            else:
                health_status[component_name] = {
                    "status": "unknown",
                    "message": "No health check defined"
                }

        return {
            "phase": self._phase.value,
            "components": health_status,
            "timestamp": datetime.utcnow().isoformat()
        }

    def _resolve_dependencies(self) -> List[str]:
        """Resolve component dependencies using topological sort.

        Returns:
            List of component names in startup order

        Raises:
            ValueError: If circular dependency detected
        """
        # Build adjacency list
        graph: Dict[str, List[str]] = {name: [] for name in self._components}
        in_degree: Dict[str, int] = {name: 0 for name in self._components}

        for name, component in self._components.items():
            for dep in component.dependencies:
                if dep not in self._components:
                    raise ValueError(f"Component '{name}' depends on unknown component '{dep}'")
                graph[dep].append(name)
                in_degree[name] += 1

        # Topological sort (Kahn's algorithm)
        queue = [name for name, degree in in_degree.items() if degree == 0]
        result = []

        while queue:
            current = queue.pop(0)
            result.append(current)

            for neighbor in graph[current]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)

        if len(result) != len(self._components):
            raise ValueError("Circular dependency detected")

        return result

    async def _start_component(self, component: Component):
        """Start a single component with timeout.

        Args:
            component: Component to start

        Raises:
            TimeoutError: If startup exceeds timeout
            Exception: If startup fails
        """
        if component.startup_fn:
            await asyncio.wait_for(
                component.startup_fn(),
                timeout=component.timeout_seconds
            )

    async def _stop_component(self, component: Component):
        """Stop a single component with timeout.

        Args:
            component: Component to stop

        Raises:
            TimeoutError: If shutdown exceeds timeout
            Exception: If shutdown fails
        """
        if component.shutdown_fn:
            await asyncio.wait_for(
                component.shutdown_fn(),
                timeout=component.timeout_seconds
            )

    async def _rollback(self):
        """Rollback startup by stopping all started components."""
        for component_name in reversed(self._started_components):
            component = self._components[component_name]
            try:
                await self._stop_component(component)
            except Exception:
                # Best effort - log but continue rollback
                pass

        self._started_components = []


# ============================================================================
# Factory Function
# ============================================================================


def create_bootstrap() -> Bootstrap:
    """Create bootstrap orchestrator with Manifest components.

    Returns:
        Configured bootstrap orchestrator
    """
    bootstrap = Bootstrap()

    # Register core service component
    async def start_core_service():
        """Start core service."""
        # Core service initialization
        pass

    async def stop_core_service():
        """Stop core service."""
        # Core service cleanup
        pass

    async def check_core_health():
        """Check core service health."""
        return {"status": "healthy"}

    bootstrap.register_component(Component(
        name="core",
        dependencies=[],
        startup_fn=start_core_service,
        shutdown_fn=stop_core_service,
        health_check_fn=check_core_health,
        timeout_seconds=30,
        critical=True
    ))

    # Register interface components (depend on core)
    async def start_rest_interface():
        """Start REST API."""
        # REST API initialization
        pass

    async def stop_rest_interface():
        """Stop REST API."""
        # REST API cleanup
        pass

    bootstrap.register_component(Component(
        name="rest",
        dependencies=["core"],
        startup_fn=start_rest_interface,
        shutdown_fn=stop_rest_interface,
        timeout_seconds=15,
        critical=False  # Non-critical - service can run without REST
    ))

    return bootstrap