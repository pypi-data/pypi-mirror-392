"""
plot.py - Plotly visualization functions for LinDistModel results
"""

from typing import Optional
import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

from distopf.matrix_models.base import LinDistBase
from distopf.importer import Case

def _choose_t(df, t=None):
    df = df.copy()
    if t is None:
        t = 0
    if "t" in df.columns:
        if t is None and len(df) > 0:
            t = min(df.t)
        df = df.loc[df.t == t, :]
        df = df.drop("t", axis=1)
    return df


def plot_voltages(v: pd.DataFrame, t=None) -> go.Figure:
    """
    Parameters
    ----------
    v : pd.DataFrame, Dataframe containing solved voltages for each bus.
        Typically generated by the LinDistModel.get_voltages() method.

    Returns
    -------
    fig : Plotly figure object
        Plotly figure object containing the voltage magnitudes for each bus.
    """
    v = v.copy()
    if "id" not in v.columns:
        v["id"] = v.index
    if "name" not in v.columns:
        v["name"] = v["id"]
    # if t is None and "t" in v.columns:
    #     t = min(v.t)
    # if "t" in v.columns:
    #     v = v.loc[v.t == t, :]
    #     v = v.drop("t", axis=1)
    v = _choose_t(v, t=t)
    v = v.melt(
        ignore_index=False, id_vars=["id", "name"], var_name="phase", value_name="v"
    )
    v["v"] = v["v"].astype(float)
    fig = px.scatter(v, x=v.name, y="v", facet_col="phase", color="phase")
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.for_each_xaxis(lambda a: a.update(title="Bus Name"))
    return fig


def compare_voltages(v1: pd.DataFrame, v2: pd.DataFrame, t=None) -> go.Figure:
    """
    Visually compare voltages by plotting two different results.
    Parameters
    ----------
    v1 : pd.DataFrame
    v2 : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """
    v1 = v1.copy()
    v2 = v2.copy()
    if "id" not in v1.columns:
        v1["id"] = v1.index
    if "name" not in v1.columns:
        v1["name"] = v1["id"]
    if "id" not in v2.columns:
        v2["id"] = v2.index
    if "name" not in v2.columns:
        v2["name"] = v2["id"]

    if t is None and "t" in v1.columns:
        t1 = min(v1.t)
    if t is None and "t" in v2.columns:
        t2 = min(v2.t)
    assert t1 == t2
    if "t" in v1.columns:
        v1 = pd.DataFrame(v1.loc[v1.t == t1, :])
        v1 = v1.drop("t", axis=1)
    if "t" in v2.columns:
        v2 = pd.DataFrame(v2.loc[v2.t == t2, :])
        v2 = v2.drop("t", axis=1)
    v1 = v1.melt(
        ignore_index=True, var_name="phase", id_vars=["id", "name"], value_name="v1"
    )
    v2 = v2.melt(
        ignore_index=True, var_name="phase", id_vars=["id", "name"], value_name="v2"
    )
    v = pd.merge(v1, v2, on=["id", "name", "phase"])
    v = v.melt(
        ignore_index=True,
        var_name="value",
        id_vars=["id", "name", "phase"],
        value_name="v",
    ).sort_values(by=["id", "phase"])
    # v1["v1"] = v1["v1"].astype(float)
    # v2["v2"] = v2["v2"].astype(float)
    # v = pd.merge(v1, v2, on=["name", "phase"])
    fig = px.line(v, x="name", facet_col="phase", y="v", color="value", markers=True)
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.for_each_xaxis(lambda a: a.update(title="Bus Name"))
    return fig


def voltage_differences(v1: pd.DataFrame, v2: pd.DataFrame, t=None) -> go.Figure:
    """
    Visually compare voltages from two different results by plotting the difference v1-v2.
    Parameters
    ----------
    v1 : pd.DataFrame
    v2 : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """
    v1 = v1.copy()
    v2 = v2.copy()
    if "id" not in v1.columns:
        v1["id"] = v1.index
    if "name" not in v1.columns:
        v1["name"] = v1["id"]
    if "id" not in v2.columns:
        v2["id"] = v2.index
    if "name" not in v2.columns:
        v2["name"] = v2["id"]
    if "t" in v1.columns:
        if t is None:
            t1 = min(v1.t)
        v1 = pd.DataFrame(v1.loc[v1.t == t1, :])
        v1 = v1.drop("t", axis=1)
    if "t" in v2.columns:
        if t is None:
            t2 = min(v2.t)
        v2 = pd.DataFrame(v2.loc[v2.t == t2, :])
        v2 = v2.drop("t", axis=1)
    v1 = v1.melt(
        ignore_index=True, var_name="phase", id_vars=["id", "name"], value_name="v1"
    )
    v2 = v2.melt(
        ignore_index=True, var_name="phase", id_vars=["id", "name"], value_name="v2"
    )
    v = pd.merge(v1, v2, on=["id", "name", "phase"])
    v["diff"] = v["v1"] - v["v2"]
    # fig = px.line(v, x="id", y="diff", facet_col="phase")
    fig = px.bar(
        v,
        x="name",
        y="diff",
        color="phase",
        barmode="group",
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.for_each_xaxis(lambda a: a.update(title="Bus Name"))
    return fig


def plot_power_flows(s: pd.DataFrame) -> go.Figure:
    """
    Plot the active and reactive power flowing into each bus on each phase.
    Parameters
    ----------
    s : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """
    s = s.copy()
    s = s.melt(
        ignore_index=True,
        id_vars=["fb", "tb", "from_name", "to_name"],
        var_name="phase",
        value_name="s",
    )
    s["p"] = s.s.apply(lambda x: x.real)
    s["q"] = s.s.apply(lambda x: x.imag)
    del s["s"]
    s = s.melt(
        ignore_index=True,
        id_vars=["fb", "tb", "from_name", "to_name", "phase"],
        var_name="part",
        value_name="power",
    )
    fig = px.bar(
        s,
        x="to_name",
        y="power",
        facet_col="phase",
        facet_row="part",
        color="phase",
        labels={"to_name": "To-Bus Name"},
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.update_layout(
        yaxis4_title="Active Power (p.u.)",
        yaxis_title="Reactive Power (p.u.)",
    )
    return fig


def plot_gens(p_gens: pd.DataFrame, q_gens: pd.DataFrame, t=None) -> go.Figure:
    """
    Plot the active and reactive power flowing into each bus on each phase.
    Parameters
    ----------
    p_gens : pd.DataFrame
    q_gens : pd.DataFrame
    Returns
    -------
    fig : Plotly figure object
    """
    p_gens = p_gens.copy()
    q_gens = q_gens.copy()
    if t is None:
        t = 0
    if "t" in p_gens.columns:
        t1 = t
        if t is None and len(p_gens) > 0:
            t1 = min(p_gens.t)
        p_gens = pd.DataFrame(p_gens.loc[p_gens.t == t1, :])
        p_gens = p_gens.drop("t", axis=1)
    if "t" in q_gens.columns:
        t2 = t
        if t is None and len(q_gens) > 0:
            t2 = min(q_gens.t)
        q_gens = pd.DataFrame(q_gens.loc[q_gens.t == t2, :])
        q_gens = q_gens.drop("t", axis=1)

    p_gens = p_gens.melt(
        ignore_index=True,
        id_vars=["id", "name"],
        var_name="phase",
        value_name="P",
    )
    q_gens = q_gens.melt(
        ignore_index=True,
        id_vars=["id", "name"],
        var_name="phase",
        value_name="Q",
    )
    gens = pd.merge(p_gens, q_gens, how="outer", on=["id", "name", "phase"])
    gens.id = p_gens.id
    gens.name = p_gens.name
    gens.phase = p_gens.phase
    gens["P"] = p_gens["P"]
    gens["Q"] = q_gens["Q"]
    gens = gens.melt(
        ignore_index=False,
        id_vars=["id", "name", "phase"],
        var_name="part",
        value_name="power",
    )
    fig = px.bar(
        gens,
        x="name",
        y="power",
        facet_col="phase",
        facet_row="part",
        color="phase",
        labels={"name": "Bus Name"},
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.update_layout(
        yaxis4_title="Active Power (p.u.)",
        yaxis_title="Reactive Power (p.u.)",
    )
    return fig


def plot_pq(p: pd.DataFrame, q: pd.DataFrame, t=None) -> go.Figure:
    """
    Plot the active and reactive power.
    Parameters
    ----------
    p : pd.DataFrame
    q : pd.DataFrame
    Returns
    -------
    fig : Plotly figure object
    """
    p = p.copy()
    q = q.copy()
    if t is None:
        t = 0
    if "t" in p.columns:
        t1 = t
        if t is None and len(p) > 0:
            t1 = min(p.t)
        p = pd.DataFrame(p.loc[p.t == t1, :])
        p = p.drop("t", axis=1)
    if "t" in q.columns:
        t2 = t
        if t is None and len(q) > 0:
            t2 = min(q.t)
        q = pd.DataFrame(q.loc[q.t == t2, :])
        q = q.drop("t", axis=1)

    p = p.melt(
        ignore_index=True,
        id_vars=["id", "name"],
        var_name="phase",
        value_name="P",
    )
    q = q.melt(
        ignore_index=True,
        id_vars=["id", "name"],
        var_name="phase",
        value_name="Q",
    )
    pq = pd.merge(p, q, how="outer", on=["id", "name", "phase"])
    pq.id = p.id
    pq.name = p.name
    pq.phase = p.phase
    pq["P"] = p["P"]
    pq["Q"] = q["Q"]
    pq = pq.melt(
        ignore_index=False,
        id_vars=["id", "name", "phase"],
        var_name="part",
        value_name="power",
    )
    fig = px.bar(
        pq,
        x="name",
        y="power",
        facet_col="phase",
        facet_row="part",
        color="phase",
        labels={"name": "Bus Name"},
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.update_layout(
        yaxis4_title="Active Power (p.u.)",
        yaxis_title="Reactive Power (p.u.)",
    )
    return fig


def compare_flows(s1: pd.DataFrame, s2: pd.DataFrame) -> go.Figure:
    """
    Similar to plot_power_flows but plots two results side by side.
    Parameters
    ----------
    s1 : pd.DataFrame
    s2 : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """
    s1 = s1.copy()
    s2 = s2.copy()
    if "from_name" not in s1.columns:
        s1["from_name"] = s1.fb
    if "to_name" not in s1.columns:
        s1["to_name"] = s1.tb
    if "from_name" not in s2.columns:
        s2["from_name"] = s2.fb
    if "to_name" not in s2.columns:
        s2["to_name"] = s2.tb

    s1 = s1.melt(
        ignore_index=True,
        id_vars=["fb", "tb", "from_name", "to_name"],
        var_name="phase",
        value_name="s",
    )
    s1["p"] = s1.s.apply(np.real)
    s1["q"] = s1.s.apply(np.imag)
    del s1["s"]
    s1 = s1.melt(
        ignore_index=True,
        id_vars=["fb", "tb", "from_name", "to_name", "phase"],
        var_name="part",
        value_name="s1",
    )
    s2 = s2.melt(
        ignore_index=True,
        id_vars=["fb", "tb", "from_name", "to_name"],
        var_name="phase",
        value_name="s",
    )
    s2["p"] = s2.s.apply(np.real)
    s2["q"] = s2.s.apply(np.imag)
    del s2["s"]
    s2 = s2.melt(
        ignore_index=True,
        id_vars=["fb", "tb", "from_name", "to_name", "phase"],
        var_name="part",
        value_name="s2",
    )
    s = pd.merge(
        s1, s2, on=["fb", "tb", "from_name", "to_name", "phase", "part"], how="outer"
    )
    fig = px.bar(
        s,
        x="to_name",
        y=["s1", "s2"],
        facet_col="phase",
        facet_row="part",
        barmode="group",
        labels={"to_name": "To-Bus Name"},
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1].upper()))
    fig.update_layout(
        yaxis4_title="Active Power (p.u.)",
        yaxis_title="Reactive Power (p.u.)",
    )
    return fig


def plot_ders(ders: pd.DataFrame) -> go.Figure:
    """
    Plot the generated power for each DER.
    Parameters
    ----------
    ders : pd.DataFrame

    Returns
    -------
    fig : Plotly figure object
    """
    ders = ders.copy()
    dec_var = ders.melt(
        ignore_index=False,
        var_name="phase",
        value_name="Generated Power (p.u.)",
        id_vars=["id", "name"],
    )
    fig = px.bar(
        dec_var,
        x=dec_var.name,
        y="Generated Power (p.u.)",
        color="phase",
        barmode="group",
        labels={"name": "DER Bus Name"},
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1]).upper())
    return fig


def plot_polar(p: pd.DataFrame, q: pd.DataFrame, t=None) -> go.Figure:
    p = p.copy()
    q = q.copy()
    if t is None:
        t = 0
    if "t" in p.columns:
        t1 = t
        if t is None and len(p) > 0:
            t1 = min(p.t)
        p = pd.DataFrame(p.loc[p.t == t1, :])
        p = p.drop("t", axis=1)
    if "t" in q.columns:
        t2 = t
        if t is None and len(q) > 0:
            t2 = min(q.t)
        q = pd.DataFrame(q.loc[q.t == t2, :])
        q = q.drop("t", axis=1)

    p = p.melt(
        ignore_index=True,
        id_vars=["id", "name"],
        var_name="phase",
        value_name="value",
    )
    q = q.melt(
        ignore_index=True,
        id_vars=["id", "name"],
        var_name="phase",
        value_name="value",
    )
    pq = pd.merge(p, q, how="outer", on=["id", "name", "phase"])
    pq.id = p.id
    pq.name = p.name
    pq.phase = p.phase
    pq["p"] = p.value
    pq["q"] = q.value
    pq["s"] = pq.p + 1j * pq.q
    pq["r"] = np.abs(pq.s)
    pq["th"] = np.angle(pq.s, deg=True)
    fig = px.scatter_polar(
        pq,
        r="r",
        theta="th",
        color="phase",
        # range_theta=[-90, 90],
        start_angle=0,
        direction="counterclockwise",
        hover_data="name",
    )
    return fig


def plot_batteries(p: pd.DataFrame, soc: pd.DataFrame) -> go.Figure:
    df = p.copy()
    p_last = df.loc[df.t == df.t.max(), :].copy()
    p_last.loc[:, "t"] = df.t.max() + 1
    df = pd.concat([df, p_last]).reset_index(drop=True)
    soc = soc.copy()
    soc.t = soc.t + 1
    soc.value = soc.value * 100
    df["value"] = df.a + df.b + df.c
    df["variable"] = "power"
    df.drop(["a", "b", "c"], axis=1)
    soc["variable"] = "soc"
    df = pd.concat([df, soc])
    fig = px.line(
        df,
        x="t",
        y="value",
        facet_row="variable",
        color="name",
        labels={"name": "Bus Name"},
    )
    for trace in fig.data:
        if trace.yaxis == "y2":  # Top row uses y2 axis
            trace.update(line_shape="hv")
    fig.for_each_annotation(lambda a: a.update(text=""))
    fig.update_layout(
        yaxis2_title="Discharging Power (p.u.)",
        yaxis_title="SOC (%)",
        yaxis=dict(matches=None),  # Make bottom y-axis independent
        yaxis2=dict(matches=None),  # Make top y-axis independent
    )

    return fig


def plot_network(
    model: LinDistBase | Case,
    v: Optional[pd.DataFrame] = None,
    s: Optional[pd.DataFrame] = None,
    p_flow: Optional[pd.DataFrame] = None,
    q_flow: Optional[pd.DataFrame] = None,
    p_gen: Optional[pd.DataFrame] = None,
    q_gen: Optional[pd.DataFrame] = None,
    v_min: float = 0.95,
    v_max: float = 1.05,
    show_phases: str = "abc",
    show_reactive_power: bool = False,
    t: Optional[int] = None,
) -> go.Figure:
    """
    Plot the distribution network showing voltage and power results.
    Parameters
    ----------
    model : LinDistBase
    v : pd.DataFrame, (default=None) Dataframe containing voltage magnitudes for each bus.
    s : pd.DataFrame, (default=None) Dataframe containing power flows for each branch. Either s or p_flow and q_flow should be provided.
    p_flow : pd.DataFrame, (default=None) Dataframe containing power flows for each branch.
    q_flow : pd.DataFrame, (default=None) Dataframe containing power flows for each branch.
    p_gen : pd.DataFrame, (default=None) Dataframe containing actve power generated by each generator.
    q_gen : pd.DataFrame, (default=None) Dataframe containing reactive power generated by each generator.
    v_min : (default=0.95) Used for scaling node colors.
    v_max : (default=1.05) Used for scaling node colors.
    show_phases : (default="abc") valid options: "a", "b", "c", or "abc"
    show_reactive_power : (default=False) If True, show reactive power flows instead of active power flows.

    Returns
    -------
    fig: plotly.graph_objects.Figure
    """
    _v = None
    _s = None
    if s is not None:
        _s = _choose_t(s.copy(), t)
    if v is not None:
        _v = _choose_t(v.copy(), t)
    if s is None and p_flow is not None and q_flow is not None:
        from_bus_map = {
            int(tb): int(fb)
            for fb, tb in model.branch_data.loc[:, ["fb", "tb"]].to_numpy()
        }
        _s = p_flow.copy()
        _s = _s.drop(["a", "b", "c"], axis=1)
        _s["a"] = p_flow.a + 1j * q_flow.a
        _s["b"] = p_flow.b + 1j * q_flow.b
        _s["c"] = p_flow.c + 1j * q_flow.c
        _s["tb"] = _s["id"]
        _s["fb"] = _s["tb"].map(from_bus_map)
        _s = _choose_t(_s, t)
    if p_gen is not None:
        p_gen = _choose_t(p_gen, t)
    if q_gen is not None:
        q_gen = _choose_t(q_gen, t)

    # validate phases
    if show_phases.lower() not in ["a", "b", "c", "abc"]:
        raise ValueError("Invalid phase. Must be 'a', 'b', 'c', or 'abc'.")
    show_phases = show_phases.lower()
    phase_list = sorted([ph.lower() for ph in show_phases])
    bus_data = model.bus_data.copy()
    branch_data = model.branch_data.copy()
    gen_data = model.gen_data.copy()
    cap_data = model.cap_data.copy()

    node_size = 10
    edge_scale = 10
    edge_min = 1

    bus_data = _process_bus_data(bus_data, _v, phase_list)
    branch_data = _process_branch_data(
        branch_data, bus_data, _s, phase_list, edge_scale, edge_min
    )
    gen_data = _process_gen_data(gen_data, p_gen, q_gen)

    node_trace = _make_node_trace(bus_data, node_size, v_max, v_min)
    cap_trace, gen_trace, substation_trace = _make_asset_markers(
        bus_data, cap_data, gen_data, node_size
    )
    edge_traces = _make_edge_traces(branch_data, show_phases, show_reactive_power)
    reverse_flow_markers_trace = _make_reverse_flow_marker_trace(
        branch_data, node_size, show_reactive_power
    )

    node_trace.text = _make_hover_text(branch_data, bus_data, cap_data, gen_data)
    title = _make_title(show_phases, show_reactive_power)

    fig = go.Figure(
        data=[
            *edge_traces,
            substation_trace,
            reverse_flow_markers_trace,
            cap_trace,
            gen_trace,
            node_trace,
        ]
    )

    fig.update_layout(
        title=title,
        plot_bgcolor="White",
        paper_bgcolor="White",
        title_font_color="Black",
        legend_font_color="Black",
        legend_bgcolor="White",
        margin=dict(t=50, b=10, l=10, r=10),
        xaxis=dict(visible=False),
        yaxis=dict(visible=False),
        legend=dict(x=0.8, y=0.9),
        font=dict(family="Droid Sans Mono", color="Black"),
        # annotations=arrow_list[0:1],
    )

    return fig


def _process_bus_data(bus_data, _v, phase_list):
    bus_data["y"] = bus_data.latitude - bus_data.latitude.mean()
    bus_data["x"] = bus_data.longitude - bus_data.longitude.mean()
    bus_data["color"] = "white"
    if bus_data.x.abs().max() > 0:
        bus_data.x = bus_data.x / bus_data.x.abs().max()
    if bus_data.y.abs().max() > 0:
        bus_data.y = bus_data.y / bus_data.y.abs().max()
    if _v is not None:
        _v.index = _v.id - 1
        bus_data.v_a = _v.a
        bus_data.v_b = _v.b
        bus_data.v_c = _v.c
        bus_data.color = _v[phase_list].mean(axis=1)
    return bus_data


def _process_branch_data(branch_data, bus_data, _s, phase_list, edge_scale, edge_min):
    branch_data = branch_data.loc[branch_data.status != "OPEN", :]
    branch_data.index = branch_data.tb.to_numpy() - 1
    branch_data["s_a"] = complex(np.nan, np.nan)
    branch_data["s_b"] = complex(np.nan, np.nan)
    branch_data["s_c"] = complex(np.nan, np.nan)
    branch_data["p_abs"] = 1
    branch_data["q_abs"] = 1
    branch_data["p_norm"] = edge_min
    branch_data["q_norm"] = edge_min
    branch_data["p_direction"] = 1
    branch_data["q_direction"] = 1
    branch_data["x0"] = bus_data.loc[branch_data.fb.to_numpy() - 1].x.to_numpy()
    branch_data["x1"] = bus_data.loc[branch_data.tb.to_numpy() - 1].x.to_numpy()
    branch_data["y0"] = bus_data.loc[branch_data.fb.to_numpy() - 1].y.to_numpy()
    branch_data["y1"] = bus_data.loc[branch_data.tb.to_numpy() - 1].y.to_numpy()
    branch_data["x_mid"] = 1 / 2 * (branch_data.x0 + branch_data.x1)
    branch_data["y_mid"] = 1 / 2 * (branch_data.y0 + branch_data.y1)
    if _s is not None:
        _s.index = _s.tb.to_numpy() - 1
        branch_data["s_a"] = _s.a
        branch_data["s_b"] = _s.b
        branch_data["s_c"] = _s.c
        branch_data["p_abs"] = np.abs(np.real(_s.loc[:, phase_list].sum(axis=1)))
        branch_data["q_abs"] = np.abs(np.imag(_s.loc[:, phase_list].sum(axis=1)))
        branch_data["p_norm"] = (
            branch_data["p_abs"].to_numpy() / branch_data["p_abs"].max() * edge_scale
            + edge_min
        )
        branch_data["q_norm"] = (
            branch_data["q_abs"].to_numpy() / branch_data["q_abs"].max() * edge_scale
            + edge_min
        )
        branch_data["p_direction"] = np.sign(
            np.real(_s.loc[:, phase_list].sum(axis=1)) + 1e-6
        )
        branch_data["q_direction"] = np.sign(
            np.imag(_s.loc[:, phase_list].sum(axis=1)) + 1e-6
        )
    return branch_data


def _process_gen_data(gen_data, p_gen, q_gen):
    gen_data.index = gen_data.id.to_numpy() - 1
    if p_gen is not None:
        p_gen.index = p_gen.id.to_numpy() - 1
        gen_data.pa = p_gen.a
        gen_data.pb = p_gen.b
        gen_data.pc = p_gen.c
    if q_gen is not None:
        q_gen.index = q_gen.id.to_numpy() - 1
        gen_data.qa = q_gen.a
        gen_data.qb = q_gen.b
        gen_data.qc = q_gen.c
    return gen_data


def _make_reverse_flow_marker_trace(branch_data, node_size, show_reactive_power):
    if show_reactive_power:
        reverse_list_x = branch_data.loc[
            branch_data.q_direction < 0, "x_mid"
        ].to_numpy()
        reverse_list_y = branch_data.loc[
            branch_data.q_direction < 0, "y_mid"
        ].to_numpy()
    else:
        reverse_list_x = branch_data.loc[
            branch_data.p_direction < 0, "x_mid"
        ].to_numpy()
        reverse_list_y = branch_data.loc[
            branch_data.p_direction < 0, "y_mid"
        ].to_numpy()
    reverse_flow_markers_trace = go.Scatter()
    if not show_reactive_power:
        reverse_flow_markers_trace = go.Scatter(
            x=reverse_list_x,
            y=reverse_list_y,
            mode="markers",
            marker=dict(
                symbol="star-triangle-up",
                size=node_size * 1,
                color="orange",
                line_width=0.5,
                line_color="black",
            ),
            showlegend=True,
            name="Reverse Power Flow",
            hoverinfo="none",
        )
    return reverse_flow_markers_trace


def _make_edge_traces(branch_data, show_phases, show_reactive_power):
    edge_traces = []
    for _, edge in branch_data.iterrows():
        x0, x1 = edge.x0, edge.x1
        y0, y1 = edge.y0, edge.y1
        dash = "solid"
        linewidth = edge.p_norm
        direction = edge.p_direction
        if show_reactive_power:
            linewidth = edge.q_norm
            direction = edge.q_direction
        if (
            show_phases.lower() != "abc"
            and show_phases.lower() not in edge.phases.lower()
        ):
            dash = "dot"

        color = "darkblue"
        if direction < 0:
            color = "maroon"
        edge_trace = go.Scatter(
            x=[x0, x1],
            y=[y0, y1],
            mode="lines",
            line=dict(color=color, width=linewidth, dash=dash),
            showlegend=False,
            hoverinfo="none",
        )
        edge_traces.append(edge_trace)
    return edge_traces


# def _make_hover_text(branch_data, bus_data, cap_data, gen_data):
#     text = [f"Bus: '{name}'      A   ||   B   ||   C" for name in bus_data["name"]]
#     for i, bus_row in enumerate(bus_data.itertuples()):
#         # if _v is not None:
#         va = bus_row.v_a
#         vb = bus_row.v_b
#         vc = bus_row.v_c
#         text[i] = text[i] + f"<br>    |V|:      {va:.3f}  {vb:.3f}  {vc:.3f}"

#         pla = bus_row.pl_a
#         plb = bus_row.pl_b
#         plc = bus_row.pl_c
#         qla = bus_row.ql_a
#         qlb = bus_row.ql_b
#         qlc = bus_row.ql_c
#         text[i] += f"<br>    P-Load: {pla:.3f}  {plb:.3f}  {plc:.3f}"
#         text[i] += f"<br>    Q-Load: {qla:.3f}  {qlb:.3f}  {qlc:.3f}"

#         if cap_data is not None:
#             if bus_row.id in cap_data.id.to_numpy():
#                 q_cap = cap_data.loc[
#                     cap_data.id == bus_row.id, ["qa", "qb", "qc"]
#                 ].to_numpy()[0]
#                 text[i] += (
#                     f"<br>    Q-Cap:  {q_cap[0]:.3f}  {q_cap[1]:.3f}  {q_cap[2]:.3f}"
#                 )

#         if bus_row.id in gen_data.id.to_numpy():
#             p_gen = gen_data.loc[
#                 gen_data.id == bus_row.id, ["pa", "pb", "pc"]
#             ].to_numpy()[0]
#             q_gen = gen_data.loc[
#                 gen_data.id == bus_row.id, ["qa", "qb", "qc"]
#             ].to_numpy()[0]
#             text[i] += f"<br>    P-Gen:  {p_gen[0]:.3f}  {p_gen[1]:.3f}  {p_gen[2]:.3f}"
#             text[i] += f"<br>    Q-Gen:  {q_gen[0]:.3f}  {q_gen[1]:.3f}  {q_gen[2]:.3f}"
#         edge = branch_data.loc[branch_data.tb == bus_row.id, :]
#         if len(edge) == 0:
#             continue
#         to_name = bus_row.name
#         fb = edge.fb.to_numpy()[0]
#         from_name = bus_data.loc[bus_data.id == fb, "name"].to_numpy()[0]
#         sa, sb, sc = (
#             edge.s_a.to_numpy()[0],
#             edge.s_b.to_numpy()[0],
#             edge.s_c.to_numpy()[0],
#         )
#         new_text = (
#             f"<br>Branch {from_name}‚Üí{to_name}"
#             f"<br>    P flow:  {np.real(sa):.3f}  {np.real(sb):.3f}  {np.real(sc):.3f}"
#             f"<br>    Q flow:  {np.imag(sa):.3f}  {np.imag(sb):.3f}  {np.imag(sc):.3f}"
#         )
#         text[i] += new_text
#     return text


def _make_hover_text(branch_data, bus_data, cap_data, gen_data):
    text = []
    for i, bus_row in enumerate(bus_data.itertuples()):
        bus_phases = bus_row.phases.lower()  # e.g. "abc", "ac", "ab", etc.

        # Helper function to format value or dash with better alignment
        def format_phase_value(value, phase):
            if phase in bus_phases:
                return f"{value:>7.3f}"  # Increased width for better alignment
            else:
                return "  ---  "  # Centered dashes with proper spacing

        # Start with bus header
        hover_text = ""
        hover_text = f"<b>  Bus: {bus_row.name:<5}        (p.u.)</b><br>"
        # Create a formatted table-like structure using spaces and HTML
        hover_text += "<b>              A       B       C</b><br>"  # Adjusted spacing
        # hover_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ<br>"

        # Voltage data
        va, vb, vc = bus_row.v_a, bus_row.v_b, bus_row.v_c
        va_str = format_phase_value(va, "a")
        vb_str = format_phase_value(vb, "b")
        vc_str = format_phase_value(vc, "c")
        hover_text += f"‚ö° V Mag   {va_str} {vb_str} {vc_str}<br>"

        # Load data
        pla, plb, plc = bus_row.pl_a, bus_row.pl_b, bus_row.pl_c
        qla, qlb, qlc = bus_row.ql_a, bus_row.ql_b, bus_row.ql_c
        pla_str = format_phase_value(pla, "a")
        plb_str = format_phase_value(plb, "b")
        plc_str = format_phase_value(plc, "c")
        qla_str = format_phase_value(qla, "a")
        qlb_str = format_phase_value(qlb, "b")
        qlc_str = format_phase_value(qlc, "c")
        hover_text += f"üí° P Load  {pla_str} {plb_str} {plc_str}<br>"
        hover_text += f"üí° Q Load  {qla_str} {qlb_str} {qlc_str}<br>"

        # Capacitor data (if present)
        if cap_data is not None and bus_row.id in cap_data.id.to_numpy():
            q_cap = cap_data.loc[
                cap_data.id == bus_row.id, ["qa", "qb", "qc"]
            ].to_numpy()[0]
            qcap_a_str = format_phase_value(q_cap[0], "a")
            qcap_b_str = format_phase_value(q_cap[1], "b")
            qcap_c_str = format_phase_value(q_cap[2], "c")
            hover_text += f"üîÉ Q Cap   {qcap_a_str} {qcap_b_str} {qcap_c_str}<br>"

        # Generator data (if present)
        if bus_row.id in gen_data.id.to_numpy():
            p_gen = gen_data.loc[
                gen_data.id == bus_row.id, ["pa", "pb", "pc"]
            ].to_numpy()[0]
            q_gen = gen_data.loc[
                gen_data.id == bus_row.id, ["qa", "qb", "qc"]
            ].to_numpy()[0]
            pgen_a_str = format_phase_value(p_gen[0], "a")
            pgen_b_str = format_phase_value(p_gen[1], "b")
            pgen_c_str = format_phase_value(p_gen[2], "c")
            qgen_a_str = format_phase_value(q_gen[0], "a")
            qgen_b_str = format_phase_value(q_gen[1], "b")
            qgen_c_str = format_phase_value(q_gen[2], "c")
            hover_text += f"‚öôÔ∏è P Gen   {pgen_a_str} {pgen_b_str} {pgen_c_str}<br>"
            hover_text += f"‚öôÔ∏è Q Gen   {qgen_a_str} {qgen_b_str} {qgen_c_str}<br>"

        # Branch flow data (if present)
        edge = branch_data.loc[branch_data.tb == bus_row.id, :]
        if len(edge) > 0:
            to_name = bus_row.name
            fb = edge.fb.to_numpy()[0]
            from_name = bus_data.loc[bus_data.id == fb, "name"].to_numpy()[0]
            sa, sb, sc = (
                edge.s_a.to_numpy()[0],
                edge.s_b.to_numpy()[0],
                edge.s_c.to_numpy()[0],
            )

            pflow_a_str = format_phase_value(np.real(sa), "a")
            pflow_b_str = format_phase_value(np.real(sb), "b")
            pflow_c_str = format_phase_value(np.real(sc), "c")
            qflow_a_str = format_phase_value(np.imag(sa), "a")
            qflow_b_str = format_phase_value(np.imag(sb), "b")
            qflow_c_str = format_phase_value(np.imag(sc), "c")

            hover_text += "<br>"
            hover_text += f"<b>  Branch: {from_name} ‚Üí {to_name}</b><br>"
            hover_text += f"‚û°Ô∏è P Flow  {pflow_a_str} {pflow_b_str} {pflow_c_str}<br>"
            hover_text += f"‚û°Ô∏è Q Flow  {qflow_a_str} {qflow_b_str} {qflow_c_str}<br>"
        text.append(hover_text)
    return text


def _make_title(show_phases, show_reactive_power):
    title = "<b>Network Plot (P.U.)</b>"
    # if _v is not None:
    title = title + "<br>Node color: "
    if show_phases == "abc":
        title = title + "Average voltage magnitude"
    else:
        title = title + f"Phase-{show_phases.upper()} voltage magnitude"
    # if _s is not None:
    title = title + "<br>Line width:"
    if show_phases == "abc":
        title = title + " Total"
    else:
        title = title + f" Phase-{show_phases.upper()}"
    if show_reactive_power:
        title = title + " <i>reactive</i> power flow"
    else:
        title = title + " <i>active</i> power flow"
    title = title + " (reverse flow in red)."
    return title


def _make_asset_markers(bus_data, cap_data, gen_data, node_size):
    # Add substation marker
    substation_buses = bus_data.loc[bus_data.bus_type == "SWING", :]
    substation_trace = go.Scatter(
        x=substation_buses["x"],
        y=substation_buses["y"],
        mode="markers",
        marker=dict(
            symbol="square",
            size=node_size * 2,
            color="black",
            line_width=1,
            line_color="black",
        ),
        showlegend=True,
        name="Substation",
        hoverinfo="none",
    )
    # Add generator markers
    gen_buses = bus_data.loc[bus_data.id.isin(gen_data.id), :]
    gen_trace = go.Scatter(
        x=gen_buses["x"],
        y=gen_buses["y"],
        mode="markers",
        marker=dict(
            symbol="square",
            size=node_size * 2,
            color="white",
            line_width=1,
            line_color="black",
        ),
        showlegend=True,
        name="Generators",
        hoverinfo="none",
    )
    # Add capacitor markers
    cap_buses = bus_data.loc[bus_data.id.isin(cap_data.id), :]
    cap_trace = go.Scatter(
        x=cap_buses["x"],
        y=cap_buses["y"],
        mode="markers",
        marker=dict(
            symbol="star-diamond",
            size=node_size * 2,
            color="white",
            line_width=1,
            line_color="black",
        ),
        showlegend=True,
        name="Capacitors",
        hoverinfo="none",
    )
    return cap_trace, gen_trace, substation_trace


def _make_node_trace(bus_data, node_size, v_max, v_min):
    node_trace = go.Scatter(
        x=bus_data["x"],
        y=bus_data["y"],
        mode="markers",
        marker=dict(
            showscale=True,
            cmin=v_min,
            cmax=v_max,
            # colorscale options
            # 'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
            # 'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
            # 'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' | 'Aggrnyl'
            colorscale="Viridis",
            reversescale=False,
            size=node_size,
            color=bus_data.color,
            line_width=node_size / 5,
            line_color="black",
        ),
        showlegend=False,
        text=bus_data["name"],
        hovertemplate="%{text}",
        hoverlabel=dict(font=dict(family="Monospace")),
        textposition="top center",
    )
    return node_trace
