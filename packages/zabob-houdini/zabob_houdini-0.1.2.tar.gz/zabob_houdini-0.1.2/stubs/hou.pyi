"""
Houdini hou module stubs for development.
This provides comprehensive type hints for the hou module when developing outside Houdini.
Hand-maintained for zabob-houdini project.

These stubs are designed to handle common type issues with Houdini's C++ bindings:
- Clear static vs instance method distinctions
- Comprehensive return type annotations
- Proper null handling and optional types
- Parameter type unions for flexible input acceptance
- Dynamic attribute access patterns
"""

from typing import Any, Generic, Sequence, Iterable, TypeAlias, overload, Type, TypeVar, Callable
from collections.abc import Iterator
import types
import datetime

from hrecipes.api.networkitems import SubnetIndirectInput
from searchbox.radialmenus import RadialMenus

# Type variables for generic operations
T = TypeVar('T')
NodeT = TypeVar('NodeT', bound='Node')

# Common type unions that Houdini uses (modern types)
ParameterValue = int | float | str | bool
ParameterDict = dict[str, ParameterValue]
NodePath = str | 'Node'
TransformValue = float | Sequence[float]

_Floats2: TypeAlias = 'tuple[float, float]|Sequence[float]|Vector2'  # A sequence of floats representing a point (x, y)

_Floats3: TypeAlias = 'tuple[float, float, float]|Sequence[float]|Vector3'

class EnumValue:
    """A simple class to represent enum values in Houdini."""
    def name(self) -> str: ...


class _Enum:
    pass

E = TypeVar('E', bound=_Enum)
class _EnumValue(EnumValue, Generic[E]):
    pass

class networkItemType(_Enum):
    """Enum for Houdini network item types."""
    Connection: '_EnumValue[networkItemType]'
    NetworkBox: '_EnumValue[networkItemType]'
    NetworkDot: '_EnumValue[networkItemType]'
    Node: '_EnumValue[networkItemType]'
    StickyNote: '_EnumValue[networkItemType]'
    SubnetIndirectInput: '_EnumValue[networkItemType]'

class exprLanguage(_Enum):
    """Enum for Houdini expression languages."""
    Python: '_EnumValue[exprLanguage]'
    Hscript: '_EnumValue[exprLanguage]'

class parmTemplateType(_Enum):
    """Houdini parameter template type enum-like object."""
    Int: '_EnumValue[parmTemplateType]'
    Float: '_EnumValue[parmTemplateType]'
    String: '_EnumValue[parmTemplateType]'
    Toggle: '_EnumValue[parmTemplateType]'
    Button: '_EnumValue[parmTemplateType]'
    Menu: '_EnumValue[parmTemplateType]'
    FolderSet: '_EnumValue[parmTemplateType]'
    Folder: '_EnumValue[parmTemplateType]'
    Separator: '_EnumValue[parmTemplateType]'
    Label: '_EnumValue[parmTemplateType]'
    Ramp: '_EnumValue[parmTemplateType]'
    Data: '_EnumValue[parmTemplateType]'

class attribType(_Enum):
    """Houdini attribute type enum-like object."""
    Float: '_EnumValue[attribType]'
    Int: '_EnumValue[attribType]'
    String: '_EnumValue[attribType]'
    Vector2: '_EnumValue[attribType]'
    Vector3: '_EnumValue[attribType]'
    Vector4: '_EnumValue[attribType]'
    Matrix3: '_EnumValue[attribType]'
    Matrix4: '_EnumValue[attribType]'
    Quaternion: '_EnumValue[attribType]'
    Transform: '_EnumValue[attribType]'

class groupType(_Enum):
    """Houdini group type enum-like object."""
    Point: '_EnumValue[groupType]'
    Prim: '_EnumValue[groupType]'
    Edge: '_EnumValue[groupType]'
    Vertex: '_EnumValue[groupType]'

class geometryType(_Enum):
    """Houdini geometry type enum-like object."""
    Points: '_EnumValue[geometryType]'
    Primitives: '_EnumValue[geometryType]'
    Edges: '_EnumValue[geometryType]'
    Vertices: '_EnumValue[geometryType]'

class attribData(_Enum):
    """Houdini attribute data enum-like object."""
    Float: '_EnumValue[attribData]'
    Int: '_EnumValue[attribData]'
    String: '_EnumValue[attribData]'

class BoundingRect:
    """Houdini bounding rectangle object."""
    @overload
    def __init__(self, x1: float, y1: float, x2: float, y2: float) -> None: ...
    @overload
    def __init__(self, p1: 'Vector2', p2: 'Vector2') -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def setTo(self, bounds_sequence: Sequence[float]) -> None: ...
    def isValid(self) -> bool: ...
    def isAlmostEqual(self, rect: 'BoundingRect', tolerance: float = 0.00001) -> bool: ...
    def min(self) -> 'Vector2': ...
    def max(self) -> 'Vector2': ...
    def size(self) -> 'Vector3': ...
    def center(self) -> 'Vector3': ...
    def contains(self, point: 'Vector2|BoundingRect') -> bool: ...
    def isEmpty(self) -> bool: ...
    @overload
    def intersects(self, other: 'NetworkMovableItem') -> bool: ...
    @overload
    def intersects(self, p1: _Floats2, p2: _Floats2) -> bool: ...
    @overload
    def intersects(self, p1: _Floats2, p2: _Floats2, p3: _Floats2) -> bool: ...
    def intersects(self, *args, **kwargs) -> bool: ...
    def closestPoint(self, point: '_Floats2') -> 'Vector2': ...
    def getOffsetToAvoid(self, bounds: 'BoundingRect', direction: 'Vector2|None' = None) -> 'Vector2': ...
    def translate(self, offset: '_Floats2') -> None: ...
    def scale(self, scale: _Floats2) -> None: ...
    def expand(self, offset: '_Floats2') -> None: ...
    def enlargeToContain(self, point_or_rect: '_Floats2|BoundingRect') -> None: ...
    def intersect(self, rect: 'BoundingRect') -> None: ...

class NetworkItem:
    """Base class for items that can be part of a network layout."""
    def networkItemType(self) -> 'networkItemType': ...

class NetworkMovableItem(NetworkItem):
    """Interface for items that can be moved in a network layout."""
    # Name and path
    def name(self) -> str: ...
    def setName(self, name: str) -> None: ...
    def digitsInName(self) -> int: ...
    def path(self) -> str: ...
    def relativePathTo(self, other: 'NetworkMovableItem') -> str: ...

    # Hierarchy
    def parent(self) -> 'NetworkMovableItem|None': ...
    def parentNetworkBox(self) -> 'NetworkBox|None': ...

    # Selection
    def isSelected(self) -> bool: ...
    def isPicked(self) -> bool: ...
    def setSelected(self, on: bool, clear_all_selected: bool=False, show_asset_if_selected: bool=False) -> None: ...
    def color(self) -> 'Color': ...
    def setColor(self, color: 'Color') -> None: ...
    def sessionId(self) -> int: ...

    # Layout
    def position(self) -> 'Vector2': ...
    def setPosition(self, position: '_Floats2') -> None: ...
    def move(self, vector2: '_Floats2') -> None: ...
    def shiftPosition(self, vector2: '_Floats2') -> None: ...
    def size(self) -> 'Vector2': ...

class NetworkBox(NetworkMovableItem):
    '''
    A network box
    '''
    def addItem(self, item: NetworkMovableItem) -> None: ...
    def addNetworkBox(self, name: str) -> 'NetworkBox': ...
    def addNode(self, node_type: str, name: str|None = None) -> 'Node': ...
    def alpha(self) -> float: ...
    def asCode(self, brief: bool=False, recurse: bool=False, save_box_contents: bool=False, save_channels_only: bool=False, save_creation_command: bool=False, save_keys_in_frames: bool=False, save_parm_values_only: bool=False, save_spare_parms: bool=False, save_box_membership: bool=True, function_name: str|None=None) -> str: ...
    def autoFit(self) -> bool: ...
    def comment(self) -> str: ...
    def destroy(self, destroy_contents: bool) -> None: ...
    def fitAroundContents(self) -> None: ...
    def isMinimized(self) -> bool: ...
    def items(self) -> tuple[NetworkMovableItem, ...]: ...
    def minimizedSize(self) -> 'Vector2': ...
    def nodes(self, recurse: bool=True) -> tuple['Node', ...]: ...
    def networkBoxes(self, recurse: bool=True) -> tuple['NetworkBox', ...]: ...
    def removeAllItems(self) -> None: ...
    def removeItem(self, item: NetworkMovableItem) -> None: ...
    def resize(self, vector2: Vector2) -> None: ...
    def restoredSize(self) -> 'Vector2': ...
    def setAutoFit(self, on: bool) -> None: ...
    def setBounds(self, bounds: BoundingRect) -> None: ...
    def setComment(self, comment: str) -> None: ...
    def setMinimized(self, on: bool) -> None: ...
    def setAlpha(self, alpha: float) -> None: ...
    def setSize(self, size: '_Floats2') -> None: ...
    def stickyNotes(self, recurse: bool=True) -> tuple['StickyNote', ...]: ...


class StickyNote(NetworkMovableItem):
    """A sticky note in the network editor."""
    def text(self) -> str: ...
    def setText(self, text: str) -> None: ...
    def textColor(self) -> 'Color': ...
    def setColor(self, color: 'Color') -> None: ...
    def textSize(self) -> float: ...
    def setTextSize(self, size: float) -> None: ...
    def destroy(self) -> None: ...
    def drawBackground(self) -> bool: ...
    def isMinimized(self) -> bool: ...
    def maximizedSize(self) -> 'Vector2': ...
    def resize(self, vector2: _Floats2) -> None: ...
    def restoredSize(self) -> 'Vector2': ...
    def setBounds(self, bounds: BoundingRect) -> None: ...
    def setMinimized(self, on: bool) -> None: ...
    def setDrawBackground(self, on: bool) -> None: ...
    def asData(self) -> dict[str, Any]: ...
    def setFromData(self, data: dict[str, Any]) -> None: ...

class IndirectInput(NetworkMovableItem):
    """A subnet indirect input in the network editor."""
    # Inputs and Outputs
    def outputs(self) -> tuple['Node', ...]: ...
    def connections(self) -> tuple['NodeConnection', ...]: ...
    def input(self) -> 'Node|None': ...
    def inputOutputIndex(self) -> int: ...

    # Metadata
    def setColorDefault(self) -> None: ...
    def setSymbolicColorName(self, name: str) -> None: ...
    def setUseColorFromOutput(self, use_output_color: bool) -> None: ...
    def symbolicColorName(self) -> str: ...
    def useColorFromOutput(self) -> bool: ...


class NetworkDot(IndirectInput):
    """A network dot in the network editor."""
    def setPinned(self) -> bool: ...
    def isPinned(self) -> bool: ...
    @overload
    def setInput(self, node: 'Node|None', output_index: int = 0) -> None: ...
    @overload
    def setInput(self, input_index: int, node: 'Node|None', output_index: int = 0) -> None: ...
    def setInput(*args, **kwargs) -> None: ...
    def insertInput(self, input_index: int, node: 'Node|None', output_index: int = 0) -> None: ...
    def inputConnections(self) -> tuple['NodeConnection', ...]: ...
    def destroy(self) -> None: ...

    # As Data
    def asData(self) -> dict[str, Any]: ...
    def setFromData(self, data: dict[str, Any]) -> None: ...


class Node(NetworkMovableItem):
    """
    Houdini node object.

    Note: This class handles the complex type patterns in Houdini's C++ bindings
    where methods can return None unexpectedly and parameters accept multiple types.
    """
    def __init__(self) -> None: ...

    # Basic node info - these are generally reliable
    def type(self) -> 'NodeType': ...  # Can raise OperationFailed if node is invalid
    def children(self) -> tuple['Node', ...]: ...  # Empty tuple if no children

    # Hierarchy methods
    def nodes(self, node_path_tuple: tuple[str, ...]) -> tuple['Node|None', ...]: ...
    def item(self, item_path: str) -> 'NetworkMovableItem|None': ...
    def items(self, item_path_tuple: tuple[str, ...]) -> tuple['NetworkMovableItem|None', ...]: ...
    def isNetwork(self) -> bool: ...
    def isEditable(self) -> bool: ...
    def allItems(self) -> tuple['NetworkMovableItem', ...]: ...
    def allNodes(self) -> Iterator['Node']: ...
    def recursiveGlob(self, pattern: str, filter: 'EnumValue' = ..., include_subnets: bool = True) -> tuple['Node', ...]: ...

    # Node connections - handle Houdini's sparse input patterns
    def inputs(self) -> tuple['Node|None', ...]: ...  # None for unconnected inputs
    def inputsFollowingOutputs(self) -> tuple['Node', ...]: ...
    def input(self, inputidx: int) -> 'Node|None': ...
    def inputFollowingOutputs(self, inputidx: int) -> 'Node|None': ...
    def outputs(self) -> tuple['Node', ...]: ...  # Connected outputs only
    def setInput(self, input_index: int, node: 'Node|None', output_index: int = 0) -> None: ...
    def inputConnections(self) -> tuple['NodeConnection', ...]: ...  # Only connected inputs
    def outputConnections(self) -> tuple['NodeConnection', ...]: ...  # All output connections
    def inputConnectors(self) -> tuple[tuple['NodeConnection', ...], ...]: ...
    def outputConnectors(self) -> tuple[tuple['NodeConnection', ...], ...]: ...

    # Extended input/output methods
    def indirectInputs(self) -> tuple['SubnetIndirectInput', ...]: ...
    def subnetOutputs(self) -> tuple['Node', ...]: ...
    def inputAncestors(self, include_ref_inputs: bool = True, follow_subnets: bool = False, only_used_inputs: bool = False) -> tuple['Node', ...]: ...
    def setNamedInput(self, input_name: str, item_to_become_input: 'Node|None', output_name_or_index: str|int) -> None: ...
    def setFirstInput(self, item_to_become_input: 'Node|None', output_index: int = 0) -> None: ...
    def setNextInput(self, item_to_become_input: 'Node|None', output_index: int = 0, unordered_only: bool = False) -> None: ...
    def insertInput(self, input_index: int, item_to_become_input: 'Node|None', output_index: int = 0) -> None: ...
    def numOrderedInputs(self) -> int: ...
    def createInputNode(self, input_index: int, node_type_name: str, node_name: str|None = None, run_init_scripts: bool = True, load_contents: bool = True, exact_type_name: bool = False) -> 'Node': ...
    def createOutputNode(self, node_type_name: str, node_name: str|None = None, run_init_scripts: bool = True, load_contents: bool = True, exact_type_name: bool = False) -> 'Node': ...
    def inputNames(self) -> tuple[str, ...]: ...
    def inputLabels(self) -> tuple[str, ...]: ...
    def outputNames(self) -> tuple[str, ...]: ...
    def outputLabels(self) -> tuple[str, ...]: ...
    def editableInputStrings(self, input_index: int) -> dict[str, str]: ...
    def editableInputString(self, input_index: int, key: str) -> str: ...
    def setEditableInputString(self, input_index: int, key: str, value: str) -> None: ...

    # Input/output info
    def inputIndex(self, node: 'Node') -> int: ...  # -1 if not connected
    def outputIndex(self, node: 'Node') -> int: ...  # -1 if not connected
    def createNode(self, node_type: str, name: str|None = None) -> 'Node': ...  # Can raise OperationFailed
    def node(self, path: str) -> 'Node|None': ...  # None if path doesn't exist
    def glob(self, pattern: str) -> tuple['Node', ...]: ...  # Empty if no matches
    def destroy(self) -> None: ...  # Can raise OperationFailed if locked/referenced

    # Adding and removing methods
    def copyItems(self, items: tuple['NetworkMovableItem', ...], channel_reference_originals: bool = False, relative_references: bool = True, connect_outputs_to_multi_inputs: bool = True) -> tuple['NetworkMovableItem', ...]: ...
    def deleteItems(self, items: tuple['NetworkMovableItem', ...], disable_safety_checks: bool = False) -> None: ...

    # Assets methods
    def canCreateDigitalAsset(self) -> bool: ...

    def allSubChildren(self,
                      filter_type: str|None = None,
                      recurse_in_locked: bool = False) -> tuple['Node', ...]: ...

    # Selection methods
    def isCurrent(self) -> bool: ...
    def setCurrent(self, on: bool, clear_all_selected: bool = False) -> None: ...
    def selectedChildren(self, include_hidden: bool = False, include_hidden_support_nodes: bool = False) -> tuple['Node', ...]: ...
    def selectedItems(self, include_hidden: bool = False, include_hidden_support_nodes: bool = False) -> tuple['NetworkMovableItem', ...]: ...
    def numItems(self, item_type: 'EnumValue|None' = None, selected_only: bool = False, include_hidden: bool = False) -> int: ...

    # Node context helpers
    def childTypeCategory(self) -> 'NodeTypeCategory': ...

    # Subnet methods
    def isSubNetwork(self) -> bool: ...
    def collapseIntoSubnet(self, child_nodes: tuple['Node', ...], subnet_name: str|None = None, subnet_type: str|None = None) -> 'Node': ...
    def extractAndDelete(self) -> tuple['NetworkMovableItem', ...]: ...

    # Layout
    def moveToGoodPosition(self, relative_to_inputs: bool=True, move_inputs: bool=True, move_outputs: bool=True, move_unconnected: bool=True) -> 'Vector2': ...
    def layoutChildren(self, items: tuple['NetworkMovableItem', ...]=(), horizontal_spacing=-1.0, vertical_spacing=-1.0) -> 'Vector2': ...
    def isHidden(self) -> bool: ...
    def hide(self, hidden: bool) -> None: ...

    # Metadata methods
    def comment(self) -> str: ...
    def setComment(self, comment: str) -> None: ...
    def appendComment(self, comment: str) -> None: ...
    def isDisplayDescriptiveNameFlagSet(self) -> bool: ...
    def setDisplayDescriptiveNameFlag(self, on: bool) -> None: ...
    def creator(self) -> 'Node': ...
    def network(self) -> 'Node': ...

    # Cooking and error handling
    def errors(self) -> tuple[str, ...]: ...
    def warnings(self) -> tuple[str, ...]: ...
    def messages(self) -> tuple[str, ...]: ...

    # NetworkBox Management
    def networkBoxes(self) -> tuple['NetworkBox', ...]: ...
    def iterNetworkBoxes(self) -> Iterator['NetworkBox']: ...
    def findNetworkBox(self, name: str) -> 'NetworkBox|None': ...
    def findNetworkBoxes(self, pattern: str) -> tuple['NetworkBox', ...]: ...
    def createNetworkBox(self, name: str|None=None) -> 'NetworkBox': ...
    def copyNetworkBox(self, network_box_to_copy: 'NetworkBox', new_name: str|None=None, channel_reference_original: bool=False) -> 'NetworkBox': ...

    # StickyNote Management
    def stickyNotes(self) -> tuple['StickyNote', ...]: ...
    def iterStickyNotes(self) -> Iterator['StickyNote']: ...
    def findStickyNote(self, name: str) -> 'StickyNote|None': ...
    def findStickyNotes(self, pattern: str) -> tuple['StickyNote', ...]: ...
    def createStickyNote(self, name: str|None=None) -> 'StickyNote': ...
    def copyStickyNote(self, sticky_note_to_copy: 'StickyNote', new_name: str|None=None) -> 'StickyNote': ...

    # Network Dots
    def networkDots(self) -> tuple['NetworkDot', ...]: ...
    def createNetworkDot(self) -> 'NetworkDot': ...

    # Serialization methods
    def copyItemsToClipboard(self, items: tuple['NetworkMovableItem', ...]) -> None: ...
    def pasteItemsFromClipboard(self, position: 'Vector2|None' = None) -> None: ...

    # Operators
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

    # User data methods
    def setUserData(self, name: str, value: str) -> None: ...
    def userDataDict(self) -> dict[str, str]: ...
    def userData(self, name: str) -> str|None: ...
    def destroyUserData(self, name: str, must_exist: bool = True) -> None: ...
    def clearUserDataDict(self) -> None: ...

    # Flag methods
    def isFlagReadable(self, flag: 'EnumValue') -> bool: ...
    def isFlagWritable(self, flag: 'EnumValue') -> bool: ...
    def isGenericFlagSet(self, flag: 'EnumValue') -> bool: ...
    def setGenericFlag(self, flag: 'EnumValue', value: bool) -> None: ...

class OpNode(Node):
    """A Houdini operator node."""
    # Adding and Removing
    def createOrMoveVisualizer(self, output_index: int) -> 'Node': ...
    def copyTo(self, destination_node: 'Node') -> 'Node': ...
    def reorderChild(self, src: int, dest: int) -> None: ...

    # parameters
    def parm(self, param_path: str) -> 'Parm|None': ...
    def globParms(self, pattern: str, ignore_case: bool=False, search_label: bool=False, single_pattern: bool=False) -> tuple['Parm', ...]: ...
    def evalParm(self, parm_path: str) -> ParameterValue: ...
    def parms(self) -> tuple['Parm', ...]: ...
    def parmsReferencingThis(self) -> tuple['Parm', ...]: ...
    def allParms(self) -> Iterator['Parm']: ...
    def setParms(self, parm_dict: dict[str, Any]) -> None: ...
    def setParmsPending(self, parm_dict: dict[str, Any]) -> None: ...
    def setParmExpressions(self, parm_dict: dict[str, str], language: exprLanguage) -> None: ...
    def parmTuple(self, param_path: str) -> 'ParmTuple|None': ...
    def evalParmTuple(self, parm_path: str) -> tuple[ParameterValue, ...]: ...
    def parmTuples(self) -> tuple['ParmTuple', ...]: ...
    def parmsInFolder(self, folder_names: Sequence[str]) -> tuple['Parm', ...]: ...
    def parmTuplesInFolder(self, folder_names: Sequence[str]) -> tuple['ParmTuple', ...]: ...
    def expressionLanguage(self) -> exprLanguage: ...
    def setExpressionLanguage(self, language: exprLanguage) -> None: ...
    def parmAliases(self, recurse: bool=False) -> dict[str, str]: ...
    def clearParmAliases(self) -> None: ...
    def spareParms(self) -> tuple['Parm', ...]: ...
    def removeSpareParms(self) -> None: ...
    def parmTemplateGroup(self) -> 'ParmTemplateGroup': ...
    def setParmTemplateGroup(self, parm_template_group: 'ParmTemplateGroup', rename_conflicting_parms: bool=False) -> None: ...

    # Deprecated methods for spare parm tuples - these are not recommended for use in new code

    #def addSpareParmTuple(self, parm_template: 'ParmTemplate', in_folder: Sequence[str]=(), create_missing_folders: bool=False) -> 'ParmTuple': ...
    #def removeSpareParmTuple(self, parm_tuple: 'ParmTuple') -> None: ...
    def addControlParmFolder(self, folder_name: str|None=None, parm_name: str|None=None) -> None: ...
    #def addSpareParmFolder(self, folder_name: str, in_folder: Sequence[str]=(), parm_name: str|None=None, create_missing_folders: bool=False) -> None: ...
    def removeSpareParmFolder(self, folder_name: Sequence[str]) -> None: ...
    def replaceSpareParmFolder(self, parm_tuple_name: str, parm_template : ParmTemplate) -> None: ...
    def localVariables(self) -> tuple[str, ...]: ...
    def localAttributes(self) -> tuple[str, ...]: ...
    def saveParmClip(self, file_name: str, start: int|None=None, end: int|None=None, sample_rate: int=0, scoped_only: bool=False) -> None: ...
    def loadParmClip(self, file_name: str, sample_rate: int=0, start: int|None=None) -> None: ...
    def parmClipData(self, start=None, end=None, binary=True, use_blosc_compression=True, sample_rate=0, scoped_only=False) -> bytes: ...
    def setParmClipData(self, data: bytes, binary: bool=True, blosc_compressed: bool=True, sample_rate: int=0, start: int=1) -> None: ...

    # Dependencies
    def references(self, include_children: bool=True) -> tuple['Node', ...]: ...
    def dependents(self, include_children: bool=True) -> tuple['Node', ...]: ...
    def fileReferences(self, recurse: bool=True, project_dir_variable: str="HIP", include_all_refs: bool=True) -> tuple[tuple[Parm, str], ...]: ...

    # Assets
    def createDigitalAsset(self, name: str|None=None, hda_file_name: str|None=None, description: str|None=None, min_num_inputs: int=0, max_num_inputs: int=0, compress_content: bool=False, comment: str|None=None, version: str|None=None, save_as_embedded: bool=False, ignore_external_references: bool=False, change_node_type: bool=True, create_backup: bool=True, install_path: str|None=None) -> 'Node': ...
    def createCompiledDigitalAsset(self, name: str|None=None, hda_file_name: str|None=None, description: str|None=None) -> None: ...
    def changeNodeType(self, new_node_type: str, keep_name: bool=True, keep_parms: bool=True, keep_network_contents: bool=True, force_change_on_node_type_match: bool=False) -> None: ...
    def allowEditingOfContents(self, propagate: bool=False) -> None: ...
    def matchCurrentDefinition(self) -> None: ...
    def syncDelayedDefinition(self) -> None: ...
    def isDelayedDefinition(self) -> bool: ...
    def isLockedHDA(self) -> bool: ...
    def isInsideLockedHDA(self) -> bool: ...
    def isEditableInsideLockedHDA(self) -> bool: ...
    def isMaterialManager(self) -> bool: ...
    def hdaModule(self) -> 'HDAModule': ...
    def hm(self) -> 'HDAModule': ...
    def hdaViewerStateModule(self) -> 'HDAViewerStateModule': ...
    def hdaViewerHandleModule(self) -> 'HDAViewerHandleModule': ...
    def syncNodeVersionIfNeeded(self, from_version: str) -> None: ...

    # Metadata methods
    def outputForViewFlag(self) -> int: ...
    def setOutputForViewFlag(self, output: int) -> None: ...
    def creationTime(self) -> 'datetime.datetime': ...
    def modificationTime(self) -> 'datetime.datetime': ...
    def creatorState(self) -> str: ...
    def setCreatorState(self, state: str) -> None: ...
    def isBuiltExplicitly(self) -> bool: ...
    def setBuiltExplicitly(self, built_explicitly: bool) -> None: ...
    def isTimeDependent(self, for_last_cook: bool = False) -> bool: ...
    def lastCookTime(self) -> float: ...
    def matchesCurrentDefinition(self) -> bool: ...

    # Cooking methods
    def cook(self, force: bool = False, frame_range: tuple = ()) -> None: ...
    def needsToCook(self, time: float = ...) -> bool: ...  # time defaults to hou.time()
    def invalidateOutput(self) -> None: ...
    def cookCount(self) -> int: ...
    def lastCookContextOptions(self, only_used_options: bool = False) -> dict[str, str|float]: ...
    def updateParmStates(self) -> None: ...
    def infoTree(self, verbose: bool = False, debug: bool = False, output_index: int = 0, force_cook: bool = False) -> 'NodeInfoTree': ...
    def infoData(self) -> dict[str, Any]: ...
    def cookPathNodes(self) -> tuple['Node', ...]: ...
    def canGenerateCookCode(self, check_parent: bool = False, check_auto_shader: bool = True) -> bool: ...
    def cookCodeGeneratorNode(self, check_parent: bool = False) -> 'Node': ...
    def cookCodeLanguage(self) -> str: ...
    def supportsMultiCookCodeContexts(self) -> bool: ...
    def saveCompiledCookCodeToFile(self, file_name: str, context_name: str|None = None) -> None: ...
    def saveCookCodeToFile(self, file_name: str, skip_header: bool = False, context_name: str|None = None) -> None: ...

    # Node groups methods
    def addNodeGroup(self, name: str|None = None) -> 'NodeGroup': ...
    def nodeGroup(self, name: str) -> 'NodeGroup|None': ...
    def nodeGroups(self) -> tuple['NodeGroup', ...]: ...

    # Scripts methods
    def runInitScripts(self) -> None: ...
    def deleteScript(self) -> str: ...
    def setDeleteScript(self, script_text: str, language: 'EnumValue' = ...) -> None: ...  # language defaults to hou.scriptLanguage.Python

    # Motion FX methods
    def motionEffectsNetworkPath(self) -> str: ...
    def findOrCreateMotionEffectsNetwork(self, create: bool = True) -> 'Node': ...

    # Stamping methods
    def stampValue(self, parm_name: str, default_value: Any) -> Any: ...

    # Extended serialization methods
    def saveItemsToFile(self, items: tuple['NetworkMovableItem', ...], file_name: str, save_hda_fallbacks: bool = False) -> None: ...
    def saveChildrenToFile(self, nodes: tuple['Node', ...], network_boxes: tuple['NetworkBox', ...], file_name: str) -> None: ...
    def loadItemsFromFile(self, file_name: str, ignore_load_warnings: bool = False) -> None: ...
    def loadChildrenFromFile(self, file_name: str, ignore_load_warnings: bool = False) -> None: ...
    def asCode(self, brief: bool = False, recurse: bool = False, save_channels_only: bool = False, save_creation_commands: bool = True, save_keys_in_frames: bool = False, save_outgoing_wires: bool = False, save_parm_values_only: bool = False, save_spare_parms: bool = True, save_box_membership: bool = True, function_name: str|None = None) -> str: ...

    # Callbacks methods
    def addEventCallback(self, event_types: tuple['EnumValue', ...], callback: Callable) -> None: ...
    def removeEventCallback(self, event_types: tuple['EnumValue', ...], callback: Callable) -> None: ...
    def addParmCallback(self, callback: Callable, parm_names: tuple[str, ...]) -> None: ...
    def removeAllEventCallbacks(self) -> None: ...
    def eventCallbacks(self) -> tuple[tuple[tuple['EnumValue', ...], Callable], ...]: ...

    # Cached user data methods
    def setCachedUserData(self, name: str, value: Any) -> None: ...
    def cachedUserDataDict(self) -> dict[str, Any]: ...
    def cachedUserData(self, name: str) -> Any|None: ...
    def destroyCachedUserData(self, name: str, must_exist: bool = True) -> None: ...
    def clearCachedUserDataDict(self) -> None: ...

    # Data blocks methods
    def dataBlockKeys(self, blocktype: str) -> tuple[str, ...]: ...
    def dataBlockType(self, key: str) -> str: ...
    def dataBlock(self, key: str) -> bytes: ...
    def setDataBlock(self, key: str, block: bytes, block_type: str|None = None) -> None: ...
    def removeDataBlock(self, key: str) -> None: ...

    # Dynamics methods
    def simulation(self) -> 'DopSimulation': ...
    def findNodesThatProcessedObject(self, dop_object: 'DopObject') -> tuple['DopNode', ...]: ...

    # PDG Work Items methods
    def selectNextVisibleWorkItem(self) -> None: ...
    def selectPreviousVisibleWorkItem(self) -> None: ...
    def deselectWorkItem(self) -> None: ...
    def setCurrentTOPPage(self, page_index: int) -> None: ...

    # Badges methods
    def addMessage(self, message: str) -> None: ...
    def addWarning(self, message: str) -> None: ...
    def addError(self, message: str, severity: 'EnumValue' = ...) -> None: ...  # severity defaults to hou.severityType.Error

    # Extended inputs and outputs methods
    def inputsWithIndices(self, ignore_network_dots: bool = False, ignore_subnet_indirect_inputs: bool = False, use_names: bool = False) -> tuple[tuple['OpNode', int|str, int|str], ...]: ...
    def outputsWithIndices(self, ignore_network_dots: bool = False, use_names: bool = False) -> tuple[tuple['OpNode', int|str, int|str], ...]: ...
    def outputLabel(self, output_index: int) -> str: ...

    # As data methods - comprehensive serialization API
    def asData(self, nodes_only: bool = False, children: bool = False, editables: bool = False, inputs: bool = False, position: bool = False, flags: bool = False, parms: bool|tuple['ParmTuple', ...]|tuple[str, ...] = True, default_parmvalues: bool = False, evaluate_parmvalues: bool = False, parms_as_brief: bool = True, parmtemplates: str = "spare_only", metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def setFromData(self, data: dict[str, Any], clear_content: bool = False, force_item_creation: bool = True, parms: bool = True, parmtemplates: bool = True, children: bool = True, editables: bool = True, skip_notes: bool = False) -> None: ...
    def parmsAsData(self, values: bool = True, parms: bool = True, default_values: bool = False, evaluate_values: bool = False, locked: bool = True, brief: bool = True, multiparm_instances: bool = True, metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def setParmsFromData(self, data: dict[str, Any]) -> None: ...
    def childrenAsData(self, nodes_only: bool = False, children: bool = True, editables: bool = True, inputs: bool = True, position: bool = True, flags: bool = True, parms: bool = True, default_parmvalues: bool = False, evaluate_parmvalues: bool = False, parms_as_brief: bool = True, parmtemplates: str = "spare_only", metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def setChildrenFromData(self, data: dict[str, Any], clear_content: bool = True, force_item_creation: bool = True, offset_position: 'Vector2' = ..., external_connections: bool = True, parms: bool = True, parmtemplates: bool = True, children: bool = True, editables: bool = True, skip_notes: bool = False) -> None: ...
    def editablesAsData(self, nodes_only: bool = False, children: bool = True, editables: bool = True, inputs: bool = True, position: bool = True, flags: bool = True, parms: bool = True, default_parmvalues: bool = False, evaluate_parmvalues: bool = False, parms_as_brief: bool = True, parmtemplates: str = "spare_only", metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def setEditablesFromData(self, data: dict[str, Any], clear_content: bool = True, force_item_creation: bool = True, offset_position: 'Vector2' = ..., external_connections: bool = True, parms: bool = True, parmtemplates: bool = True, children: bool = True, editables: bool = True, skip_notes: bool = False) -> None: ...
    def createDecorationItemsFromData(self, items: tuple['NetworkMovableItem', ...], frame_nodes: tuple['NetworkMovableItem', ...]|None = None, selected_nodes: tuple['NetworkMovableItem', ...]|None = None, current_node: 'NetworkMovableItem|None' = None, flags: bool = True, nodes_only: bool = False, target_children: bool = False, children: bool = True, target_editables: bool = False, editables: bool = True, target_parms: bool|tuple['ParmTuple', ...]|tuple[str, ...] = True, parms: bool = True, default_parmvalues: bool = False, evaluate_parmvalues: bool = False, parms_as_brief: bool = True, parmtemplates: str = "spare_only", metadata: bool = False, verbose: bool = False) -> dict[str, Any]: ...
    def parmTemplatesAsData(self, name: str = "", children: bool = True, parmtemplate_order: bool = False) -> dict[str, Any]: ...
    def parmTemplateChildrenAsData(self, name: str = "", parmtemplate_order: bool = False) -> dict[str, Any]: ...
    def appendParmTemplatesFromData(self, data: dict[str, Any], rename_conflicts: bool = True) -> dict[str, 'ParmTuple']: ...
    def replaceParmTemplatesFromData(self, data: dict[str, Any]) -> dict[str, 'ParmTuple']: ...
    def insertParmTemplatesBeforeFromData(self, data: dict[str, Any], parm_name: str, rename_conflicts: bool = True) -> dict[str, 'ParmTuple']: ...
    def insertParmTemplatesAfterFromData(self, data: dict[str, Any], parm_name: str, rename_conflicts: bool = True) -> dict[str, 'ParmTuple']: ...
    def appendParmTemplatesToFolderFromData(self, data: dict[str, Any], parm_name: str, rename_conflicts: bool = True) -> dict[str, 'ParmTuple']: ...
    def prependParmTemplatesToFolderFromData(self, data: dict[str, Any], parm_name: str, rename_conflicts: bool = True) -> dict[str, 'ParmTuple']: ...
    def inputsAsData(self, ignore_network_dots: bool = False, ignore_subnet_indirect_inputs: bool = False, use_names: bool = False) -> tuple[dict[str, Any], ...]: ...
    def setInputsFromData(self, data: dict[str, Any]) -> None: ...
    def outputsAsData(self, ignore_network_dots: bool = False, ignore_subnet_indirect_inputs: bool = False, use_names: bool = False) -> tuple[dict[str, Any], ...]: ...
    def setOutputsFromData(self, data: dict[str, Any]) -> None: ...


class HDAModule(types.ModuleType):
    "User HDA module for custom Python code in digital assets."
    pass

class HDAViewerStateModule(types.ModuleType):
    "User HDA viewer state module for custom Python code in digital assets."
    pass

class HDAViewerHandleModule(types.ModuleType):
    "User HDA viewer handle module for custom Python code in digital assets."
    pass

class Parm:
    """Houdini parameter object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def eval(self) -> Any: ...
    def evalAsFloat(self) -> float: ...
    def evalAsInt(self) -> int: ...
    def evalAsString(self) -> str: ...
    def set(self, value: Any) -> None: ...
    def setExpression(self, expression: str) -> None: ...
    def expression(self) -> str: ...
    def unexpandedString(self) -> str: ...
    def node(self) -> 'Node': ...
    def parmTemplate(self) -> 'ParmTemplate': ...
    def isLocked(self) -> bool: ...
    def lock(self, on: bool) -> None: ...

class ParmTuple:
    """Houdini parameter tuple object (for vector parameters)."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def eval(self) -> tuple[float, ...]: ...
    def evalAsFloats(self) -> tuple[float, ...]: ...
    def evalAsInts(self) -> tuple[int, ...]: ...
    def evalAsStrings(self) -> tuple[str, ...]: ...
    def set(self, values: Sequence[Any]) -> None: ...
    def setExpression(self, expressions: Sequence[str]) -> None: ...
    def node(self) -> 'Node': ...
    def parmTemplate(self) -> 'ParmTemplate': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'Parm': ...

class NodeConnection:
    """Houdini node connection object."""
    def __init__(self) -> None: ...
    def inputNode(self) -> 'Node': ...
    def outputNode(self) -> 'Node': ...
    def inputIndex(self) -> int: ...
    def outputIndex(self) -> int: ...

class NodeType:
    """Houdini node type object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def description(self) -> str: ...
    def helpUrl(self) -> str: ...
    def category(self) -> 'NodeTypeCategory': ...
    def defaultName(self) -> str: ...
    def maxNumInputs(self) -> int: ...
    def minNumInputs(self) -> int: ...
    def maxNumOutputs(self) -> int: ...
    def childTypeCategory(self) -> 'NodeTypeCategory': ...
    def isGenerator(self) -> bool: ...
    def isManager(self) -> bool: ...
    def embeddedHelp(self) -> str: ...
    def defaultColor(self) -> 'Color': ...
    def setDefaultColor(self, color: 'Color') -> None: ...
    def defaultShape(self) -> str: ...
    def setDefaultShape(self, shape: str) -> None: ...
    def isWritable(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def icon(self) -> str: ...
    def resolvedIcon(self) -> str: ...
    def hasUnorderedInputs(self) -> bool: ...
    def hasEditableInputData(self) -> bool: ...
    def parmTemplates(self) -> tuple['ParmTemplate', ...]: ...
    def parmTemplateGroup(self) -> 'ParmTemplateGroup': ...
    def deprecationInfo(self) -> dict[str, Any]: ...

class ParmTemplateGroup:
    """Houdini parameter template group object."""
    def __init__(self, parm_templates: Sequence[ParmTemplate]=()) -> None: ...
    def name(self) -> str: ...
    def label(self) -> str: ...
    def setName(self, name: str) -> None: ...
    def setLabel(self, label: str) -> None: ...
    def clear(self) -> None: ...
    def entries(self) -> tuple['ParmTemplate', ...]: ...
    def parmTemplates(self) -> tuple['ParmTemplate', ...]: ...
    def find(self, name: str) -> 'ParmTemplate|None': ...
    def findFolder(self, label_or_labels: str | Sequence[str]) -> 'ParmTemplateGroup|None': ...
    def findIndices(self, label_or_labels: str | Sequence[str]) -> int | tuple[int, ...]: ...
    def entryAtIndices(self, indices: int | Sequence[int]) -> 'ParmTemplate': ...
    def asCode(self, function_name: str | None=None, variable_name: str | None=None) -> str: ...
    # Additional methods for adding and removing parms

class NodeTypeCategory:
    """Houdini node type category object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def description(self) -> str: ...
    def nodeTypes(self) -> dict[str, 'NodeType']: ...
    def nodeType(self, name: str) -> 'NodeType|None': ...
    def label(self) -> str: ...
    def allowedChildTypes(self) -> tuple['NodeType', ...]: ...
    def canContainNodeType(self, node_type: 'NodeType') -> bool: ...
    def hasSubNetworkType(self) -> bool: ...
    def subnetworkType(self) -> 'NodeType|None': ...
    def defaultColor(self) -> 'Color': ...


class Color:
    """Houdini color object."""
    def __init__(self, rgb: tuple) -> None: ...
    def rgb(self) -> tuple[float, float, float]: ...
    def setRgb(self, rgb: tuple[float, float, float]) -> None: ...
    def hsv(self) -> tuple[float, float, float]: ...
    def setHsv(self, hsv: tuple[float, float, float]) -> None: ...
    def hsl(self) -> tuple[float, float, float]: ...
    def setHsl(self, hsl: tuple[float, float, float]) -> None: ...
    def lab(self) -> tuple[float, float, float]: ...
    def setLAB(self, lab: tuple[float, float, float]) -> None: ...
    def tmi(self) -> tuple[float, float, float]: ...
    def setTmi(self, tmi: tuple[float, float, float]) -> None: ...
    def xyz(self) -> tuple[float, float, float]: ...
    def setXYZ(self, xyz: tuple[float, float, float]) -> None: ...
    def ocio_transform(self, from_space: str, to_space: str, looks: str) -> 'Color': ...
    def ocio_viewTransform(self, src_colorspace, display_name, view_name) -> 'Color': ...
    @staticmethod
    def reload_ocio() -> None: ...
    @staticmethod
    def ocio_spaces() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_configPath() -> str: ...
    @staticmethod
    def ocio_activeDisplays() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_activeViews() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_looks() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_roles() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_views() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_DefaultView() -> str: ...
    @staticmethod
    def ocio_DefaultDisplay() -> str: ...

class ParmTemplate:
    """Houdini parameter template object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def label(self) -> str: ...
    def type(self) -> 'parmTemplateType': ...
    def numComponents(self) -> int: ...
    def defaultValue(self) -> Any: ...
    def help(self) -> str: ...
    def tags(self) -> dict[str, str]: ...
    def setTags(self, tags: dict[str, str]) -> None: ...
    def scriptCallback(self) -> str: ...
    def setScriptCallback(self, callback: str) -> None: ...
    def scriptCallbackLanguage(self) -> str: ...
    def setScriptCallbackLanguage(self, language: str) -> None: ...

class SopNode(OpNode):
    """
    Represents a surface node.
    Houdini geometry (SOP) node for surface operations.
    """

    def geometry(self, output_index: int = 0) -> 'Geometry | None': ...
    def geometryAtFrame(self, frame: float, output_index: int = 0) -> 'Geometry | None': ...
    def inputGeometry(self, index: int) -> 'Geometry | None': ...
    def inputGeometryAtFrame(self, frame: float, index: int) -> 'Geometry | None': ...
    def generateInputAttribMenu(self, index: int, attrib_type: 'attribType | None' = None, data_type: 'attribData | None' = None, min_size: int = 1, max_size: int = -1, array_type: bool = True, scalar_type: bool = True, case_sensitive: bool = True, pattern: str = "*", decode_tokens: bool = False) -> tuple[str, ...]: ...
    def generateInputGroupMenu(self, index: int, group_types: 'tuple[groupType, ...] | None' = None, include_selection: bool = True, include_name_attrib: bool = True, case_sensitive: bool = True, pattern: str = "*", decode_tokens: bool = False, parm: 'Parm | None' = None) -> tuple[str, ...]: ...
    def geometryDelta(self) -> 'GeometryDelta | None': ...
    def geometryNoDep(self, output_index: int = 0) -> 'Geometry | None': ...
    def geometryDep(self, output_index: int = 0) -> None: ...
    def selection(self, selection_type: 'geometryType') -> 'Selection': ...
    def setSelection(self, selection: 'Selection') -> None: ...
    def curPoint(self) -> 'Point | None': ...
    def setCurPoint(self, point_or_none: 'Point | None' = None) -> None: ...
    def curPrim(self) -> 'Prim | None': ...
    def setCurPrim(self, prim_or_none: 'Prim | None' = None) -> None: ...
    def curVertex(self) -> 'Vertex | None': ...
    def setCurVertex(self, vertex_or_none: 'Vertex | None' = None) -> None: ...
    def displayNode(self) -> 'Node | None': ...
    def renderNode(self) -> 'OpNode | None': ...
    def isBypassed(self) -> bool: ...
    def bypass(self, on: bool) -> None: ...
    def isDisplayFlagSet(self) -> bool: ...
    def setDisplayFlag(self, on: bool) -> None: ...
    def isRenderFlagSet(self) -> bool: ...
    def setRenderFlag(self, on: bool) -> None: ...
    def isHighlightFlagSet(self) -> bool: ...
    def setHighlightFlag(self, on: bool) -> None: ...
    def isTemplateFlagSet(self) -> bool: ...
    def setTemplateFlag(self, on: bool) -> None: ...
    def isSelectableTemplateFlagSet(self) -> bool: ...
    def setSelectableTemplateFlag(self, on: bool) -> None: ...
    def isHardLocked(self) -> bool: ...
    def setHardLocked(self, on: bool) -> None: ...
    def isSoftLocked(self) -> bool: ...
    def setSoftLocked(self, on: bool) -> None: ...
    def isUnloadFlagSet(self) -> bool: ...
    def setUnloadFlag(self, on: bool) -> None: ...
    def hasVerb(self) -> bool: ...
    def verb(self) -> 'SopVerb': ...
    def managesAttribDataIds(self) -> bool: ...
    def setManagesAttribDataIds(self, on: bool) -> None: ...

class ObjNode(Node):
    """
    Houdini object (OBJ) node.
    Handles transforms and object-level operations.
    """
    def worldTransform(self) -> 'Matrix4': ...  # Can be expensive, may fail
    def localTransform(self) -> 'Matrix4': ...  # Local transformation
    def worldTransformAtTime(self, time: float) -> 'Matrix4': ...
    def localTransformAtTime(self, time: float) -> 'Matrix4': ...

    # Object-specific operations
    def isDisplayFlagSet(self) -> bool: ...  # Override with OBJ-specific behavior
    def isSelectableFlagSet(self) -> bool: ...
    def setSelectableFlag(self, on: bool) -> None: ...

class ChopNode(Node):
    """Houdini channel operator (CHOP) node."""
    def tracks(self) -> tuple['Track', ...]: ...
    def track(self, name: str) -> 'Track|None': ...

class RopNode(Node):
    """Houdini render operator (ROP) node."""
    def render(self, frame_range: tuple[int, int]|None = None,
               background: bool = False) -> None: ...  # Can take a long timeclass VopNode(Node):
    """Houdini VEX operator (VOP) node."""
    def vexCode(self) -> str: ...  # Generated VEX code
    def shaderName(self) -> str: ...

class DopNode(Node):
    """Houdini dynamics operator (DOP) node."""
    def simulation(self) -> 'DopSimulation|None': ...

# Additional specialized node types
class CopNode(Node):
    """Houdini compositing operator (COP) node."""
    def image(self) -> 'Image|None': ...

class TopNode(Node):
    """Houdini task operator (TOP/PDG) node."""
    def workItems(self) -> tuple['WorkItem', ...]: ...

class NodeGroup:
    """
    Houdini node group object.

    Represents a node group that contains a set of nodes from the same network.
    Each group is named, and you can edit a group's contents from the network view pane.
    """
    def __init__(self) -> None: ...

    def name(self) -> str: ...
    def parent(self) -> 'OpNode': ...
    def nodes(self) -> tuple['OpNode', ...]: ...
    def addNode(self, node: 'OpNode') -> None: ...
    def removeNode(self, node: 'OpNode') -> None: ...
    def clear(self) -> None: ...
    def destroy(self) -> None: ...
    def asCode(self, save_creation_commands: bool = False, function_name: str|None = None) -> str: ...

class NodeInfoTree:
    """
    Houdini node info tree object.

    A tree structure designed to contain information about nodes and the data they
    generate. This class represents a tree structure, where each branch of the tree can have
    any number of named sub-trees, as well as a two dimensional grid of strings. Most
    often this grid has two columns ("Property" and "Value"), with some number of
    rows to represent arbitrary key/value pairs. But the grid can also contain more
    complex data (such as the volume information in geometry data).
    """
    def __init__(self) -> None: ...

    def name(self) -> str: ...
    def infoType(self) -> str: ...
    def branchOrder(self) -> tuple[str, ...]: ...
    def branches(self) -> dict[str, 'NodeInfoTree']: ...
    def headings(self) -> tuple[str, ...]: ...
    def rows(self) -> tuple[tuple[str, ...], ...]: ...

class Geometry:
    """Houdini geometry object."""
    def __init__(self) -> None: ...
    def points(self) -> tuple['Point', ...]: ...
    def prims(self) -> tuple['Prim', ...]: ...
    def vertices(self) -> tuple['Vertex', ...]: ...
    def numPoints(self) -> int: ...
    def numPrims(self) -> int: ...

class Point:
    """Houdini geometry point."""
    def __init__(self) -> None: ...
    def number(self) -> int: ...
    def position(self) -> 'Vector3': ...
    def setPosition(self, pos: 'Vector3') -> None: ...

class Prim:
    """Houdini geometry primitive."""
    def __init__(self) -> None: ...
    def number(self) -> int: ...
    def vertices(self) -> tuple['Vertex', ...]: ...

class Vertex:
    """Houdini geometry vertex."""
    def __init__(self) -> None: ...
    def number(self) -> int: ...
    def point(self) -> 'Point': ...

class Selection:
    """Houdini geometry selection object."""
    pass

class GeometryDelta:
    """Houdini geometry delta object for tracking changes."""
    pass

class SopVerb:
    """Houdini SOP verb for compiled geometry operations."""
    pass

class Vector2:
    """2D vector."""
    def __init__(self, x: float = 0, y: float = 0) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...

class Vector3:
    """3D vector."""
    def __init__(self, x: float = 0, y: float = 0, z: float = 0) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...

class Matrix4:
    """4x4 transformation matrix."""
    def __init__(self) -> None: ...

# Module-level functions - these are the PRIMARY module interface
# Note: These handle the static/instance confusion by being clearly module-level

def node(path: str) -> Node:
    """
    Get node by path. Returns None if path doesn't exist.
    This is the main way to access existing nodes.
    """
    ...

def root() -> Node:
    """Get root node. Always succeeds."""
    ...

def pwd() -> Node:
    """Get current working directory node. Always succeeds."""
    ...

def cd(path: str) -> None:
    """
    Change current directory. Can raise OperationFailed if path invalid.
    Affects behavior of relative paths in other hou functions.
    """
    ...

def selectedNodes() -> tuple[Node, ...]:
    """Get currently selected nodes. Empty tuple if none selected."""
    ...

def clearAllSelected() -> None:
    """Clear all node selections. Always succeeds."""
    ...

# Enhanced node finding with better error handling
def findNode(path: str) -> Node:
    """Find node by path, returns None if not found (alias for node())."""
    ...

def nodeAtPath(path: str, create_missing_dirs: bool = False) -> Node:
    """
    Get node at path, optionally creating parent directories.
    More robust than basic node() function.
    """
    ...

# Node type functions
def nodeTypeCategories() -> dict[str, NodeTypeCategory]:
    """Get all node type categories."""
    ...

def nodeType(category: str | NodeTypeCategory, name: str) -> NodeType|None:
    """Get a specific node type."""
    ...

# Session info
def applicationName() -> str:
    """Get application name."""
    ...

def applicationVersion() -> tuple[int, int, int]:
    """Get application version as tuple."""
    ...

def applicationVersionString() -> str:
    """Get application version as string."""
    ...

def isUIAvailable() -> bool:
    """Check if UI is available."""
    ...

class HipFile:
    """Houdini hip file operations."""
    def name(self) -> str: ...
    def path(self) -> str: ...
    def save(self, file_name: str|None = None) -> None: ...
    def load(self, file_name: str) -> None: ...
    def clear(self) -> None: ...
    def isNewFile(self) -> bool: ...

# File operations - hipFile is both a function and an instance in Houdini
hipFile: HipFile

# Common exceptions that Houdini can raise
class OperationFailed(Exception):
    """Houdini operation failed exception."""
    pass

class InvalidInput(Exception):
    """Invalid input exception."""
    pass

class LoadWarning(Warning):
    """Houdini load warning."""
    pass

# Additional specialized classes for different node types
class Track:
    """CHOP track (channel) object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def samples(self) -> tuple[float, ...]: ...
    def values(self) -> tuple[float, ...]: ...

class DopSimulation:
    """DOP simulation object."""
    def __init__(self) -> None: ...
    def objects(self) -> tuple['DopObject', ...]: ...
    def timestep(self) -> float: ...

class DopObject:
    """DOP simulation object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def geometry(self) -> 'Geometry|None': ...

class Image:
    """COP image object."""
    def __init__(self) -> None: ...
    def resolution(self) -> tuple[int, int]: ...
    def pixels(self) -> Any: ...  # NumPy array if available

class WorkItem:
    """TOP/PDG work item."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def state(self) -> str: ...  # "ready", "cooking", "cooked", "failed"

# Context managers for safer Houdini operations
class UndoGroup:
    """Context manager for grouping operations into a single undo."""
    def __init__(self, name: str) -> None: ...
    def __enter__(self) -> 'UndoGroup': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

def undos() -> 'UndoManager':
    """Get undo manager for grouping operations."""
    ...

class UndoManager:
    """Undo manager for grouping operations."""
    def group(self, name: str) -> UndoGroup: ...
    def clear(self) -> None: ...
    def disabler(self) -> 'UndoDisabler': ...

class UndoDisabler:
    """Context manager to disable undo tracking."""
    def __enter__(self) -> 'UndoDisabler': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

# Progress reporting for long operations
def progressBar() -> 'ProgressBar':
    """Get progress bar for long operations."""
    ...

class ProgressBar:
    """Progress reporting for long operations."""
    def __init__(self) -> None: ...
    def __enter__(self) -> 'ProgressBar': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def update(self, progress: float, message: str = "") -> None: ...
    def setLabel(self, label: str) -> None: ...
