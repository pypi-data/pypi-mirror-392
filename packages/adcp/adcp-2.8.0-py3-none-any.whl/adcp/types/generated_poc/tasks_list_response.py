# generated by datamodel-codegen:
#   filename:  tasks-list-response.json
#   timestamp: 2025-11-18T03:35:10+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any

from adcp.types.base import AdCPBaseModel
from pydantic import AwareDatetime, ConfigDict, Field

from . import task_status
from . import task_type as task_type_1


class Pagination(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    has_more: Annotated[bool, Field(description='Whether there are more tasks beyond this page')]
    limit: Annotated[int, Field(description='Limit that was applied to this query', ge=1)]
    next_offset: Annotated[
        int | None,
        Field(description='Offset to use for next page (only present if has_more is true)', ge=0),
    ] = None
    offset: Annotated[int, Field(description='Offset that was applied to this query', ge=0)]


class DomainBreakdown(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    media_buy: Annotated[
        int | None,
        Field(alias='media-buy', description='Number of media-buy tasks in results', ge=0),
    ] = None
    signals: Annotated[
        int | None, Field(description='Number of signals tasks in results', ge=0)
    ] = None


class Direction(Enum):
    asc = 'asc'
    desc = 'desc'


class SortApplied(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    direction: Direction
    field: str


class QuerySummary(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    domain_breakdown: Annotated[
        DomainBreakdown | None, Field(description='Count of tasks by domain')
    ] = None
    filters_applied: Annotated[
        list[str] | None, Field(description='List of filters that were applied to the query')
    ] = None
    returned: Annotated[int, Field(description='Number of tasks returned in this response', ge=0)]
    sort_applied: Annotated[
        SortApplied | None, Field(description='Sort order that was applied')
    ] = None
    status_breakdown: Annotated[
        dict[str, int] | None, Field(description='Count of tasks by status')
    ] = None
    total_matching: Annotated[
        int, Field(description='Total number of tasks matching filters (across all pages)', ge=0)
    ]


class Domain(Enum):
    media_buy = 'media-buy'
    signals = 'signals'


class Task(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    completed_at: Annotated[
        AwareDatetime | None,
        Field(
            description='When the task completed (ISO 8601, only for completed/failed/canceled tasks)'
        ),
    ] = None
    created_at: Annotated[
        AwareDatetime, Field(description='When the task was initially created (ISO 8601)')
    ]
    domain: Annotated[Domain, Field(description='AdCP domain this task belongs to')]
    has_webhook: Annotated[
        bool | None, Field(description='Whether this task has webhook configuration')
    ] = None
    status: Annotated[task_status.TaskStatus, Field(description='Current task status')]
    task_id: Annotated[str, Field(description='Unique identifier for this task')]
    task_type: Annotated[task_type_1.TaskType, Field(description='Type of AdCP operation')]
    updated_at: Annotated[
        AwareDatetime, Field(description='When the task was last updated (ISO 8601)')
    ]


class TasksListResponse(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Annotated[
        dict[str, Any] | None,
        Field(
            description='Initiator-provided context echoed inside the task payload. Opaque metadata such as UI/session hints, correlation tokens, or tracking identifiers.'
        ),
    ] = None
    pagination: Annotated[Pagination, Field(description='Pagination information')]
    query_summary: Annotated[
        QuerySummary, Field(description='Summary of the query that was executed')
    ]
    tasks: Annotated[list[Task], Field(description='Array of tasks matching the query criteria')]
