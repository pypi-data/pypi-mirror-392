"""
Tests for the _check_error() function in bellhop.py

This module tests all three branches of the _check_error() function:
1. FileNotFoundError handling when .prt file doesn't exist
2. Fatal error detection when "*** FATAL ERROR ***" is found
3. Error continuation collecting subsequent lines after fatal error
"""

import pytest
import tempfile
import os
from pathlib import Path
from bellhop.bellhop import BellhopSimulator


class TestCheckError:
    """Test class for _check_error function."""

    def setup_method(self):
        """Set up test fixtures."""
        self.bellhop = BellhopSimulator()
        self.temp_dir = tempfile.mkdtemp()

    def teardown_method(self):
        """Clean up test fixtures."""
        # Clean up any temporary files
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_check_error_file_not_found(self):
        """Test FileNotFoundError branch when .prt file doesn't exist."""
        # Use a non-existent file base
        nonexistent_base = os.path.join(self.temp_dir, "nonexistent")

        # Call _check_error with non-existent file
        result = self.bellhop._check_error(nonexistent_base)

        # Should return None when file doesn't exist
        assert result is ""

    def test_check_error_no_fatal_error(self):
        """Test normal .prt file without fatal errors."""
        # Create a temporary .prt file without fatal errors
        test_base = os.path.join(self.temp_dir, "test_normal")
        prt_file = test_base + ".prt"

        with open(prt_file, 'w') as f:
            f.write("Normal bellhop output\n")
            f.write("Some other line\n")
            f.write("Everything is fine\n")

        # Call _check_error
        result = self.bellhop._check_error(test_base)

        # Should return None when no fatal error
        assert result is ""

    def test_check_error_fatal_error_single_line(self):
        """Test fatal error detection with single line."""
        # Create a temporary .prt file with fatal error
        test_base = os.path.join(self.temp_dir, "test_fatal")
        prt_file = test_base + ".prt"

        with open(prt_file, 'w') as f:
            f.write("Normal output line\n")
            f.write("*** FATAL ERROR ***\n")
            f.write("Error description\n")

        # Call _check_error
        result = self.bellhop._check_error(test_base)

        # Should return error message starting with fatal error line
        assert result is not None
        assert '[FATAL] Error description' in result

    def test_check_error_fatal_error_multiple_lines(self):
        """Test error continuation branch with multiple error lines."""
        # Create a temporary .prt file with fatal error and multiple continuation lines
        test_base = os.path.join(self.temp_dir, "test_multiline")
        prt_file = test_base + ".prt"

        with open(prt_file, 'w') as f:
            f.write("Normal output\n")
            f.write("*** FATAL ERROR ***\n")
            f.write("Generated by program or subroutine: BELLHOP\n")
            f.write("Invalid input parameter\n")
            f.write("Check your environment file\n")
            f.write("Program terminated\n")

        # Call _check_error
        result = self.bellhop._check_error(test_base)

        # Should return complete error message
        assert result is not None

        # Check that all subsequent lines are included with [BELLHOP] prefix
        expected_lines = [
            '[FATAL] Generated by program or subroutine: BELLHOP',
            '[FATAL] Invalid input parameter',
            '[FATAL] Check your environment file',
            '[FATAL] Program terminated'
        ]

        for expected_line in expected_lines:
            assert expected_line in result

    def test_check_error_fatal_error_with_context(self):
        """Test that lines before fatal error are not included."""
        # Create a temporary .prt file with context before fatal error
        test_base = os.path.join(self.temp_dir, "test_context")
        prt_file = test_base + ".prt"

        with open(prt_file, 'w') as f:
            f.write("Starting BELLHOP\n")
            f.write("Reading environment file\n")
            f.write("Processing parameters\n")
            f.write("*** FATAL ERROR ***\n")
            f.write("Something went wrong\n")

        # Call _check_error
        result = self.bellhop._check_error(test_base)

        # Should only include fatal error and subsequent lines
        assert result is not None
        assert 'Starting BELLHOP' not in result
        assert 'Reading environment file' not in result
        assert 'Processing parameters' not in result
        assert '[BELLHOP] *** FATAL ERROR ***' not in result
        assert '[FATAL] Something went wrong' in result

    def test_check_error_empty_file(self):
        """Test with empty .prt file."""
        # Create empty .prt file
        test_base = os.path.join(self.temp_dir, "test_empty")
        prt_file = test_base + ".prt"

        with open(prt_file, 'w') as f:
            pass  # Create empty file

        # Call _check_error
        result = self.bellhop._check_error(test_base)

        # Should return None for empty file
        assert result is ""

    def test_check_error_fatal_error_partial_match(self):
        """Test that partial matches don't trigger fatal error detection."""
        # Create a .prt file with partial match
        test_base = os.path.join(self.temp_dir, "test_partial")
        prt_file = test_base + ".prt"

        with open(prt_file, 'w') as f:
            f.write("This line contains ERROR but not fatal\n")
            f.write("*** FATAL but not complete ***\n")
            f.write("FATAL ERROR without stars\n")
            f.write("Normal completion\n")

        # Call _check_error
        result = self.bellhop._check_error(test_base)

        # Should return None as no exact "*** FATAL ERROR ***" match
        assert result is ""
