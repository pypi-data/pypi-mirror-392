# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _flumy
else:
    import _flumy

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _flumy.delete_SwigPyIterator

    def value(self):
        return _flumy.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _flumy.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _flumy.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _flumy.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _flumy.SwigPyIterator_equal(self, x)

    def copy(self):
        return _flumy.SwigPyIterator_copy(self)

    def next(self):
        return _flumy.SwigPyIterator_next(self)

    def __next__(self):
        return _flumy.SwigPyIterator___next__(self)

    def previous(self):
        return _flumy.SwigPyIterator_previous(self)

    def advance(self, n):
        return _flumy.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _flumy.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _flumy.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _flumy.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _flumy.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _flumy.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _flumy.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _flumy:
_flumy.SwigPyIterator_swigregister(SwigPyIterator)
class DoNotUseVectorIntStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _flumy.DoNotUseVectorIntStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _flumy.DoNotUseVectorIntStd___nonzero__(self)

    def __bool__(self):
        return _flumy.DoNotUseVectorIntStd___bool__(self)

    def __len__(self):
        return _flumy.DoNotUseVectorIntStd___len__(self)

    def __getslice__(self, i, j):
        return _flumy.DoNotUseVectorIntStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _flumy.DoNotUseVectorIntStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _flumy.DoNotUseVectorIntStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _flumy.DoNotUseVectorIntStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _flumy.DoNotUseVectorIntStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _flumy.DoNotUseVectorIntStd___setitem__(self, *args)

    def pop(self):
        return _flumy.DoNotUseVectorIntStd_pop(self)

    def append(self, x):
        return _flumy.DoNotUseVectorIntStd_append(self, x)

    def empty(self):
        return _flumy.DoNotUseVectorIntStd_empty(self)

    def size(self):
        return _flumy.DoNotUseVectorIntStd_size(self)

    def swap(self, v):
        return _flumy.DoNotUseVectorIntStd_swap(self, v)

    def begin(self):
        return _flumy.DoNotUseVectorIntStd_begin(self)

    def end(self):
        return _flumy.DoNotUseVectorIntStd_end(self)

    def rbegin(self):
        return _flumy.DoNotUseVectorIntStd_rbegin(self)

    def rend(self):
        return _flumy.DoNotUseVectorIntStd_rend(self)

    def clear(self):
        return _flumy.DoNotUseVectorIntStd_clear(self)

    def get_allocator(self):
        return _flumy.DoNotUseVectorIntStd_get_allocator(self)

    def pop_back(self):
        return _flumy.DoNotUseVectorIntStd_pop_back(self)

    def erase(self, *args):
        return _flumy.DoNotUseVectorIntStd_erase(self, *args)

    def __init__(self, *args):
        _flumy.DoNotUseVectorIntStd_swiginit(self, _flumy.new_DoNotUseVectorIntStd(*args))

    def push_back(self, x):
        return _flumy.DoNotUseVectorIntStd_push_back(self, x)

    def front(self):
        return _flumy.DoNotUseVectorIntStd_front(self)

    def back(self):
        return _flumy.DoNotUseVectorIntStd_back(self)

    def assign(self, n, x):
        return _flumy.DoNotUseVectorIntStd_assign(self, n, x)

    def resize(self, *args):
        return _flumy.DoNotUseVectorIntStd_resize(self, *args)

    def insert(self, *args):
        return _flumy.DoNotUseVectorIntStd_insert(self, *args)

    def reserve(self, n):
        return _flumy.DoNotUseVectorIntStd_reserve(self, n)

    def capacity(self):
        return _flumy.DoNotUseVectorIntStd_capacity(self)
    __swig_destroy__ = _flumy.delete_DoNotUseVectorIntStd

# Register DoNotUseVectorIntStd in _flumy:
_flumy.DoNotUseVectorIntStd_swigregister(DoNotUseVectorIntStd)
class DoNotUseVectorUCharStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _flumy.DoNotUseVectorUCharStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _flumy.DoNotUseVectorUCharStd___nonzero__(self)

    def __bool__(self):
        return _flumy.DoNotUseVectorUCharStd___bool__(self)

    def __len__(self):
        return _flumy.DoNotUseVectorUCharStd___len__(self)

    def __getslice__(self, i, j):
        return _flumy.DoNotUseVectorUCharStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _flumy.DoNotUseVectorUCharStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _flumy.DoNotUseVectorUCharStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _flumy.DoNotUseVectorUCharStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _flumy.DoNotUseVectorUCharStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _flumy.DoNotUseVectorUCharStd___setitem__(self, *args)

    def pop(self):
        return _flumy.DoNotUseVectorUCharStd_pop(self)

    def append(self, x):
        return _flumy.DoNotUseVectorUCharStd_append(self, x)

    def empty(self):
        return _flumy.DoNotUseVectorUCharStd_empty(self)

    def size(self):
        return _flumy.DoNotUseVectorUCharStd_size(self)

    def swap(self, v):
        return _flumy.DoNotUseVectorUCharStd_swap(self, v)

    def begin(self):
        return _flumy.DoNotUseVectorUCharStd_begin(self)

    def end(self):
        return _flumy.DoNotUseVectorUCharStd_end(self)

    def rbegin(self):
        return _flumy.DoNotUseVectorUCharStd_rbegin(self)

    def rend(self):
        return _flumy.DoNotUseVectorUCharStd_rend(self)

    def clear(self):
        return _flumy.DoNotUseVectorUCharStd_clear(self)

    def get_allocator(self):
        return _flumy.DoNotUseVectorUCharStd_get_allocator(self)

    def pop_back(self):
        return _flumy.DoNotUseVectorUCharStd_pop_back(self)

    def erase(self, *args):
        return _flumy.DoNotUseVectorUCharStd_erase(self, *args)

    def __init__(self, *args):
        _flumy.DoNotUseVectorUCharStd_swiginit(self, _flumy.new_DoNotUseVectorUCharStd(*args))

    def push_back(self, x):
        return _flumy.DoNotUseVectorUCharStd_push_back(self, x)

    def front(self):
        return _flumy.DoNotUseVectorUCharStd_front(self)

    def back(self):
        return _flumy.DoNotUseVectorUCharStd_back(self)

    def assign(self, n, x):
        return _flumy.DoNotUseVectorUCharStd_assign(self, n, x)

    def resize(self, *args):
        return _flumy.DoNotUseVectorUCharStd_resize(self, *args)

    def insert(self, *args):
        return _flumy.DoNotUseVectorUCharStd_insert(self, *args)

    def reserve(self, n):
        return _flumy.DoNotUseVectorUCharStd_reserve(self, n)

    def capacity(self):
        return _flumy.DoNotUseVectorUCharStd_capacity(self)
    __swig_destroy__ = _flumy.delete_DoNotUseVectorUCharStd

# Register DoNotUseVectorUCharStd in _flumy:
_flumy.DoNotUseVectorUCharStd_swigregister(DoNotUseVectorUCharStd)
class DoNotUseVectorUIntStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _flumy.DoNotUseVectorUIntStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _flumy.DoNotUseVectorUIntStd___nonzero__(self)

    def __bool__(self):
        return _flumy.DoNotUseVectorUIntStd___bool__(self)

    def __len__(self):
        return _flumy.DoNotUseVectorUIntStd___len__(self)

    def __getslice__(self, i, j):
        return _flumy.DoNotUseVectorUIntStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _flumy.DoNotUseVectorUIntStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _flumy.DoNotUseVectorUIntStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _flumy.DoNotUseVectorUIntStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _flumy.DoNotUseVectorUIntStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _flumy.DoNotUseVectorUIntStd___setitem__(self, *args)

    def pop(self):
        return _flumy.DoNotUseVectorUIntStd_pop(self)

    def append(self, x):
        return _flumy.DoNotUseVectorUIntStd_append(self, x)

    def empty(self):
        return _flumy.DoNotUseVectorUIntStd_empty(self)

    def size(self):
        return _flumy.DoNotUseVectorUIntStd_size(self)

    def swap(self, v):
        return _flumy.DoNotUseVectorUIntStd_swap(self, v)

    def begin(self):
        return _flumy.DoNotUseVectorUIntStd_begin(self)

    def end(self):
        return _flumy.DoNotUseVectorUIntStd_end(self)

    def rbegin(self):
        return _flumy.DoNotUseVectorUIntStd_rbegin(self)

    def rend(self):
        return _flumy.DoNotUseVectorUIntStd_rend(self)

    def clear(self):
        return _flumy.DoNotUseVectorUIntStd_clear(self)

    def get_allocator(self):
        return _flumy.DoNotUseVectorUIntStd_get_allocator(self)

    def pop_back(self):
        return _flumy.DoNotUseVectorUIntStd_pop_back(self)

    def erase(self, *args):
        return _flumy.DoNotUseVectorUIntStd_erase(self, *args)

    def __init__(self, *args):
        _flumy.DoNotUseVectorUIntStd_swiginit(self, _flumy.new_DoNotUseVectorUIntStd(*args))

    def push_back(self, x):
        return _flumy.DoNotUseVectorUIntStd_push_back(self, x)

    def front(self):
        return _flumy.DoNotUseVectorUIntStd_front(self)

    def back(self):
        return _flumy.DoNotUseVectorUIntStd_back(self)

    def assign(self, n, x):
        return _flumy.DoNotUseVectorUIntStd_assign(self, n, x)

    def resize(self, *args):
        return _flumy.DoNotUseVectorUIntStd_resize(self, *args)

    def insert(self, *args):
        return _flumy.DoNotUseVectorUIntStd_insert(self, *args)

    def reserve(self, n):
        return _flumy.DoNotUseVectorUIntStd_reserve(self, n)

    def capacity(self):
        return _flumy.DoNotUseVectorUIntStd_capacity(self)
    __swig_destroy__ = _flumy.delete_DoNotUseVectorUIntStd

# Register DoNotUseVectorUIntStd in _flumy:
_flumy.DoNotUseVectorUIntStd_swigregister(DoNotUseVectorUIntStd)
class DoNotUseVectorDoubleStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _flumy.DoNotUseVectorDoubleStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _flumy.DoNotUseVectorDoubleStd___nonzero__(self)

    def __bool__(self):
        return _flumy.DoNotUseVectorDoubleStd___bool__(self)

    def __len__(self):
        return _flumy.DoNotUseVectorDoubleStd___len__(self)

    def __getslice__(self, i, j):
        return _flumy.DoNotUseVectorDoubleStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _flumy.DoNotUseVectorDoubleStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _flumy.DoNotUseVectorDoubleStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _flumy.DoNotUseVectorDoubleStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _flumy.DoNotUseVectorDoubleStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _flumy.DoNotUseVectorDoubleStd___setitem__(self, *args)

    def pop(self):
        return _flumy.DoNotUseVectorDoubleStd_pop(self)

    def append(self, x):
        return _flumy.DoNotUseVectorDoubleStd_append(self, x)

    def empty(self):
        return _flumy.DoNotUseVectorDoubleStd_empty(self)

    def size(self):
        return _flumy.DoNotUseVectorDoubleStd_size(self)

    def swap(self, v):
        return _flumy.DoNotUseVectorDoubleStd_swap(self, v)

    def begin(self):
        return _flumy.DoNotUseVectorDoubleStd_begin(self)

    def end(self):
        return _flumy.DoNotUseVectorDoubleStd_end(self)

    def rbegin(self):
        return _flumy.DoNotUseVectorDoubleStd_rbegin(self)

    def rend(self):
        return _flumy.DoNotUseVectorDoubleStd_rend(self)

    def clear(self):
        return _flumy.DoNotUseVectorDoubleStd_clear(self)

    def get_allocator(self):
        return _flumy.DoNotUseVectorDoubleStd_get_allocator(self)

    def pop_back(self):
        return _flumy.DoNotUseVectorDoubleStd_pop_back(self)

    def erase(self, *args):
        return _flumy.DoNotUseVectorDoubleStd_erase(self, *args)

    def __init__(self, *args):
        _flumy.DoNotUseVectorDoubleStd_swiginit(self, _flumy.new_DoNotUseVectorDoubleStd(*args))

    def push_back(self, x):
        return _flumy.DoNotUseVectorDoubleStd_push_back(self, x)

    def front(self):
        return _flumy.DoNotUseVectorDoubleStd_front(self)

    def back(self):
        return _flumy.DoNotUseVectorDoubleStd_back(self)

    def assign(self, n, x):
        return _flumy.DoNotUseVectorDoubleStd_assign(self, n, x)

    def resize(self, *args):
        return _flumy.DoNotUseVectorDoubleStd_resize(self, *args)

    def insert(self, *args):
        return _flumy.DoNotUseVectorDoubleStd_insert(self, *args)

    def reserve(self, n):
        return _flumy.DoNotUseVectorDoubleStd_reserve(self, n)

    def capacity(self):
        return _flumy.DoNotUseVectorDoubleStd_capacity(self)
    __swig_destroy__ = _flumy.delete_DoNotUseVectorDoubleStd

# Register DoNotUseVectorDoubleStd in _flumy:
_flumy.DoNotUseVectorDoubleStd_swigregister(DoNotUseVectorDoubleStd)
class DoNotUseVectorStringStd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _flumy.DoNotUseVectorStringStd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _flumy.DoNotUseVectorStringStd___nonzero__(self)

    def __bool__(self):
        return _flumy.DoNotUseVectorStringStd___bool__(self)

    def __len__(self):
        return _flumy.DoNotUseVectorStringStd___len__(self)

    def __getslice__(self, i, j):
        return _flumy.DoNotUseVectorStringStd___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _flumy.DoNotUseVectorStringStd___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _flumy.DoNotUseVectorStringStd___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _flumy.DoNotUseVectorStringStd___delitem__(self, *args)

    def __getitem__(self, *args):
        return _flumy.DoNotUseVectorStringStd___getitem__(self, *args)

    def __setitem__(self, *args):
        return _flumy.DoNotUseVectorStringStd___setitem__(self, *args)

    def pop(self):
        return _flumy.DoNotUseVectorStringStd_pop(self)

    def append(self, x):
        return _flumy.DoNotUseVectorStringStd_append(self, x)

    def empty(self):
        return _flumy.DoNotUseVectorStringStd_empty(self)

    def size(self):
        return _flumy.DoNotUseVectorStringStd_size(self)

    def swap(self, v):
        return _flumy.DoNotUseVectorStringStd_swap(self, v)

    def begin(self):
        return _flumy.DoNotUseVectorStringStd_begin(self)

    def end(self):
        return _flumy.DoNotUseVectorStringStd_end(self)

    def rbegin(self):
        return _flumy.DoNotUseVectorStringStd_rbegin(self)

    def rend(self):
        return _flumy.DoNotUseVectorStringStd_rend(self)

    def clear(self):
        return _flumy.DoNotUseVectorStringStd_clear(self)

    def get_allocator(self):
        return _flumy.DoNotUseVectorStringStd_get_allocator(self)

    def pop_back(self):
        return _flumy.DoNotUseVectorStringStd_pop_back(self)

    def erase(self, *args):
        return _flumy.DoNotUseVectorStringStd_erase(self, *args)

    def __init__(self, *args):
        _flumy.DoNotUseVectorStringStd_swiginit(self, _flumy.new_DoNotUseVectorStringStd(*args))

    def push_back(self, x):
        return _flumy.DoNotUseVectorStringStd_push_back(self, x)

    def front(self):
        return _flumy.DoNotUseVectorStringStd_front(self)

    def back(self):
        return _flumy.DoNotUseVectorStringStd_back(self)

    def assign(self, n, x):
        return _flumy.DoNotUseVectorStringStd_assign(self, n, x)

    def resize(self, *args):
        return _flumy.DoNotUseVectorStringStd_resize(self, *args)

    def insert(self, *args):
        return _flumy.DoNotUseVectorStringStd_insert(self, *args)

    def reserve(self, n):
        return _flumy.DoNotUseVectorStringStd_reserve(self, n)

    def capacity(self):
        return _flumy.DoNotUseVectorStringStd_capacity(self)
    __swig_destroy__ = _flumy.delete_DoNotUseVectorStringStd

# Register DoNotUseVectorStringStd in _flumy:
_flumy.DoNotUseVectorStringStd_swigregister(DoNotUseVectorStringStd)
class Flumy(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nx, ny, mesh, verbose=False):
        _flumy.Flumy_swiginit(self, _flumy.new_Flumy(nx, ny, mesh, verbose))
    __swig_destroy__ = _flumy.delete_Flumy

    def launch(self, seed, hmax, isbx, ng, zul=-1., niter=-1, lvb=True):
        return _flumy.Flumy_launch(self, seed, hmax, isbx, ng, zul, niter, lvb)

    def getDomain(self):
        return _flumy.Flumy_getDomain(self)

    def getAge(self):
        return _flumy.Flumy_getAge(self)

    def getAggradationRate(self):
        return _flumy.Flumy_getAggradationRate(self)

    def getMigrationRate(self):
        return _flumy.Flumy_getMigrationRate(self)

    def getMeanVelocityPerturbation(self):
        return _flumy.Flumy_getMeanVelocityPerturbation(self)

    def getSinuosity(self):
        return _flumy.Flumy_getSinuosity(self)

    def getTortuosity(self):
        return _flumy.Flumy_getTortuosity(self)

    def getWavelength(self):
        return _flumy.Flumy_getWavelength(self)

    def getSandBodyExtension(self):
        return _flumy.Flumy_getSandBodyExtension(self)

    def getNbCutoff(self):
        return _flumy.Flumy_getNbCutoff(self)

# Register Flumy in _flumy:
_flumy.Flumy_swigregister(Flumy)

def printVersion():
    return _flumy.printVersion()
MP_FAMILY_MASK = _flumy.MP_FAMILY_MASK
MP_GRANULO_OFFSET = _flumy.MP_GRANULO_OFFSET
MP_STUT_SIZE = _flumy.MP_STUT_SIZE
MP_AGUT_SIZE = _flumy.MP_AGUT_SIZE
MP_INIT_AGE = _flumy.MP_INIT_AGE
MP_INIT_PERIOD_VAL = _flumy.MP_INIT_PERIOD_VAL
MP_INIT_POISSON_VAL = _flumy.MP_INIT_POISSON_VAL
MP_INIT_CONST = _flumy.MP_INIT_CONST
MP_INIT_MIN = _flumy.MP_INIT_MIN
MP_INIT_MAX = _flumy.MP_INIT_MAX
MP_INIT_NORM_MEAN = _flumy.MP_INIT_NORM_MEAN
MP_INIT_NORM_STDEV = _flumy.MP_INIT_NORM_STDEV
MP_INIT_LOGNORM_MEAN = _flumy.MP_INIT_LOGNORM_MEAN
MP_INIT_LOGNORM_STDEV = _flumy.MP_INIT_LOGNORM_STDEV
MP_CHANNEL_A_AFF = _flumy.MP_CHANNEL_A_AFF
MP_CHANNEL_A_SEC = _flumy.MP_CHANNEL_A_SEC
MP_CHANNEL_A = _flumy.MP_CHANNEL_A
MP_FLU_EFF_TO_MAX_HFLOW = _flumy.MP_FLU_EFF_TO_MAX_HFLOW
MP_TUR_EFF_TO_MAX_HFLOW = _flumy.MP_TUR_EFF_TO_MAX_HFLOW
MP_FLU_HMAX_TO_MAX_HFLOW = _flumy.MP_FLU_HMAX_TO_MAX_HFLOW
MP_TUR_HMAX_TO_MAX_HFLOW = _flumy.MP_TUR_HMAX_TO_MAX_HFLOW
MP_PI = _flumy.MP_PI
MP_2PI = _flumy.MP_2PI
MP_G = _flumy.MP_G
MP_YEAR_SECONDS = _flumy.MP_YEAR_SECONDS
MP_PARAB_MEAN_TO_MAX_FACTOR = _flumy.MP_PARAB_MEAN_TO_MAX_FACTOR
MP_PARAB_MAX_TO_MEAN_FACTOR = _flumy.MP_PARAB_MAX_TO_MEAN_FACTOR
MP_DENSITY_SED = _flumy.MP_DENSITY_SED
MP_R = _flumy.MP_R
MP_VISCO = _flumy.MP_VISCO
MP_K = _flumy.MP_K
MP_FRICTION_COEFF_SKIN = _flumy.MP_FRICTION_COEFF_SKIN
MP_Z0 = _flumy.MP_Z0
MP_TURBI_SCALE_FACTOR = _flumy.MP_TURBI_SCALE_FACTOR
MP_LOC_SLOPE_ALPHA = _flumy.MP_LOC_SLOPE_ALPHA
MP_VEL_TURB_POW = _flumy.MP_VEL_TURB_POW
MP_FLU_D2W_FACTOR = _flumy.MP_FLU_D2W_FACTOR
MP_FLU_W2WL_FACTOR = _flumy.MP_FLU_W2WL_FACTOR
MP_FLU_W2LOB_FACTOR = _flumy.MP_FLU_W2LOB_FACTOR
MP_FLU_SINUO = _flumy.MP_FLU_SINUO
MP_FLU_SINUO_ALLEN = _flumy.MP_FLU_SINUO_ALLEN
MP_FLU_KOB = _flumy.MP_FLU_KOB
MP_FLU_KMIG_STD = _flumy.MP_FLU_KMIG_STD
MP_FLU_KMIG_NEW = _flumy.MP_FLU_KMIG_NEW
MP_FLU_KVP = _flumy.MP_FLU_KVP
MP_FLU_TAU_CUT = _flumy.MP_FLU_TAU_CUT
MP_TUR_D2W_FACTOR = _flumy.MP_TUR_D2W_FACTOR
MP_TUR_W2WL_FACTOR = _flumy.MP_TUR_W2WL_FACTOR
MP_TUR_W2LOB_FACTOR = _flumy.MP_TUR_W2LOB_FACTOR
MP_TUR_SINUO = _flumy.MP_TUR_SINUO
MP_TUR_SINUO_ALLEN = _flumy.MP_TUR_SINUO_ALLEN
MP_TUR_KOB = _flumy.MP_TUR_KOB
MP_TUR_KMIG_STD = _flumy.MP_TUR_KMIG_STD
MP_TUR_KMIG_NEW = _flumy.MP_TUR_KMIG_NEW
MP_TUR_KVP = _flumy.MP_TUR_KVP
MP_TUR_TAU_CUT = _flumy.MP_TUR_TAU_CUT
MP_MIN_SLOPE_WARN = _flumy.MP_MIN_SLOPE_WARN
MP_MAX_SLOPE_WARN = _flumy.MP_MAX_SLOPE_WARN
MP_PEAT_COMPRESS_FACTOR = _flumy.MP_PEAT_COMPRESS_FACTOR
MP_DEFAULT_MIG_WELL_FACTOR = _flumy.MP_DEFAULT_MIG_WELL_FACTOR
MP_DEFAULT_ZUL_TOL = _flumy.MP_DEFAULT_ZUL_TOL
MP_THICKNESS_RATIO = _flumy.MP_THICKNESS_RATIO
MP_INACTIVE_EP = _flumy.MP_INACTIVE_EP
MP_MAX_CS_CHANNEL = _flumy.MP_MAX_CS_CHANNEL
MP_MAX_MEANDER_DEFAULT_VALUES = _flumy.MP_MAX_MEANDER_DEFAULT_VALUES
MP_MAX_NB_NODES = _flumy.MP_MAX_NB_NODES
MP_MAX_NB_NODES_WARN = _flumy.MP_MAX_NB_NODES_WARN
MP_ERR_MAX_WELLS = _flumy.MP_ERR_MAX_WELLS
MP_WARN_MAX_WELLS = _flumy.MP_WARN_MAX_WELLS
MP_MAX_GRID_SIZE = _flumy.MP_MAX_GRID_SIZE
MP_ZOOM_TIFF = _flumy.MP_ZOOM_TIFF
MP_REFRESH_LOOP = _flumy.MP_REFRESH_LOOP
MP_DEFAULT_CELLS_ORDER = _flumy.MP_DEFAULT_CELLS_ORDER
MP_DEFAULT_GSLIB_CELLS_ORDER = _flumy.MP_DEFAULT_GSLIB_CELLS_ORDER
MP_DEFAULT_NA_VALUE = _flumy.MP_DEFAULT_NA_VALUE
MP_RN_DEFAULT_MODULUS = _flumy.MP_RN_DEFAULT_MODULUS
MP_RN_DEFAULT_MULTIPLIER = _flumy.MP_RN_DEFAULT_MULTIPLIER
MP_RN_DEFAULT_QUOTIENT = _flumy.MP_RN_DEFAULT_QUOTIENT
MP_RN_DEFAULT_REST = _flumy.MP_RN_DEFAULT_REST
MP_RN_SHUFFLING_TABLE_SIZE = _flumy.MP_RN_SHUFFLING_TABLE_SIZE
MP_EPSILON = _flumy.MP_EPSILON
MP_UNKNOWN_STRING_VALUE = _flumy.MP_UNKNOWN_STRING_VALUE
MP_UNKNOWN_REAL_VALUE = _flumy.MP_UNKNOWN_REAL_VALUE
MP_MAX_REAL_VALUE = _flumy.MP_MAX_REAL_VALUE
MP_MIN_REAL_VALUE = _flumy.MP_MIN_REAL_VALUE
MP_UNKNOWN_INT_VALUE = _flumy.MP_UNKNOWN_INT_VALUE
MP_MAX_INT_VALUE = _flumy.MP_MAX_INT_VALUE
MP_MIN_INT_VALUE = _flumy.MP_MIN_INT_VALUE
class InferenceStats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    age = property(_flumy.InferenceStats_age_get, _flumy.InferenceStats_age_set)
    pb_prop = property(_flumy.InferenceStats_pb_prop_get, _flumy.InferenceStats_pb_prop_set)
    sand_prop = property(_flumy.InferenceStats_sand_prop_get, _flumy.InferenceStats_sand_prop_set)
    agg_rate = property(_flumy.InferenceStats_agg_rate_get, _flumy.InferenceStats_agg_rate_set)
    mig_rate = property(_flumy.InferenceStats_mig_rate_get, _flumy.InferenceStats_mig_rate_set)
    mean_vp = property(_flumy.InferenceStats_mean_vp_get, _flumy.InferenceStats_mean_vp_set)
    infer_kob = property(_flumy.InferenceStats_infer_kob_get, _flumy.InferenceStats_infer_kob_set)
    infer_kmig = property(_flumy.InferenceStats_infer_kmig_get, _flumy.InferenceStats_infer_kmig_set)
    infer_kvp = property(_flumy.InferenceStats_infer_kvp_get, _flumy.InferenceStats_infer_kvp_set)
    sinuo = property(_flumy.InferenceStats_sinuo_get, _flumy.InferenceStats_sinuo_set)
    tortuo = property(_flumy.InferenceStats_tortuo_get, _flumy.InferenceStats_tortuo_set)
    sinuo_allen = property(_flumy.InferenceStats_sinuo_allen_get, _flumy.InferenceStats_sinuo_allen_set)
    sbext = property(_flumy.InferenceStats_sbext_get, _flumy.InferenceStats_sbext_set)
    wl = property(_flumy.InferenceStats_wl_get, _flumy.InferenceStats_wl_set)

    def __init__(self):
        _flumy.InferenceStats_swiginit(self, _flumy.new_InferenceStats())
    __swig_destroy__ = _flumy.delete_InferenceStats

# Register InferenceStats in _flumy:
_flumy.InferenceStats_swigregister(InferenceStats)
class TauCutStats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    age = property(_flumy.TauCutStats_age_get, _flumy.TauCutStats_age_set)
    tau_cut = property(_flumy.TauCutStats_tau_cut_get, _flumy.TauCutStats_tau_cut_set)
    sinuo = property(_flumy.TauCutStats_sinuo_get, _flumy.TauCutStats_sinuo_set)
    sinuo_allen = property(_flumy.TauCutStats_sinuo_allen_get, _flumy.TauCutStats_sinuo_allen_set)
    tortuo = property(_flumy.TauCutStats_tortuo_get, _flumy.TauCutStats_tortuo_set)
    wavelength = property(_flumy.TauCutStats_wavelength_get, _flumy.TauCutStats_wavelength_set)
    mean_sbext = property(_flumy.TauCutStats_mean_sbext_get, _flumy.TauCutStats_mean_sbext_set)

    def __init__(self):
        _flumy.TauCutStats_swiginit(self, _flumy.new_TauCutStats())
    __swig_destroy__ = _flumy.delete_TauCutStats

# Register TauCutStats in _flumy:
_flumy.TauCutStats_swigregister(TauCutStats)
SPACES = _flumy.SPACES

def trim_right(*args, **kwargs):
    return _flumy.trim_right(*args, **kwargs)

def trim_left(*args, **kwargs):
    return _flumy.trim_left(*args, **kwargs)

def trim_all(*args, **kwargs):
    return _flumy.trim_all(*args, **kwargs)
UNAVAILABLE_FACIES = _flumy.UNAVAILABLE_FACIES
UNAVAILABLE_AGE = _flumy.UNAVAILABLE_AGE
UNAVAILABLE_GRAIN_SIZE = _flumy.UNAVAILABLE_GRAIN_SIZE
FACIES_UDF_ID = _flumy.FACIES_UDF_ID
FACIES_CL_ID = _flumy.FACIES_CL_ID
FACIES_PB_ID = _flumy.FACIES_PB_ID
FACIES_SP_ID = _flumy.FACIES_SP_ID
FACIES_CSI_ID = _flumy.FACIES_CSI_ID
FACIES_CCH_ID = _flumy.FACIES_CCH_ID
FACIES_CSII_ID = _flumy.FACIES_CSII_ID
FACIES_LV_ID = _flumy.FACIES_LV_ID
FACIES_OB_ID = _flumy.FACIES_OB_ID
FACIES_MP_ID = _flumy.FACIES_MP_ID
FACIES_HP_ID = _flumy.FACIES_HP_ID
FACIES_WL_ID = _flumy.FACIES_WL_ID
FACIES_DR_ID = _flumy.FACIES_DR_ID
FACIES_PL_ID = _flumy.FACIES_PL_ID
FACIES_MIN_ID = _flumy.FACIES_MIN_ID
FACIES_MAX_ID = _flumy.FACIES_MAX_ID
FACIES_UDF_LABEL = _flumy.FACIES_UDF_LABEL
FACIES_CL_LABEL = _flumy.FACIES_CL_LABEL
FACIES_PB_LABEL = _flumy.FACIES_PB_LABEL
FACIES_SP_LABEL = _flumy.FACIES_SP_LABEL
FACIES_CSI_LABEL = _flumy.FACIES_CSI_LABEL
FACIES_CCH_LABEL = _flumy.FACIES_CCH_LABEL
FACIES_CSII_LABEL = _flumy.FACIES_CSII_LABEL
FACIES_LV_LABEL = _flumy.FACIES_LV_LABEL
FACIES_OB_LABEL = _flumy.FACIES_OB_LABEL
FACIES_MP_LABEL = _flumy.FACIES_MP_LABEL
FACIES_HP_LABEL = _flumy.FACIES_HP_LABEL
FACIES_WL_LABEL = _flumy.FACIES_WL_LABEL
FACIES_DR_LABEL = _flumy.FACIES_DR_LABEL
FACIES_PL_LABEL = _flumy.FACIES_PL_LABEL
FACIES_UDF_BRIEF = _flumy.FACIES_UDF_BRIEF
FACIES_CL_BRIEF = _flumy.FACIES_CL_BRIEF
FACIES_PB_BRIEF = _flumy.FACIES_PB_BRIEF
FACIES_SP_BRIEF = _flumy.FACIES_SP_BRIEF
FACIES_CSI_BRIEF = _flumy.FACIES_CSI_BRIEF
FACIES_CCH_BRIEF = _flumy.FACIES_CCH_BRIEF
FACIES_CSII_BRIEF = _flumy.FACIES_CSII_BRIEF
FACIES_LV_BRIEF = _flumy.FACIES_LV_BRIEF
FACIES_OB_BRIEF = _flumy.FACIES_OB_BRIEF
FACIES_MP_BRIEF = _flumy.FACIES_MP_BRIEF
FACIES_HP_BRIEF = _flumy.FACIES_HP_BRIEF
FACIES_WL_BRIEF = _flumy.FACIES_WL_BRIEF
FACIES_DR_BRIEF = _flumy.FACIES_DR_BRIEF
FACIES_PL_BRIEF = _flumy.FACIES_PL_BRIEF
FACIES_MAX_GRAIN = _flumy.FACIES_MAX_GRAIN
FACIES_CL_GRAIN = _flumy.FACIES_CL_GRAIN
FACIES_PB_GRAIN = _flumy.FACIES_PB_GRAIN
FACIES_SP_GRAIN = _flumy.FACIES_SP_GRAIN
FACIES_CSI_GRAIN_MAX = _flumy.FACIES_CSI_GRAIN_MAX
FACIES_CSI_GRAIN = _flumy.FACIES_CSI_GRAIN
FACIES_CSI_GRAIN_MIN = _flumy.FACIES_CSI_GRAIN_MIN
FACIES_CCH_GRAIN_MAX = _flumy.FACIES_CCH_GRAIN_MAX
FACIES_CCH_GRAIN = _flumy.FACIES_CCH_GRAIN
FACIES_CCH_GRAIN_MIN = _flumy.FACIES_CCH_GRAIN_MIN
FACIES_CSII_GRAIN_MAX = _flumy.FACIES_CSII_GRAIN_MAX
FACIES_CSII_GRAIN = _flumy.FACIES_CSII_GRAIN
FACIES_CSII_GRAIN_MIN = _flumy.FACIES_CSII_GRAIN_MIN
FACIES_LV_GRAIN_MAX_TR = _flumy.FACIES_LV_GRAIN_MAX_TR
FACIES_LV_GRAIN_MAX_FL = _flumy.FACIES_LV_GRAIN_MAX_FL
FACIES_LV_GRAIN = _flumy.FACIES_LV_GRAIN
FACIES_LV_GRAIN_MIN = _flumy.FACIES_LV_GRAIN_MIN
FACIES_OB_GRAIN_MAX = _flumy.FACIES_OB_GRAIN_MAX
FACIES_OB_GRAIN = _flumy.FACIES_OB_GRAIN
FACIES_OB_GRAIN_MIN = _flumy.FACIES_OB_GRAIN_MIN
FACIES_MP_GRAIN = _flumy.FACIES_MP_GRAIN
FACIES_HP_GRAIN = _flumy.FACIES_HP_GRAIN
FACIES_WL_GRAIN = _flumy.FACIES_WL_GRAIN
FACIES_DR_GRAIN = _flumy.FACIES_DR_GRAIN
FACIES_PL_GRAIN = _flumy.FACIES_PL_GRAIN
FACIES_MIN_GRAIN = _flumy.FACIES_MIN_GRAIN
FACIES_UDF_GRAIN = _flumy.FACIES_UDF_GRAIN
MD_MAX_GRANULO = _flumy.MD_MAX_GRANULO
MD_CL_GRANULO = _flumy.MD_CL_GRANULO
MD_PB_GRANULO = _flumy.MD_PB_GRANULO
MD_SP_GRANULO = _flumy.MD_SP_GRANULO
MD_CSI_GRANULO = _flumy.MD_CSI_GRANULO
MD_CCH_GRANULO = _flumy.MD_CCH_GRANULO
MD_CSII_GRANULO = _flumy.MD_CSII_GRANULO
MD_LV_GRANULO = _flumy.MD_LV_GRANULO
MD_OB_GRANULO = _flumy.MD_OB_GRANULO
MD_MP_GRANULO = _flumy.MD_MP_GRANULO
MD_HP_GRANULO = _flumy.MD_HP_GRANULO
MD_WL_GRANULO = _flumy.MD_WL_GRANULO
MD_DR_GRANULO = _flumy.MD_DR_GRANULO
MD_PL_GRANULO = _flumy.MD_PL_GRANULO
MD_MIN_GRANULO = _flumy.MD_MIN_GRANULO
MD_UDF_GRANULO = _flumy.MD_UDF_GRANULO
MD_NB_CLASS_GR = _flumy.MD_NB_CLASS_GR
MD_NB_TEMPLATES = _flumy.MD_NB_TEMPLATES
MD_SED_TP_STD_IDX = _flumy.MD_SED_TP_STD_IDX
MD_SED_TP_SANDY_IDX = _flumy.MD_SED_TP_SANDY_IDX
MD_SED_TP_FINE_IDX = _flumy.MD_SED_TP_FINE_IDX
MD_SED_TP_MUDDY_IDX = _flumy.MD_SED_TP_MUDDY_IDX
MD_E_FAC = _flumy.MD_E_FAC
MD_MAX_USER_CLASS = _flumy.MD_MAX_USER_CLASS
MD_MENU_FLUVIAL = _flumy.MD_MENU_FLUVIAL
MD_MENU_TURBIDITE = _flumy.MD_MENU_TURBIDITE
MD_MENU_TURBIDITE2 = _flumy.MD_MENU_TURBIDITE2
MD_MENU_LOBES = _flumy.MD_MENU_LOBES
MD_MENU_NONE = _flumy.MD_MENU_NONE
MD_MENU_UDF = _flumy.MD_MENU_UDF
MD_MENU_DR = _flumy.MD_MENU_DR
MD_MENU_PL = _flumy.MD_MENU_PL
MD_MENU_PB = _flumy.MD_MENU_PB
MD_MENU_LV = _flumy.MD_MENU_LV
MD_MENU_OB = _flumy.MD_MENU_OB
MD_MENU_HP = _flumy.MD_MENU_HP
MD_MENU_MP = _flumy.MD_MENU_MP
MD_MENU_WL = _flumy.MD_MENU_WL
MD_MENU_FL = _flumy.MD_MENU_FL
MD_MENU_ER = _flumy.MD_MENU_ER
MD_MENU_GH = _flumy.MD_MENU_GH
MD_MENU_NEVER = _flumy.MD_MENU_NEVER
MD_MENU_PER = _flumy.MD_MENU_PER
MD_MENU_POIS = _flumy.MD_MENU_POIS
MD_MENU_CONST = _flumy.MD_MENU_CONST
MD_MENU_UNIF = _flumy.MD_MENU_UNIF
MD_MENU_NORM = _flumy.MD_MENU_NORM
MD_MENU_LOGN = _flumy.MD_MENU_LOGN
MD_MENU_FILE = _flumy.MD_MENU_FILE
MD_PROP_FACIES = _flumy.MD_PROP_FACIES
MD_PROP_GRAINSIZE = _flumy.MD_PROP_GRAINSIZE
MD_PROP_ATTRIBUTES = _flumy.MD_PROP_ATTRIBUTES
MD_UNAVAILABLE_KEY = _flumy.MD_UNAVAILABLE_KEY
MD_REMOVED_KEY = _flumy.MD_REMOVED_KEY
FLUVIAL_SYSTEM = _flumy.FLUVIAL_SYSTEM
TURBIDITE_SYSTEM = _flumy.TURBIDITE_SYSTEM
LOBES_SYSTEM = _flumy.LOBES_SYSTEM
AGG_NONE = _flumy.AGG_NONE
AGG_DR = _flumy.AGG_DR
AGG_OB = _flumy.AGG_OB
AGG_GH = _flumy.AGG_GH
AGG_ER = _flumy.AGG_ER
FREQ_NEVER = _flumy.FREQ_NEVER
FREQ_PERIODIC = _flumy.FREQ_PERIODIC
FREQ_POISSON = _flumy.FREQ_POISSON
DIST_CONSTANT = _flumy.DIST_CONSTANT
DIST_UNIFORM = _flumy.DIST_UNIFORM
DIST_NORMAL = _flumy.DIST_NORMAL
DIST_LOGNORMAL = _flumy.DIST_LOGNORMAL
FILL_UNDEFINED = _flumy.FILL_UNDEFINED
FILL_CHANNEL_LAG = _flumy.FILL_CHANNEL_LAG
FILL_POINT_BAR = _flumy.FILL_POINT_BAR
FILL_SAND_PLUG = _flumy.FILL_SAND_PLUG
FILL_CREVASSE_SPLAY_I = _flumy.FILL_CREVASSE_SPLAY_I
FILL_CREVASSE_SPLAY_CHANNELS = _flumy.FILL_CREVASSE_SPLAY_CHANNELS
FILL_CREVASSE_SPLAY_II = _flumy.FILL_CREVASSE_SPLAY_II
FILL_LEVEE = _flumy.FILL_LEVEE
FILL_OVERBANK = _flumy.FILL_OVERBANK
FILL_MUD_PLUG = _flumy.FILL_MUD_PLUG
FILL_HEMIPELAGIC_PLUG = _flumy.FILL_HEMIPELAGIC_PLUG
FILL_WETLAND = _flumy.FILL_WETLAND
FILL_DRAPING = _flumy.FILL_DRAPING
FILL_PELAGIC = _flumy.FILL_PELAGIC
DRAP_UNDEFINED = _flumy.DRAP_UNDEFINED
DRAP_DRAPING = _flumy.DRAP_DRAPING
DRAP_PELAGIC = _flumy.DRAP_PELAGIC
ZUL_NONE = _flumy.ZUL_NONE
ZUL_NEUTRAL = _flumy.ZUL_NEUTRAL
ZUL_EROSIVE = _flumy.ZUL_EROSIVE
ZUL_STRATI = _flumy.ZUL_STRATI
SURF_NONE = _flumy.SURF_NONE
SURF_CONST = _flumy.SURF_CONST
SURF_FILE = _flumy.SURF_FILE
EMAP_CONST = _flumy.EMAP_CONST
EMAP_LOAD = _flumy.EMAP_LOAD
EMAP_LOAD_CONV = _flumy.EMAP_LOAD_CONV
EMAP_BUILD = _flumy.EMAP_BUILD
SURF_EXCD = _flumy.SURF_EXCD
SURF_REPL = _flumy.SURF_REPL
SURF_AGGR = _flumy.SURF_AGGR
SURF_EROD_DOWN = _flumy.SURF_EROD_DOWN
SURF_EROD_UP = _flumy.SURF_EROD_UP
STE_NO_ERROR = _flumy.STE_NO_ERROR
STE_UNKNOWN_ERROR = _flumy.STE_UNKNOWN_ERROR
STE_INIT_ERROR = _flumy.STE_INIT_ERROR
STE_NOT_READY = _flumy.STE_NOT_READY
STE_CHANNEL_ERROR = _flumy.STE_CHANNEL_ERROR
STE_CONSISTENCY_WARN = _flumy.STE_CONSISTENCY_WARN
STE_CONSISTENCY_ERROR = _flumy.STE_CONSISTENCY_ERROR
STE_ZUL_REACHED = _flumy.STE_ZUL_REACHED
STE_STOP_HONORED = _flumy.STE_STOP_HONORED
STE_STOPPED = _flumy.STE_STOPPED
TL_NONE = _flumy.TL_NONE
TL_FATAL = _flumy.TL_FATAL
TL_ERROR = _flumy.TL_ERROR
TL_WARNING = _flumy.TL_WARNING
TL_INFO = _flumy.TL_INFO
TL_DEBUG = _flumy.TL_DEBUG
TL_ALL = _flumy.TL_ALL
STEEP_UNKNOWN = _flumy.STEEP_UNKNOWN
STEEP_CUTOFF = _flumy.STEEP_CUTOFF
STEEP_OK = _flumy.STEEP_OK
STEEP_SELF_CUT = _flumy.STEEP_SELF_CUT
STEEP_UP_OR_DOWN = _flumy.STEEP_UP_OR_DOWN
STEEP_SHORT = _flumy.STEEP_SHORT
STEEP_TRAP = _flumy.STEEP_TRAP
STEEP_OUT_EXT = _flumy.STEEP_OUT_EXT
STEEP_MARGINS = _flumy.STEEP_MARGINS
STEEP_COMPLETE = _flumy.STEEP_COMPLETE
NO_DISTRIB = _flumy.NO_DISTRIB
FREE_DISTRIB = _flumy.FREE_DISTRIB
PREMIUM_DISTRIB = _flumy.PREMIUM_DISTRIB
RESEARCH_DISTRIB = _flumy.RESEARCH_DISTRIB
NO_DISTRIB_STR = _flumy.NO_DISTRIB_STR
FREE_DISTRIB_STR = _flumy.FREE_DISTRIB_STR
PREMIUM_DISTRIB_STR = _flumy.PREMIUM_DISTRIB_STR
RESEARCH_DISTRIB_STR = _flumy.RESEARCH_DISTRIB_STR
KEY_SIM_SEED = _flumy.KEY_SIM_SEED
KEY_SIM_TYPE = _flumy.KEY_SIM_TYPE
KEY_DOMAIN_OX = _flumy.KEY_DOMAIN_OX
KEY_DOMAIN_OY = _flumy.KEY_DOMAIN_OY
KEY_DOMAIN_NX = _flumy.KEY_DOMAIN_NX
KEY_DOMAIN_NY = _flumy.KEY_DOMAIN_NY
KEY_DOMAIN_DX = _flumy.KEY_DOMAIN_DX
KEY_DOMAIN_DY = _flumy.KEY_DOMAIN_DY
KEY_DOMAIN_GRID_DIR = _flumy.KEY_DOMAIN_GRID_DIR
KEY_DOMAIN_ZREF = _flumy.KEY_DOMAIN_ZREF
KEY_DOMAIN_SLOPE = _flumy.KEY_DOMAIN_SLOPE
KEY_CHNL_WIDTH = _flumy.KEY_CHNL_WIDTH
KEY_CHNL_MAX_DEPTH = _flumy.KEY_CHNL_MAX_DEPTH
KEY_CHNL_WAVELENGTH = _flumy.KEY_CHNL_WAVELENGTH
KEY_CHNL_MARGIN = _flumy.KEY_CHNL_MARGIN
KEY_CHNL_FLW_DIR = _flumy.KEY_CHNL_FLW_DIR
KEY_CHNL_SCALE_DIST = _flumy.KEY_CHNL_SCALE_DIST
KEY_CHNL_SCALE_CONST = _flumy.KEY_CHNL_SCALE_CONST
KEY_CHNL_SCALE_MIN = _flumy.KEY_CHNL_SCALE_MIN
KEY_CHNL_SCALE_MAX = _flumy.KEY_CHNL_SCALE_MAX
KEY_CHNL_SCALE_NORM_MEAN = _flumy.KEY_CHNL_SCALE_NORM_MEAN
KEY_CHNL_SCALE_NORM_STDEV = _flumy.KEY_CHNL_SCALE_NORM_STDEV
KEY_CHNL_SCALE_LOGNORM_MEAN = _flumy.KEY_CHNL_SCALE_LOGNORM_MEAN
KEY_CHNL_SCALE_LOGNORM_STDEV = _flumy.KEY_CHNL_SCALE_LOGNORM_STDEV
KEY_DYN_EMAP_ACTIVE = _flumy.KEY_DYN_EMAP_ACTIVE
KEY_EROD_COEF = _flumy.KEY_EROD_COEF
KEY_EROD_OFFSET = _flumy.KEY_EROD_OFFSET
KEY_ZUL_TYPE = _flumy.KEY_ZUL_TYPE
KEY_AV_LV_OB = _flumy.KEY_AV_LV_OB
KEY_AV_NO_SPLAY = _flumy.KEY_AV_NO_SPLAY
KEY_AV_LOC_FREQ = _flumy.KEY_AV_LOC_FREQ
KEY_AV_LOC_PERIOD = _flumy.KEY_AV_LOC_PERIOD
KEY_AV_LOC_POISSON = _flumy.KEY_AV_LOC_POISSON
KEY_AV_LOC_PROB1 = _flumy.KEY_AV_LOC_PROB1
KEY_AV_LOC_PROB2 = _flumy.KEY_AV_LOC_PROB2
KEY_AV_REG_FREQ = _flumy.KEY_AV_REG_FREQ
KEY_AV_REG_PERIOD = _flumy.KEY_AV_REG_PERIOD
KEY_AV_REG_POISSON = _flumy.KEY_AV_REG_POISSON
KEY_AG_TYPE = _flumy.KEY_AG_TYPE
KEY_AG_DRAP = _flumy.KEY_AG_DRAP
KEY_AG_EXP_DEC_THICK = _flumy.KEY_AG_EXP_DEC_THICK
KEY_AG_LV_WIDTH = _flumy.KEY_AG_LV_WIDTH
KEY_AG_RAND_LAMBDA = _flumy.KEY_AG_RAND_LAMBDA
KEY_AG_OB_FREQ = _flumy.KEY_AG_OB_FREQ
KEY_AG_OB_PERIOD = _flumy.KEY_AG_OB_PERIOD
KEY_AG_OB_POISSON = _flumy.KEY_AG_OB_POISSON
KEY_AG_OB_DIST = _flumy.KEY_AG_OB_DIST
KEY_AG_OB_CONST = _flumy.KEY_AG_OB_CONST
KEY_AG_OB_MIN = _flumy.KEY_AG_OB_MIN
KEY_AG_OB_MAX = _flumy.KEY_AG_OB_MAX
KEY_AG_OB_NORM_MEAN = _flumy.KEY_AG_OB_NORM_MEAN
KEY_AG_OB_NORM_STDEV = _flumy.KEY_AG_OB_NORM_STDEV
KEY_AG_OB_LOGNORM_MEAN = _flumy.KEY_AG_OB_LOGNORM_MEAN
KEY_AG_OB_LOGNORM_STDEV = _flumy.KEY_AG_OB_LOGNORM_STDEV
KEY_AG_OB_PEAT = _flumy.KEY_AG_OB_PEAT
KEY_AG_OB_PEL_DRAP_INT = _flumy.KEY_AG_OB_PEL_DRAP_INT
KEY_AG_EP_INIT_ELEV = _flumy.KEY_AG_EP_INIT_ELEV
KEY_AG_EP_FREQ = _flumy.KEY_AG_EP_FREQ
KEY_AG_EP_PERIOD = _flumy.KEY_AG_EP_PERIOD
KEY_AG_EP_POISSON = _flumy.KEY_AG_EP_POISSON
KEY_AG_EP_DIST = _flumy.KEY_AG_EP_DIST
KEY_AG_EP_CONST = _flumy.KEY_AG_EP_CONST
KEY_AG_EP_MIN = _flumy.KEY_AG_EP_MIN
KEY_AG_EP_MAX = _flumy.KEY_AG_EP_MAX
KEY_AG_EP_NORM_MEAN = _flumy.KEY_AG_EP_NORM_MEAN
KEY_AG_EP_NORM_STDEV = _flumy.KEY_AG_EP_NORM_STDEV
KEY_AG_EP_LOGNORM_MEAN = _flumy.KEY_AG_EP_LOGNORM_MEAN
KEY_AG_EP_LOGNORM_STDEV = _flumy.KEY_AG_EP_LOGNORM_STDEV
KEY_COND_WELL_RELAX = _flumy.KEY_COND_WELL_RELAX
KEY_COND_WELL_CLOSURE_ON = _flumy.KEY_COND_WELL_CLOSURE_ON
KEY_COND_WELL_STOP_HONORED = _flumy.KEY_COND_WELL_STOP_HONORED
KEY_COND_WELL_CLOSURE = _flumy.KEY_COND_WELL_CLOSURE
KEY_SED_LOAD_MEAN = _flumy.KEY_SED_LOAD_MEAN
KEY_SED_LOAD_VOL = _flumy.KEY_SED_LOAD_VOL
KEY_MASS_BAL_ACTIVE = _flumy.KEY_MASS_BAL_ACTIVE
KEY_MASS_BAL_COEF = _flumy.KEY_MASS_BAL_COEF
KEY_GR_QUICK_C0 = _flumy.KEY_GR_QUICK_C0
KEY_GR_THRESHOLD = _flumy.KEY_GR_THRESHOLD
KEY_GR_PB = _flumy.KEY_GR_PB
KEY_GR_PB_PROXY = _flumy.KEY_GR_PB_PROXY
KEY_GR_PB_OPTIM = _flumy.KEY_GR_PB_OPTIM
KEY_GR_PB_OPTIM_MIN = _flumy.KEY_GR_PB_OPTIM_MIN
KEY_GR_PB_OPTIM_MAX = _flumy.KEY_GR_PB_OPTIM_MAX
KEY_GR_PB_OPTIM_ALPHA = _flumy.KEY_GR_PB_OPTIM_ALPHA
DEF_SIM_SEED = _flumy.DEF_SIM_SEED
DEF_SIM_TYPE = _flumy.DEF_SIM_TYPE
DEF_DOMAIN_OX = _flumy.DEF_DOMAIN_OX
DEF_DOMAIN_OY = _flumy.DEF_DOMAIN_OY
DEF_DOMAIN_NX = _flumy.DEF_DOMAIN_NX
DEF_DOMAIN_NY = _flumy.DEF_DOMAIN_NY
DEF_DOMAIN_DX = _flumy.DEF_DOMAIN_DX
DEF_DOMAIN_DY = _flumy.DEF_DOMAIN_DY
DEF_DOMAIN_GRID_DIR = _flumy.DEF_DOMAIN_GRID_DIR
DEF_DOMAIN_ZREF = _flumy.DEF_DOMAIN_ZREF
DEF_DOMAIN_SLOPE = _flumy.DEF_DOMAIN_SLOPE
DEF_CHNL_WIDTH = _flumy.DEF_CHNL_WIDTH
DEF_CHNL_MAX_DEPTH = _flumy.DEF_CHNL_MAX_DEPTH
DEF_CHNL_WAVELENGTH = _flumy.DEF_CHNL_WAVELENGTH
DEF_CHNL_MARGIN = _flumy.DEF_CHNL_MARGIN
DEF_CHNL_FLW_DIR = _flumy.DEF_CHNL_FLW_DIR
DEF_CHNL_SCALE_CONST = _flumy.DEF_CHNL_SCALE_CONST
DEF_CHNL_SCALE_MIN = _flumy.DEF_CHNL_SCALE_MIN
DEF_CHNL_SCALE_MAX = _flumy.DEF_CHNL_SCALE_MAX
DEF_CHNL_SCALE_NORM_MEAN = _flumy.DEF_CHNL_SCALE_NORM_MEAN
DEF_CHNL_SCALE_NORM_STDEV = _flumy.DEF_CHNL_SCALE_NORM_STDEV
DEF_CHNL_SCALE_LOGNORM_MEAN = _flumy.DEF_CHNL_SCALE_LOGNORM_MEAN
DEF_CHNL_SCALE_LOGNORM_STDEV = _flumy.DEF_CHNL_SCALE_LOGNORM_STDEV
DEF_EROD_COEF = _flumy.DEF_EROD_COEF
DEF_EROD_OFFSET = _flumy.DEF_EROD_OFFSET
DEF_ZUL_TYPE = _flumy.DEF_ZUL_TYPE
DEF_AV_LV_OB = _flumy.DEF_AV_LV_OB
DEF_AV_NO_SPLAY = _flumy.DEF_AV_NO_SPLAY
DEF_AV_LOC_PERIOD = _flumy.DEF_AV_LOC_PERIOD
DEF_AV_LOC_POISSON = _flumy.DEF_AV_LOC_POISSON
DEF_AV_LOC_PROB1 = _flumy.DEF_AV_LOC_PROB1
DEF_AV_LOC_PROB2 = _flumy.DEF_AV_LOC_PROB2
DEF_AV_REG_PERIOD = _flumy.DEF_AV_REG_PERIOD
DEF_AV_REG_POISSON = _flumy.DEF_AV_REG_POISSON
DEF_AG_EXP_DEC_THICK = _flumy.DEF_AG_EXP_DEC_THICK
DEF_AG_LV_WIDTH = _flumy.DEF_AG_LV_WIDTH
DEF_AG_RAND_LAMBDA = _flumy.DEF_AG_RAND_LAMBDA
DEF_COND_WELL_RELAX = _flumy.DEF_COND_WELL_RELAX
DEF_COND_WELL_CLOSURE_ON = _flumy.DEF_COND_WELL_CLOSURE_ON
DEF_COND_WELL_STOP_HONORED = _flumy.DEF_COND_WELL_STOP_HONORED
DEF_COND_WELL_CLOSURE = _flumy.DEF_COND_WELL_CLOSURE
DEF_AG_EP_INIT_ELEV = _flumy.DEF_AG_EP_INIT_ELEV
DEF_AG_EP_PERIOD = _flumy.DEF_AG_EP_PERIOD
DEF_AG_EP_POISSON = _flumy.DEF_AG_EP_POISSON
DEF_AG_EP_CONST = _flumy.DEF_AG_EP_CONST
DEF_AG_EP_MIN = _flumy.DEF_AG_EP_MIN
DEF_AG_EP_MAX = _flumy.DEF_AG_EP_MAX
DEF_AG_EP_NORM_MEAN = _flumy.DEF_AG_EP_NORM_MEAN
DEF_AG_EP_NORM_STDEV = _flumy.DEF_AG_EP_NORM_STDEV
DEF_AG_EP_LOGNORM_MEAN = _flumy.DEF_AG_EP_LOGNORM_MEAN
DEF_AG_EP_LOGNORM_STDEV = _flumy.DEF_AG_EP_LOGNORM_STDEV
DEF_AG_OB_PEAT = _flumy.DEF_AG_OB_PEAT
DEF_AG_OB_PEL_DRAP_INT = _flumy.DEF_AG_OB_PEL_DRAP_INT
DEF_AG_OB_PERIOD = _flumy.DEF_AG_OB_PERIOD
DEF_AG_OB_POISSON = _flumy.DEF_AG_OB_POISSON
DEF_AG_OB_CONST = _flumy.DEF_AG_OB_CONST
DEF_AG_OB_MIN = _flumy.DEF_AG_OB_MIN
DEF_AG_OB_MAX = _flumy.DEF_AG_OB_MAX
DEF_AG_OB_NORM_MEAN = _flumy.DEF_AG_OB_NORM_MEAN
DEF_AG_OB_NORM_STDEV = _flumy.DEF_AG_OB_NORM_STDEV
DEF_AG_OB_LOGNORM_MEAN = _flumy.DEF_AG_OB_LOGNORM_MEAN
DEF_AG_OB_LOGNORM_STDEV = _flumy.DEF_AG_OB_LOGNORM_STDEV
DEF_SED_LOAD_MEAN = _flumy.DEF_SED_LOAD_MEAN
DEF_MASS_BAL_ACTIVE = _flumy.DEF_MASS_BAL_ACTIVE
DEF_MASS_BAL_COEF = _flumy.DEF_MASS_BAL_COEF
DEF_GR_QUICK_C0 = _flumy.DEF_GR_QUICK_C0
DEF_GR_THRESHOLD = _flumy.DEF_GR_THRESHOLD
DEF_GR_PB = _flumy.DEF_GR_PB
DEF_GR_PB_PROXY = _flumy.DEF_GR_PB_PROXY
DEF_GR_PB_OPTIM = _flumy.DEF_GR_PB_OPTIM
DEF_GR_PB_OPTIM_MIN = _flumy.DEF_GR_PB_OPTIM_MIN
DEF_GR_PB_OPTIM_MAX = _flumy.DEF_GR_PB_OPTIM_MAX
DEF_GR_PB_OPTIM_ALPHA = _flumy.DEF_GR_PB_OPTIM_ALPHA
DEF_TURBI_DOMAIN_NX = _flumy.DEF_TURBI_DOMAIN_NX
DEF_TURBI_DOMAIN_NY = _flumy.DEF_TURBI_DOMAIN_NY
DEF_TURBI_DOMAIN_DX = _flumy.DEF_TURBI_DOMAIN_DX
DEF_TURBI_DOMAIN_DY = _flumy.DEF_TURBI_DOMAIN_DY
DEF_TURBI_DOMAIN_SLOPE = _flumy.DEF_TURBI_DOMAIN_SLOPE
DEF_TURBI_CHNL_WIDTH = _flumy.DEF_TURBI_CHNL_WIDTH
DEF_TURBI_CHNL_WAVELENGTH = _flumy.DEF_TURBI_CHNL_WAVELENGTH
DEF_TURBI_CHNL_MAX_DEPTH = _flumy.DEF_TURBI_CHNL_MAX_DEPTH
DEF_TURBI_CHNL_MARGIN = _flumy.DEF_TURBI_CHNL_MARGIN
DEF_TURBI_EROD_COEF = _flumy.DEF_TURBI_EROD_COEF
DEF_TURBI_COND_WELL_CLOSURE = _flumy.DEF_TURBI_COND_WELL_CLOSURE
DEF_TURBI_AG_LV_WIDTH = _flumy.DEF_TURBI_AG_LV_WIDTH
DEF_TURBI_AG_EXP_DEC_THICK = _flumy.DEF_TURBI_AG_EXP_DEC_THICK
DEF_TURBI_AG_EP_PERIOD = _flumy.DEF_TURBI_AG_EP_PERIOD
DEF_TURBI_AG_EP_POISSON = _flumy.DEF_TURBI_AG_EP_POISSON
DEF_TURBI_AG_EP_CONST = _flumy.DEF_TURBI_AG_EP_CONST
DEF_TURBI_AG_EP_MIN = _flumy.DEF_TURBI_AG_EP_MIN
DEF_TURBI_AG_EP_MAX = _flumy.DEF_TURBI_AG_EP_MAX
DEF_TURBI_AG_EP_NORM_MEAN = _flumy.DEF_TURBI_AG_EP_NORM_MEAN
DEF_TURBI_AG_EP_NORM_STDEV = _flumy.DEF_TURBI_AG_EP_NORM_STDEV
DEF_TURBI_AG_EP_LOGNORM_MEAN = _flumy.DEF_TURBI_AG_EP_LOGNORM_MEAN
DEF_TURBI_AG_EP_LOGNORM_STDEV = _flumy.DEF_TURBI_AG_EP_LOGNORM_STDEV
DEF_TURBI_AG_OB_CONST = _flumy.DEF_TURBI_AG_OB_CONST
DEF_TURBI_AG_OB_MIN = _flumy.DEF_TURBI_AG_OB_MIN
DEF_TURBI_AG_OB_MAX = _flumy.DEF_TURBI_AG_OB_MAX
DEF_TURBI_AG_OB_NORM_MEAN = _flumy.DEF_TURBI_AG_OB_NORM_MEAN
DEF_TURBI_AG_OB_NORM_STDEV = _flumy.DEF_TURBI_AG_OB_NORM_STDEV
DEF_TURBI_AG_OB_LOGNORM_MEAN = _flumy.DEF_TURBI_AG_OB_LOGNORM_MEAN
DEF_TURBI_AG_OB_LOGNORM_STDEV = _flumy.DEF_TURBI_AG_OB_LOGNORM_STDEV
DEF_TURBI_AG_OB_PERIOD = _flumy.DEF_TURBI_AG_OB_PERIOD
DEF_TURBI_AG_OB_POISSON = _flumy.DEF_TURBI_AG_OB_POISSON
DEF_TURBI_AV_LOC_PERIOD = _flumy.DEF_TURBI_AV_LOC_PERIOD
DEF_TURBI_AV_LOC_POISSON = _flumy.DEF_TURBI_AV_LOC_POISSON
DEF_TURBI_AV_REG_PERIOD = _flumy.DEF_TURBI_AV_REG_PERIOD
DEF_TURBI_AV_REG_POISSON = _flumy.DEF_TURBI_AV_REG_POISSON
DEF_TURBI_SED_LOAD_MEAN = _flumy.DEF_TURBI_SED_LOAD_MEAN
DEF_TURBI_MASS_BAL_COEF = _flumy.DEF_TURBI_MASS_BAL_COEF
MIN_SIM_SEED = _flumy.MIN_SIM_SEED
MIN_DOMAIN_NX = _flumy.MIN_DOMAIN_NX
MIN_DOMAIN_NY = _flumy.MIN_DOMAIN_NY
MAX_DOMAIN_NX = _flumy.MAX_DOMAIN_NX
MAX_DOMAIN_NY = _flumy.MAX_DOMAIN_NY
MIN_DOMAIN_DX = _flumy.MIN_DOMAIN_DX
MIN_DOMAIN_DY = _flumy.MIN_DOMAIN_DY
MIN_DOMAIN_GRID_DIR = _flumy.MIN_DOMAIN_GRID_DIR
MAX_DOMAIN_GRID_DIR = _flumy.MAX_DOMAIN_GRID_DIR
MIN_DOMAIN_SLOPE = _flumy.MIN_DOMAIN_SLOPE
MAX_DOMAIN_SLOPE = _flumy.MAX_DOMAIN_SLOPE
MIN_CHNL_WIDTH = _flumy.MIN_CHNL_WIDTH
MAX_CHNL_WIDTH = _flumy.MAX_CHNL_WIDTH
MIN_CHNL_WAVELENGTH = _flumy.MIN_CHNL_WAVELENGTH
MAX_CHNL_WAVELENGTH = _flumy.MAX_CHNL_WAVELENGTH
MIN_CHNL_MAX_DEPTH = _flumy.MIN_CHNL_MAX_DEPTH
MAX_CHNL_MAX_DEPTH = _flumy.MAX_CHNL_MAX_DEPTH
MIN_CHNL_MARGIN = _flumy.MIN_CHNL_MARGIN
MAX_CHNL_MARGIN = _flumy.MAX_CHNL_MARGIN
MIN_CHNL_FLW_DIR = _flumy.MIN_CHNL_FLW_DIR
MAX_CHNL_FLW_DIR = _flumy.MAX_CHNL_FLW_DIR
MIN_CHNL_SCALE_CONST = _flumy.MIN_CHNL_SCALE_CONST
MAX_CHNL_SCALE_CONST = _flumy.MAX_CHNL_SCALE_CONST
MIN_CHNL_SCALE_MIN = _flumy.MIN_CHNL_SCALE_MIN
MAX_CHNL_SCALE_MIN = _flumy.MAX_CHNL_SCALE_MIN
MIN_CHNL_SCALE_MAX = _flumy.MIN_CHNL_SCALE_MAX
MAX_CHNL_SCALE_MAX = _flumy.MAX_CHNL_SCALE_MAX
MIN_CHNL_SCALE_NORM_MEAN = _flumy.MIN_CHNL_SCALE_NORM_MEAN
MAX_CHNL_SCALE_NORM_MEAN = _flumy.MAX_CHNL_SCALE_NORM_MEAN
MIN_CHNL_SCALE_NORM_STDEV = _flumy.MIN_CHNL_SCALE_NORM_STDEV
MAX_CHNL_SCALE_NORM_STDEV = _flumy.MAX_CHNL_SCALE_NORM_STDEV
MIN_CHNL_SCALE_LOGNORM_MEAN = _flumy.MIN_CHNL_SCALE_LOGNORM_MEAN
MAX_CHNL_SCALE_LOGNORM_MEAN = _flumy.MAX_CHNL_SCALE_LOGNORM_MEAN
MIN_CHNL_SCALE_LOGNORM_STDEV = _flumy.MIN_CHNL_SCALE_LOGNORM_STDEV
MAX_CHNL_SCALE_LOGNORM_STDEV = _flumy.MAX_CHNL_SCALE_LOGNORM_STDEV
MIN_EROD_COEF = _flumy.MIN_EROD_COEF
MAX_EROD_COEF = _flumy.MAX_EROD_COEF
MIN_AV_LOC_PERIOD = _flumy.MIN_AV_LOC_PERIOD
MIN_AV_LOC_POISSON = _flumy.MIN_AV_LOC_POISSON
MIN_AV_LOC_PROB1 = _flumy.MIN_AV_LOC_PROB1
MAX_AV_LOC_PROB1 = _flumy.MAX_AV_LOC_PROB1
MIN_AV_LOC_PROB2 = _flumy.MIN_AV_LOC_PROB2
MAX_AV_LOC_PROB2 = _flumy.MAX_AV_LOC_PROB2
MIN_AV_REG_PERIOD = _flumy.MIN_AV_REG_PERIOD
MIN_AV_REG_POISSON = _flumy.MIN_AV_REG_POISSON
MIN_AG_EXP_DEC_THICK = _flumy.MIN_AG_EXP_DEC_THICK
MIN_AG_LV_WIDTH = _flumy.MIN_AG_LV_WIDTH
MIN_COND_WELL_RELAX = _flumy.MIN_COND_WELL_RELAX
MAX_COND_WELL_RELAX = _flumy.MAX_COND_WELL_RELAX
MIN_COND_WELL_CLOSURE = _flumy.MIN_COND_WELL_CLOSURE
MAX_COND_WELL_CLOSURE = _flumy.MAX_COND_WELL_CLOSURE
MIN_AG_EP_PERIOD = _flumy.MIN_AG_EP_PERIOD
MIN_AG_EP_POISSON = _flumy.MIN_AG_EP_POISSON
MIN_AG_EP_CONST = _flumy.MIN_AG_EP_CONST
MIN_AG_EP_MIN = _flumy.MIN_AG_EP_MIN
MIN_AG_EP_MAX = _flumy.MIN_AG_EP_MAX
MIN_AG_EP_NORM_MEAN = _flumy.MIN_AG_EP_NORM_MEAN
MIN_AG_EP_NORM_STDEV = _flumy.MIN_AG_EP_NORM_STDEV
MIN_AG_EP_LOGNORM_MEAN = _flumy.MIN_AG_EP_LOGNORM_MEAN
MIN_AG_EP_LOGNORM_STDEV = _flumy.MIN_AG_EP_LOGNORM_STDEV
MIN_AG_OB_PEAT = _flumy.MIN_AG_OB_PEAT
MAX_AG_OB_PEAT = _flumy.MAX_AG_OB_PEAT
MIN_AG_OB_PEL_DRAP_INT = _flumy.MIN_AG_OB_PEL_DRAP_INT
MAX_AG_OB_PEL_DRAP_INT = _flumy.MAX_AG_OB_PEL_DRAP_INT
MIN_AG_OB_PERIOD = _flumy.MIN_AG_OB_PERIOD
MIN_AG_OB_POISSON = _flumy.MIN_AG_OB_POISSON
MIN_AG_OB_CONST = _flumy.MIN_AG_OB_CONST
MIN_AG_OB_MIN = _flumy.MIN_AG_OB_MIN
MIN_AG_OB_MAX = _flumy.MIN_AG_OB_MAX
MIN_AG_OB_NORM_MEAN = _flumy.MIN_AG_OB_NORM_MEAN
MIN_AG_OB_NORM_STDEV = _flumy.MIN_AG_OB_NORM_STDEV
MIN_AG_OB_LOGNORM_MEAN = _flumy.MIN_AG_OB_LOGNORM_MEAN
MIN_AG_OB_LOGNORM_STDEV = _flumy.MIN_AG_OB_LOGNORM_STDEV
MIN_SED_LOAD_MEAN = _flumy.MIN_SED_LOAD_MEAN
MAX_SED_LOAD_MEAN = _flumy.MAX_SED_LOAD_MEAN
MIN_SED_LOAD_VOL = _flumy.MIN_SED_LOAD_VOL
MAX_SED_LOAD_VOL = _flumy.MAX_SED_LOAD_VOL
MIN_GR_THRESHOLD = _flumy.MIN_GR_THRESHOLD
MAX_GR_THRESHOLD = _flumy.MAX_GR_THRESHOLD
MIN_GR_PB_OPTIM_MIN = _flumy.MIN_GR_PB_OPTIM_MIN
MAX_GR_PB_OPTIM_MIN = _flumy.MAX_GR_PB_OPTIM_MIN
MIN_GR_PB_OPTIM_MAX = _flumy.MIN_GR_PB_OPTIM_MAX
MAX_GR_PB_OPTIM_MAX = _flumy.MAX_GR_PB_OPTIM_MAX
MIN_GR_PB_OPTIM_ALPHA = _flumy.MIN_GR_PB_OPTIM_ALPHA
MAX_GR_PB_OPTIM_ALPHA = _flumy.MAX_GR_PB_OPTIM_ALPHA
MIN_MASS_BAL_COEF = _flumy.MIN_MASS_BAL_COEF
MAX_TURBI_DOMAIN_SLOPE = _flumy.MAX_TURBI_DOMAIN_SLOPE
MIN_TURBI_CHNL_WIDTH = _flumy.MIN_TURBI_CHNL_WIDTH
MAX_TURBI_CHNL_WIDTH = _flumy.MAX_TURBI_CHNL_WIDTH
MIN_TURBI_CHNL_WAVELENGTH = _flumy.MIN_TURBI_CHNL_WAVELENGTH
MAX_TURBI_CHNL_WAVELENGTH = _flumy.MAX_TURBI_CHNL_WAVELENGTH
MIN_TURBI_CHNL_MAX_DEPTH = _flumy.MIN_TURBI_CHNL_MAX_DEPTH
MAX_TURBI_CHNL_MAX_DEPTH = _flumy.MAX_TURBI_CHNL_MAX_DEPTH
MIN_TURBI_COND_WELL_CLOSURE = _flumy.MIN_TURBI_COND_WELL_CLOSURE
MAX_TURBI_COND_WELL_CLOSURE = _flumy.MAX_TURBI_COND_WELL_CLOSURE
MIN_TURBI_AG_EXP_DEC_THICK = _flumy.MIN_TURBI_AG_EXP_DEC_THICK
MIN_NEXUS_ISBX = _flumy.MIN_NEXUS_ISBX
MAX_NEXUS_ISBX = _flumy.MAX_NEXUS_ISBX
MIN_NEXUS_NG = _flumy.MIN_NEXUS_NG
MAX_NEXUS_NG = _flumy.MAX_NEXUS_NG
class iDomain(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _flumy.delete_iDomain

    def getSlope(self):
        return _flumy.iDomain_getSlope(self)

    def getSlopeAlongX(self):
        return _flumy.iDomain_getSlopeAlongX(self)

    def getSlopeAlongY(self):
        return _flumy.iDomain_getSlopeAlongY(self)

    def getZref(self):
        return _flumy.iDomain_getZref(self)

    def getRotGrid(self):
        return _flumy.iDomain_getRotGrid(self)

    def getRotFlow(self):
        return _flumy.iDomain_getRotFlow(self)

    def getErodMax(self):
        return _flumy.iDomain_getErodMax(self)

    def getOldestAge(self):
        return _flumy.iDomain_getOldestAge(self)

    def getZMaxGeo(self):
        return _flumy.iDomain_getZMaxGeo(self)

    def getZMinGeo(self):
        return _flumy.iDomain_getZMinGeo(self)

    def getZMaxRel(self):
        return _flumy.iDomain_getZMaxRel(self)

    def getZMinRel(self):
        return _flumy.iDomain_getZMinRel(self)

    def getMeshX(self):
        return _flumy.iDomain_getMeshX(self)

    def getMeshY(self):
        return _flumy.iDomain_getMeshY(self)

    def getNbNodeX(self):
        return _flumy.iDomain_getNbNodeX(self)

    def getNbNodeY(self):
        return _flumy.iDomain_getNbNodeY(self)

    def getGrid(self):
        return _flumy.iDomain_getGrid(self)

    def getMeanTopoGeo(self, with_water_depth=True):
        return _flumy.iDomain_getMeanTopoGeo(self, with_water_depth)

    def getProportionFull(self, fac, zmin=1.e30, zmax=1.e30):
        return _flumy.iDomain_getProportionFull(self, fac, zmin, zmax)

    def getProportion(self, fac, ix_min, ix_max, iy_min, iy_max, zmin=1.e30, zmax=1.e30):
        return _flumy.iDomain_getProportion(self, fac, ix_min, ix_max, iy_min, iy_max, zmin, zmax)

    def getGeoPointFromGrid(self, ix, iy):
        return _flumy.iDomain_getGeoPointFromGrid(self, ix, iy)

    def getGeoPointFromRel(self, relPoint):
        return _flumy.iDomain_getGeoPointFromRel(self, relPoint)

    def getRelPointFromGeo(self, geoPoint):
        return _flumy.iDomain_getRelPointFromGeo(self, geoPoint)

    def getRelPointFromGrid(self, ix, iy):
        return _flumy.iDomain_getRelPointFromGrid(self, ix, iy)

    def getGridPointFromRel(self, relPoint):
        return _flumy.iDomain_getGridPointFromRel(self, relPoint)

    def getGridPointFromGeo(self, geoPoint):
        return _flumy.iDomain_getGridPointFromGeo(self, geoPoint)

    def isValid(self, ix, iy):
        return _flumy.iDomain_isValid(self, ix, iy)

    def getAllThickness(self):
        return _flumy.iDomain_getAllThickness(self)

    def getAllFacies(self):
        return _flumy.iDomain_getAllFacies(self)

    def getAllGrainsize(self):
        return _flumy.iDomain_getAllGrainsize(self)

    def getAllGrainsizeClass(self):
        return _flumy.iDomain_getAllGrainsizeClass(self)

    def getAllAge(self):
        return _flumy.iDomain_getAllAge(self)

    def getRegularPile(self, ix, iy, dz, facies, ages=None, grain=None, minz=None, nbz=None):
        return _flumy.iDomain_getRegularPile(self, ix, iy, dz, facies, ages, grain, minz, nbz)

    def getRegular(self, ix_min, ix_max, iy_min, iy_max, dz, facies, ages=None, granulo=None, minz=None, nbz=None):
        return _flumy.iDomain_getRegular(self, ix_min, ix_max, iy_min, iy_max, dz, facies, ages, granulo, minz, nbz)

    def getRegularFacies(self, dz, minz, nbz):
        return _flumy.iDomain_getRegularFacies(self, dz, minz, nbz)

    def getRegularGrain(self, dz, minz, nbz):
        return _flumy.iDomain_getRegularGrain(self, dz, minz, nbz)

    def getRegularAge(self, dz, minz, nbz):
        return _flumy.iDomain_getRegularAge(self, dz, minz, nbz)

    def getTopo(self, topo, with_water=True, age_limit=2147483647):
        return _flumy.iDomain_getTopo(self, topo, with_water, age_limit)

    def saveF2G(self, *args, **kwargs):
        return _flumy.iDomain_saveF2G(self, *args, **kwargs)

    def getCondStats(self):
        return _flumy.iDomain_getCondStats(self)

    def getCenterlineDisc(self, cldisc, ch):
        return _flumy.iDomain_getCenterlineDisc(self, cldisc, ch)

# Register iDomain in _flumy:
_flumy.iDomain_swigregister(iDomain)
class Point2D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _flumy.Point2D_swiginit(self, _flumy.new_Point2D(*args))
    __swig_destroy__ = _flumy.delete_Point2D

    def distance(self, arg2):
        return _flumy.Point2D_distance(self, arg2)

    def transform(self, translate, dilate, do_round=False):
        return _flumy.Point2D_transform(self, translate, dilate, do_round)

    def scalar(self, arg2):
        return _flumy.Point2D_scalar(self, arg2)

    def vectorial(self, arg2):
        return _flumy.Point2D_vectorial(self, arg2)

    def reset(self, x=0., y=0.):
        return _flumy.Point2D_reset(self, x, y)

    def rotate_half_pi(self):
        return _flumy.Point2D_rotate_half_pi(self)

    def rotate_pi(self):
        return _flumy.Point2D_rotate_pi(self)

    def rotate(self, *args):
        return _flumy.Point2D_rotate(self, *args)

    def rotate_inv(self, *args):
        return _flumy.Point2D_rotate_inv(self, *args)

    def __iadd__(self, arg2):
        return _flumy.Point2D___iadd__(self, arg2)

    def __isub__(self, arg2):
        return _flumy.Point2D___isub__(self, arg2)

    def __imul__(self, arg2):
        return _flumy.Point2D___imul__(self, arg2)

    def __itruediv__(self, *args):
        return _flumy.Point2D___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __eq__(self, arg2):
        return _flumy.Point2D___eq__(self, arg2)

    def __ne__(self, arg2):
        return _flumy.Point2D___ne__(self, arg2)

    def get_abscissa(self):
        return _flumy.Point2D_get_abscissa(self)

    def set_abscissa(self, x):
        return _flumy.Point2D_set_abscissa(self, x)

    def get_ordinate(self):
        return _flumy.Point2D_get_ordinate(self)

    def set_ordinate(self, y):
        return _flumy.Point2D_set_ordinate(self, y)

    def debug(self):
        return _flumy.Point2D_debug(self)

# Register Point2D in _flumy:
_flumy.Point2D_swigregister(Point2D)

def sqnorm(arg1):
    return _flumy.sqnorm(arg1)

def lgth(arg1):
    return _flumy.lgth(arg1)

def arc_tan(arg1):
    return _flumy.arc_tan(arg1)

class GridParams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _flumy.GridParams_swiginit(self, _flumy.new_GridParams(*args))
    __swig_destroy__ = _flumy.delete_GridParams

    def clear(self):
        return _flumy.GridParams_clear(self)

    def reset(self, *args):
        return _flumy.GridParams_reset(self, *args)

    def getDx(self):
        return _flumy.GridParams_getDx(self)

    def getDy(self):
        return _flumy.GridParams_getDy(self)

    def getDz(self):
        return _flumy.GridParams_getDz(self)

    def getNx(self):
        return _flumy.GridParams_getNx(self)

    def getNy(self):
        return _flumy.GridParams_getNy(self)

    def getNz(self):
        return _flumy.GridParams_getNz(self)

    def getOx(self):
        return _flumy.GridParams_getOx(self)

    def getOy(self):
        return _flumy.GridParams_getOy(self)

    def getOz(self):
        return _flumy.GridParams_getOz(self)

    def getOrigin(self):
        return _flumy.GridParams_getOrigin(self)

    def getNbNodes(self):
        return _flumy.GridParams_getNbNodes(self)

    def getApexRel(self, p1, p2, p3, p4):
        return _flumy.GridParams_getApexRel(self, p1, p2, p3, p4)

    def setLocation(self, *args):
        return _flumy.GridParams_setLocation(self, *args)

    def getLocation(self):
        return _flumy.GridParams_getLocation(self)

    def getZLoc(self):
        return _flumy.GridParams_getZLoc(self)

    def convertTo2D(self):
        return _flumy.GridParams_convertTo2D(self)

    def setRotation(self, rot):
        return _flumy.GridParams_setRotation(self, rot)

    def getRotation(self):
        return _flumy.GridParams_getRotation(self)

    def getLength(self):
        return _flumy.GridParams_getLength(self)

    def getWidth(self):
        return _flumy.GridParams_getWidth(self)

    def getHeight(self):
        return _flumy.GridParams_getHeight(self)

    def is3D(self):
        return _flumy.GridParams_is3D(self)

    def isCompatibleWith(self, grid, check_geo=False, check_3D=True):
        return _flumy.GridParams_isCompatibleWith(self, grid, check_geo, check_3D)

    def rel2Geo(self, point):
        return _flumy.GridParams_rel2Geo(self, point)

    def geo2Rel(self, point):
        return _flumy.GridParams_geo2Rel(self, point)

    def geo2Grid(self, point, round=True):
        return _flumy.GridParams_geo2Grid(self, point, round)

    def grid2Geo(self, ix, iy):
        return _flumy.GridParams_grid2Geo(self, ix, iy)

    def rel2Grid(self, *args):
        return _flumy.GridParams_rel2Grid(self, *args)

    def grid2Rel(self, *args):
        return _flumy.GridParams_grid2Rel(self, *args)

    def is_on_grid(self, point):
        return _flumy.GridParams_is_on_grid(self, point)

    def is_on_grid_nearest(self, point):
        return _flumy.GridParams_is_on_grid_nearest(self, point)

# Register GridParams in _flumy:
_flumy.GridParams_swigregister(GridParams)
GFF_UNDEFINED = _flumy.GFF_UNDEFINED
GFF_ERROR = _flumy.GFF_ERROR
GFF_F2G = _flumy.GFF_F2G
GFF_GSLIB = _flumy.GFF_GSLIB
GFF_CPS3 = _flumy.GFF_CPS3
GFF_GRDECL = _flumy.GFF_GRDECL
class GridReal(GridParams):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _flumy.GridReal_swiginit(self, _flumy.new_GridReal(*args))
    __swig_destroy__ = _flumy.delete_GridReal

    def clear(self):
        return _flumy.GridReal_clear(self)

    def reset(self, *args):
        return _flumy.GridReal_reset(self, *args)

    def check(self, val, correct=True):
        return _flumy.GridReal_check(self, val, correct)

    def fill(self, val):
        return _flumy.GridReal_fill(self, val)

    def fill_2D(self, values):
        return _flumy.GridReal_fill_2D(self, values)

    def fill_yxz(self, size, values):
        return _flumy.GridReal_fill_yxz(self, size, values)

    def fill_zyx(self, size, values):
        return _flumy.GridReal_fill_zyx(self, size, values)

    def add(self, value):
        return _flumy.GridReal_add(self, value)

    def migrate(self, grid, strict=True, verbose=True, tracer=None):
        return _flumy.GridReal_migrate(self, grid, strict, verbose, tracer)

    def set_at(self, *args):
        return _flumy.GridReal_set_at(self, *args)

    def get_at(self, *args):
        return _flumy.GridReal_get_at(self, *args)

    def write(self, *args, **kwargs):
        return _flumy.GridReal_write(self, *args, **kwargs)

    def read(self, filename):
        return _flumy.GridReal_read(self, filename)

    def get_values(self):
        return _flumy.GridReal_get_values(self)

    def get_values_zyx(self):
        return _flumy.GridReal_get_values_zyx(self)

    def has_values(self):
        return _flumy.GridReal_has_values(self)

    def get_mean(self):
        return _flumy.GridReal_get_mean(self)

    def get_min(self, *args):
        return _flumy.GridReal_get_min(self, *args)

    def get_max(self, *args):
        return _flumy.GridReal_get_max(self, *args)

    def get_nb_positive(self):
        return _flumy.GridReal_get_nb_positive(self)

    def get_nb_negative(self):
        return _flumy.GridReal_get_nb_negative(self)

    def add_variable(self, aux):
        return _flumy.GridReal_add_variable(self, aux)

    def set_name(self, name):
        return _flumy.GridReal_set_name(self, name)

    def get_name(self):
        return _flumy.GridReal_get_name(self)

    def set_undef_string(self, undef):
        return _flumy.GridReal_set_undef_string(self, undef)

    def get_undef_string(self):
        return _flumy.GridReal_get_undef_string(self)

    def set_undef_value(self, undef):
        return _flumy.GridReal_set_undef_value(self, undef)

    def get_undef_value(self):
        return _flumy.GridReal_get_undef_value(self)

    @staticmethod
    def is_order_valid(*args):
        return _flumy.GridReal_is_order_valid(*args)

    @staticmethod
    def get_format(filename):
        return _flumy.GridReal_get_format(filename)

    @staticmethod
    def get_format_label(format):
        return _flumy.GridReal_get_format_label(format)

    def last_error(self):
        return _flumy.GridReal_last_error(self)

# Register GridReal in _flumy:
_flumy.GridReal_swigregister(GridReal)
class Topo(GridReal):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _flumy.Topo_swiginit(self, _flumy.new_Topo(*args))
    __swig_destroy__ = _flumy.delete_Topo

    def shift_down(self, topo):
        return _flumy.Topo_shift_down(self, topo)

    def shift_up(self, topo):
        return _flumy.Topo_shift_up(self, topo)

# Register Topo in _flumy:
_flumy.Topo_swigregister(Topo)


import numpy as np
import matplotlib.colors as mcol
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from collections import Counter

# Facies definition
# TODO : redundant with MCRCDefines.h
#TODO : use the following dictionary?
#fac_dic = [{'id':  0, 'color': [0.60, 0.60, 0.90, 1.00], 'brief': "UDF" , 'label': "Undefined"},
#           {'id':  1, 'color': [1.00, 0.50, 0.00, 1.00], 'brief': "CL"  , 'label': "Channel Lag"},
#           {'id':  2, 'color': [1.00, 1.00, 0.00, 1.00], 'brief': "PB"  , 'label': "Point Bar / LAPs"},
#           {'id':  3, 'color': [0.75, 0.75, 0.55, 1.00], 'brief': "SP"  , 'label': "Sand Plug"},
#           {'id':  4, 'color': [0.80, 0.50, 0.20, 1.00], 'brief': "CSI" , 'label': "Crevasse Splay I"},
#           {'id':  5, 'color': [0.80, 1.00, 0.20, 1.00], 'brief': "CCh" , 'label': "Splay II Channels"},
#           {'id':  6, 'color': [0.80, 0.80, 0.20, 1.00], 'brief': "CSII", 'label': "Crevasse Splay II"},
#           {'id':  7, 'color': [0.40, 0.80, 0.20, 1.00], 'brief': "LV"  , 'label': "Levee"},
#           {'id':  8, 'color': [0.00, 1.00, 0.00, 1.00], 'brief': "OB"  , 'label': "Overbank"},
#           {'id':  9, 'color': [0.00, 0.80, 0.50, 1.00], 'brief': "MP"  , 'label': "Mud Plug"},
#           {'id': 10, 'color': [0.50, 0.50, 0.50, 1.00], 'brief': "HP"  , 'label': "Hemipelagic Plug"},
#           {'id': 11, 'color': [0.85, 0.45, 0.85, 1.00], 'brief': "WL"  , 'label': "Wetland"},
#           {'id': 12, 'color': [0.60, 0.80, 0.90, 1.00], 'brief': "DR"  , 'label': "Draping"},
#           {'id': 13, 'color': [1.00, 0.80, 1.00, 1.00], 'brief': "PL"  , 'label': "Pelagic"}]

# Facies colors, identifiers and labels
fac_col = [[0.60, 0.60, 0.90, 1.00], # Undefined (UDF)
           [1.00, 0.50, 0.00, 1.00], # Channel Lag (CL)
           [1.00, 1.00, 0.00, 1.00], # Point Bar / LAPs (PB)
           [0.75, 0.75, 0.55, 1.00], # Sand Plug (SP)
           [0.80, 0.50, 0.20, 1.00], # Crevasse Splay I (CSI)
           [0.80, 1.00, 0.20, 1.00], # Splay II Channels (CCh)
           [0.80, 0.80, 0.20, 1.00], # Crevasse Splay II (CSII)
           [0.40, 0.80, 0.20, 1.00], # Levee (LV)
           [0.00, 1.00, 0.00, 1.00], # Overbank (OB)
           [0.00, 0.80, 0.50, 1.00], # Mud Plug (MP)
           [0.50, 0.50, 0.50, 1.00], # Hemipelagic Plug (HP)
           [0.85, 0.45, 0.85, 1.00], # Wetland (WL)
           [0.60, 0.80, 0.90, 1.00], # Draping (DR)
           [1.00, 0.80, 1.00, 1.00]] # Pelagic (PL)

fac_lab = ["UDF", "CL", "PB", "SP", "CSI", "CCh", "CSII", "LV", "OB", "MP", "HP", "WL", "DR", "PL"]

fac_id = np.arange(len(fac_lab))

# Grain size definition

# TODO : use official definition from MCRCDefines.h 
#TODO : or the following dictionary:
#gr_dic = [{'id':  0, 'value': 0.0625, 'color': [0.60, 0.60, 0.90, 1.00],'label': "Undefined"},
#          {'id':  1, 'value': 0.1250, 'color': [0.47, 0.71, 0.20, 1.00],'label': "Clay (11-14)"},
#          {'id':  2, 'value': 0.1875, 'color': [0.59, 0.75, 0.22, 1.00],'label': "Clay (9-10)"},
#          {'id':  3, 'value': 0.2500, 'color': [0.69, 0.80, 0.26, 1.00],'label': "Clay (8)"},
#          {'id':  4, 'value': 0.3125, 'color': [0.78, 0.84, 0.30, 1.00],'label': "Silt (7)"},
#          {'id':  5, 'value': 0.3750, 'color': [0.85, 0.86, 0.33, 1.00],'label': "Silt (6)"},
#          {'id':  6, 'value': 0.4375, 'color': [0.91, 0.89, 0.34, 1.00],'label': "Silt (5)"},
#          {'id':  7, 'value': 0.5000, 'color': [0.93, 0.88, 0.29, 1.00],'label': "Silt (4)"},
#          {'id':  8, 'value': 0.5625, 'color': [0.94, 0.88, 0.24, 1.00],'label': "Very Fine Sand (3)"},
#          {'id':  9, 'value': 0.6250, 'color': [0.97, 0.87, 0.12, 1.00],'label': "Fine Sand (2)"},
#          {'id': 10, 'value': 0.6875, 'color': [1.00, 0.84, 0.05, 1.00],'label': "Medium Sand (1)"},
#          {'id': 11, 'value': 0.7500, 'color': [0.97, 0.69, 0.05, 1.00],'label': "Coarse Sand (0)"},
#          {'id': 12, 'value': 0.8125, 'color': [0.94, 0.54, 0.04, 1.00],'label': "Very Coarse Sand (-1)"},
#          {'id': 13, 'value': 0.8750, 'color': [0.93, 0.44, 0.05, 1.00],'label': "Gravel (-2)"},
#          {'id': 14, 'value': 0.9375, 'color': [0.91, 0.32, 0.08, 1.00],'label': "Pebble (-3,-5)"},
#          {'id': 15, 'value': 1.0000, 'color': [0.90, 0.22, 0.09, 1.00],'label': "Cobble (-6,-8)"}]

gr_col = [[0.60, 0.60, 0.90, 1.00],
          [0.47, 0.71, 0.20, 1.00],
          [0.59, 0.75, 0.22, 1.00],
          [0.69, 0.80, 0.26, 1.00],
          [0.78, 0.84, 0.30, 1.00],
          [0.85, 0.86, 0.33, 1.00],
          [0.91, 0.89, 0.34, 1.00],
          [0.93, 0.88, 0.29, 1.00],
          [0.94, 0.88, 0.24, 1.00],
          [0.97, 0.87, 0.12, 1.00],
          [1.00, 0.84, 0.05, 1.00],
          [0.97, 0.69, 0.05, 1.00],
          [0.94, 0.54, 0.04, 1.00],
          [0.93, 0.44, 0.05, 1.00],
          [0.91, 0.32, 0.08, 1.00],
          [0.90, 0.22, 0.09, 1.00]]

gr_lab = [" 0 - Undefined",
          " 1 - Clay (11-14)", 
          " 2 - Clay (9-10)", 
          " 3 - Clay (8)",
          " 4 - Silt (7)",
          " 5 - Silt (6)",
          " 6 - Silt (5)",
          " 7 - Silt (4)",
          " 8 - Very Fine Sand (3)",
          " 9 - Fine Sand (2)",
          "10 - Medium Sand (1)",
          "11 - Coarse Sand (0)",
          "12 - Very Coarse Sand (-1)",
          "13 - Gravel (-2)",
          "14 - Pebble (-3,-5)",
          "15 - Cobble (-6,-8)"]

gr_nclass = MD_NB_CLASS_GR+1

gr_val = np.linspace(1/gr_nclass,1,gr_nclass)

def granulo_to_class(gr) :
  return np.asarray(np.floor(gr * MD_NB_CLASS_GR), dtype=int)

def getTopo(self, age=None):
  """
  Retrieve a 2D numpy array containing the topography a Flumy simulation.
  This method returns three 2D numpy arrays:
  - fac: Flumy facies identifiers
  - grain: Grain size (0: fine sediment, 1: coarse sediment)
  - age: Age of the deposit (iteration number = year)
  Values are ordered +Y +X (y-index increases faster, x-index increases slower)

  z: Horizontal slice elevation
  """

# Default age (top topography)
  if (age is None):
    age = MP_UNKNOWN_INT_VALUE

# Get the domain size
  dom = self.getDomain()
  nx = dom.getNbNodeX()
  ny = dom.getNbNodeY()

# Get the topography
  topo = Topo()
  if (not dom.getTopo(topo, True, age)): # include water
    print("Error while getting topography")
    return np.array(0)
  topo_arr = np.asarray(topo.get_values()).reshape(ny,nx) # Column first
  return topo_arr

def getSlice(self, z):
  """
  Retrieve an horizontal 2D slice of a Flumy simulation at a given elevation.
  This method returns three 2D numpy arrays:
  - fac: Flumy facies identifiers
  - grain: Grain size (0: fine sediment, 1: coarse sediment)
  - age: Age of the deposit (iteration number)
  Values are ordered +Y +X (y-index increases faster, x-index increases slower)

  z: Horizontal slice elevation

  Slice elevation must take into account initial grid elevation Zref
  and flattening surface (if used).
  """
# Get the domain size
  dom = self.getDomain()
  nx = dom.getNbNodeX()
  ny = dom.getNbNodeY()

# Get a slice
  fac = dom.getRegularFacies(dz=0.01, minz=z, nbz=1)
  fac_arr = np.asarray(fac).reshape(nx,ny)
  grain = dom.getRegularGrain(dz=0.01, minz=z, nbz=1)
  grain_arr = np.asarray(grain).reshape(nx,ny)
  age = dom.getRegularAge(dz=0.01, minz=z, nbz=1)
  age_arr = np.asarray(age).reshape(nx,ny)
  return fac_arr, grain_arr, age_arr


def getBlock(self, dz, zb=None, zt=None, nz=None):
  """
  Retrieve the 3D block of a Flumy simulation.
  The sediment volume is vertically discretized using given arguments.
  This method returns three 3D numpy arrays:
  - fac: Flumy facies identifiers
  - grain: Grain size (0: undefined, 0+: fine sediment, 1: coarse sediment)
  - age: Age of the deposit (iteration number = year)
  Values are ordered +Z +Y +X (z-index increases faster, x-index increases slower)

  dz: Vertical step
  zb: Bottom elevation of the block (if None, use Min deposit elevation)
  zt: Top elevation of the block (if None, use Max Topography)
  nz: Number of vertical discretization steps (if None, discretize up to Max Topo)

  Elevations must take into account initial grid elevation (Zref) and
  flattening surface (if used)
  """
# Get the domain size
  dom = self.getDomain()
  nx = dom.getNbNodeX()
  ny = dom.getNbNodeY()

  if (zb == None):
    zb = dom.getZMinGeo() # Minimum deposit elevation
  if (zt == None):
    zt = dom.getZMaxGeo() # Maximum topography
  if (nz == None):
    nz = int(round((zt - zb)/dz, 0) + 1)
  else:
    if ((zb + nz * dz) > zt):
      nz = int(round((zt - zb)/dz, 0) + 1)

# Vertical discretization
  fac = dom.getRegularFacies(dz=dz, minz=zb, nbz=nz)
  fac_arr = np.asarray(fac).reshape(nx,ny,nz)
  grain = dom.getRegularGrain(dz=dz, minz=zb, nbz=nz)
  grain_arr = np.asarray(grain).reshape(nx,ny,nz)
  age = dom.getRegularAge(dz=dz, minz=zb, nbz=nz)
  age_arr = np.asarray(age).reshape(nx,ny,nz)
  return fac_arr, grain_arr, age_arr

# Print proportions (arr must be a numpy array of integers)
# https://stackoverflow.com/a/24273934/3952924
def getProps(arr, remove_na = True, na_val = UNAVAILABLE_FACIES, lab = fac_lab, reverse = False):
  l = arr.reshape(-1)    # 1D array (make it hashable for Counter)
  if (remove_na):        # If we must ignore nan
    l = l[l != na_val]   # Remove NA from the serie
  c = Counter(l)
  v = sorted(c, reverse = reverse)
  p = {'NA' if i == na_val else lab[i]: round(c[i] / len(l) * 100.0, 2) for i in v}
  return p

# Print facies proportions
# https://stackoverflow.com/a/24273934/3952924
def getFaciesProps(arr, remove_na = True):
  """
  Return a dictionary containing the Flumy facies proportion (percentage)
  of a Flumy simulation. Dictionary keys are Flumy facies short names (i.e. 'PB')

  arr: numpy array of Flumy facies identifiers
  remove_na: If False, proportion of 'NA' facies is considered 
  """
  if (not issubclass(arr.dtype.type, np.integer)): # Not integers
    arr[np.isnan(arr)] = UNAVAILABLE_FACIES        # If nan, convert to UNAVAILABLE_FACIES
    arr = np.asarray(arr, dtype=int)               # Convert to integers
  return getProps(arr, remove_na, UNAVAILABLE_FACIES, fac_lab)

# Print grain size class proportions
def getGrainProps(arr, remove_na = True):
  """
  Return a dictionary containing the Flumy grain size class proportion (percentage)
  of a Flumy simulation. Dictionary keys are Flumy grain size class names (i.e. 'Clay 11:14')

  arr: numpy array of Flumy grain size class values
  remove_na: If False, proportion of 'NA' class is considered 
  """
  if (not issubclass(arr.dtype.type, np.integer)): # Not integers
    arr[np.isnan(arr)] = UNAVAILABLE_GRAIN_SIZE    # If nan, convert to UNAVAILABLE_GRAIN_SIZE
    arr = granulo_to_class(arr)                    # Convert to integers
  return getProps(arr, remove_na, UNAVAILABLE_GRAIN_SIZE, gr_lab, reverse=True)

def getGrainDist(self, density=False):
  dom = self.getDomain()
  t = np.asarray(dom.getAllThickness())
  f = np.asarray(dom.getAllFacies())
  g = np.asarray(dom.getAllGrainsizeClass())
# Remove all deposition units having null thickness (age hiatus)
  g2 = np.delete(g,np.where(t==0)[0])
  f2 = np.delete(f,np.where(t==0)[0])
  t2 = np.delete(t,np.where(t==0)[0])
  bins = np.arange(gr_nclass+1)
  values = np.asarray([np.histogram(g2[f2==i], bins=bins, weights=t2[f2==i], density=False)[0] for i in fac_id])
  if (density):
      values = values / t2.sum()
  return values

def getProba(f2gfiles, facid=[FACIES_PB_ID], channel=False, verbose=False):
    probas={}
    if (len(facid) <= 0):
        print("You must provide a list of facies ID!")
        return probas

    nx = None
    ny = None
    nz = None
    n = len(f2gfiles)

# Parse all F2G files
    f2gfiles.sort()
    idx = 0
    for f2gfile in f2gfiles:

        if (verbose):
            print(f"#{idx} Reading {f2gfile}...")
        gfac = GridReal()
        if (gfac.read(f2gfile) == False):
            print(f"Error reading {f2gfile}: {gfac.last_error()}")
            n = n-1
            continue
        if (gfac.is3D() == False):
            print(f"Error: F2G {f2gfile} must be 3D")
            n = n-1
            continue
        if (nx is None):
            nx = gfac.getNx()
            ny = gfac.getNy()
            nz = gfac.getNz()
        else:
            if (nx != gfac.getNx() or ny != gfac.getNy() or nz != gfac.getNz()):
                print(f"Error: Wrong grid size for {f2gfile}")
                n = n-1
                continue

        fac = np.array(gfac.get_values_zyx()) # Values order is +Z +Y +X
        fac[fac==MP_UNKNOWN_REAL_VALUE] = UNAVAILABLE_FACIES
        fac = np.array(fac, dtype='int').reshape(nx,ny,nz)

# Calculate probabilities
        if (probas):
            for fid in facid:
                probas[fid] = np.add(probas[fid], np.array(fac==fid, dtype='int'))
            if (channel):
                probas[99] = np.add(probas[99], np.array((fac==FACIES_CL_ID) |
                                                         (fac==FACIES_PB_ID) |
                                                         (fac==FACIES_SP_ID) |
                                                         (fac==FACIES_CSI_ID), dtype='int'))
        else:
            for fid in facid:
                probas[fid] = np.array(fac==fid, dtype='int')
            if (channel):
                probas[99] = np.array((fac==FACIES_CL_ID) |
                                      (fac==FACIES_PB_ID) |
                                      (fac==FACIES_SP_ID) |
                                      (fac==FACIES_CSI_ID), dtype='int')
        idx = idx + 1

    for k in probas.keys():
        probas[k] = probas[k]/n

    return probas

# Extend Flumy class (need getDomain method)
setattr(Flumy, 'getTopo',  getTopo)
setattr(Flumy, 'getSlice', getSlice)
setattr(Flumy, 'getBlock', getBlock)

################################################################################
#                                PLOT FUNCTIONS
################################################################################


def showVPC(simu, dz, zmin=None, zmax=None, color=0, title="VPC", filepng=None):
  """
  Show (Facies or Grain size) VPC from a 3D block

  simu: Flumy Simulation
  dz: Level thickness
  zmin: Bottom elevation of the block (if None, use Min deposit elevation)
  zmax: Top elevation of the block (if None, use Max Topography)
  color: Color palette identifier:
    color = 0 => Facies
   color = 1 => Grain size class
   color = 2 => Age
  title: Main caption of the plot
  filepng: Name of the PNG file to be saved.

  Minimum and maximum elevations must take into account initial grid elevation (Zref) and
  flattening surface (if used)
  """
  if (simu.getAge() <= 0):
    print("Simulator hasn't run yet")
    return
  if (zmin is None):
    zmin = simu.getDomain().getZMinGeo() #Minimum deposit elevation
  if (zmax is None):
    zmax = simu.getDomain().getZMaxGeo() # Maximum topography
  if (zmax <= zmin):
    print("zmax must be greater than zmin")
    return
  if (dz <= 0):
    print("dz must be strictly positive")
    return

# Get 3D regular block
  nz = int(round((zmax-zmin)/dz, 0) + 1)
  fac_arr,gr_arr,age_arr = simu.getBlock(dz, zb=zmin, zt=zmax)

#Select appropriate array
  if (color == 0):
    arr = fac_arr
    col = fac_col
    lab = fac_lab
    props = getFaciesProps(arr)
  if (color == 1):
    arr = gr_arr
    col = gr_col
    lab = gr_lab
    props = getGrainProps(arr)
  if (color == 2):
    print("VPC for age property not yet implemented")
    return

#Retrieve proportions labels
  keys  = props.keys()

  vpc = {}
  for k in keys:
    vpc[k] = []
  for iz in range(0, nz) :
    if (color == 0):
      p = getFaciesProps(arr[:,:,iz])
    if (color == 1):
      p = getGrainProps(arr[:,:,iz])
    for k in keys:
      if (k in p.keys()) :
        vpc[k].append(p[k])
      else :
        vpc[k].append(0.)

  levels = [str(iz) for iz in range(0,nz)]

  fig, ax = plt.subplots()
  left = np.zeros(nz)
  width = 1.0
  for label, pr in vpc.items():
    p = ax.barh(levels, pr, width, label=label, left=left, color=col[lab.index(label)])
    left += pr

  ax.set_title(title)

# Shrink current axis by 20%
  box = ax.get_position()
  ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])

# Create level labels on the y-axis
  yt = np.linspace(0,nz,5)
  yl = [f"{zmin+it*dz:.2f}m" for it in yt]
  plt.yticks(yt, yl)

# Put a legend to the right of the current axis
  ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

  if (filepng) : 
    plt.savefig(f"{filepng}.png", format='png')
  else:
    plt.show()
  plt.close()

# Show grain size distribution
def showGrainDist(gr, title="", ylim=None):

  fig, ax = plt.subplots()

# Default title
  if (not title):
    title = 'Grain size distribution'
  ax.set_title(title)

  bins = np.arange(gr_nclass+1)
  for i in range(gr.shape[0]):
    ax.bar(np.arange(gr_nclass), gr[i], bottom = np.sum(gr[:i], axis = 0), color=fac_col[i])
  if ylim is not None:
    plt.ylim(0, ylim)
  plt.xticks(bins, bins)
  plt.show()
  plt.close()


# Show topography
def showTopo(topo, size=5, title="", legend=0, filepng=None, extent=None):
  """
  legend: 0: no legend, 1: legend (right)
  """

# Default title
  if (not title):
    title = 'Topography'

  topo = np.array(topo, dtype=float) # No transposition

  fig, ax = plt.subplots(figsize=(size,size))
  im = ax.imshow(topo, origin='lower', extent=extent)
  plt.title(title)

  if (legend > 0):
    cb = fig.colorbar(im, ax=ax)

  if (filepng) : 
    plt.savefig(f"{filepng}.png", bbox_inches='tight', format='png')
  else:
    plt.show()
  plt.close()

# Show facies section
def showSectionFac(fac, size=5, title="", legend=0, extent=None, aspect=None, full_legend=False, filepng=None):
  """
  Show a section of Facies from a 2D array
  legend: 0: no legend, 1: right, 2: bottom
  full_legend: Valid only when displaying Facies.
               If True, the legend shows all known Flumy facies.
               If False, the legend only shows Facies contained in the section
  """

# Default title
  if (not title):
    title = 'Facies Section'

  as_na = False
  if (np.count_nonzero(fac == UNAVAILABLE_FACIES) > 0):
    as_na = True 

  if (full_legend == False):
# Colorbar with only the slice's facies
    unique, newfac = np.unique(fac, return_inverse=1) # Assume fac is np.array of facies (integers) (0-13,255)
    unique = unique[unique!=UNAVAILABLE_FACIES]       # Remove unavailable facies (255)
    newfac = newfac.reshape(fac.shape).T              # Reshape using new ids (from 0 to max, consecutive)
    newid = np.unique(newfac)                         # Get the list of new ids (equivalent to np.arange(newfac.max()+1))
    if (as_na):
      newid = newid[newid!=newid.max()]               # Remove unavailable facies (max of new ids)
    newcols = np.take(fac_col,unique,axis=0)          # Extract colors of preserved facies ids
    newlab = np.take(fac_lab,unique)                  # Extract labels of preserved facies ids
  else:
# Full colorbar
    newfac = fac.T # Transpose for plot
    newid = fac_id
    newcols = fac_col
    newlab = fac_lab

# Create the colormap containing N colors and a normalizer
  cmap = mcol.ListedColormap(newcols, int(newid.max())+1)
  cmap.set_bad(color='white')
  cmap_bounds = np.arange(len(newid)+1) - 0.5
  norm = mcol.BoundaryNorm(cmap_bounds, cmap.N)

# Plot the slice
  newfac = np.array(newfac, dtype=float) # Convert to float (which permits nan)
  if (as_na):
    newfac[newfac==newfac.max()] = np.nan
  fig, ax = plt.subplots(figsize=(size,size))
  im = ax.imshow(newfac, cmap=cmap, norm=norm, origin='lower', extent=extent, aspect=aspect)
  plt.title(title)
  if (legend > 0):
    divider = make_axes_locatable(ax)
    if (legend == 1):
      loc = "right"
      orient = "vertical"
      pad = 0.1
    else:
      loc = "bottom"
      orient = "horizontal"
      pad = 0.3
    cax = divider.append_axes(loc, size=0.2, pad=pad)
    cb = fig.colorbar(im, ticks=newid, ax=ax, norm=norm, cax=cax, orientation=orient)
    cb.set_ticklabels(newlab)

  if (filepng) : 
    plt.savefig(f"{filepng}.png", format='png')
  else:
    plt.show()
  plt.close()

def getGrainColorMap():
# Create the colormap containing N colors and a normalizer
  nx2 = gr_nclass*2
  cmap = mcol.ListedColormap(gr_col, gr_nclass+1)
  cmap.set_bad(color='white')
  cmap_bounds = np.linspace(1/nx2,(nx2+1)/nx2,gr_nclass+1)
  norm = mcol.BoundaryNorm(cmap_bounds, cmap.N)
  return cmap, norm

def showSectionGrain(grain, size=5, title="", legend=0, extent=None, aspect=None, filepng=None):
  """
  Show a section of Grain classes from a 2D array
  legend: 0: no legend, 1: right, 2: bottom
  """

# Default title
  if (not title):
    title = 'Grain Section'

  grain = np.array(grain, dtype=float).T
  grain[grain==UNAVAILABLE_GRAIN_SIZE] = np.nan
  grain[grain==MD_UDF_GRANULO] = np.nan

# Create the colormap containing N colors and a normalizer
  cmap, norm = getGrainColorMap()

  fig, ax = plt.subplots(figsize=(size,size))
  im = ax.imshow(grain, cmap=cmap, norm=norm, origin='lower', extent=extent, aspect=aspect)
  plt.title(title)

  if (legend > 0):
    divider = make_axes_locatable(ax)
    if (legend == 1):
      loc = "right"
      orient = "vertical"
      pad = 0.1
    else:
      loc = "bottom"
      orient = "horizontal"
      pad = 0.3
    cax = divider.append_axes(loc, size=0.2, pad=pad)
    gr_val = np.linspace(1/gr_nclass,1,gr_nclass)
    cb = fig.colorbar(im, ticks=gr_val, ax=ax, norm=norm, cax=cax, orientation=orient)
    cb.set_ticklabels(gr_lab)

  if (filepng) : 
    plt.savefig(f"{filepng}.png", format='png')
  else:
    plt.show()
  plt.close()

def showSectionAge(age, size=5, title="", vmax=None, legend=0, extent=None, aspect=None, filepng=None):
  """
  Show a section of Age values from a 2D array
  legend: 0: no legend, 1: right, 2: bottom
  """

# Default title
  if (not title):
    title = 'Age Section'

  age = np.array(age, dtype=float).T
  age[age==UNAVAILABLE_AGE] = np.nan

  fig, ax = plt.subplots(figsize=(size,size))
  im = ax.imshow(age, origin='lower', vmin=0, vmax=vmax, extent=extent, aspect=aspect)
  plt.title(title)

  if (legend > 0):
    divider = make_axes_locatable(ax)
    if (legend == 1):
      loc = "right"
      orient = "vertical"
      pad = 0.1
    else:
      loc = "bottom"
      orient = "horizontal"
      pad = 0.3
    cax = divider.append_axes(loc, size=0.2, pad=pad)
    cb = fig.colorbar(im, ax=ax, cax=cax, orientation=orient)

  if (filepng) : 
    plt.savefig(f"{filepng}.png", format='png')
  else:
    plt.show()
  plt.close()

def showSection(fac=None, grain=None, age=None, size=5, title="",
                legend=0, extent=None, aspect=None, full_legend=False, filepng=None):
  """
  Display a 2D section of a Flumy simulation (facies, grain size or age)

  fac: 2D numpy array of Flumy facies identifiers
  grain: 2D numpy array of grain size values
  age: 2D numpy array of age values
  size: Size of the figure
  title: Title of the figure
  legend: 0: no legend, 1: right, 2: bottom
  extent: See imshow
  aspect: See imshow
  full_legend: Valid only when displaying Facies.
               If True, the legend shows all known Flumy Facies.
               If False, the legend only shows Facies contained in the section
  filepng: If defined, do not show the plot and save it in the given file name
  """

  if (fac is None and grain is None and age is None):
    print("Please provide one array among fac, grain or age")
    return

  if (np.any(fac)):
    showSectionFac(fac, size, title, legend, extent, aspect, full_legend, filepng)
  elif (np.any(grain)):
    showSectionGrain(grain, size, title, legend, extent, aspect, filepng)
  elif (np.any(age)):
    showSectionAge(age, size, title, None, legend, extent, aspect, filepng)



def showProbaSection(proba, size=5, title="", legend=0, extent=None, filepng=None):
  """
  Show a section of Probabilities from a 2D array
  legend: 0: no legend, 1: right, 2: bottom
  """

# Default title
  if (not title):
    title = 'Proba Section'

  proba = np.array(proba, dtype=float).T

  fig, ax = plt.subplots(figsize=(size,size))
  im = ax.imshow(proba, origin='lower', vmin=0, vmax=1, extent=extent)
  plt.title(title)

  if (legend > 0):
    divider = make_axes_locatable(ax)
    if (legend == 1):
      loc = "right"
      orient = "vertical"
      pad = 0.1
    else:
      loc = "bottom"
      orient = "horizontal"
      pad = 0.3
    cax = divider.append_axes(loc, size=0.2, pad=pad)
    cb = fig.colorbar(im, ax=ax, cax=cax, orientation=orient)

  if (filepng) : 
    plt.savefig(f"{filepng}.png", format='png')
  else:
    plt.show()
  plt.close()


def get_rgba_color(col):
  col_int = np.array(col) * 255
  col_int = col_int.astype(int)
  return 'rgba(%d,%d,%d,%d)' % (col_int[0], col_int[1], col_int[2], col_int[3])


def getFaciesColorscale():
# Create the colorscale for Facies identifiers
  cs = [[v, get_rgba_color(c)] for v,c in zip(fac_id, fac_col)]
  cl_col = get_rgba_color(fac_col[1])
  cs = [cs[0],[fac_id[0]+1e-4, cl_col]] + cs[1:]
  return cs


def getGrainColorscale():
# Create the colorscale for Grain Size values
  cs = [[v, get_rgba_color(c)] for v,c in zip(gr_val, gr_col)]
  undef_col = get_rgba_color(gr_col[0])
  shale_col = get_rgba_color(gr_col[1])
  cs = [[0.0, undef_col]] + [cs[0]] + [[gr_val[0]+1e-4, shale_col]] + cs[1:]
  return cs

import plotly.graph_objects as go
import plotly.colors as pc

def sliceFromGrid(grid, section = 0, index = 0,
                  colorscale = None, showscale = False,
                  cmin = None, cmax = None):
  """
  Extract a 2D slice (plotly surface) of a Flumy 3D simulation (facies, grain size or age).
  Undefined values (np.nan) are made transparent.
  The grid must be a 3D numpy ndarray ordered in +Z +Y +X. 
  See plotly.graph_objects.Surface for details

  grid: 3D numpy array of facies, grain size or age values
  section: 0: X-section, 1: Y-section, 2: Z-slice
  index: Index of the section (0-based)
  colorscale: Colorscale like the one returned by getGrainColorscale (Viridis by default)
  showscale: Show colorscale bar (hidden by default)
  cmin: Minimum value (useful when using same colorscale for several topo/slice)
  cmax: Maximum value (useful when using same colorscale for several topo/slice)
  """

  shape = list(grid.shape)
  if len(shape) != 3:
    print("The grid must be 3D")
    return None
  if index >= shape[section]:
    print(f"Index out of range {shape}")
    return None
  if section < 0 or section > 2:
    print("Section identifier out of range (0, 1 or 2)")
    return None
  if colorscale is None:
    colorscale = pc.sequential.Viridis

  shape.pop(section)
  n = np.prod(list(shape))
  if section == 0:
    val = grid[index,:,:]
    x =              np.repeat(index,               n       ).reshape(shape).astype(float)
    y =              np.repeat(np.arange(shape[0]), shape[1]).reshape(shape).astype(float)
    z = np.transpose(np.repeat(np.arange(shape[1]), shape[0]).reshape(np.flip(shape))).astype(float)
  elif section == 1:
    val = grid[:,index,:]
    x =              np.repeat(np.arange(shape[0]), shape[1]).reshape(shape).astype(float)
    y =              np.repeat(index,               n       ).reshape(shape).astype(float)
    z = np.transpose(np.repeat(np.arange(shape[1]), shape[0]).reshape(np.flip(shape))).astype(float)
  elif section == 2:
    val = grid[:,:,index]
    x =              np.repeat(np.arange(shape[0]), shape[1]).reshape(shape).astype(float)
    y = np.transpose(np.repeat(np.arange(shape[1]), shape[0]).reshape(np.flip(shape))).astype(float)
    z =              np.repeat(index,               n       ).reshape(shape).astype(float)

  x[np.isnan(val)] = np.nan
  y[np.isnan(val)] = np.nan
  z[np.isnan(val)] = np.nan

  if cmin is None:
    cmin = np.nanmin(val)
  if cmax is None:
    cmax = np.nanmax(val)

# Normalized colorscale
  if (len(colorscale[0]) != 2):
    vc = np.linspace(cmin, cmax, len(colorscale)-1) / cmax
    custom_colorscale = [[0.0, colorscale[0]]] + [ [vc[i], colorscale[i+1]] for i in range(len(colorscale)-1)]
  else:
    if (colorscale[0][0] != 0.0):
      colorscale = [[0.0, colorscale[0][1]]] + colorscale
    vc = [v / cmax for v,c in colorscale]
    custom_colorscale = [[vc[i], colorscale[i][1]] for i in range(len(colorscale))]

  slice = go.Surface(x=x, y=y, z=z, surfacecolor=val, opacity=1.,
                     colorscale=custom_colorscale, autocolorscale=False,
                     connectgaps=False, showscale=showscale,
                     cmin=cmin, cmax=cmax)

  return slice

# Find first non-NaN values downward along axis 2
def first_non_nan_indices_and_values(arr):
  mask = ~np.isnan(arr)  # Mask for non-NaN values
  rev_indices = mask[:, :, ::-1].argmax(axis=2)  # Reverse indicies
  has_non_nan = mask.any(axis=2)  # Check wether it exist a non-Nan value at all (i, j)

  indices = np.where(has_non_nan, arr.shape[2] - rev_indices - 1, -1)  # Conversion in real indicies
  values = np.where(has_non_nan, arr[np.arange(arr.shape[0])[:, None], np.arange(arr.shape[1]), indices], np.nan)  # Value extraction

  return indices.astype(float), values.astype(float)

def topoFromGrid(grid, colorscale = None, showscale = False,
                 cmin = None, cmax = None):
  """
  Extract the topography (plotly surface) of a Flumy 3D simulation (facies, grain size or age).
  Undefined values (np.nan) are made transparent.
  The grid must be a 3D numpy ndarray ordered in +Z +Y +X.
  See plotly.graph_objects.Surface for details

  grid: 3D numpy array of facies, grain size or age values
  colorscale: Colorscale like the one returned by getGrainColorscale (Viridis by default)
  showscale: Show colorscale bar (hidden by default)
  cmin: Minimum value (useful when using same colorscale for several topo/slice)
  cmax: Maximum value (useful when using same colorscale for several topo/slice)
  """

  shape = list(grid.shape)
  if len(shape) != 3:
    print("The grid must be 3D")
    return None
  if colorscale is None:
    colorscale = pc.sequential.Viridis

  shape.pop(2) #Drop 
  x = np.repeat(np.arange(shape[0]), shape[1]).reshape(shape).astype(float)
  y = np.transpose(np.repeat(np.arange(shape[1]), shape[0]).reshape(np.flip(shape))).astype(float)
  z, val = first_non_nan_indices_and_values(grid)

  x[np.isnan(val)] = np.nan
  y[np.isnan(val)] = np.nan
  z[np.isnan(val)] = np.nan   

  if cmin is None:
    cmin = np.nanmin(val)
  if cmax is None:
    cmax = np.nanmax(val)

# Normalized colorscale
  if (len(colorscale[0]) != 2):
    vc = np.linspace(cmin, cmax, len(colorscale)-1) / cmax
    custom_colorscale = [[0.0, colorscale[0]]] + [ [vc[i], colorscale[i+1]] for i in range(len(colorscale)-1)]
  else:
    if (colorscale[0][0] != 0.0):
      colorscale = [[0.0, colorscale[0][1]]] + colorscale
    vc = [v / cmax for v,c in colorscale]
    custom_colorscale = [[vc[i], colorscale[i][1]] for i in range(len(colorscale))]

  slice = go.Surface(x=x, y=y, z=z, surfacecolor=val, opacity=1.,
                     colorscale=custom_colorscale, autocolorscale=False,
                     connectgaps=True, showscale=showscale,
                     cmin=cmin, cmax=cmax)
  return slice



