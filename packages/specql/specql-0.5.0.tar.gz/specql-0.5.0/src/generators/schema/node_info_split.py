"""Node+Info split pattern for complex entities."""

import logging

from src.core.ast_models import EntityDefinition, FieldDefinition

logger = logging.getLogger(__name__)


def should_split_entity(entity: EntityDefinition) -> bool:
    """Determine if entity should use node+info split pattern.

    Args:
        entity: Entity definition from AST

    Returns:
        True if entity should use split pattern, False otherwise

    Split criteria:
    1. User explicitly opted in via metadata_split flag
    2. Auto-suggest for entities with >12 fields (but don't auto-split)
    """
    # Check for explicit opt-in (future: when metadata is added to EntityDefinition)
    # if hasattr(entity, 'metadata_split') and entity.metadata_split:
    #     return True

    # For now, we'll use a field count heuristic
    # Count business fields (exclude system fields like id, tenant_id, etc.)
    business_fields = [
        field
        for field in entity.fields.values()
        if not field.name.startswith(("id", "tenant_id", "created_at", "updated_at", "deleted_at"))
        and field.name not in ("identifier", "sequence_number", "display_identifier", "path")
    ]

    field_count = len(business_fields)

    # Auto-suggest split for entities with many fields
    if field_count > 12:
        logger.warning(
            f"Entity '{entity.name}' has {field_count} business fields. "
            "Consider using node+info split pattern for cleaner schema."
        )

    # For now, don't auto-split - require explicit opt-in
    # This can be changed when metadata support is added
    return False


def split_entity_fields(
    entity: EntityDefinition,
) -> tuple[list[FieldDefinition], list[FieldDefinition]]:
    """Split entity fields into node fields and info fields.

    Args:
        entity: Entity definition

    Returns:
        Tuple of (node_fields, info_fields)

    Node fields: Structure, hierarchy, tenant isolation
    Info fields: Business data, deduplication, business audit
    """
    node_fields = []
    info_fields = []

    for field_name, field_def in entity.fields.items():
        # Node table gets: hierarchy and structural fields
        if field_name in ("path", "fk_parent_" + entity.name.lower()):
            node_fields.append(field_def)
        # Info table gets: business fields, deduplication, business audit
        else:
            info_fields.append(field_def)

    return node_fields, info_fields


def generate_node_table_ddl(entity: EntityDefinition, schema: str) -> str:
    """Generate DDL for the node table (structure/hierarchy only)."""
    entity_lower = entity.name.lower()

    ddl = f"""-- Structure table: Hierarchy and tenant isolation only
CREATE TABLE {schema}.tb_{entity_lower}_node (
    -- Trinity Pattern
    pk_{entity_lower} INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE,

    -- Multi-Tenancy
    tenant_id UUID NOT NULL,

    -- Hierarchy
    path ltree NOT NULL,
    fk_parent_{entity_lower} INTEGER REFERENCES {schema}.tb_{entity_lower}_node(pk_{entity_lower})
        ON DELETE RESTRICT,

    -- Foreign key to info table
    fk_{entity_lower}_info INTEGER NOT NULL,

    -- Structural Audit (creation/deletion only)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by UUID,
    deleted_at TIMESTAMPTZ,
    deleted_by UUID,

    -- Path Audit
    path_updated_at TIMESTAMPTZ,
    path_updated_by UUID,

    -- Constraints
    UNIQUE (tenant_id, id),
    UNIQUE (tenant_id, path)
);

-- Indexes for node table
CREATE INDEX idx_{entity_lower}_node_tenant
    ON {schema}.tb_{entity_lower}_node(tenant_id)
    WHERE deleted_at IS NULL;

CREATE INDEX idx_{entity_lower}_node_path
    ON {schema}.tb_{entity_lower}_node USING GIST (path)
    WHERE deleted_at IS NULL;

CREATE INDEX idx_{entity_lower}_node_parent
    ON {schema}.tb_{entity_lower}_node(fk_parent_{entity_lower})
    WHERE deleted_at IS NULL;

CREATE INDEX idx_{entity_lower}_node_info_fk
    ON {schema}.tb_{entity_lower}_node(fk_{entity_lower}_info);"""

    return ddl


def generate_info_table_ddl(entity: EntityDefinition, schema: str) -> str:
    """Generate DDL for the info table (business data only)."""
    entity_lower = entity.name.lower()

    # Build field list for info table
    info_fields = []

    # Deduplication fields
    info_fields.extend(
        [
            "    -- Deduplication",
            "    identifier TEXT NOT NULL,",
            "    sequence_number INTEGER NOT NULL DEFAULT 1,",
            "    display_identifier TEXT GENERATED ALWAYS AS (",
            "        CASE WHEN sequence_number > 1",
            "            THEN identifier || '#' || sequence_number",
            "            ELSE identifier",
            "        END",
            "    ) STORED,",
        ]
    )

    # Business fields
    info_fields.append("    -- Business Fields")
    for field_name, field_def in entity.fields.items():
        # Skip structural fields that go in node table
        if field_name not in ("path", "fk_parent_" + entity_lower):
            # Generate field DDL (simplified for now)
            nullable = "" if field_def.nullable else " NOT NULL"
            info_fields.append(
                f"    {field_def.name} {field_def.postgres_type or 'TEXT'}{nullable},"
            )

    # Business audit
    info_fields.extend(
        [
            "",
            "    -- Business Audit",
            "    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),",
            "    created_by UUID,",
            "    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),",
            "    updated_by UUID,",
            "",
            "    -- Identifier Audit",
            "    identifier_recalculated_at TIMESTAMPTZ,",
            "    identifier_recalculated_by UUID",
        ]
    )

    # Remove trailing comma from last field
    if info_fields[-1].endswith(","):
        info_fields[-1] = info_fields[-1].rstrip(",")

    field_list = "\n".join(info_fields)

    ddl = f"""-- Attributes table: Business data and versioning
CREATE TABLE {schema}.tb_{entity_lower}_info (
    -- Trinity Pattern
    pk_{entity_lower}_info INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE,

    -- Multi-Tenancy
    tenant_id UUID NOT NULL,
{field_list},

    -- Constraints
    UNIQUE (tenant_id, display_identifier),
    UNIQUE (identifier, sequence_number)
);

-- Indexes for info table
CREATE INDEX idx_{entity_lower}_info_tenant
    ON {schema}.tb_{entity_lower}_info(tenant_id);

CREATE INDEX idx_{entity_lower}_info_identifier
    ON {schema}.tb_{entity_lower}_info(identifier);"""

    return ddl


def generate_unified_view_ddl(entity: EntityDefinition, schema: str) -> str:
    """Generate DDL for the unified view (JOIN of node + info)."""
    entity_lower = entity.name.lower()

    # Build field list for view
    view_fields = [
        "    -- Node fields",
        f"    n.pk_{entity_lower},",
        "    n.id,",
        "    n.tenant_id,",
        "    n.path,",
        f"    n.fk_parent_{entity_lower},",
        "",
        "    -- Info fields",
        f"    i.pk_{entity_lower}_info,",
        "    i.identifier,",
        "    i.sequence_number,",
        "    i.display_identifier,",
    ]

    # Add business fields from info table
    for field_name, field_def in entity.fields.items():
        if field_name not in ("path", "fk_parent_" + entity_lower):
            view_fields.append(f"    i.{field_def.name},")

    # Add combined audit fields
    view_fields.extend(
        [
            "",
            "    -- Audit (combined)",
            "    n.created_at,",
            "    n.created_by,",
            "    i.updated_at,",
            "    i.updated_by,",
            "    n.deleted_at,",
            "    n.deleted_by,",
            "",
            "    -- Recalculation Audit",
            "    i.identifier_recalculated_at,",
            "    i.identifier_recalculated_by,",
            "    n.path_updated_at,",
            "    n.path_updated_by",
        ]
    )

    # Remove trailing comma from last field
    if view_fields[-1].endswith(","):
        view_fields[-1] = view_fields[-1].rstrip(",")

    field_list = "\n".join(view_fields)

    ddl = f"""-- Convenience view: JOIN node + info
CREATE VIEW {schema}.v_{entity_lower} AS
SELECT
{field_list}
FROM {schema}.tb_{entity_lower}_node n
INNER JOIN {schema}.tb_{entity_lower}_info i
    ON i.pk_{entity_lower}_info = n.fk_{entity_lower}_info
WHERE n.deleted_at IS NULL;

-- FraiseQL metadata
COMMENT ON VIEW {schema}.v_{entity_lower} IS
'Table view for {entity.name} entity.

@fraiseql:type
name: {entity.name}
schema: {schema}';"""

    return ddl


def generate_node_info_split_ddl(entity: EntityDefinition, schema: str) -> list[str]:
    """Generate complete DDL for node+info split pattern.

    Args:
        entity: Entity definition
        schema: Schema name

    Returns:
        List of DDL statements for node table, info table, and view
    """
    ddl_statements = []

    # Node table
    ddl_statements.append(generate_node_table_ddl(entity, schema))

    # Info table
    ddl_statements.append(generate_info_table_ddl(entity, schema))

    # Unified view
    ddl_statements.append(generate_unified_view_ddl(entity, schema))

    return ddl_statements
