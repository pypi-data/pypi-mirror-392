---
description: Define toolkit specification (SDD - Spec-Driven Development)
---

## User Input

```text
$ARGUMENTS
```

You **MUST** consider the user input before proceeding (if not empty).

## Outline

The text the user typed after `/metaspec.sdd.specify` is the **toolkit specification description**. 

**PURPOSE: Toolkit Specification (SDD)** ğŸ¯

This command is for defining **toolkit implementation specifications**:
- Focus: HOW to implement the toolkit
- Output: `specs/toolkit/001-{name}/spec.md`
- Must depend on specification specs
- Implementation-focused

**NOT for specification definition** - Use `/metaspec.sds.specify` for that.

---

### ğŸ“– Navigation Guide (Quick Reference with Line Numbers)

**ğŸ¯ AI Token Optimization**: Use `read_file` with `offset` and `limit` to read only needed sections.

**Core Flow** (Read sequentially):

| Step | Lines | Size | read_file Usage |
|------|-------|------|-----------------|
| 1. Setup & Verify | 103-159 | 56 lines | `read_file(target_file, offset=103, limit=56)` |
| 2. Gather Content | 160-239 | 79 lines | `read_file(target_file, offset=160, limit=79)` |
| 3. Generate Sections | 240-2673 | 2433 lines | See components below â¬‡ï¸ **LARGE** |
| 4. Write File | 2674-2722 | 48 lines | `read_file(target_file, offset=2674, limit=48)` |
| 5. Impact Report | 2723-2821 | 98 lines | `read_file(target_file, offset=2723, limit=98)` |
| 6-9. Analysis & Report | 2822-3118 | 296 lines | `read_file(target_file, offset=2822, limit=296)` |

**ğŸ“‹ Key Components in Step 3** (Jump to specific components):

| Component | Lines | Size | Priority | Usage |
|-----------|-------|------|----------|-------|
| Overview & Dependencies | 264-316 | 52 lines | ğŸ”´ MUST READ | `read_file(target_file, offset=264, limit=52)` |
| **Use Case â†’ Component Analysis** â­ | 317-380 | 63 lines | ğŸ”´ **UPDATED** | `read_file(target_file, offset=317, limit=63)` |
| Component 1: Parser | 434-475 | 41 lines | ğŸŸ¢ Optional | `read_file(target_file, offset=434, limit=41)` |
| Component 2: Validator | 476-520 | 44 lines | ğŸŸ¢ Optional | `read_file(target_file, offset=476, limit=44)` |
| **Component 3: CLI Commands** â­ | 524-962 | 438 lines | ğŸ”´ **KEY** | See subsections below â¬‡ï¸ |
| **Component 4: Slash Commands** â­â­ | 963-2109 | 1146 lines | ğŸ”´ **LARGE** | See subsections below â¬‡ï¸ |
| **Component 5: Generator** â­â­â­ | 2110-2514 | 404 lines | ğŸ”´ **CRITICAL** | See subsections below â¬‡ï¸ |
| Architecture & Requirements | 2744-2814 | 70 lines | ğŸŸ¡ Important | `read_file(target_file, offset=2744, limit=70)` |

**ğŸ¨ Component 3: CLI Commands Subsections**:

| Subsection | Lines | Size | Usage |
|------------|-------|------|-------|
| AGENTS.md Compliance | 533-556 | 23 lines | `read_file(target_file, offset=533, limit=23)` |
| init Command Standards | 629-768 | 139 lines | `read_file(target_file, offset=629, limit=139)` |
| Naming Principles | 591-607 | 16 lines | `read_file(target_file, offset=591, limit=16)` |

**ğŸ¨ Component 4: Slash Commands Subsections** (1146 lines total):

| Subsection | Lines | Size | Usage |
|------------|-------|------|-------|
| Overview | 963-1069 | 106 lines | `read_file(target_file, offset=963, limit=106)` |
| **Custom Commands** â­ | 1070-1578 | 508 lines | `read_file(target_file, offset=1070, limit=508)` |
| **Library Commands** â­ | 1910-2109 | 199 lines | `read_file(target_file, offset=1910, limit=199)` |

**ğŸ¨ Component 5: Generator Subsections** (404 lines total, â­â­â­ v0.9.4):

| Subsection | Lines | Size | Usage |
|------------|-------|------|-------|
| **ğŸ¯ Generator vs AI Commands** â­â­â­ UPDATED | 2116-2211 | 96 lines | `read_file(target_file, offset=2116, limit=96)` |
| Step 1-4: Analysis Logic | 2214-2293 | 80 lines | `read_file(target_file, offset=2214, limit=80)` |
| **Step 5: Define Generator** â­ UPDATED | 2294-2487 | 193 lines | `read_file(target_file, offset=2294, limit=193)` |
| **âœ… Verification Checklist** â­â­ ENHANCED | 2488-2513 | 25 lines | `read_file(target_file, offset=2488, limit=25)` |
| Step 6: Omit Generator | 2514-2527 | 13 lines | `read_file(target_file, offset=2514, limit=13)` |

**ğŸ’¡ Typical Usage Patterns**:
```python
# Minimal: Read only Steps 1-2 (135 lines)
read_file(target_file, offset=103, limit=135)

# **Use Case Analysis**: Critical for component decisions (63 lines) â­ UPDATED
read_file(target_file, offset=317, limit=63)

# **init Standards**: Essential for Generator/Scaffolder (139 lines) â­ UPDATED
read_file(target_file, offset=629, limit=139)

# CLI Design: Component 3 with AGENTS.md compliance (438 lines) â­ OPTIMIZED
read_file(target_file, offset=524, limit=438)

# **ğŸ¯ Generator vs AI Commands**: Role separation (96 lines) â­â­â­ v0.9.4
read_file(target_file, offset=2116, limit=96)

# **âœ… Verification Checklist**: Simplified checklist (25 lines) â­â­ v0.9.4 OPTIMIZED
read_file(target_file, offset=2488, limit=25)

# **Generator Logic**: Complete Component 5 (404 lines total) â­â­â­ v0.9.4 OPTIMIZED
read_file(target_file, offset=2110, limit=404)

# Slash Commands: Component 4 overview (106 lines)
read_file(target_file, offset=963, limit=106)
```

**Token Savings (v0.9.4 + Optimization)**: 
- Full file: 3279 lines (~11,100 tokens) [Optimized from 3573 lines]
- **Targeted reading: 25-438 lines (~85-1,480 tokens)**
- **Generator vs AI Commands: 96 lines (~325 tokens) - 97% savings** ğŸ†
- **Verification Checklist: 25 lines (~85 tokens) - 99% savings** ğŸ†ğŸ† [Optimized from 192 lines]
- **Step 5 (Generator): 193 lines (~650 tokens) - 94% savings** ğŸ† [Optimized from 224 lines]
- **Overall savings: 84-99% tokens** ğŸ‰ [Improved with optimization]

---

Follow this execution flow:

### 1. Determine Toolkit and Load Existing Specification

**Step 1a: Verify Specification Dependency (REQUIRED)**

```bash
# Check if specification specs exist
ls specs/domain/ | grep -E '^[0-9]{3}-'
```

**CRITICAL REQUIREMENT**: Toolkit specs MUST depend on at least one specification spec.

If no specification specs exist, **STOP** and show this error:

```
âŒ ERROR: Cannot create toolkit without domain specification

MetaSpec is a Spec-Driven framework. Every toolkit MUST depend on a specification.

The specification defines WHAT (domain specification).
The toolkit defines HOW (implementation).

Please run this command first:
  /metaspec.sds.specify "Define {domain} specification"

Then return to create toolkit with:
  /metaspec.sdd.specify "Create {toolkit} for {domain}"

Why this matters:
- Specification is the specification (core asset)
- Toolkit is the implementation (supporting tool)
- Without specification, this becomes a generic code generator
- MetaSpec's value is in spec-driven development
```

**Do not proceed** if no specification specs exist.

**Step 1b: Generate Toolkit Name**

Based on user input, generate:
- Short name: `{domain}-{component}`
- Example: "api-validator", "graphql-parser", "spec-analyzer"
- Check existing `specs/toolkit/` directory structure

**Step 1c: Find Next Available Number**

```bash
# List existing toolkit specs
ls specs/toolkit/ | grep -E '^[0-9]{3}-' | sort -n
# Find next number (e.g., if 001, 002 exist, use 003)
```

**Step 1d: Load Existing or Create New**

- Check for `specs/toolkit/{number}-{name}/spec.md`
- If exists, load for updating
- If new, create new directory structure

### 2. Gather Toolkit Specification Content

**Focus**: Define how to implement tools to support the specification.

**Critical Questions**:

1. **Dependencies**: Which specification specs does this toolkit support?
   - **REQUIRED**: Must reference at least one `domain/XXX-` spec
   - Example: "Depends on: domain/001-api-specification"
   
2. **Toolkit Purpose**: What does this toolkit do?
   - Example: "Parse and validate specification documents"
   
3. **Implementation Language** (NEW - CRITICAL ğŸ¯):
   - **Primary language**: Python / TypeScript / Go / Rust / Other?
   - **Rationale**: Why this language?
     - Target user community (Python devs, TS/JS devs, etc.)
     - Ecosystem fit (existing tools, libraries)
     - Performance requirements
     - Deployment constraints
   - **Secondary languages**: Any additional language support needed?
   
4. **Required Components** (NEW - CRITICAL ğŸ¯):
   Determine which components are needed for this toolkit:
   
   - [ ] **Parser** - Parse specifications from files
     - Needed if: Users write specs in files (YAML/JSON/TOML)
     - Not needed if: Specs are generated programmatically
   
   - [ ] **Validator** - Validate against specification rules
     - Needed if: Need to enforce specification compliance
     - Always recommended for spec-driven toolkits
   
   - [ ] **CLI** - Command-line interface
     - Needed if: Users interact via terminal
     - Provides: init, validate, generate commands
   
  - [ ] **Generator** - Generate project files/structure from specifications
    - Needed if: Toolkit creates projects or spec files
    - Examples: Generate project structure, spec templates, model classes from spec entities
   
   - [ ] **SDK/Library** - Programmatic API
     - Needed if: Other tools need to integrate
     - Provides: Python/TS/Go module for importing
   
   **Which are MVP (must have) vs. future enhancements (nice to have)?**
   
5. **Architecture Direction** (NEW ğŸ¯):
   - **Structure**: Monolithic / Modular / Plugin-based?
   - **Dependencies**: What frameworks/libraries?
     - Examples: Pydantic (Python), Zod (TypeScript), encoding/json (Go)
   - **Extensibility**: Plugin system / Hooks / Base classes?
   
6. **Parser Component** (if needed): How will specifications be parsed?
   - Input formats (YAML, JSON, TOML, other)?
   - Output format (Objects, AST, IR)?
   
7. **Validator Component** (if needed): What validation will it perform?
   - Must validate against specification rules
   - What error messages/codes?
   
8. **CLI Commands** (if needed): What commands will users run?
   - Example: `{toolkit-name} init`, `validate`, `generate`
   - What are the inputs/outputs for each command?

9. **Generator Component** (if needed): What will it generate?
   - Output formats: Code (Python/TS/Go), Docs (MD), Config (JSON/YAML)?
   - Templates: Built-in / User-provided / Both?

10. **SDK/Library** (if needed): Will there be programmatic APIs?
    - Public API surface: What functions/classes?
    - Integration: How will other tools use this?

**Important Notes**:
- This is SDD (Spec-Driven Development) - focus on implementation
- Must explicitly depend on specification specs
- For specification definition, use `/metaspec.sds.specify` instead

**If user input is vague**, make informed guesses based on domain standards and document assumptions.

### 3. Generate Toolkit Specification Content

Generate **Toolkit Implementation Specification** with these sections:

#### **Dependencies Section** (REQUIRED - CRITICAL)

**First and foremost**, declare dependencies on domain specifications:

```markdown
## Dependencies

**Domain Specifications**:
- **domain/001-{domain}-specification** - {Brief description of what specification defines}

### Dependency Rationale

{Explain how this toolkit depends on the specification:}
- Which specification entities are parsed/validated?
- Which specification rules are enforced?
- How does the toolkit implement specification operations?

**Important**: 
- This toolkit MUST reference at least one domain specification
- Changes to specification may require updates to this toolkit
- Without specification dependency, this violates the Spec-Driven principle
```

**CRITICAL**: This Dependencies section is mandatory. Toolkit without specification is not a valid speckit.

#### **Toolkit Overview**
```markdown
## Overview

**Name**: {Toolkit Name}
**Version**: {version}
**Status**: Draft | In Development | Stable
**Created**: {date}

**Purpose**: {What this toolkit does}

**Target Specification**: Implements support for domain/001-{domain}-spec

**Primary Use Cases**:
1. {Use case 1}
2. {Use case 2}
3. {Use case 3}

**Example**:
```bash
# How users will use this toolkit
{toolkit-name} init spec.yaml
{toolkit-name} validate spec.yaml
{toolkit-name} generate --output ./generated
```
\```

#### **Use Case â†’ Component Analysis** â­ NEW
```markdown
## Component Requirements Analysis

**Based on Primary Use Cases above, derive which components are REQUIRED**:

### Automatic Derivation Rules

Apply these rules to analyze your use cases:

1. **Parser Component**:
   - Required if use cases mention: "parse", "read", "load", "import", "process input"
   - Example: "Parse YAML specifications" â†’ Parser is CORE

2. **Validator Component**:
   - Required if use cases mention: "validate", "check", "verify", "enforce", "ensure compliance"
   - Example: "Validate against schema" â†’ Validator is CORE

3. **Generator Component**:
   - Required if use cases mention: "generate", "create", "produce", "output", "build", "scaffold"
   - âš ï¸ **CRITICAL**: "Project Generation", "Spec Generation", "Template-based Generation" â†’ Generator is CORE
   - Example: "Generate project structure from specifications" â†’ Generator is CORE
   - âš ï¸ **WRONG**: "Generate marketing content" â†’ This is domain content, NOT toolkit generation!

4. **CLI Component**:
   - Usually CORE for most toolkits (standard interface)
   - Required if use cases mention: "command-line", "terminal", "run commands"

### Component Priority Matrix

Based on the use cases you defined above, fill in this matrix:

| Component | Priority | Rationale |
|-----------|----------|-----------|
| Parser | CORE / RECOMMENDED / OPTIONAL | {Why? Which use case requires it?} |
| Validator | CORE / RECOMMENDED / OPTIONAL | {Why? Which use case requires it?} |
| Generator | CORE / RECOMMENDED / OPTIONAL | {Why? Which use case requires it?} |
| CLI | CORE / RECOMMENDED / OPTIONAL | {Why? Which use case requires it?} |

**Priority Definitions**:
- **CORE**: Must implement in MVP (use case depends on it)
- **RECOMMENDED**: Should implement soon (enhances core use cases)
- **OPTIONAL**: Can defer (nice-to-have feature)

### Analysis Example

**Example Use Cases**:
1. "Generate project structure from specifications" â† **Toolkit infrastructure**
2. "Validate marketing specifications against rules"
3. "Parse marketing campaign YAML files"

**Derived Components**:
| Component | Priority | Rationale |
|-----------|----------|-----------|
| Parser | CORE | Use case #3 explicitly requires parsing |
| Validator | CORE | Use case #2 explicitly requires validation |
| Generator | CORE | Use case #1 explicitly requires generation (keyword: "Generate project structure") |
| CLI | CORE | Standard interface for all operations |

âš ï¸ **CRITICAL WARNING**: 
- âœ… "Generate **project structure**" â†’ Generator is CORE (toolkit infrastructure)
- âŒ "Generate **marketing content**" â†’ This is domain content, NOT toolkit generation!
  - See "Generator vs AI Commands" (Line 2220-2311) for role separation

âœ… **Correct**: If primary use case is **project/infrastructure** generation, Generator must be CORE
\```

#### **Implementation Details** (NEW ğŸ¯)
```markdown
## Implementation

### Language & Ecosystem

**Primary Language**: {Python / TypeScript / Go / Rust / Other}

**Rationale**: 
{Why this language was chosen:}
- Target user community: {who will use this}
- Ecosystem fit: {existing tools and libraries}
- Performance considerations: {if relevant}
- Deployment needs: {pip / npm / binary / etc.}

**Key Dependencies**:
- {Framework/library 1}: {Purpose}
- {Framework/library 2}: {Purpose}
- {Framework/library 3}: {Purpose}

### Architecture

**Structure**: {Monolithic / Modular / Plugin-based}

**Core Components**:
- [ ] Parser - {Brief description}
- [ ] Validator - {Brief description}
- [ ] CLI - {Brief description}
- [ ] Generator - {Brief description if included}
- [ ] SDK - {Brief description if included}

**Extensibility**:
{How will users extend this toolkit:}
- Plugin system / Custom validators / Hooks / etc.

**File Structure** (Preliminary):
```
src/
  {package_name}/
    __init__.py         # Package initialization
    models.py           # Data models (if needed)
    parser.py           # Parser component (if needed)
    validator.py        # Validator component (if needed)
    cli.py              # CLI component (if needed)
    generator.py        # Generator component (if needed)
    api.py              # SDK interface (if needed)
```

Note: Actual structure will be refined in `/metaspec.sdd.plan`
\```

#### **Component Specifications**

Define each toolkit component:

##### **Component 1: Parser**

```markdown
### Parser Component

**Purpose**: Parse user specifications into validated objects

**Input Formats**:
- YAML (primary)
- JSON (alternative)
- Python dict (programmatic)

**Output Format**:
- Validated Python object
- AST representation (if needed)

**Parsing Steps**:
1. Load file (YAML/JSON)
2. Validate schema structure
3. Transform to internal representation
4. Return parsed object or errors

**Error Handling**:
- `ParseError`: Invalid YAML/JSON syntax
- `SchemaError`: Missing required fields
- `TypeE Error`: Incorrect field types

**API**:
```python
from {toolkit_name}.parser import parse_spec

# Parse from file
spec = parse_spec("spec.yaml")

# Parse from string
spec = parse_spec(yaml_string, format="yaml")

# Parse from dict
spec = parse_spec(spec_dict, format="dict")
```
\```

##### **Component 2: Validator**

```markdown
### Validator Component

**Purpose**: Validate specifications against specification rules (from domain/001-xxx)

**Validation Rules** (Reference specification spec):
1. {Rule from domain/001-xxx}
2. {Rule from domain/001-xxx}
3. {Rule from domain/001-xxx}

**Validation Levels**:
- **Error**: Violations that prevent usage
- **Warning**: Issues that should be fixed
- **Info**: Suggestions for improvement

**Validation Output**:
```python
ValidationResult(
    valid: bool,
    errors: List[ValidationError],
    warnings: List[ValidationWarning],
    info: List[ValidationInfo]
)
```

**Error Messages**:
- Clear, actionable error messages
- Point to exact location in spec
- Suggest fixes when possible

**API**:
```python
from {toolkit_name}.validator import validate_spec

# Validate parsed spec
result = validate_spec(spec)

if not result.valid:
    for error in result.errors:
        print(f"{error.location}: {error.message}")
```
\```

##### **Component 3: CLI Commands**

**CRITICAL**: CLI commands come from **Toolkit Purpose**, NOT from specification workflow.

```markdown
### CLI Commands

**Key Distinction**:
- **Slash Commands** â†’ From specification workflow (define-requirements, create-design)
- **CLI Commands** â†’ From toolkit function (init, check, list, validate)

---

**STEP 0: Reference AGENTS.md Standards** â­ NEW

**Before defining CLI commands, verify alignment with AGENTS.md**:

#### Quick Compliance Check

```bash
# Read project's AGENTS.md for consistency requirements
read_file("AGENTS.md")
```

**Key Requirements**:
- `init` command MUST create complete project structure (not single file)
- Project MUST include: `.{toolkit}/`, `memory/`, `specs/` directories
- CLI workflow MUST align with AGENTS.md guidance

**For Generator/Scaffolder toolkits**: See detailed `init` command standards below (Line 676-844).

**Common Mistake to Avoid**:
```bash
âŒ {toolkit-name} init my-spec.yaml    # Creates single file only
âœ… {toolkit-name} init my-project      # Creates complete structure
```

---

**STEP 1: Define Toolkit Type**

**Question: What type of tool is this toolkit?**

Select primary toolkit type(s):

- [ ] **Generator/Scaffolder** - Creates projects, initializes structures
  - Example: Specify (`specify init`), MetaSpec (`metaspec init`)
  
- [ ] **Environment Checker** - Verifies system setup, dependencies
  - Example: Specify (`specify check`)
  
- [ ] **Validator** - Validates against specification schemas
  - Example: OpenSpec (`openspec validate`)
  
- [ ] **Query/Reference Tool** - Provides specification information
  - Example: OpenSpec (`openspec show`, `openspec list`)
  
- [ ] **State Manager** - Manages project/spec state
  - Example: OpenSpec (`openspec update`)
  
- [ ] **Community Platform** - Connects to package registry
  - Example: MetaSpec (`metaspec search`, `metaspec install`)

---

**STEP 2: CLI Command Naming Principles**

#### ğŸ† Golden Reference: GitHub spec-kit

**Before designing commands, study the gold standard**: [GitHub spec-kit](https://github.com/github/spec-kit)

**Why spec-kit is the reference**:
- âœ… Only 2 commands: `init`, `check`
- âœ… Minimalist but feature-complete
- âœ… Excellent user experience
- âœ… Widely adopted in production

**Key lessons**:
1. `init` provides complete project initialization
2. `check` unifies ALL validation functions (not split into validate/verify/lint)
3. Extend via parameters, don't create new commands
4. Command names are natural and intuitive

**Design principle**: Unless you have a compelling reason, follow spec-kit's minimalist design

---

#### Core Naming Principles

**1. Prioritize Industry Best Practices**

Some command names are **industry standards**, not "fixed names to avoid":

| Standard Command | Use For | Examples |
|-----------------|---------|----------|
| `init` | Project generation | spec-kit, MetaSpec, Specify |
| `check`/`validate` | Validation/verification | spec-kit, OpenSpec |
| `list`/`show` | Query/display | OpenSpec, MetaSpec |
| `search`/`install` | Community platform | MetaSpec, npm, pip |

**âœ… DO**: Use standard names when they fit  
**âŒ DON'T**: Create unnecessary variations (`examine`, `inspect`, `verify`) just to be "different"

---

### init Command Standard Definition â­ NEW

**If toolkit type is "Generator/Scaffolder"**, the `init` command **MUST** follow these standards:

#### Mandatory Requirements

**1. Argument Format**:
```bash
{toolkit-name} init <project-directory> [OPTIONS]
```
- âœ… Argument MUST be a **directory name**, not a filename
- âŒ FORBIDDEN: `init <filename>`
- âŒ FORBIDDEN: `init` (without argument, unless using --interactive flag)

**2. Output Structure** (MUST create):
```
<project-directory>/
â”œâ”€â”€ .{toolkit-name}/           # Configuration directory
â”‚   â”œâ”€â”€ commands/              # Slash commands for AI (MUST deploy)
â”‚   â””â”€â”€ templates/             # (Optional) Output templates
â”œâ”€â”€ memory/
â”‚   â””â”€â”€ constitution.md        # Project principles (MUST have content)
â”œâ”€â”€ specs/
â”‚   â””â”€â”€ README.md              # Workflow guidance (NOT spec template)
â””â”€â”€ README.md                  # Project documentation
```

**3. constitution.md Content**:
- âœ… MUST be pre-filled with template content
- âœ… MUST include project development principles
- âœ… MUST be domain-specific guidance
- âŒ FORBIDDEN: Empty file or placeholder

**4. specs/README.md Content** (See "Generator vs AI Commands" below):
- âœ… MUST explain how to use slash commands for spec generation
- âœ… MUST include workflow guidance and examples
- âœ… MUST guide users to AI-driven specification creation
- âŒ FORBIDDEN: Empty spec templates or example specs

**5. Output Messages**:
```
âœ“ Created '{project-name}/' with standard structure

Next steps:
  1. cd {project-name}
  2. Edit memory/constitution.md to define your principles
  3. Use AI to generate specifications (see specs/README.md)
     Example: "Create a Q1 campaign specification"
  4. AI will generate specs/001-xxx/spec.{format}
  5. Run: {toolkit-name} validate specs/001-xxx/spec.{format}
```

#### Implementation Checklist

When generating spec.md, verify:

- [ ] init parameter is `<project-dir>`, NOT `<filename>`
- [ ] Output includes `.{toolkit}/`, `memory/`, `specs/` directories
- [ ] `memory/constitution.md` has pre-filled content (not empty)
- [ ] `specs/README.md` contains workflow guidance (NOT spec template)
- [ ] `.{toolkit}/commands/` contains deployed slash commands
- [ ] Project `README.md` explains project structure and usage
- [ ] Success message guides user to AI-driven workflow

#### Anti-Patterns (FORBIDDEN)

**âŒ Wrong Example 1: File-only creation**
```bash
{toolkit-name} init my-spec.yaml
# Output: Creates only my-spec.yaml (single file)
# Problem: Does not create project structure
# Violation: Missing .{toolkit}/, memory/, README.md
```

**âŒ Wrong Example 2: Missing required directories**
```bash
{toolkit-name} init my-project
# Output: my-project/spec.yaml (only one file)
# Problem: Missing required directories
# Violation: No memory/, .{toolkit}/, README.md
```

**âŒ Wrong Example 3: Empty constitution.md**
```bash
{toolkit-name} init my-project
# Output: memory/constitution.md exists but is empty
# Problem: Should include template content
# Violation: Empty constitution.md violates standard
```

#### Correct Implementations

**âœ… Correct Example 1: MetaSpec**
```bash
metaspec init my-speckit
# Output:
my-speckit/
â”œâ”€â”€ .metaspec/
â”‚   â””â”€â”€ commands/          # âœ… Slash commands deployed
â”‚       â”œâ”€â”€ sds.specify.md
â”‚       â”œâ”€â”€ sds.plan.md
â”‚       â””â”€â”€ ... (19 commands)
â”œâ”€â”€ memory/
â”‚   â””â”€â”€ constitution.md    # âœ… Pre-filled with 3-part template
â”œâ”€â”€ specs/
â”‚   â””â”€â”€ README.md          # âœ… Workflow guidance (NOT spec template)
â””â”€â”€ README.md              # âœ… Usage instructions

âœ… Creates infrastructure only
âœ… NO spec templates or example specs
âœ… User generates specs via AI + slash commands
```

**âœ… Correct Example 2: spec-kit**
```bash
spec-kit init
# Initializes in current directory
# Output:
.speckit/
memory/constitution.md
specs/
README.md

âœ… Initializes in place
âœ… Creates standard structure
```

#### Special Case: Non-Generator Toolkits

**If toolkit type is NOT "Generator/Scaffolder"**, init may have different behavior:

- **Validator-only toolkit**: `init` may create single spec file
- **Query tool**: May not have `init` command at all
- **State manager**: `init` may initialize state file

**Key distinction**: Only "Generator/Scaffolder" type MUST follow full project structure creation.

#### Reference Alignment

This standard ensures:
- âœ… Consistency with AGENTS.md "Recommended Project Structure"
- âœ… Alignment with MetaSpec and spec-kit patterns
- âœ… Clear user expectations across all speckits
- âœ… Prevention of common mistakes (file-only creation)

---

**2. Prefer Unified Commands (spec-kit approach)**

âŒ **Don't**: `validate-req`, `validate-design`, `validate-project` (3 commands)  
âœ… **Do**: `check <target> [--type TYPE]` (1 unified command)

ğŸ’¡ **See detailed guidelines** in "Unified vs Specialized Commands" section below

---

#### Real Project Examples

| Project | Toolkit Type | Actual Commands | Insight |
|---------|-------------|-----------------|---------|
| **ğŸ† spec-kit** (GitHub) | Workflow Tool | `init` - Initialize project<br>`check` - Unified validation | **Gold standard**: 2 commands, minimalist design |
| **Specify** | Generator<br>+ Checker | `init` - Create project<br>`check` - Verify tools | Follows spec-kit pattern |
| **OpenSpec** | Validator<br>+ Query<br>+ Manager | `validate` - Check proposal<br>`list` - Show proposals<br>`show` - Display details<br>`update` - Sync state | State-management oriented |
| **MetaSpec** | Generator<br>+ Community | `init` - Generate speckit<br>`search` - Find packages<br>`install` - Get from community<br>`contribute` - Share speckit<br>`list`, `info`, `version` | Community platform (7 commands justified) |

**Key Insight**: spec-kit shows that 2 well-designed commands can be complete

---

#### Unified vs Specialized Commands

**Critical design decision**: When to combine functions into one command vs splitting into multiple commands

**When to UNIFY into one command** âœ…:

**1. Similar functions, different objects**
```bash
# âŒ Over-specialized (3 commands)
validate-requirements
validate-design
validate-project

# âœ… Unified (1 command)
check <target> [--type TYPE]
```

**2. Sequential workflow, users run together**
```bash
# âŒ Split (2 commands)
validate
check-transition

# âœ… Unified (1 command)
check [--phase PHASE]
```

**3. Same underlying logic**
```bash
# âŒ Separated (multiple commands)
list-servers
list-tools
list-resources

# âœ… Unified (1 command)
list <entity-type>
```

**When to SPLIT into separate commands** âœ…:

**1. Completely different functions**
```bash
# âœ… Keep separate
init      # Creates project
check     # Validates project
# These are fundamentally different operations
```

**2. Different user contexts**
```bash
# âœ… Keep separate  
search    # Browse community (discovery)
install   # Get package (action)
# Users have different mindsets for these
```

**3. Different permission levels**
```bash
# âœ… Keep separate
validate  # Read-only
publish   # Requires credentials
```

**Real-world example: spec-kit's `check` command**

spec-kit unifies ALL validation into one command:
```bash
check requirements
check design  
check project
check transition
# All use the same underlying validation logic
```

This is better than:
```bash
# âŒ Over-engineered
validate-requirements
validate-design
validate-project
check-transition
```

**Command Count Guidance**:

| Toolkit Type | Recommended Count | Rationale |
|-------------|------------------|-----------|
| **Workflow Tool** | 1-2 commands | spec-kit model: `init` + unified `check` |
| **Validator + Query** | 2-3 commands | Add `list`/`show` if needed |
| **Community Platform** | 5-7 commands | Social features need dedicated commands |

âš ï¸ **Warning**: If you have >7 commands, reconsider if some can be unified

---

**STEP 3: Specification-Influenced CLI Parameters**

**Specification content can influence command parameters** (not command names):

**If specification defines entity types**:
```bash
# Specification has: Server, Tool, Resource entities
{toolkit-name} show <entity-type>     # show server | tool | resource
{toolkit-name} init <entity-type>     # init server | tool
```

**If specification has structured sections**:
```bash
# Specification has: Overview, Entities, Operations, Examples sections
{toolkit-name} docs [section]         # docs entities | docs operations
```

**If specification defines workflow phases**:
```bash
# Specification has: Phase 1, Phase 2, Phase 3
{toolkit-name} status                 # Show current phase
{toolkit-name} next                   # Move to next phase
```

**Key Principle**: 
- Specification influences **parameters and options**
- NOT command names (those come from toolkit purpose)
- Use specification's actual terminology in parameters

---

**STEP 4: Define CLI Implementation**

**For each derived command, specify**:

```markdown
### Command: {command-name}

**Purpose**: {What this command does}

**Usage**:
\```bash
{toolkit-name} {command} [arguments] [options]
\```

**Arguments**:
- arg1: (required) Description
- arg2: (optional) Description

**Options**:
- --option1: Description
- --option2: Description

**Example**:
\```bash
{toolkit-name} {command} example-arg --option1 value
\```

**Implementation Notes**:
- Uses: {library/framework}
- Output: {format}
- Exit codes: 0 (success), 1 (error)
```

---

**CLI vs Slash Commands**: See Component 4 below for detailed distinction. Summary: CLI = independent tools, Slash = AI execution guides, separated by design.

---

##### **Component 4: Slash Commands - Spec-Driven Execution (CRITICAL for AI-Oriented Tools)**

**Component Structure**:
- **Overview**: What Slash Commands are and dual-source architecture
- **[Source 1](#source-1-specification-derived-commands-custom)**: Specification-Derived Commands (7-STEP process)
- **[Source 2](#source-2-library-selected-commands-reusable)**: Library-Selected Commands (Selection & Adaptation)

**CRITICAL UNDERSTANDING**: Slash Commands are **NOT** CLI usage manuals. They are **spec-driven execution guides** that embed specification knowledge and guide AI to produce spec-compliant outputs.

```markdown
### Slash Commands

**What they are**: Spec-driven execution guides with embedded specification knowledge
**Where they go**: `templates/{source}/commands/` directory (organized by specification system source)  
**How AI uses them**: Via `/` prefix in AI chat (Cursor, Windsurf, etc.)
**Core purpose**: Guide AI to **produce outputs that comply with domain specifications**

**Key Distinction**:
- âŒ **NOT**: "How to call CLI commands" (wrapper documentation)
- âœ… **YES**: "How to execute according to specification specs" (spec-driven guidance)

**When to Include**:
- âœ… Primary users are AI agents
- âœ… Tool enforces a specific specification/specification
- âœ… Outputs must comply with validation rules
- âœ… Multi-step workflows require specification knowledge

---

### ğŸ“‹ Frontmatter Fields (YAML Metadata)

All slash commands support frontmatter metadata (inspired by [Claude Code slash commands](https://code.claude.com/docs/en/slash-commands)):

| Field | Required | Description | Example |
|-------|----------|-------------|---------|
| `description` | âœ… Yes | Brief description (shown in `/help`) | `"Create feature specification"` |
| `argument-hint` | âš ï¸ Recommended | Show expected arguments | `[feature-description]` or `[pr-number] [priority]` |
| `scripts` | Optional | Cross-platform scripts | `sh: scripts/bash/script.sh`<br>`ps: scripts/powershell/script.ps1` |
| `allowed-tools` | Optional | Restrict tools (security) | `Bash(git:*), FileEdit(specs/*)` |
| `model` | Optional | Specify AI model | `claude-3-5-sonnet-20241022` |

**Argument Access Patterns**:
- `$ARGUMENTS` - All arguments as single string (e.g., "arg1 arg2 arg3")
- `$1`, `$2`, `$3` - Individual positional arguments (like shell scripts)
- `{ARGS}` - Escaped for safe script execution

**Example frontmatter**:
\```yaml
---
description: Review pull request with priority
argument-hint: [pr-number] [priority] [assignee]
allowed-tools: Bash(git:*), FileEdit(docs/*)
model: claude-3-5-sonnet-20241022
---
\```

---

### ğŸ¯ Dual-Source Architecture (Composable Spec Systems)

**IMPORTANT**: Slash Commands come from **TWO sources** and can be **composed**:

#### Source 1: Specification-Derived (Custom)
- **From**: SDS domain specification (`specs/domain/`)
- **Nature**: Dynamic, specification-specific, tailored
- **Process**: Analyze specification â†’ Derive commands
- **Examples**: `get-template`, `validate`, workflow actions

#### Source 2: Library-Selected (Reusable)
- **From**: MetaSpec template library (`library/`)
- **Nature**: Pre-built, domain-specific, reusable
- **Process**: Select specification system â†’ Adapt to toolkit
- **Examples**: Generic SD-X, Spec-Kit workflow, OpenSpec evolution

#### Composition Strategy

```
Choose one or combine:

Option A: Specification-Only (Custom)
  â†’ Derive all commands from specification
  â†’ Fully tailored to domain
  â†’ Example: Domain-specific commands from specification phases

Option B: Library-Only (Reusable)
  â†’ Use pre-built spec system
  â†’ Quick start, proven patterns
  â†’ Example: Generic SD-X workflow

Option C: Composed (Recommended)
  â†’ Base: Library spec system
  â†’ Extension: Specification-derived commands
  â†’ Example: Generic workflow + specification-specific commands
```

**MetaSpec's Composability**:
- MetaSpec itself uses `meta/` spec system (19 commands)
- Spec-Kit uses `library/sdd/spec-kit/` spec system
- OpenSpec uses `library/sdd/openspec/` spec system
- Your speckit can choose/compose these systems

---

#### Source 1: Specification-Derived Commands (Custom)

**Overview**: Derive commands by analyzing your domain specification and extracting domain-specific terminology.

---

### ğŸš¨ CRITICAL: Determine Toolkit Type First â­ NEW (v0.7.2+)

**Before analyzing specification**, determine toolkit type to avoid generating wrong command patterns.

#### Type A: Data-Access Toolkit (Rare)

**Purpose**: Provide API access to existing data  
**Examples**: REST API client, Database ORM  
**Commands**: Entity operations (CRUD)  
**Pattern**: `/{domain}.{entity}.{operation}`

```bash
# Example: API client
/api.user.get
/api.user.create
/api.post.list
```

**When to use**:
- âŒ Toolkit accesses existing data store
- âŒ Provides CRUD operations on data
- âŒ Not for specification creation

#### Type B: Workflow-Guidance Toolkit (Speckit Standard) â­ RECOMMENDED

**Purpose**: Guide users to create and manage specifications  
**Examples**: spec-kit, MetaSpec, domain-specific speckits  
**Commands**: Workflow actions  
**Pattern**: `/{domain}spec.{action}` or `/{domain}.{action}`

```bash
# Example: spec-kit (real project - adapt to your domain)
/speckit.constitution
/speckit.specify
/speckit.clarify
/speckit.plan
/speckit.tasks
/speckit.implement
/speckit.checklist
/speckit.analyze
```

**When to use**:
- âœ… Toolkit guides specification creation (THIS IS WHAT YOU WANT!)
- âœ… Provides workflow commands
- âœ… Follows spec-kit / MetaSpec pattern
- âœ… Reference: MetaSpec itself uses this pattern

#### How to Choose?

**Ask yourself**:

Q: Is this toolkit helping users **create specifications**?  
âœ… YES â†’ **Type B: Workflow-Guidance** (Use workflow commands)  
âŒ NO â†’ Continue to next question

Q: Is this toolkit providing **API access** to existing data?  
âœ… YES â†’ **Type A: Data-Access** (Use entity operations)  
âŒ NO â†’ Type B is correct

**Default for Speckits**: âœ… **Type B: Workflow-Guidance**

**ğŸ¯ Key Insight**: 
- Domain spec's **entities** = specification structure (WHAT to specify)
- Toolkit's **commands** = workflow actions (HOW to create specs)
- **NOT**: Entity CRUD operations

---

**CHECKPOINT** âš ï¸

**Before proceeding to STEP 1, confirm toolkit type**:

- [ ] I have determined this is Type B: Workflow-Guidance toolkit
- [ ] I understand domain entities are specification structures, not data objects
- [ ] I will derive workflow commands, not entity operations
- [ ] I have reviewed MetaSpec's own command structure as reference

**If you selected Type A**: This is rare for speckits. Double-check your decision.

**If you selected Type B**: âœ… Continue to STEP 1 (most common for speckits)

---

**STEP 1: Analyze Domain Specification**

**Before defining Slash Commands**, analyze the SDS domain specification in `specs/domain/`.

**Questions to Ask**:

1. **Specification Complexity**
   - [ ] Does the specification define complex rules and constraints?
   - [ ] Will AI need to reference these rules repeatedly?
   - **If YES** â†’ Need commands to access specification knowledge

2. **Specification Structure** (For Reference Only)
   - [ ] Does the specification define multiple entity types?
   - [ ] Do entities have specific structures (schemas, fields, validation)?
   - **Purpose**: Understand specification complexity
   - **âš ï¸ CRITICAL - For Type B (Workflow-Guidance) Toolkits**:
     - Entities are **specification structures**, not data objects
     - âŒ Do NOT generate entity operation commands
     - âœ… Instead, generate workflow commands that guide users to create these entities
   - **Example**:
     - Domain spec defines: Project, Campaign, Channel entities
     - âŒ Wrong: Generate `/domain.project`, `/domain.campaign` commands (entity operations)
     - âœ… Right: Generate `/domainspec.constitution`, `/domainspec.specify` commands (workflow actions, adapted from spec-kit pattern)

3. **Validation Rules**
   - [ ] Does the specification specify validation constraints?
   - [ ] Must outputs be validated against schemas?
   - **If YES** â†’ Need validation commands

4. **Workflows & Phases** â­ CRITICAL FOR TYPE B

   **For Type B (Workflow-Guidance) toolkits - THIS IS WHAT YOU WANT!**
   
   **First, check your Domain Specification** (specs/domain/001-*/spec.md):
   - [ ] Does it have a "Specification Usage Workflow" section? (Should be Type 2 workflow, not entity state machines)
   - [ ] Does this workflow define the end-to-end process of creating specifications?
   - [ ] Are workflow steps defined at action level (8-12 steps typical)?
   - **If YES** â†’ âœ… **Perfect! Use this workflow directly to derive commands**
   - **If NO** â†’ âš ï¸ **Go back to Domain Spec and define it first** (use `/metaspec.sds.specify` guidance)
   
   **Key Question to Ask**:
   > "The domain spec defines entities and rules. What is the recommended workflow for users to create specifications using these entities?"
   
   Expected answer should provide:
   - Step-by-step process (8-12 steps)
   - Each step's goal, inputs, outputs
   - Quality checkpoints
   - Entities involved in each step
   - Command naming pattern
   
   **If this workflow is ALREADY in your Domain Spec** â†’ Just map it to commands!
   **If NOT** â†’ You need to define it in Domain Spec first (MetaSpec SDS workflow is the pattern)
   
   **How to Derive** (MetaSpec's Own Pattern - Dogfooding):
   
   ```
   Specification Workflow Phase â†’ Command Verb â†’ Command Name
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   CONSTITUTION principles      â†’ constitution  â†’ /metaspec.sds.constitution
   SPECIFY requirements         â†’ specify       â†’ /metaspec.sds.specify
   CLARIFY ambiguities          â†’ clarify       â†’ /metaspec.sds.clarify
   PLAN architecture            â†’ plan          â†’ /metaspec.sds.plan
   CREATE tasks                 â†’ tasks         â†’ /metaspec.sds.tasks
   IMPLEMENT solution           â†’ implement     â†’ /metaspec.sds.implement
   CHECK quality                â†’ checklist     â†’ /metaspec.sds.checklist
   ANALYZE results              â†’ analyze       â†’ /metaspec.sds.analyze
   ```
   
   **Key Principle**: If specification phases are **verb-able actions**, derive commands directly.
   
   **Example - spec-kit Pattern** (Adapt to Your Domain):
   ```
   Specification Workflow Phase â†’ Command Verb â†’ Command Name
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   CONSTITUTION principles      â†’ constitution  â†’ /speckit.constitution
   SPECIFY requirements         â†’ specify       â†’ /speckit.specify
   CLARIFY ambiguities          â†’ clarify       â†’ /speckit.clarify
   PLAN architecture            â†’ plan          â†’ /speckit.plan
   CREATE tasks                 â†’ tasks         â†’ /speckit.tasks
   IMPLEMENT solution           â†’ implement     â†’ /speckit.implement
   CHECK quality                â†’ checklist     â†’ /speckit.checklist
   ANALYZE results              â†’ analyze       â†’ /speckit.analyze
   ```
   
   **ğŸ¯ Adaptation Principle**: Use spec-kit's 8-phase workflow as a base, then customize:
   - Keep core phases (constitution, specify, plan, implement)
   - Adapt command names to your domain terminology
   - Add/remove phases based on domain requirements
   - Example: Marketing domain might add "research" or "campaign" phases
   
   **âš ï¸ Anti-Pattern to Avoid**:
   ```
   âŒ WRONG: Deriving from domain entities
   Domain has: Project, Campaign, Channel
   â†’ Generating: /domain.project, /domain.campaign, /domain.channel
   This creates a data-access tool, not a workflow-guidance tool!
   
   âœ… RIGHT: Deriving from workflow phases (adapt spec-kit pattern)
   Base workflow: constitution â†’ specify â†’ clarify â†’ plan â†’ tasks â†’ implement
   Adapt to domain: Add domain-specific phases as needed
   â†’ Generating: /domainspec.constitution, /domainspec.specify, /domainspec.clarify, etc.
   This creates a workflow-guidance tool (Speckit standard)!
   ```
   
   **Note**: MetaSpec itself was built this way - we eat our own dog food.

5. **Examples & Templates**
   - [ ] Does the specification include examples or templates?
   - [ ] Will AI need to reference these?
   - **If YES** â†’ Need commands to retrieve examples

---

**STEP 1 Checklist** âœ…

**Complete this analysis before moving to STEP 2**:

**Specification Understanding**:
- [ ] Identified all specification entities (Server, Tool, Resource, etc.)
- [ ] Listed all specification operations (initialize, list, call, etc.)
- [ ] Documented validation rules (schemas, constraints)

**Workflow Analysis** (CRITICAL):
- [ ] Determined workflow type:
  - [ ] Type A (State Machine): Abstract states â†’ navigation commands
  - [ ] Type B (Action Sequence): Concrete actions/phases â†’ action commands
  - [ ] Type C (Composed): Both patterns
  
**If Type B detected**:
- [ ] Listed all workflow phases/actions
- [ ] Confirmed phases are "verb-able" (can become command verbs)
- [ ] Prepared phase-to-command mapping

**Mapping Example** (for Type B):
```
Specification Phase     â†’ Command Verb â†’ Command Name         â†’ With Namespace
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SPECIFY feature    â†’ specify      â†’ specify              â†’ sdd.specify
CLARIFY ambiguity  â†’ clarify      â†’ clarify              â†’ sdd.clarify
PLAN architecture  â†’ plan         â†’ plan                 â†’ sdd.plan
IMPLEMENT code     â†’ implement    â†’ implement            â†’ sdd.implement
```

**Why This Matters**:
- âŒ Skipping this analysis â†’ Generic commands without domain context
- âœ… Complete analysis â†’ Simple, memorable commands derived from specification phases
- ğŸ’¡ Use simple verbs; add namespace if needed; context goes in help text

---

### âš ï¸ ANTI-PATTERNS TO AVOID â­ NEW (v0.7.2+)

**Before proceeding to command naming**, review these common mistakes:

#### Anti-Pattern 1: Entity-Based Commands (For Type B Toolkits)

**âŒ WRONG**: Deriving from domain entities â†’ `/domain.project`, `/domain.product`  
**âœ… RIGHT**: Deriving from workflow phases â†’ `/domainspec.constitution`, `/domainspec.specify`

**Key difference**: Entity commands = data access; Workflow commands = specification guidance

**See "Type B: Workflow-Guidance Toolkit" above (Line 1176-1234) for complete explanation.**

#### Anti-Pattern 2: Forgetting MetaSpec's Own Pattern

MetaSpec uses workflow commands (`/metaspec.sds.specify`), NOT entity operations.  
**Your toolkit should follow the same pattern**.

#### Anti-Pattern 3: Missing Workflow Analysis

If you skipped "Workflows & Phases" analysis (Step 1, Item 4):
- âš ï¸ STOP and go back
- Workflow is CORE for Type B toolkits

---

**ğŸ¯ Golden Rule for Type B Toolkits**:

1. **Start with spec-kit pattern** (proven workflow: 8 phases)
2. **Adapt to your domain** (rename phases, add domain-specific steps)
3. **Never derive from entities** (entities are specification structures, not commands)
4. **Always derive from workflow** (phases/actions â†’ commands)

**Example Adaptation**:
```
spec-kit base:      /speckit.constitution â†’ specify â†’ clarify â†’ plan â†’ tasks â†’ implement â†’ checklist â†’ analyze
Marketing domain:   /marketspec.constitution â†’ discover â†’ strategy â†’ design â†’ content â†’ execute â†’ measure â†’ optimize
API Testing domain: /apispec.constitution â†’ define â†’ schema â†’ test â†’ mock â†’ validate â†’ document â†’ deploy
```

**Key insight**: spec-kit's workflow is a template, not a requirement. Customize freely!

---

**STEP 2: Derive Command Names from Specification**

**CRITICAL**: âŒ **DON'T use generic names** (get-spec, get-template, validate)  
            âœ… **DO extract domain-specific names** from specification terminology

**Why This Matters**:
- Generic names lose domain meaning
- Real projects use domain-specific terminology
- Better developer experience with familiar terms

---

**Command Naming Process**:

1. **Read Specification Content**
   - Workflow phases: "Define Server", "Configure Endpoints"
   - Entity names: "Server", "Tool", "Resource"
   - Operations: "Initialize", "Validate", "Deploy"

2. **Extract Verb + Noun Pairs**
   - "Define Server" â†’ verb: define, noun: server
   - "Configure Endpoints" â†’ verb: configure, noun: endpoints
   - "Validate Configuration" â†’ verb: validate, noun: configuration

3. **Form Simple Command Names**
   - Single verbs: `specify`, `plan`, `validate`
   - Or use specification's exact terminology (keep simple)

---

**Real Project Command Naming Patterns**:

| Project | Pattern | Examples | Use Case | Insight |
|---------|---------|----------|----------|---------|
| **MetaSpec** | Namespaced Verbs | `sdd.specify`<br>`sdd.clarify`<br>`sdd.plan`<br>`sdd.implement`<br>`sdd.analyze` | Multi-layer systems | **Simple verbs + namespace** (dogfooding) |
| **OpenSpec** | Domain Verbs | `proposal`<br>`apply`<br>`archive` | Single-domain tools | **Domain-specific single verbs** |

**Key Insights**: 
- âœ… **Two proven patterns**: Use namespaces for multi-layer systems, domain verbs for focused tools
- âœ… **Keep verbs simple**: `specify` not `specify-feature`, `plan` not `plan-implementation`
- âœ… **Context in help text** - not in command names (e.g., `specify --help` shows detailed context)

---

**Command Purpose Categories** (for guidance, NOT fixed names):

| Specification Contains | Command Purpose | Naming Examples | When to Include |
|------------------|----------------|-----------------|-----------------|
| **Workflow phases** | Execute phase actions | MetaSpec: `specify`, `clarify`, `plan`<br>Generic: `design`, `build`, `test` | Always (if workflow exists) |
| **Validation** | Validate outputs | MetaSpec: `analyze`, `checklist`<br>Generic: `validate`, `verify`, `lint` | If validation rules exist |
| **Multi-step process** | Navigate process | Generic: `next`, `status`, `rollback`<br>Lifecycle: `init`, `deploy`, `cleanup` | If state machine workflow |
| **Reference docs** | Access knowledge | Generic: `docs`, `show`, `reference`<br>Query: `list`, `search`, `info` | If complex docs (20+ pages) |

**Key Principle**: Use specification's own vocabulary, don't impose generic names

---

**Quick Reference**:
```markdown
Specification workflow: "Specify Feature" â†’ Command: `specify` (simple verb)
Specification phases: "Plan Architecture" â†’ Command: `plan` (phase becomes command)
Specification validation: "Check Quality" â†’ Command: `checklist` (domain-specific verb)

Key principle: Extract simple verbs from specification phases/actions
```

---

**STEP 3: Classify Commands (Slash + CLI/Script Support)**

**CRITICAL**: Slash Commands are for AI execution. CLI/Scripts provide optional support.

**Command Types** (based on real projects: Spec-Kit, OpenSpec, MetaSpec):

| Type | AI Role | Support | Slash? | CLI? | Script? | Example |
|------|---------|---------|--------|------|---------|---------|
| **Pure-Execution** | Produces content | None | âœ… Yes | âŒ No | âŒ No | `define-requirements` |
| **Script-Assisted** | Produces content | Shell scripts | âœ… Yes | âŒ No | âœ… Yes | Spec-Kit's `specify` |
| **CLI-Referenced** | Produces + validates | Independent CLI | âœ… Yes | âœ… Yes | âŒ No | OpenSpec's `proposal` |

**Classification Decision Tree**:

```
For each derived command, ask:

1. Does AI need to produce structured content?
   âœ… YES â†’ Continue to Q2
   âŒ NO â†’ This is likely a pure CLI tool (skip Slash)

2. Does it need file system setup (directories, skeleton)?
   âœ… YES â†’ Script-Assisted (create helper script)
   âŒ NO â†’ Continue to Q3

3. Should output be validated independently?
   âœ… YES â†’ CLI-Referenced (create validate CLI)
   âŒ NO â†’ Pure-Execution (Slash only)
```

**Key Insights from Real Projects**:

- **Spec-Kit**: Uses shell scripts for setup, AI for content
  ```bash
  /speckit.specify â†’ calls create-new-feature.sh â†’ AI fills content
  ```

- **OpenSpec**: AI produces, CLI validates independently
  ```bash
  /openspec.proposal â†’ AI creates â†’ User runs: openspec validate <id>
  ```

- **MetaSpec**: Pure AI execution, CLI for other purposes
  ```bash
  /metaspec.sdd.specify â†’ AI produces spec.md (no CLI needed)
  metaspec init â†’ Separate CLI for generation
  ```

**Classification Result**:

```markdown
For each derived command, classify as:

- **Pure-Execution**: AI produces content â†’ Slash only
  - Example: specify, plan, design (most common)
  
- **Script-Assisted**: Need structure setup â†’ Script + Slash
  - Example: init-project (if creating directories)
  
- **CLI-Referenced**: Need independent validation â†’ CLI + Slash
  - Example: validate command (See **Component 3, STEP 2: Derive CLI Commands from Toolkit Purpose** for CLI design)

**Typical Counts**:
- Slash Commands: 4-8
- Helper Scripts: 1-2 (if Script-Assisted)
- CLI Commands: 3-5 (if CLI-Referenced, defined in Component 3)
```

---

**STEP 4: Implement Support Tools (CLI + Scripts)**

**IMPORTANT**: CLI commands should be fully defined in **Component 3: CLI Commands** first.  
This section covers implementation of support tools specifically for Slash Commands.

**Cross-Reference**: See **Component 3: CLI Commands** for complete CLI command specification.

**This section covers**:
- 4a. CLI Commands (CLI-Referenced Pattern only - subset of Component 3)
- 4b. Helper Scripts (Script-Assisted Pattern only)

---

**Implement based on command classification**:

**4a. CLI Commands (CLI-Referenced Pattern)**

**Cross-Reference**: This is a subset of CLI commands defined in **Component 3: CLI Commands**.

**Context**: When STEP 3 identifies "CLI-Referenced Pattern" commands, implement the associated CLI tools here.

**From Component 3**: Follow the **CLI Command Derivation Process** (Component 3, STEP 1-4) to fully define these CLI commands before implementing.

**Purpose**: Independent tools for validation, querying, display

```markdown
### CLI Implementation Checklist

**Independent CLI Tools** (user calls directly):

Based on your toolkit functions (from **Component 3, STEP 1: Define Toolkit Type**), implement:

- [ ] **Validation**: validate <file>, check, lint
  - Validate against specification schema
  - Independent verification tool

- [ ] **Information Display**: show [section], docs <topic>, help
  - Display specification documentation
  - Provide reference information

- [ ] **Query**: list {type}, info
  - List available entities/examples
  - Show specification information

**Naming Reminder**:
- âŒ Don't hardcode: get-spec, get-template, get-example
- âœ… Choose intuitive: show, docs, list, help
- âœ… Or domain-specific: show-spec, list-entities

**Implementation Guidelines**:
- These are **standalone tools**, not called by Slash Commands
- Focus on validation, querying, displaying
- Should work without AI involvement
- Users call them directly after AI produces content
```

**4b. Helper Scripts (Script-Assisted Only)**

**Purpose**: Set up file structure, create skeletons

```markdown
### Script Implementation Checklist

**Helper Scripts** (called by Slash Commands):
- [ ] scripts/setup-project.sh: Create project structure
- [ ] scripts/init-entity.sh <entity>: Create entity skeleton
- [ ] scripts/check-prerequisites.sh: Verify environment

**Script Guidelines**:
- Keep scripts simple (directory creation, file copying)
- AI does content production, scripts do structure
- Example from Spec-Kit:
  ```bash
  # scripts/setup-project.sh
  mkdir -p specs/ templates/ docs/
  cp templates/spec-template.md specs/
  echo "Structure ready for AI to fill"
  ```
```

**Key Principle**: **Slash Commands don't "call" CLI**. CLI and Scripts are separate support tools.

---

**STEP 5: Create Spec-Driven Slash Commands (All Types)**

**Based on classification in STEP 3**, create appropriate Slash Command templates for each type.

**Reference**: See **STEP 3: Classify Commands** above for command type definitions (Pure-Execution, Script-Assisted, CLI-Referenced).

---

##### Template 1: Pure-Execution Slash Commands (Most Common)

```markdown
---
description: Brief description of what this command does
argument-hint: [arg1] [arg2]  # Optional: show expected arguments
allowed-tools: Bash(git:*), FileEdit(specs/*)  # Optional: restrict tools
model: claude-3-5-sonnet-20241022  # Optional: specify model
---

# /{toolkit-name}.{command}

## User Input

\```text
$ARGUMENTS
\```

You **MUST** consider the user input before proceeding (if not empty).

**Argument Access**: `$ARGUMENTS`, `$1`, `$2`, `$3` (see [Frontmatter Fields](#frontmatter-fields-yaml-metadata) above)

## Purpose
{What specification-compliant output to produce}

## Domain Specification (EMBEDDED)
**From**: specs/domain/{XXX}/spec.md

### Entity Structure
[Copy entity definition from specification]
- field1: type (required) - description
- field2: type (optional) - description
- Constraints: [Specification constraints]

### Validation Rules
- VR001: {Rule from specification}
- VR002: {Rule from specification}

### Examples
[Specification examples]

## AI Execution Steps
1. **Understand User Intent**
   - Extract key information
   - Map to specification entity

2. **Apply Specification Rules**
   - Check constraint 1
   - Ensure constraint 2

3. **Structure Output**
   - Follow entity schema
   - Include required fields

4. **Self-Validate**
   - Verify against specification rules
   - Check all constraints met

## Output Template
\```json
{
  "field1": "...",  // From specification
  "field2": "..."   // Validated against VR001
}
\```

## Validation (Optional)
User can validate output independently:
\```bash
{toolkit-name} validate output.json
\```

## Related Commands
- /{toolkit}.get-spec - Reference full specification (if exists)
```

**Example**: MetaSpec's `/metaspec.sdd.specify`, OpenSpec's `/openspec.proposal`

---

##### Template 2: Script-Assisted Slash Commands (Spec-Kit Pattern)

```markdown
---
description: Brief description of what this command does
argument-hint: [arg1] [arg2]  # Optional: show expected arguments
scripts:
  sh: scripts/bash/{script-name}.sh --json "{ARGS}"
  ps: scripts/powershell/{script-name}.ps1 -Json "{ARGS}"
allowed-tools: Bash(*), FileEdit(*)  # Scripts need broader permissions
model: claude-3-5-sonnet-20241022  # Optional: specify model
---

# /{toolkit-name}.{command}

## User Input

\```text
$ARGUMENTS
\```

You **MUST** consider the user input before proceeding (if not empty).

**Argument Access**: `$ARGUMENTS`, `$1`, `$2`, `$3`, `{ARGS}` (see [Frontmatter Fields](#frontmatter-fields-yaml-metadata) above)

## Purpose
{What to produce, with script handling setup}

## Helper Script

**Cross-platform execution**:
\```bash
# Linux/Mac
scripts/bash/{script-name}.sh --json "$ARGUMENTS"

# Windows
scripts/powershell/{script-name}.ps1 -Json "$ARGUMENTS"
\```

**Script Purpose**: Set up file structure, create skeleton

## Domain Specification (EMBEDDED)
**From**: specs/domain/{XXX}/spec.md

[Copy relevant specification sections like Pure-Execution template]

## Execution Flow
1. **Call Helper Script**
   \```bash
   scripts/setup-{entity}.sh --name {entity-name}
   \```
   - Script creates: Directory structure, skeleton files
   - Script outputs: Paths to files AI should fill

2. **AI Produces Content**
   - Read script output (file paths)
   - Load domain specification
   - Fill skeleton with specification-compliant content

3. **Verify Structure**
   - Check all required files created
   - Validate against specification

## Output
- Structure: Created by script
- Content: Produced by AI

## Related Commands
- /{toolkit}.validate - Validate final output
```

**Example**: Spec-Kit's `/speckit.specify` (calls `create-new-feature.sh`)

---

##### Template 3: CLI-Referenced Slash Commands (Validation Reminder)

**Purpose**: Remind AI to suggest CLI validation after production

```markdown
---
description: Validate output against domain specifications
argument-hint: [file-to-validate]  # Optional: show expected arguments
allowed-tools: Bash({toolkit-name}:validate:*)  # Only allow validation tools
model: claude-3-5-haiku-20241022  # Can use lighter model for simple reminders
---

# /{toolkit-name}.validate

## User Input

\```text
$ARGUMENTS
\```

**Argument Access**: `$ARGUMENTS`, `$1` (see [Frontmatter Fields](#frontmatter-fields-yaml-metadata) above)

## Purpose
Remind AI to suggest validation after producing content

## When to Use
After AI has produced output via Pure-Execution commands

## What AI Should Do
1. Acknowledge content production complete
2. Suggest validation to user:
   \```
   "Content created successfully!
   
   To validate against {specification-name} schema, run:
     {toolkit-name} validate <file>
   "
   \```

## Available CLI Commands
- `{toolkit-name} validate <file>` - Validate against schema
- `{toolkit-name} get-spec` - View specification details
- `{toolkit-name} list` - List available entities

## Note
This Slash Command doesn't "call" CLI directly.
It teaches AI to suggest appropriate CLI commands to users.
```

**Example**: After `/speckit.define-requirements`, AI suggests `speckit validate requirements.json`

---

**STEP 6: Workflow-Specific Commands (Type B Only)**

**If specification defines Type B Workflow (Action Sequence)**, these workflow actions become **Pure-Execution Slash Commands**:

```markdown
Specification Workflow Example:
  phases:
    - Requirements:
        actions:
          - define_requirements   â† Action (verb)
          - clarify_requirements  â† Action (verb)
    - Design:
        actions:
          - create_design         â† Action (verb)
          - review_design         â† Action (verb)

Command Classification:
  - define-requirements â†’ Pure-Execution (AI produces)
  - clarify-requirements â†’ Pure-Execution (AI refines)
  - create-design â†’ Pure-Execution (AI produces)
  - review-design â†’ Pure-Execution (AI reviews)

Each Slash Command contains:
  - Specification knowledge for that phase
  - Entity structure for that artifact
  - Spec-driven execution steps
  - Validation rules for outputs
  - No CLI needed (AI produces directly)
```

**Judgment Rule**: 
- Workflow step is a **verb/action** â†’ Pure-Execution Slash Command
- Workflow step is a **noun/state** â†’ CLI-Backed navigation commands (`get-workflow`, `next-phase`)

---

**STEP 7: Final Command Inventory**

**Summarize all derived and classified commands**:

```markdown
## Command Inventory

### CLI Commands (Total: X)

**CLI-Backed** (Y commands):
- [ ] get-spec: Read specification files
- [ ] get-template: Read entity templates
- [ ] validate: Execute validation logic
- [ ] get-workflow: Query workflow state
- [ ] get-example: Read examples

**Hybrid** (Z commands):
- [ ] init: Create project structure

**Total CLI**: X = Y + Z

### Slash Commands (Total: X+N)

**CLI-Backed** (Y commands - matches CLI):
- [ ] /{toolkit}.get-spec.md
- [ ] /{toolkit}.get-template.md
- [ ] /{toolkit}.validate.md
- [ ] /{toolkit}.get-workflow.md
- [ ] /{toolkit}.get-example.md

**Hybrid** (Z commands - matches CLI):
- [ ] /{toolkit}.init.md

**Pure-Execution** (N commands - NO CLI):
- [ ] /{toolkit}.define-requirements.md
- [ ] /{toolkit}.clarify-requirements.md
- [ ] /{toolkit}.create-design.md
- [ ] /{toolkit}.generate-code.md
- ... (from workflow actions)

**Total Slash**: X + N
```

**Key Ratios**:
- CLI commands: 5-10 typical
- Slash commands: 10-20 typical
- Slash > CLI (this is expected!)

**Priority Guide**:
- P0 (Critical): get-spec, get-template, validate, workflow actions
- P1 (Important): get-workflow, get-example, init
- P2 (Skip): info, version (use CLI --help instead)

---

**Design Principles: Spec-Driven Execution**

1. **Embed Specification Knowledge**
   - âœ… Include entity definitions from specification
   - âœ… Copy validation rules into commands
   - âœ… Provide specification examples
   - âŒ Don't just say "call this CLI"

2. **Guide Spec-Compliant Production**
   - âœ… Show how to structure outputs per specification
   - âœ… Explain how to apply validation rules
   - âœ… Provide output templates from specification
   - âŒ Don't just describe CLI parameters

3. **Validate Against Specification**
   - âœ… Include validation checklists from specification
   - âœ… Self-check steps for AI
   - âœ… Clear compliance criteria
   - âŒ Don't rely on external validation only

**Quality Checklist**:
- [ ] Embeds specification knowledge (entities, rules, constraints)
- [ ] Guides spec-compliant output production
- [ ] Includes validation rules from specification
- [ ] Provides specification-based templates
- [ ] AI can produce compliant output without external reference

**Summary**: Source 1 provides a 7-STEP process to derive custom Slash Commands from your domain specification, ensuring domain-specific terminology and spec-driven execution.

---

#### Source 2: Library-Selected Commands (Reusable)

**Overview**: Select and adapt pre-built specification systems from MetaSpec's template library.

**Alternative/Complement to Specification-Derived**: Use pre-built specification systems from MetaSpec library.

**Why Simpler Process?**  
Unlike Source 1 (derive from scratch), Source 2 reuses proven commands. The process is:
1. **Select** appropriate library (based on domain/workflow)
2. **Adapt** variables to your domain
3. **Integrate** into your speckit

This is intentionally simpler than Source 1's 7-STEP derivation process.

---

**Discover Available Libraries**

**Library Location**: MetaSpec GitHub repository

**To explore available specification systems**:

1. **Browse library catalog online**:
   ```
   https://github.com/ACNet-AI/MetaSpec/tree/main/src/metaspec/templates/library
   ```

2. **Read library README**:
   ```
   https://github.com/ACNet-AI/MetaSpec/blob/main/src/metaspec/templates/library/README.md
   ```

3. **View specific library**:
   ```
   https://github.com/ACNet-AI/MetaSpec/tree/main/src/metaspec/templates/library/{library-name}
   ```

**Each library provides**:
- Pre-built Slash Commands
- Proven workflow patterns
- Domain-specific or universal abstractions
- Adaptation guidelines

**Selection Principles**

**Choose library based on**:

1. **Domain Match**
   - Software development â†’ Look for SDD libraries
   - Design/Testing/Documentation â†’ Look for generic/universal libraries
   - Specific specifications â†’ Look for specification-specific libraries

2. **Abstraction Level**
   - Need pure abstraction â†’ Choose generic/universal
   - Need domain concepts â†’ Choose specialized (e.g., sdd/*)
   - Need specification-specific â†’ Choose specification libraries

3. **Workflow Type**
   - Greenfield (from scratch) â†’ Greenfield workflows
   - Brownfield (evolution) â†’ Evolution/change management workflows
   - Both â†’ Compose multiple libraries

4. **Complexity**
   - Simple toolkit â†’ Start with generic
   - Complex domain â†’ Use specialized library
   - Uncertain â†’ Start generic, specialize later

**Quick Reference (Current Libraries)**

**See [library/README.md](https://github.com/ACNet-AI/MetaSpec/blob/main/src/metaspec/templates/library/README.md) for complete catalog.**

**Common libraries include**:

- [`generic/`](https://github.com/ACNet-AI/MetaSpec/tree/main/src/metaspec/templates/library/generic) - Universal SD-X (domain-agnostic)
- [`sdd/spec-kit/`](https://github.com/ACNet-AI/MetaSpec/tree/main/src/metaspec/templates/library/sdd/spec-kit) - Software development (greenfield)
- [`sdd/openspec/`](https://github.com/ACNet-AI/MetaSpec/tree/main/src/metaspec/templates/library/sdd/openspec) - Specification evolution (brownfield)

**As library grows, refer to [online catalog](https://github.com/ACNet-AI/MetaSpec/tree/main/src/metaspec/templates/library) for full list.**

---

**Adaptation Process**

**When using library commands**:

1. **Variable Mapping**
   - Map library variables to your domain terms
   - Example: `{{ entity_type }}` â†’ "API Endpoint"
   - Example: `{{ deliverable }}` â†’ "OpenAPI Schema"
   - See library's README.md on GitHub for all variables

2. **Terminology Adjustment**
   - Replace generic terms with domain-specific ones
   - Maintain command structure and workflow logic
   - Preserve spec-driven execution principles

3. **Add Specification Context** (if composing)
   - Enhance library commands with specification knowledge
   - Embed entity definitions and validation rules
   - Result: Library structure + Specification specifics

**See selected library's README.md on [MetaSpec GitHub](https://github.com/ACNet-AI/MetaSpec/tree/main/src/metaspec/templates/library) for detailed adaptation guidelines.**

---

**Composition Examples**

**Composition Pattern 1: Library + Specification**

```
Base: Select library (e.g., generic/)
  â†’ Provides workflow commands
  
Extension: Derive from specification
  â†’ Add entity-specific commands (get-template)
  â†’ Add specification commands (get-spec, validate)

Result: Combined command set
```

**Composition Pattern 2: Specification Only**

```
Derive all commands from specification
  â†’ No library dependency
  â†’ Fully custom to domain
  
Result: Tailored command set
```

**Composition Pattern 3: Library Only**

```
Use library as-is
  â†’ Quick start
  â†’ Adapt variables only
  
Result: Proven workflow pattern
```

---

**Integration with Generator**

**In toolkit specification**, document:

```markdown
### Slash Commands Strategy

**Source**: [Specification | Library | Composed]

**If Library**: 
- Selected: {library-name} (from MetaSpec library)
- Reference: https://github.com/ACNet-AI/MetaSpec/tree/main/src/metaspec/templates/library/{library-name}
- Rationale: {Why this library}

**If Specification-Derived**:
- Based on: specs/domain/{number}-{name}
- Commands needed: {List and rationale}

**If Composed**:
- Base: {library-name} (from MetaSpec)
- Extensions: {Specification-derived commands}
- Composition rationale: {Why compose}
```

**Generator expectations**:
- Copy selected library from MetaSpec to `templates/{source}/commands/`
- Apply variable mappings (cli_name, entity_type, etc.)
- Add specification-derived commands if specified
- Source isolation prevents naming conflicts

---

**Quality Checklist (Library-Selected)**

- [ ] Selected appropriate library for domain
- [ ] Mapped all library variables to domain terms
- [ ] Adapted terminology to match domain
- [ ] Added specification knowledge where applicable
- [ ] No naming conflicts between library and specification commands
- [ ] All commands properly prefixed (/{toolkit}.*)

---

**Integration with Generated Speckit**

These Slash Commands (from library and/or specification) will:
1. Be generated into `templates/{source}/commands/` directory (organized by source)
2. Embed specification knowledge where applicable
3. Provide reusable workflow patterns from library
4. Enable spec-driven development by AI agents
5. Support composition of multiple specification systems

**This demonstrates MetaSpec's Composability**: Specification systems can be selected, adapted, and composed.

**Summary**: Source 2 enables rapid adoption by selecting pre-built specification systems from MetaSpec's library, adapting variables to your domain, and composing with custom commands.

\```

##### **Component 5: Generator (Conditionally Required)** â­ UPDATED

**âš ï¸ CRITICAL**: Generator is NOT always optional. Determine if required based on use cases.

---

### ğŸ¯ **Generator vs AI Commands: Role Separation** â­ NEW v0.9.4

**FUNDAMENTAL PRINCIPLE**: Understand the separation of responsibilities between Generator and AI Commands.

#### Generator's Role (init command)

**Purpose**: Set up project **infrastructure**, NOT generate specifications.

**Responsibilities**:
- âœ… Create project structure (`.{toolkit}/`, `memory/`, `specs/` directories)
- âœ… Deploy slash commands (`.{toolkit}/commands/*.md`) - **Critical for AI**
- âœ… Generate infrastructure files (constitution, README, .gitignore)
- âœ… Generate **guidance** documents (`specs/README.md` explaining workflow)
- âŒ **NOT** generate specification files (spec.md, plan.md, tasks.md)
- âŒ **NOT** generate empty spec templates for users to fill in

#### AI Commands' Role (slash commands)

**Purpose**: Generate **specifications** through interactive dialogue.

**Responsibilities**:
- âœ… Interactive dialogue with users (ask clarifying questions)
- âœ… Generate specification files (`specs/001-xxx/spec.md`)
- âœ… Generate planning files (`specs/001-xxx/plan.md`)
- âœ… Generate task files (`specs/001-xxx/tasks.md`)
- âœ… Adapt to user's specific domain needs
- âœ… Create contextual, high-quality specifications

#### Why This Separation?

1. **Flexibility**: Each user's specifications are unique - can't pre-template effectively
2. **Intelligence**: AI can ask clarifying questions and adapt to context
3. **Quality**: Interactive generation produces better, more relevant specs
4. **True Spec-Driven**: Specifications ARE the conversation, not form-filling
5. **AI-First Design**: Embraces AI as core generator, not optional assistant

#### Workflow Comparison

**âŒ DON'T (Template-First Anti-Pattern)**:
```bash
# Wrong approach - Pre-generate empty templates
my-toolkit init my-project
â†’ specs/spec-template.yaml          # Empty template, user fills manually
â†’ specs/example-spec.yaml            # Static example

User: Opens spec-template.yaml
User: Sees 100+ empty fields
User: Confused about what to fill in
User: Manually fills (error-prone, tedious)
```

**âœ… DO (AI-First Correct Pattern)**:
```bash
# Correct approach - Guide to AI generation
my-toolkit init my-project
â†’ specs/README.md                    # Explains workflow
â†’ .my-toolkit/commands/*.md          # AI operational guides

User: Reads specs/README.md
User: Talks to AI: "I want to create a Q1 campaign"
AI: Asks clarifying questions
AI: Generates specs/001-q1-campaign/spec.yaml
User: Reviews and validates
```

#### Real-World Example: MetaSpec Itself

**MetaSpec's Generator** (generator.py Line 233):
```python
base_project_files = [
    ("base/constitution.md.j2", "memory/constitution.md"),
    ("base/specs/README.md.j2", "specs/README.md"),      # â† Only guidance
    ("base/README.md.j2", "README.md"),
    # NOTE: No spec-template, no example-spec
]
```

**MetaSpec's specs/ directory** after `metaspec init`:
```
my-speckit/
â””â”€â”€ specs/
    â””â”€â”€ README.md           # â† Only this file!
                           # Explains how to use /metaspec.sds.specify
```

**Specifications generated by AI**:
```bash
# User invokes slash command
/metaspec.sds.specify "Define MCP specification"

# AI generates (not pre-templated)
specs/domain/001-mcp-specification/spec.md
```

**Key Insight**: Even MetaSpec - a specification framework - doesn't pre-generate spec templates. It uses AI + slash commands.

---

### Step 1: Determine if Generator is Required

**Automatic Requirements Detection**:

#### Generator is REQUIRED (CORE Component) if:

1. **Use Case explicitly mentions generation**:
   - âœ… "Generate code/content/docs/config"
   - âœ… "Create artifacts from specs"
   - âœ… "Output files/templates"
   - âœ… "AI-driven content generation"
   - âœ… "Scaffolding/Boilerplate generation"
   - âœ… "Code generation from specifications"

2. **Toolkit type is "Generator/Scaffolder"**:
   - âœ… CLI includes `generate` command
   - âœ… Toolkit purpose is to produce artifacts
   - âœ… init command creates scaffolding

3. **Similar toolkits have generators**:
   - âœ… MetaSpec has `generator.py` (generates speckit code)
   - âœ… Specify has generation features
   - âœ… spec-kit's init is essentially generation

#### Generator is OPTIONAL if:

1. **Pure validation/query tool**:
   - â­ï¸ Only validates specs, no artifact generation
   - â­ï¸ Only queries/displays information

2. **State management tool**:
   - â­ï¸ Only manages state, no file generation

### Step 2: Analysis Decision Tree

```
Check Primary Use Cases (from "Component Requirements Analysis" above)
    â†“
Detect keywords: ["generate", "create", "output", "build", "scaffold"]
    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Keywords Found            â”‚ No Keywords
    â†“                          â†“
Check Toolkit Type         Check Toolkit Type
    â†“                          â†“
    â”œâ”€ Generator/Scaffolder â†’ Generator: CORE
    â”œâ”€ Has "generate" command â†’ Generator: CORE
    â””â”€ Other                 â†’ Generator: OPTIONAL
```

### Step 3: Cross-Reference with Component Priority Matrix

**Go back to "Component Requirements Analysis" section and verify**:

| Component | Priority | Does it match analysis? |
|-----------|----------|------------------------|
| Generator | CORE / OPTIONAL | âœ… Consistent with use cases |

**Common Mistakes**:
- âŒ Use case says "AI-Driven **Content Generation**" but Generator marked OPTIONAL
- âŒ Toolkit type is "Generator" but Generator not in Core Components
- âŒ CLI has `generate` command but Generator marked as Future Enhancement

### Step 4: Examples for Reference

| Toolkit | Primary Use Case | Generator Status | Rationale |
|---------|-----------------|------------------|-----------|
| **MetaSpec** | "Generate speckit code" | âœ… CORE | Keyword: "Generate" |
| **marketing-spec-kit** | "AI-driven **content generation**" | âœ… CORE | Keyword: "generation" |
| **OpenSpec** | "Validate proposals" | â­ï¸ OPTIONAL | No generation keywords |
| **Validator-only** | "Check schema compliance" | â­ï¸ OPTIONAL | Pure validation |

---


---


---

### Step 5: Define Generator Component (if CORE)

**Use this template for your Specification Toolkit**

```markdown
### Generator Component

**Purpose**: Generate project structure and specification files from templates

**Decision**: Generator is **CORE** because:
- Primary use case requires project initialization
- Toolkit type is "Specification Toolkit" (manages specifications)
- init command requires structured project generation
- Users need standardized project structure

**Generation Targets** (Project infrastructure only):
- **Project structure**: Create `.{toolkit}/`, `memory/`, `specs/` directories
- **Constitution**: Generate `memory/constitution.md` from principles template
- **Project README**: Create project README with toolkit usage guide
- **Specs guidance**: Generate `specs/README.md` explaining how to use slash commands (see "Generator vs AI Commands" above for role separation)
- **Git config**: Create `.gitignore` with standard patterns
- **Slash Commands**: Deploy toolkit's slash commands to `.{toolkit}/commands/`
  - âœ… **Always deploy** all slash command files (`*.md`) from `templates/{source}/commands/`
  - âœ… **Target location**: `.{toolkit}/commands/` directory in user projects
  - âœ… **Method**: Direct file copy (NOT Jinja2 rendering)
  - âš ï¸ **Critical** - Required for AI-driven workflows

**Note**: See Line 2220-2311 "Generator vs AI Commands" for detailed role separation and anti-patterns.

**Architecture Pattern** (Follow MetaSpec):
```python
# CLI layer (commands/cli.py)
def init(project_name: str, template: str = "default"):
    """Initialize new project with Generator"""
    generator = {Toolkit}Generator()
    project = generator.generate_project(
        name=project_name,
        template=template,
        output_dir=Path(project_name)
    )
    console.print(f"âœ“ Created {len(project.files)} files")
    
# Business logic layer (generator.py)
class {Toolkit}Generator:
    """Generate complete {toolkit} projects from templates"""
    
    def generate_project(self, name: str, template: str, output_dir: Path):
        # 1. Validate output directory
        self._validate_output_dir(output_dir)
        
        # 2. Select and load templates
        template_set = self._load_templates(template)
        
        # 3. Create template context
        context = self._create_context(name, template)
        
        # 4. Render all templates
        files = self._render_templates(template_set, context)
        
        # 5. Build project structure
        project = self._build_structure(files)
        
        # 6. Deploy slash commands (if toolkit has them)
        self._deploy_slash_commands(output_dir)
        
        # 7. Write to disk (atomic)
        self._write_files(project, output_dir)
        
        return GeneratedProject(files=files)
```

**Command Deployment Implementation**:
```python
def _deploy_slash_commands(self, output_dir: Path) -> None:
    """
    Deploy toolkit's slash commands to user project.
    
    Copies all command files from toolkit's templates to 
    `.{toolkit}/commands/` so AI assistants can read them in user projects.
    
    Args:
        output_dir: Target project directory
    
    Behavior:
        - Copies all *.md files from templates/{source}/commands/
        - Creates `.{toolkit}/commands/` directory if needed
        - Preserves original .md format (no Jinja2 rendering)
        - Skips if no commands directory exists in templates
    """
    # Get toolkit's command directory from package
    commands_source = Path(__file__).parent.parent / "templates" / "{source}" / "commands"
    
    if not commands_source.exists():
        return  # No commands to deploy (optional component)
    
    # Create target directory in user project
    commands_target = output_dir / f".{self.toolkit_name}" / "commands"
    commands_target.mkdir(parents=True, exist_ok=True)
    
    # Copy all command files (direct copy, no rendering)
    for cmd_file in commands_source.glob("*.md"):
        shutil.copy(cmd_file, commands_target / cmd_file.name)
        logger.debug(f"Deployed command: {cmd_file.name}")
```

**Template Selection** (infrastructure only):
```python
def _select_templates(self, template: str) -> dict[str, str]:
    """Select infrastructure templates to render (see Line 2220-2311 for role separation)."""
    templates = {
        "memory/constitution.md": "constitution.md.j2",
        "specs/README.md": "specs-readme.md.j2",     # Guidance, NOT spec template
        "README.md": "readme.md.j2",
        ".gitignore": "gitignore.j2",
    }
    return templates
```

**Templates**:
- **Location**: `src/{toolkit_name}/templates/{source}/` directory
  - `{source}`: Domain-specific subdirectory (e.g., `mcp`, `marketing`, `api`)
  - âš ï¸ **Note**: Most toolkits don't need a `base/` directory - put templates directly in `{source}/`
- **Format**: Plain files or Jinja2 templates (`.j2` extension)
- **Customization**: User-overridable in `.{toolkit}/templates/`

- **Required Infrastructure Templates** (in `templates/{source}/`):
  - `constitution.md.j2` - Project principles template (domain-specific)
  - `readme.md.j2` - Project README template
  - `.gitignore.j2` - Git ignore rules template
  - `specs-readme.md.j2` - specs/ directory guidance template â­ **CRITICAL**
    - **Target**: `specs/README.md` (NOT spec-template)
    - **Content**: Explains how to use slash commands to generate specifications
    - **Example**: See MetaSpec's `templates/base/specs/README.md.j2`
  
- **What NOT to Create**: See "Generator vs AI Commands" (Line 2220-2311) for anti-patterns

- **Required Command Deployment** (if toolkit has slash commands):
  - **Source**: `templates/{source}/commands/*.md` (same `{source}` as above)
  - **Target**: `.{toolkit}/commands/*.md` (in user projects)
  - **Method**: Direct file copy (NOT Jinja2 rendering)
  - **Purpose**: AI assistant operational guides
  - **When**: Always deploy during project initialization

**Input**:
- **Project name** (string): Name for the new project
- **Template choice** (string): `minimal` / `default` / `full`
- **Custom variables** (dict, optional): User-defined template variables

**Output**:
- **Complete project directory**: All files and subdirectories
- **Generation report**: Summary of files created, warnings if any
- **Success indicator**: Boolean status

**CLI Integration**:
```bash
# init command uses Generator
{toolkit-name} init <project-name> [--template TEMPLATE]

# Examples
{toolkit-name} init my-marketing-project --template default
{toolkit-name} init quick-start --template minimal
```

**Programmatic API**:
```python
from {toolkit_name}.generator import {Toolkit}Generator

# Initialize generator
generator = {Toolkit}Generator()

# Generate project
project = generator.generate_project(
    name="my-project",
    template="default",
    output_dir="./my-project"
)

# Check result
print(f"âœ“ Generated {len(project.files)} files")
for file in project.files:
    print(f"  - {file.path}")
```

**Error Handling**:
- Invalid template name â†’ `TemplateNotFoundError`
- Output directory exists â†’ `DirectoryExistsError` (unless --force)
- Template rendering error â†’ `TemplateRenderError`
- File write error â†’ `IOError`

**Reference Implementation**: See MetaSpec's `src/metaspec/generator.py`
\```

---

### âœ… Post-Generation Verification Checklist

**After defining your Generator component, verify alignment with MetaSpec standards.**

**Quick Reference**: See "Generator vs AI Commands" (Line 2220-2311) for role separation details.

##### Component-Level Checks

| Area | Verify | Anti-Pattern |
|------|--------|--------------|
| **Purpose** | âœ… Creates project infrastructure | âŒ Generates domain content |
| **init argument** | âœ… `<project-directory>` | âŒ `<spec-file>` |
| **init output** | âœ… Complete project structure | âŒ Single file |
| **Slash commands** | âœ… Deployed to `.{toolkit}/commands/` | âŒ Missing or incomplete |
| **specs/ content** | âœ… Only `README.md` (guidance) | âŒ spec-template, example-spec |

##### Verification Code Example

```python
# After: {toolkit} init my-project
assert (my-project / ".{toolkit}" / "commands").exists()
assert (my-project / "specs" / "README.md").exists()
assert not (my-project / "specs" / "spec-template.yaml").exists()
```

**For detailed validation rules and red flags**, see "Generator vs AI Commands" (Line 2220-2311).

---

### Step 6: Omit Generator (if OPTIONAL)

**If Generator is OPTIONAL (not needed for MVP)**:

```markdown
### Future Enhancements

**Generator Component** (Deferred):
- May be added in future if generation features are needed
- Current focus: validation and querying only
\```

### Verification Checklist

Before finalizing this component:

- [ ] Generator status (CORE/OPTIONAL) matches "Component Requirements Analysis"
- [ ] If CORE: Use case explicitly requires generation
- [ ] If CORE: Detailed component specification provided
- [ ] If OPTIONAL: Clearly stated as "Future Enhancement"
- [ ] No contradiction: Use case says "generation" but Generator marked OPTIONAL

#### **Architecture Design**

```markdown
## Architecture

### Module Structure
```
{toolkit_name}/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ parser.py          # Parser component
â”œâ”€â”€ validator.py       # Validator component
â”œâ”€â”€ generator.py       # Generator component (optional)
â”œâ”€â”€ cli.py             # CLI entry point
â”œâ”€â”€ models.py          # Data models
â”œâ”€â”€ exceptions.py      # Custom exceptions
â””â”€â”€ templates/         # Templates (if generator exists)
```

### Data Flow
```
Input File
    â†“
  Parser  â”€â”€â”€â†’ Parsed Spec Object
    â†“
Validator â”€â”€â”€â†’ Validation Result
    â†“
Generator â”€â”€â”€â†’ Output Artifacts
```

### Key Classes
- `{Toolkit}Spec`: Main specification object
- `{Toolkit}Parser`: Parser implementation
- `{Toolkit}Validator`: Validator implementation
- `{Toolkit}Generator`: Generator implementation (optional)
\```

#### **Dependencies and Requirements**

```markdown
## Technical Requirements

### Language
- Python 3.9+

### Core Dependencies
- `pydantic`: Data validation and settings management
- `typer`: CLI framework
- `pyyaml` or `ruamel.yaml`: YAML parsing
- `jinja2`: Template engine (if generator)
- `rich`: Terminal formatting

### Development Dependencies
- `pytest`: Testing framework
- `mypy`: Type checking
- `ruff`: Linting and formatting
- `coverage`: Code coverage

### Optional Dependencies
- {Additional deps based on specific needs}
```

#### **Validation Strategy**

```markdown
## Validation Strategy

### Unit Tests
- Test each component independently
- Mock external dependencies
- Aim for 80%+ coverage

### Integration Tests
- Test component interactions
- Test CLI commands end-to-end
- Test with real specification files

### Validation Cases
1. **Parser Tests**:
   - Valid YAML/JSON parsing
   - Invalid syntax handling
   - Edge cases (empty files, large files)

2. **Validator Tests**:
   - Each validation rule from specification spec
   - Error message quality
   - Multiple errors handling

3. **CLI Tests**:
   - Each command with various options
   - Error handling
   - Help messages

4. **Generator Tests** (if applicable):
   - Template rendering
   - Output file creation
   - Custom template handling

### Validation Data
- Sample valid specifications
- Sample invalid specifications
- Edge cases

**Validation Location**: `tests/` directory
```

#### **Success Criteria**

```markdown
## Success Criteria

### MVP Features
- âœ… {Feature 1}
- âœ… {Feature 2}
- âœ… {Feature 3}

### Quality Metrics
- All tests pass
- 80%+ code coverage
- No critical linting errors
- Type hints complete (mypy passes)

### Documentation
- README with quickstart
- API documentation
- CLI help messages complete
- Example specifications

### User Experience
- Clear error messages
- Fast execution (< 1s for typical specs)
- Good CLI UX (progress bars, colors)
```

### 4. Write Specification File

**Location**: `specs/toolkit/{number}-{name}/spec.md`

**Structure**:
```markdown
# {Toolkit Name}

**Version**: {version}
**Status**: Draft | In Development | Stable
**Created**: {date}

## Dependencies

{Dependencies from Section 3: Generate Toolkit Specification Content}

## Overview

{Overview from Section 3: Generate Toolkit Specification Content}

## Components

{Component specifications from Section 3: Generate Toolkit Specification Content}

## Architecture

{Architecture design from Section 3: Generate Toolkit Specification Content}

## Technical Requirements

{Requirements from Section 3: Generate Toolkit Specification Content}

## Validation Strategy

{Validation strategy from Section 3: Generate Toolkit Specification Content}

## Success Criteria

{Success criteria from Section 3: Generate Toolkit Specification Content}

## Implementation Plan

See `plan.md` (created via `/metaspec.sdd.plan`)

## Tasks

See `tasks.md` (created via `/metaspec.sdd.tasks`)
```

### 5. Generate Detailed Impact Report (NEW)

**Purpose**: Create comprehensive change tracking and impact analysis for toolkit specifications.

**Step 5a: Prepare Report Content**

Collect information for the report:

```markdown
Report Data:
- Toolkit ID: {spec_id}
- Version: {version} (1.0.0 for new, increment for updates)
- Date: {today}
- Type: New | Update
- Language: {Primary language}
- Components: {List of components}
- Dependencies: {List of domain specs}
```

**Step 5b: Generate HTML Comment**

Create compact report and **prepend** to spec.md:

```html
<!--
Toolkit Specification Report
============================
Toolkit: {spec_id} v{version} | {New | Update}
Date: {ISO_DATE}

Summary:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Language: {Python | TypeScript | Go | Rust}
Components: {count} ({Parser, Validator, CLI, etc.})
Domain Dependencies: {count}
Status: {Draft | In Development | Stable}

Impact:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Created: specs/toolkit/{spec_id}/spec.md
Review: README.md, AGENTS.md{IF dependencies}, domain specs{END}

Constitution: {âœ… Compliant | âš ï¸ Check: {issues}}

Next: Plan architecture, Break down tasks, Verify dependencies

Generated by: /metaspec.sdd.specify
-->
```

**Step 5c: Write Order**

When writing spec.md:
1. **First**: Prepend HTML comment (Impact Report)
2. **Then**: Write toolkit specification content

**Step 5d: Recommend Next Steps**

After writing spec.md, provide clear guidance:

```markdown
âœ… Toolkit specification generated successfully!

ğŸ“„ Output: specs/toolkit/{spec_id}/spec.md

ğŸ“‹ Recommended Next Steps:

1. **Review Specification**
   - Read generated spec.md
   - Verify component definitions match your needs
   - Check CLI command definitions
   - Ensure init command follows standards (if Generator/Scaffolder)

2. **Run Quality Checks** (Strongly Recommended)
   - `/metaspec.sdd.analyze` - Check cross-document consistency
     â€¢ AGENTS.md alignment
     â€¢ Domain spec dependencies
     â€¢ Use Case â†” Component logic
   - `/metaspec.sdd.checklist` - Validate specification completeness

3. **Proceed to Implementation** (After validation)
   - `/metaspec.sdd.plan` - Design architecture
   - `/metaspec.sdd.tasks` - Break down work
   - `/metaspec.sdd.implement` - Build toolkit

âš ï¸  **Important**: For Generator/Scaffolder toolkits, verify:
   - init command uses <project-directory> (not <filename>)
   - init creates complete project structure (.{toolkit}/, memory/, specs/)
   - Component priorities match use cases (e.g., Generator is CORE if use case is generation)

ğŸ’¡ **Quick Validation**:
   ```bash
   # Check basic consistency
   grep -A 5 "init.*<" specs/toolkit/{spec_id}/spec.md
   grep -A 10 "Core Components" specs/toolkit/{spec_id}/spec.md
   ```
```

### 6. Consistency Propagation and Impact Analysis

**Purpose**: Identify affected files and verify dependencies.

After writing spec.md, systematically check related files:

#### A. Domain Specification Dependencies (CRITICAL)

**Verify all dependencies exist**:

```bash
# Extract dependencies from spec.md
grep -A 10 "^## Dependencies" specs/toolkit/{spec_id}/spec.md

# For each domain spec dependency:
# 1. Verify it exists
# 2. Check if entities are correctly referenced
# 3. Verify validation rules are consistent
```

**Actions**:
- **Read**: Each dependent domain spec
- **Verify**: Entity names and structures match
- **Check**: Validation rules are aligned
- **Note**: Any mismatches or missing references
- **Mark**: Dependencies needing updates

**Example Check**:
```markdown
Checking dependency: domain/001-mcp-core-spec...
- Status: âœ… Exists
- Entities referenced by toolkit: Server, Tool, Resource
- Verification: âœ… All entities exist in domain spec
- Validation rules: âœ… Toolkit enforces domain rules

Checking dependency: domain/002-auth-spec...
- Status: âŒ NOT FOUND
- âš ï¸  CRITICAL: Toolkit declares dependency but spec doesn't exist
- â†’ Action: Create domain/002-auth-spec first, or remove dependency
```

#### B. Other Toolkit Specifications

**Check for overlaps or conflicts**:

```bash
# List all other toolkit specifications
ls specs/toolkit/ | grep -E '^[0-9]{3}-' | grep -v {current_spec_id}

# For each existing toolkit:
# 1. Component overlap (do toolkits do similar things?)
# 2. Naming conflicts
# 3. Dependency relationships
```

**Actions**:
- **Read**: Each toolkit's purpose and components
- **Compare**: Against new toolkit's functionality
- **Note**: Any functional overlaps
- **Mark**: Potential consolidation opportunities

**Example Check**:
```markdown
Checking specs/toolkit/001-mcp-parser/spec.md...
- Purpose: Parse MCP server definitions
- Components: Parser, Validator
- âš ï¸  OVERLAP: New toolkit also has Parser component
- â†’ Review: Consider reusing vs separate implementation

Checking specs/toolkit/002-mcp-generator/spec.md...
- Purpose: Generate MCP client code
- Components: Generator, Templates
- âœ… No overlap with new toolkit
```

#### C. MetaSpec Commands (Slash Commands)

**Check if toolkit commands need generation**:

```bash
# If toolkit defined slash commands in Component 4
# Check if command files should be generated

# For each slash command specified:
# - Should .metaspec/commands/ be created?
# - Are there library commands to copy?
# - Are custom commands needed?
```

**Actions**:
- **Read**: Component 4 (Slash Commands) from spec.md
- **Check**: Command derivation strategy (specification vs library)
- **Note**: Commands to be generated
- **Mark**: For generation in /metaspec.sdd.implement

**Example**:
```markdown
Slash Commands Strategy: Composed (Library + Specification-derived)
- Base Library: library/sdd/spec-kit
- Custom Commands: get-spec, validate, show-template
- â†’ Action: Copy library commands + generate custom commands
```

#### D. Source Code Structure (If Exists)

**Check existing source code**:

```bash
# If src/{toolkit_name}/ already exists
ls src/{toolkit_name}/

# For each component in specification:
# - Does corresponding source file exist?
# - Does it need updates?
# - Are new files needed?
```

**Actions**:
- **Read**: Existing source files
- **Compare**: Against specified components
- **Note**: Missing implementations
- **Mark**: Files needing updates or creation

**Example Check**:
```markdown
Checking src/mcp-parser/...
- parser.py: âœ… Exists (may need updates)
- validator.py: âœ… Exists (may need updates)
- models.py: âŒ NOT FOUND (needs creation)
- cli.py: âœ… Exists (may need updates)
- generator.py: âŒ NOT PLANNED (new component, needs creation)

â†’ Impact: 2 new files, 3 files needing review
```

#### E. Project Documentation

**Check documentation files**:

```bash
# Files to review
- README.md: Toolkit list and usage
- AGENTS.md: Toolkit documentation for AI
- CHANGELOG.md: Record toolkit addition
- docs/*.md: Any toolkit guides
```

**Actions**:
- **Read**: Current documentation
- **Check**: If toolkit is documented
- **Note**: Missing documentation sections
- **Update**: Add to Impact Report

**Example**:
```markdown
Checking README.md...
- âš ï¸  New toolkit not listed
- â†’ Action: Add to "Toolkits" section with purpose

Checking AGENTS.md...
- âš ï¸  Toolkit commands not documented
- â†’ Action: Add toolkit slash commands section
```

#### F. Test Files (If Tests Directory Exists)

**Check test coverage**:

```bash
# If tests/ directory exists
ls tests/

# For each component in specification:
# - Do corresponding tests exist?
# - What tests need to be created?
# - Are existing tests still valid?
```

**Actions**:
- **Read**: Existing test files
- **Check**: Coverage for specified components
- **Note**: Missing test files
- **Mark**: Tests to create or update

**Example**:
```markdown
Checking tests/unit/...
- test_parser.py: âœ… Exists
- test_validator.py: âœ… Exists
- test_models.py: âŒ NOT FOUND (needs creation)
- test_cli.py: âœ… Exists

Checking tests/integration/...
- test_end_to_end.py: âš ï¸  May need updates for new generator component

â†’ Test Impact: 1 new test file, 1 file needing review
```

### 7. Validation Checklist (Document-Level)

**Purpose**: Ensure toolkit specification document quality before finalizing.

**Critical checks** (different from Component-Level checks in Step 5):

- [ ] **Structure**: All required sections present (Dependencies, Overview, Implementation, etc.)
- [ ] **Dependencies**: At least one domain spec referenced and verified to exist
- [ ] **Implementation**: Language + rationale, architecture defined
- [ ] **Components**: Core components listed with clear purposes
- [ ] **Constitution**: Compliant with Part III principles (Entity-First, Spec-First, AI-Friendly)
- [ ] **Impact Report**: Prepended at top of spec.md
- [ ] **File Path**: Correct location `specs/toolkit/{spec_id}/spec.md`

### 8. Generate Validation Report

**Output validation results**:

```markdown
Validation Report
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Structure Validation: âœ… PASSED (3/3 checks)
- Header section: âœ…
- Required sections: âœ… (All present)
- File organization: âœ…

Content Validation: âœ… PASSED (6/6 checks)
- Dependencies: âœ… (Depends on domain/001-mcp-spec)
- Implementation details: âœ… (Python 3.10+, Modular)
- Component specifications: âœ… (4 components defined)
- Architecture design: âœ… (Clear module structure)
- Validation strategy: âœ… (Unit + Integration tests)
- Success criteria: âœ… (MVP features listed)

Constitution Compliance: âœ… PASSED (6/6 principles)
- Entity-First Design: âœ…
- Validator Extensibility: âœ…
- Spec-First Development: âœ…
- AI-Agent Friendly: âœ…
- Progressive Enhancement: âœ…
- Automated Quality: âœ…

Dependency Validation: âœ… PASSED (4/4 checks)
- All dependencies exist: âœ… (domain/001-mcp-spec verified)
- No circular dependencies: âœ…
- Consistent references: âœ… (Entity names match)
- Version compatibility: âœ…

Implementation Validation: âœ… PASSED (5/5 checks)
- Language choice: âœ… (Python justified for ecosystem)
- Dependencies: âœ… (Pydantic, Typer available)
- Architecture: âœ… (Modular is feasible)
- Components: âœ… (All implementable)
- Performance targets: âœ… (< 100ms is realistic)

Overall Score: 24/24 (100%) âœ…

{IF any warnings}:
âš ï¸  Warnings:
- {Warning 1}
- {Warning 2}

{IF any suggestions}:
ğŸ’¡ Suggestions:
- {Suggestion 1}: {Rationale}
- {Suggestion 2}: {Rationale}
```

### 9. Success Output (Enhanced)

**Provide comprehensive summary with validation and impact results**:

```
âœ… Toolkit specification created/updated successfully

ğŸ“ Location:
   specs/toolkit/{number}-{name}/spec.md

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“‹ Toolkit Summary:
   Name: {Toolkit Name}
   Version: {version}
   Status: {Draft | In Development | Stable}
   Primary Language: {Python | TypeScript | Go | Rust}
   Architecture: {Monolithic | Modular | Plugin-based}

ğŸ“¦ Dependencies:
   Domain Specifications:
   - domain/{dependency-1}: {What it provides}
   - domain/{dependency-2}: {What it provides}
   ...

   Key Libraries:
   - {library-1}: {Purpose}
   - {library-2}: {Purpose}
   ...

ğŸ”§ Components ({count}):
   - {Component 1}: {brief description}
   - {Component 2}: {brief description}
   ...

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… Validation Results: PASSED ({score}/24 checks)

   Structure: âœ… {3/3 checks passed}
   Content: âœ… {6/6 checks passed}
   Constitution: âœ… {6/6 principles compliant}
   Dependencies: âœ… {4/4 checks passed}
   Implementation: âœ… {5/5 checks passed}

{IF any warnings}:
   âš ï¸  Warnings:
   - {Warning 1}
   - {Warning 2}

{IF any suggestions}:
   ğŸ’¡ Suggestions:
   - {Suggestion 1}
   - {Suggestion 2}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“‹ Impact Analysis:

   âœ… Files Created/Updated:
   - specs/toolkit/{spec_id}/spec.md

   âš ï¸  Files Requiring Manual Review:
   - README.md (add toolkit to list)
   - AGENTS.md (document toolkit commands)
   {IF domain specs dependencies}:
   - Domain specs verified: {list of checked specs}
   {IF source code exists}:
   - Source files needing review: {count} files
   {IF tests exist}:
   - Test files needing update: {count} files

   ğŸ“Š Consistency Check:
   - Domain specifications verified: {count}
   - Toolkit specifications reviewed: {count}
   - Source files analyzed: {count}
   - Test files checked: {count}
   - Documentation needing updates: {count} files

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ”„ Next Steps:

   Immediate:
   1. Review toolkit specification completeness
   2. Verify domain specification dependencies
   3. Update README.md with toolkit information
   4. Update AGENTS.md with commands documentation
   {IF conflicts}:
   5. âš ï¸  Resolve component overlaps with other toolkits
   {IF source impact}:
   6. âš ï¸  Review and update {count} source files

   Recommended:
   - Run /metaspec.sdd.plan to create architecture plan
   - Run /metaspec.sdd.tasks to break down implementation
   - Run /metaspec.sdd.implement to start building
   {IF slash commands needed}:
   - Generate slash commands during implementation

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Suggested commit message:
   {IF new}:
   feat(toolkit): add {spec_id} toolkit specification
   
   - Primary language: {language}
   - Components: {count} ({component list})
   - Depends on: {domain spec list}
   {IF slash commands}:
   - Slash commands: {count} planned
   
   {IF update}:
   feat(toolkit): update {spec_id} toolkit specification
   
   - {summary of changes}
```

## Best Practices

### Toolkit Specification Focus

âœ… **DO**:
- Define HOW to implement the toolkit
- Specify Parser, Validator, CLI, Generator
- Reference specification specs explicitly
- Include architecture and validation strategy
- Focus on user experience

âŒ **DON'T**:
- Redefine the specification (belongs in specification specs)
- Skip dependency declarations
- Mix specification and toolkit concerns
- Over-specify implementation details

### Dependency Management

- **Always** declare specification dependencies at the top
- Reference specific specification/XXX- specs
- Document which specification features are supported
- Note version compatibility if relevant

### Component Design

- Keep components modular and testable
- Clear interfaces between components
- Minimal coupling
- Support both CLI and programmatic usage

### Progressive Enhancement

Start with MVP:
1. Parser (basic)
2. Validator (core rules)
3. CLI (init + validate)

Add later:
4. Generator
5. Advanced CLI features
6. SDK/Library enhancements

## Constitution Check

Before finalizing, verify against `memory/constitution.md`:

```bash
# Check toolkit spec against constitution
grep -A 5 "Minimal Viable Abstraction" memory/constitution.md
grep -A 5 "AI-First Design" memory/constitution.md
```

**Ensure**:
- Start with minimal viable toolkit
- Components are clearly defined
- Architecture supports extension
- Testing is built-in from start

## Troubleshooting

**If no specification specs exist**:
â†’ Prompt user to create specification spec first with `/metaspec.sds.specify`

**If toolkit seems too complex**:
â†’ Break into multiple toolkit specs (e.g., parser-only, validator-only)

**If unclear architecture**:
â†’ Use `/metaspec.sdd.clarify` to resolve design questions

**If components overlap**:
â†’ Review separation of concerns, consider merging or splitting

**If validation strategy unclear**:
â†’ Focus on contract testing at component boundaries
