<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Select an Email</title>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.12.1/polyfill.min.js"></script> -->
        <style>

            :root {
                --espresso-dark: #3B2323; /* Darkened color */
                --espresso-medium: #4E3B3B; /* Adjusted for a more coffee-like tone */
                --espresso-light: #7A4B4B; /* Darkened color */
                --cream: #EDE0D4; /* Darkened color */
                --background: #dcd6c9; /* Darkened color */
                --accent: #C65D1E; /* Darkened color */
                --error-red: #D9534F;
                --loading-orange: #F0AD4E;
                --text-color: #222222; /* Darkened color */
                --button-hover: #4B2E2E; /* Darkened color */
            }

            * {
                box-sizing: border-box;
            }

            body {
                font-family: 'Montserrat', sans-serif;
                margin: 0;
                padding: 0;
                background-color: var(--background);
                color: var(--text-color);
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
            }

            main {
                width: 90%;
                max-width: 800px; /* Reduced max-width */
                margin: 20px auto; /* Reduced margin */
                padding: 20px; /* Reduced padding */
                background: var(--cream);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Reduced shadow */
                border-radius: 8px; /* Reduced border-radius */
                display: flex;
                flex-direction: column;
                gap: 20px; /* Reduced gap */
            }

            h1 {
                text-align: center;
                font-family: 'Roboto', sans-serif;
                font-weight: 600; /* Reduced font weight */
                color: var(--espresso-dark);
                margin-bottom: 15px; /* Reduced margin */
                font-size: 1.8em; /* Reduced font size */
                position: relative;
            }

            h1::after {
                content: '';
                display: block;
                width: 50px; /* Reduced width */
                height: 3px; /* Reduced height */
                background-color: var(--espresso-medium);
                margin: 8px auto 0; /* Reduced margin */
                border-radius: 2px;
            }

            ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
                display: flex;
                flex-direction: column;
                gap: 10px; /* Reduced gap */
            }

            li {
                background-color: var(--espresso-light);
                padding: 8px; /* Reduced padding */
                border-radius: 6px; /* Reduced border-radius */
                font-size: 1.1em; /* Reduced font size */
            }

            /* New styling for docxEmailList */
            #docxEmailList li {
                background-color: transparent; /* Plain background */
                padding: 8px; /* Keep padding */
                border: none; /* No border */
                box-shadow: none; /* No shadow */
                transition: none; /* No transition */
            }

            button {
                width: 100%;
                padding: 4px 8px; /* Reduced padding */
                background-color: var(--espresso-medium);
                color: #ffffff;
                border: none;
                border-radius: 6px; /* Reduced border-radius */
                cursor: pointer;
                font-size: 1.1em; /* Reduced font size */
                font-weight: 500; /* Reduced font weight */
                transition: background-color 0.3s, transform 0.2s;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-bottom: 8px; /* Reduced margin */
            }

            button:hover {
                background-color: var(--espresso-dark);
                transform: scale(1.01); /* Reduced scale effect */
            }

            .error-message {
                color: var(--error-red);
                text-align: center;
                font-weight: bold;
                margin-top: 15px; /* Reduced margin */
                padding: 8px; /* Reduced padding */
                border: 1px solid var(--error-red);
                border-radius: 6px;
                background-color: #fdecea;
            }

            .loading-message {
                color: var(--loading-orange);
                text-align: center;
                font-weight: bold;
                margin-top: 15px; /* Reduced margin */
                padding: 8px; /* Reduced padding */
                border: 1px solid var(--loading-orange);
                border-radius: 6px;
                background-color: #fff4e6;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px; /* Reduced gap */
            }

            /* Responsive Design */
            @media (max-width: 600px) {
                main {
                    padding: 15px; /* Reduced padding */
                }

                h1 {
                    font-size: 1.1em; /* Reduced font size */
                }

                button {
                    font-size: 1em; /* Reduced font size */
                    padding: 4px 6px; /* Reduced padding */
                }
            }
            /* Status banner and details panel */
            .status-banner {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                margin: 0 auto;
                max-width: 800px;
                background: #fff4e6;
                color: var(--espresso-medium);
                border: 1px solid var(--loading-orange);
                border-radius: 8px 8px 0 0;
                box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.08);
                padding: 10px 14px;
                display: flex;
                gap: 10px;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            }
            .status-banner.status-safe {
                background: #e8f7ee;
                color: #1f5132;
                border-color: #30a46c;
            }
            .status-banner .icon { font-size: 1.2em; }
            .status-toggle {
                margin-left: auto;
                background: transparent;
                border: none;
                color: inherit;
                text-decoration: underline;
                cursor: pointer;
                font-size: 0.95em;
            }
            .status-details {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 56px;
                margin: 0 auto;
                max-width: 800px;
                background: #faf7f2;
                color: var(--espresso-dark);
                border: 1px solid #e2d3c4;
                border-radius: 8px;
                box-shadow: 0 -4px 12px rgba(0,0,0,.06);
                padding: 10px 14px;
                z-index: 9998;
            }
            .status-details ul {
                list-style: none;
                margin: 0;
                padding: 0;
                display: grid;
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 6px 14px;
            }
        </style>
    </head>
    <body>
        <main>
            <!-- <h1>Please Select the Correct Email</h1> -->
            <!-- <ul id="emailList"></ul> -->

            <h1>New Secure Messages</h1>
            <ul id="otpList" style="color: var(--text-color);"></ul>
            <div id="otpEmptyMessage" style="display:none; text-align:center; font-size: 0.9em; color: var(--espresso-dark); margin-top: 6px;">No new secure messages.</div>
            <div id="otpLoadingMessage" class="loading-message" style="display:none;">
                <span>⏳</span> Loading secure messages...
            </div>

            <h1>New Surgery Schedules</h1>
            <ul id="docxEmailList" style="color: var(--text-color);"></ul> <!-- Static list with black text -->

            <div id="errorMessage" class="error-message" style="display:none;"></div>
            <div id="loadingMessage" class="loading-message" style="display:none;">
                <span>⏳</span> Loading DOCX results...
            </div>

            <div style="text-align:center; margin-top: 10px;">
                <a id="diagLink" href="#" target="_blank" style="font-size: 0.9em; color: var(--espresso-dark); text-decoration: underline;">Open diagnostics</a>
            </div>
            
        </main>
        <div id="closeStatusBanner" class="status-banner status-working" aria-live="polite">
            <span class="icon" aria-hidden="true">⏳</span>
            <span class="text">Please keep this tab open while we process your files…</span>
            <button id="statusDetailsToggle" class="status-toggle" type="button" aria-expanded="false">Details</button>
        </div>
        <div id="statusDetails" class="status-details" hidden>
            <ul>
                <li><strong>Phase:</strong> <span id="stPhase">working</span></li>
                <li><strong>Links:</strong> <span id="stLinks">0</span></li>
                <li><strong>Downloaded:</strong> <span id="stDownloaded">0</span></li>
                <li><strong>To delete:</strong> <span id="stToDelete">0</span></li>
                <li><strong>Deleted (confirmed):</strong> <span id="stDeleted">0</span></li>
                <li id="stErrorRow" style="display:none;"><strong>Error:</strong> <span id="stError"></span></li>
            </ul>
        </div>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            try {
                var params = new URLSearchParams(window.location.search || '');
                var actionParam = params.get('action');
                console.log("Document ready, initializing flows... action=", actionParam);
            } catch (e) {
                console.log("Document ready, initializing flows...");
            }
            try {
                var base = window.location.origin + window.location.pathname;
                var diagUrl = base + '?diag=1';
                var a = document.getElementById('diagLink');
                if (a) { a.href = diagUrl; }
            } catch (e) {}
            initializeOtpFlow();
            initializeDocxEmailListFlow();
            setBannerWorking();
            startStatusPollingOnce();
        });

        /**
         * Initializes the Email List Flow.
         * Fetches email subjects and builds the email list.
         */
        async function initializeEmailListFlow() {
            try {
                console.log("Initializing Email List Flow...");
                const subjectsResponse = await fetchEmailSubjects();
                console.log("Email subjects fetched:", subjectsResponse);
                buildEmailList(subjectsResponse);
            } catch (error) {
                console.error("Error initializing Email List Flow:", error);
                displayErrorMessage("Failed to load email subjects.");
            }
        }

        /**
         * Initializes the DOCX Email List Flow.
         * Initiates DOCX processing and fetches results upon completion.
         */
        async function initializeDocxEmailListFlow() {
            try {
                console.log("Initializing DOCX Email List Flow...");
                showLoadingMessage();
                // Start server-side processing (skip list already posted by Python)
                const processResponse = await startProcessingDocxAsync();
                console.log("DOCX processing initiated:", processResponse);
        
                if (processResponse.status === "success") {
                    const docxResultsResponse = await fetchDocxResults();
                    console.log("DOCX results fetched:", docxResultsResponse);
                    buildDocxList(docxResultsResponse);
                } else {
                    console.error("DOCX processing failed:", processResponse.message);
                    displayErrorMessage("Failed to process DOCX attachments: " + processResponse.message);
                }
                hideLoadingMessage();
            } catch (error) {
                console.error("Error initializing DOCX Email List Flow:", error);
                displayErrorMessage("Failed to process DOCX attachments.");
                hideLoadingMessage();
            }
        }

        // OTP FLOW
        async function initializeOtpFlow() {
            try {
                console.log("Initializing OTP Flow...");
                showOtpLoadingMessage();
                hideOtpEmptyMessage();
                const otpResponse = await fetchOtpCandidates();
                if (otpResponse && otpResponse.status === 'success' && otpResponse.data && Array.isArray(otpResponse.data.candidates) && otpResponse.data.candidates.length) {
                    buildOtpList(otpResponse.data.candidates);
                    hideOtpEmptyMessage();
                } else {
                    console.log('No new OTP candidates to display.');
                    const ul = document.getElementById('otpList');
                    if (ul) { ul.innerHTML = ''; }
                    showOtpEmptyMessage();
                }
                hideOtpLoadingMessage();
            } catch (e) {
                console.error('OTP flow failed:', e);
                hideOtpLoadingMessage();
            }
        }

        async function fetchOtpCandidates() {
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(res => resolve(res))
                    .withFailureHandler(err => reject(err))
                    .get_otp_candidates();
            });
        }

        function buildOtpList(candidates) {
            const ul = document.getElementById('otpList');
            if (!ul) return;
            ul.innerHTML = '';
            hideOtpEmptyMessage();
            candidates.forEach(item => {
                const li = document.createElement('li');
                const button = document.createElement('button');
                button.textContent = item.subject;
                button.addEventListener('click', () => openOtpLink(item.threadId));
                li.appendChild(button);
                ul.appendChild(li);
            });
        }

        async function openOtpLink(threadId) {
            try {
                const res = await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(r => resolve(r))
                        .withFailureHandler(e => reject(e))
                        .get_link_by_threadId(threadId);
                });
                if (res && res.status === 'success' && res.data) {
                    window.open(res.data, '_blank');
                } else {
                    displayErrorMessage('Unable to extract link from the selected message.');
                }
            } catch (e) {
                console.error('Open OTP link failed:', e);
                displayErrorMessage('Failed to open the OTP link.');
            }
        }

        async function fetchDownloadedEmailsFromLocal() {
            const url = 'https://127.0.0.1:8000/downloaded-emails';
            const resp = await fetch(url, { method: 'GET', mode: 'cors', cache: 'no-store', credentials: 'omit' });
            if (!resp.ok) {
                throw new Error('downloaded-emails fetch failed: ' + resp.status);
            }
            return await resp.json();
        }

        async function setDownloadedEmailsOnServer(downloadedEmails) {
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(res => {
                        console.log('setDownloadedEmails result:', res);
                        resolve(res);
                    })
                    .withFailureHandler(err => {
                        console.error('setDownloadedEmails failed:', err);
                        reject(err);
                    })
                    .setDownloadedEmails(downloadedEmails);
            });
        }

        /**
         * Fetches email subjects from the server.
         * @returns {Object} The email subjects response.
         */
        async function fetchEmailSubjects() {
            console.log("Fetching email subjects...");
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(response => {
                        console.log("Received email subjects response:", response);
                        resolve(response);
                    })
                    .withFailureHandler(error => {
                        console.error("Failed to fetch email subjects:", error);
                        reject(error);
                    })
                    .get_subjects();
            });
        }

        /**
         * Builds the email list UI based on fetched subjects.
         * @param {Object} subjectsResponse The email subjects response.
         */
        function buildEmailList(subjectsResponse) {
            console.log("Building email list...");
            if (subjectsResponse.status === "success") {
                const subjects = subjectsResponse.data;
                const emailList = document.getElementById('emailList');
                emailList.innerHTML = ''; // Clear existing list

                subjects.forEach(subject => {
                    const li = document.createElement('li');
                    const button = document.createElement('button');
                    button.textContent = subject.subject;
                    button.addEventListener('click', () => selectEmail(subject.index));
                    li.appendChild(button);
                    emailList.appendChild(li);
                });

                console.log("Email list built successfully.");
            } else {
                console.error("Failed to retrieve email subjects:", subjectsResponse.message);
                displayErrorMessage("Failed to load email subjects: " + subjectsResponse.message);
            }
        }

        /**
         * Handles email selection by the user.
         * Extracts the link from the selected email and redirects the user.
         * @param {number} index The index of the selected email.
         */
        async function selectEmail(index) {
            try {
                console.log("User selected email with index:", index);
                const response = await extractLinkFromEmail(index);
                console.log("Link extraction response:", response);

                if (response.status === "success") {
                    console.log("Redirecting to link:", response.data);
                    window.open(response.data, '_blank'); // polyfill not necessary because can't inject into the Office 365.
                    // window.location.href = response.data; // Open link in the same tab.
                } else {
                    alert('Error: ' + response.message);
                }
            } catch (error) {
                console.error("Error selecting email:", error);
                alert('Failed to extract email link.');
            }
        }

        /**
         * Extracts a link from the selected email.
         * @param {number} index The index of the email to extract the link from.
         * @returns {Object} The link extraction response.
         */
        async function extractLinkFromEmail(index) {
            console.log("Extracting link from email with index:", index);
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(response => {
                        console.log("Received link extraction response:", response);
                        resolve(response);
                    })
                    .withFailureHandler(error => {
                        console.error("Failed to extract link from email:", error);
                        reject(error);
                    })
                    .get_link(index);
            });
        }

        /**
        * Initiates DOCX processing synchronously on the server.
        * @returns {Object} The processing initiation response.
        */
        async function startProcessingDocxAsync() {
            console.log("Starting DOCX processing...");
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(response => {
                        console.log("DOCX processing initiation response:", response);
                        resolve(response);
                    })
                    .withFailureHandler(error => {
                        console.error("Failed to initiate DOCX processing:", error);
                        reject(error);
                    })
                    .process_docx();
            });
        }

        /**
         * Fetches the DOCX processing results from the server.
         * @returns {Object} The DOCX results response.
         */
        async function fetchDocxResults() {
            console.log("Fetching DOCX processing results...");
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(response => {
                        console.log("Received DOCX results response:", response);
                        resolve(response);
                    })
                    .withFailureHandler(error => {
                        console.error("Failed to fetch DOCX results:", error);
                        reject(error);
                    })
                    .get_docx_results();
            });
        }

        /**
         * Builds the DOCX email list UI based on fetched results.
         * @param {Object} docxResultsResponse The DOCX results response.
         */
        function buildDocxList(docxResultsResponse) {
            console.log("Building DOCX email list...");
            if (docxResultsResponse.status === "success") {
                const { subjects, downloadLinks } = docxResultsResponse.data;
                const docxList = document.getElementById('docxEmailList');
                docxList.innerHTML = ''; // Clear existing list

                subjects.forEach(subject => {
                    const li = document.createElement('li');
                    li.textContent = subject.subject;
                    docxList.appendChild(li);
                });

                console.log("DOCX email list built successfully.");
                // Send download links to the Python server; the Python server will handle cleanup upon success
                (async () => {
                    try {
                        await sendDownloadLinksToPythonServer(downloadLinks);
                    } catch (e) {
                        console.error('Download flow failed:', e);
                    }
                })();
            } else {
                console.error("Failed to retrieve DOCX results:", docxResultsResponse.message);
                displayErrorMessage("Failed to load DOCX results: " + docxResultsResponse.message);
            }
        }

        /**
         * Sends download links to the Python server for further processing.
         * @param {Array} downloadLinks The list of download links.
         */
        async function sendDownloadLinksToPythonServer(downloadLinks) {
            // Normalize links and notify Python server even when there is no work,
            // so it can conclude and signal safe shutdown.
            const normalizedLinks = Array.isArray(downloadLinks) ? downloadLinks : [];
            if (normalizedLinks.length === 0) {
                console.log("No download links to send; notifying Python server to conclude session.");
            }

            const baseUrl = 'https://127.0.0.1:8000';
            console.log("Python server URL:", baseUrl);
            console.log("Sending download links to Python server:", normalizedLinks);
            try {
                setBannerWorking();
                startStatusPollingOnce();
                const response = await fetch(baseUrl + '/download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        links: normalizedLinks.map(link => ({
                            url: link.url,
                            filename: link.filename,
                            fileId: link.fileId,
                        }))
                    }),
                    mode: 'cors'
                });

                if (!response.ok) {
                    const errorText = await response.text().catch(() => '');
                    throw new Error(`Network response was not ok: ${response.status} - ${errorText}`);
                }

                const data = await response.json().catch(() => ({}));
                console.log("Python server response:", data);
                if (data.status === 'success') {
                    console.log('Python server handshake complete. Accepted ' + normalizedLinks.length + ' link(s).');
                    if (data.safeToClose) { setBannerSafe(); }
                    return data;
                } else {
                    console.error("Error from Python server:", data.message);
                    displayErrorMessage('Error: ' + (data.message || 'Unexpected server response'));
                }
            } catch (error) {
                console.error('Error sending download links to Python server:', error);
                await diagnoseAfterFailure(baseUrl, error);
                throw error; // Propagate so callers can abort cleanup flow
            }
        }

        // Status banner helpers and polling
        var SAFE_TO_CLOSE = false;
        function setBannerSafe(){
            SAFE_TO_CLOSE = true;
            try { window.onbeforeunload = null; } catch (e) {}
            var b = document.getElementById('closeStatusBanner');
            if(!b) return;
            b.classList.remove('status-working');
            b.classList.add('status-safe');
            var ic = b.querySelector('.icon'); if (ic) ic.textContent = '✅';
            var tx = b.querySelector('.text'); if (tx) tx.textContent = 'All set — you can close this tab now. Cleanup will continue in the background.';
        }
        function setBannerWorking(){
            SAFE_TO_CLOSE = false;
            try { window.onbeforeunload = function(){ return 'Work is still in progress. Are you sure you want to leave?'; }; } catch (e) {}
            var b = document.getElementById('closeStatusBanner');
            if(!b) return;
            b.classList.remove('status-safe');
            b.classList.add('status-working');
            var ic = b.querySelector('.icon'); if (ic) ic.textContent = '⏳';
            var tx = b.querySelector('.text'); if (tx) tx.textContent = 'Please keep this tab open while we process your files…';
        }
        function updateStatusDetails(data){
            try{
                var d = data||{}; var c = (d.counts||{});
                var S = function(id,v){ var el=document.getElementById(id); if(el){ el.textContent = String(v==null? '': v); } };
                S('stPhase', d.phase||'working');
                S('stLinks', c.linksReceived||0);
                S('stDownloaded', c.filesDownloaded||0);
                S('stToDelete', c.filesToDelete||0);
                S('stDeleted', c.filesDeleted||0);
                var er = document.getElementById('stErrorRow');
                var et = document.getElementById('stError');
                if(er && et){ if(d.lastError){ er.style.display='list-item'; et.textContent=String(d.lastError);} else { er.style.display='none'; et.textContent=''; } }
            }catch(e){}
        }
        var __statusPollStarted = false;
        function startStatusPollingOnce(){ if (__statusPollStarted) return; __statusPollStarted = true; pollSafeStatus(); }
        async function pollSafeStatus(){
            try{
                const res = await fetch('https://127.0.0.1:8000/status', { method:'GET', mode:'cors', cache:'no-store', credentials:'omit' });
                if(res && res.ok){
                    const data = await res.json();
                    updateStatusDetails(data);
                    if(data && data.safeToClose){ setBannerSafe(); return; }
                }
            }catch(e){ /* ignore transient errors */ }
            if(!SAFE_TO_CLOSE){ setTimeout(pollSafeStatus, 2000); }
        }
        (function(){
            var btn = document.getElementById('statusDetailsToggle');
            var panel = document.getElementById('statusDetails');
            if(btn && panel){
                btn.addEventListener('click', function(){
                    var expanded = btn.getAttribute('aria-expanded') === 'true';
                    btn.setAttribute('aria-expanded', String(!expanded));
                    panel.hidden = expanded;
                });
            }
        })();

        async function deleteFilesInGas(fileIds) {
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(res => { console.log('handleDeleteFiles result:', res); resolve(res); })
                    .withFailureHandler(err => { console.error('handleDeleteFiles failed:', err); reject(err); })
                    .handleDeleteFiles(fileIds);
            });
        }

        async function diagnoseAfterFailure(baseUrl, originalError) {
            try {
                if (!navigator.onLine) {
                    displayErrorMessage('You appear to be offline. Please check your internet connection.');
                    return;
                }
                // Probe server reachability
                let healthOk = false;
                let healthStatus = null;
                try {
                    const res = await fetch(baseUrl + '/_health', { method: 'GET', mode: 'cors', cache: 'no-store', credentials: 'omit' });
                    healthOk = !!res && res.ok;
                    healthStatus = res ? (res.status + ' ' + (res.statusText || '')) : null;
                } catch (e) {
                    // ignore, handled below
                }

                if (healthOk) {
                    displayErrorMessage('The Python server is reachable, but the download request failed. Please try again or restart the Python tool.');
                    showRetryAction(() => initializeDocxEmailListFlow());
                } else {
                    // Generic but actionable guidance
                    displayErrorMessage('Unable to reach the local Python server at https://127.0.0.1:8000. Ensure it is running and trusted by your browser (open the URL once if needed).');
                    showRetryAction(() => initializeDocxEmailListFlow());
                }
            } catch (diagErr) {
                // Fallback to original error message
                displayErrorMessage('Unable to send download links to the server. Error: ' + (originalError && originalError.message ? originalError.message : String(originalError)));
                showRetryAction(() => initializeDocxEmailListFlow());
            }
        }

        /**
         * Delays execution for a specified number of milliseconds.
         * @param {number} ms The delay duration in milliseconds.
         * @returns {Promise} A promise that resolves after the delay.
         */
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Displays an error message to the user.
         * @param {string} message The error message to display.
         */
        function displayErrorMessage(message) {
            console.error("Error:", message); // Log the error to the console
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function showRetryAction(handler) {
            try {
                const errorDiv = document.getElementById('errorMessage');
                if (!errorDiv) return;
                const btn = document.createElement('button');
                btn.textContent = 'Try again';
                btn.addEventListener('click', () => {
                    errorDiv.style.display = 'none';
                    handler && handler();
                });
                errorDiv.appendChild(document.createElement('br'));
                errorDiv.appendChild(btn);
            } catch (e) { /* no-op */ }
        }

        function showOtpLoadingMessage() {
            try {
                const loadingDiv = document.getElementById('otpLoadingMessage');
                if (loadingDiv) loadingDiv.style.display = 'block';
            } catch (e) {}
        }

        function hideOtpLoadingMessage() {
            try {
                const loadingDiv = document.getElementById('otpLoadingMessage');
                if (loadingDiv) loadingDiv.style.display = 'none';
            } catch (e) {}
        }

        function showOtpEmptyMessage() {
            try {
                const emptyDiv = document.getElementById('otpEmptyMessage');
                if (emptyDiv) emptyDiv.style.display = 'block';
            } catch (e) {}
        }

        function hideOtpEmptyMessage() {
            try {
                const emptyDiv = document.getElementById('otpEmptyMessage');
                if (emptyDiv) emptyDiv.style.display = 'none';
            } catch (e) {}
        }

        /**
         * Shows the loading message.
         */
        function showLoadingMessage() {
            console.log("Showing loading message.");
            const loadingDiv = document.getElementById('loadingMessage');
            loadingDiv.style.display = 'block';
        }

        /**
         * Hides the loading message.
         */
        function hideLoadingMessage() {
            console.log("Hiding loading message.");
            const loadingDiv = document.getElementById('loadingMessage');
            loadingDiv.style.display = 'none';
        }
    </script>
</body>
</html>