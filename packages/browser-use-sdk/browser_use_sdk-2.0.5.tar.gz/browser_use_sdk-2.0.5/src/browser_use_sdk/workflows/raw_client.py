# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.execution_mode import ExecutionMode
from ..types.workflow_execution_list_response import WorkflowExecutionListResponse
from ..types.workflow_execution_log_response import WorkflowExecutionLogResponse
from ..types.workflow_execution_response import WorkflowExecutionResponse
from ..types.workflow_execution_status import WorkflowExecutionStatus
from ..types.workflow_generate_response import WorkflowGenerateResponse
from ..types.workflow_list_response import WorkflowListResponse
from ..types.workflow_response import WorkflowResponse
from ..types.workflow_yaml_presigned_upload_response import WorkflowYamlPresignedUploadResponse
from .types.execute_workflow_workflows_workflow_id_execute_post_response import (
    ExecuteWorkflowWorkflowsWorkflowIdExecutePostResponse,
)

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawWorkflowsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_workflows(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        is_archived: typing.Optional[bool] = None,
        user_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowListResponse]:
        """
        Get paginated list of workflows with optional filtering.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        is_archived : typing.Optional[bool]

        user_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowListResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "isArchived": is_archived,
                "userId": user_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowListResponse,
                    construct_type(
                        type_=WorkflowListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_workflow(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowResponse]:
        """
        Create a new workflow. The workflow YAML should be uploaded separately via the update endpoint.

        Parameters
        ----------
        name : str
            Name of the workflow

        description : typing.Optional[str]
            Optional description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows",
            method="POST",
            json={
                "name": name,
                "description": description,
                "variables": variables,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowResponse]:
        """
        Get detailed workflow information including presigned URL to download YAML.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowResponse]:
        """
        Archive a workflow (soft delete).

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_workflow(
        self,
        workflow_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowResponse]:
        """
        Update workflow metadata.

        Parameters
        ----------
        workflow_id : str

        name : typing.Optional[str]
            Name of the workflow

        description : typing.Optional[str]
            Description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "variables": variables,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_workflow_yaml_presigned_url(
        self,
        workflow_id: str,
        *,
        size_bytes: int,
        file_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowYamlPresignedUploadResponse]:
        """
        Get a presigned URL to upload workflow YAML directly to S3 from the browser.

        This avoids sending the YAML content through the backend, reducing latency
        and avoiding KMS permission issues in local development.

        Parameters
        ----------
        workflow_id : str

        size_bytes : int
            Size of the YAML file in bytes

        file_name : typing.Optional[str]
            The name of the YAML file to upload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowYamlPresignedUploadResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/yaml/presigned-url",
            method="POST",
            json={
                "fileName": file_name,
                "sizeBytes": size_bytes,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowYamlPresignedUploadResponse,
                    construct_type(
                        type_=WorkflowYamlPresignedUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def execute_workflow(
        self,
        workflow_id: str,
        *,
        input: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        mode: typing.Optional[ExecutionMode] = OMIT,
        execution_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ExecuteWorkflowWorkflowsWorkflowIdExecutePostResponse]:
        """
        Execute a workflow either synchronously or asynchronously.

        - ASYNC mode: Returns execution ID immediately and processes in background via Lambda
        - SYNC mode: Waits for execution to complete and returns results inline (max 5 min timeout)

        Parameters
        ----------
        workflow_id : str

        input : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Input parameters for the workflow execution

        mode : typing.Optional[ExecutionMode]
            Execution mode (sync or async)

        execution_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional metadata for this execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ExecuteWorkflowWorkflowsWorkflowIdExecutePostResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/execute",
            method="POST",
            json={
                "input": input,
                "mode": mode,
                "executionMetadata": execution_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ExecuteWorkflowWorkflowsWorkflowIdExecutePostResponse,
                    construct_type(
                        type_=ExecuteWorkflowWorkflowsWorkflowIdExecutePostResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_workflow(
        self,
        workflow_id: str,
        *,
        task_prompt: str,
        workflow_name: typing.Optional[str] = OMIT,
        enable_variable_extraction: typing.Optional[bool] = OMIT,
        use_deterministic_conversion: typing.Optional[bool] = OMIT,
        use_cloud_browser: typing.Optional[bool] = OMIT,
        enable_pattern_variable_identification: typing.Optional[bool] = OMIT,
        pattern_variable_confidence: typing.Optional[float] = OMIT,
        enable_ai_validation: typing.Optional[bool] = OMIT,
        cleanup_yaml: typing.Optional[bool] = OMIT,
        remove_descriptions: typing.Optional[bool] = OMIT,
        remove_verification_checks: typing.Optional[bool] = OMIT,
        remove_expected_outcomes: typing.Optional[bool] = OMIT,
        remove_agent_reasoning: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowGenerateResponse]:
        """
        Generate a workflow from a natural language task description.

        This endpoint uses the workflow-use library's HealingService to:
        1. Record browser interactions for the task
        2. Convert interactions to a reusable workflow
        3. Extract variables for parameterization
        4. Save the generated YAML to S3

        The generation happens asynchronously via the workflow_worker Lambda.

        Parameters
        ----------
        workflow_id : str

        task_prompt : str
            Natural language description of the task to automate

        workflow_name : typing.Optional[str]
            Optional name for the generated workflow. If not provided, will be inferred from prompt.

        enable_variable_extraction : typing.Optional[bool]
            Whether to extract reusable variables from the workflow

        use_deterministic_conversion : typing.Optional[bool]
            Whether to use deterministic conversion (faster and cheaper)

        use_cloud_browser : typing.Optional[bool]
            Whether to use cloud browser for recording (recommended for production)

        enable_pattern_variable_identification : typing.Optional[bool]
            Enable pattern-based variable identification (no LLM, $0 cost)

        pattern_variable_confidence : typing.Optional[float]
            Minimum confidence threshold for pattern-based detection (0.0 to 1.0)

        enable_ai_validation : typing.Optional[bool]
            Enable AI validation to review and fix generated workflow

        cleanup_yaml : typing.Optional[bool]
            Remove verbose fields from generated YAML

        remove_descriptions : typing.Optional[bool]
            Remove step descriptions (only if cleanup_yaml=True)

        remove_verification_checks : typing.Optional[bool]
            Remove verification_checks (only if cleanup_yaml=True)

        remove_expected_outcomes : typing.Optional[bool]
            Remove expected_outcome fields (only if cleanup_yaml=True)

        remove_agent_reasoning : typing.Optional[bool]
            Remove agent_reasoning fields (only if cleanup_yaml=True)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowGenerateResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/generate",
            method="POST",
            json={
                "taskPrompt": task_prompt,
                "workflowName": workflow_name,
                "enableVariableExtraction": enable_variable_extraction,
                "useDeterministicConversion": use_deterministic_conversion,
                "useCloudBrowser": use_cloud_browser,
                "enablePatternVariableIdentification": enable_pattern_variable_identification,
                "patternVariableConfidence": pattern_variable_confidence,
                "enableAiValidation": enable_ai_validation,
                "cleanupYaml": cleanup_yaml,
                "removeDescriptions": remove_descriptions,
                "removeVerificationChecks": remove_verification_checks,
                "removeExpectedOutcomes": remove_expected_outcomes,
                "removeAgentReasoning": remove_agent_reasoning,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowGenerateResponse,
                    construct_type(
                        type_=WorkflowGenerateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowExecutionResponse]:
        """
        Get detailed execution information including status, results, and costs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionResponse,
                    construct_type(
                        type_=WorkflowExecutionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_workflow_executions(
        self,
        workflow_id_: str,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowExecutionListResponse]:
        """
        Get paginated list of executions for a specific workflow.

        Parameters
        ----------
        workflow_id_ : str

        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionListResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id_)}/executions",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "status": status,
                "workflowId": workflow_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionListResponse,
                    construct_type(
                        type_=WorkflowExecutionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_all_executions(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowExecutionListResponse]:
        """
        Get paginated list of all workflow executions for a project.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionListResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows/executions",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "status": status,
                "workflowId": workflow_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionListResponse,
                    construct_type(
                        type_=WorkflowExecutionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def cancel_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowExecutionResponse]:
        """
        Cancel a pending or running workflow execution.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/cancel",
            method="PATCH",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionResponse,
                    construct_type(
                        type_=WorkflowExecutionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_execution_logs(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowExecutionLogResponse]:
        """
        Get presigned URL to download execution logs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionLogResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/logs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionLogResponse,
                    construct_type(
                        type_=WorkflowExecutionLogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawWorkflowsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_workflows(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        is_archived: typing.Optional[bool] = None,
        user_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowListResponse]:
        """
        Get paginated list of workflows with optional filtering.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        is_archived : typing.Optional[bool]

        user_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowListResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "isArchived": is_archived,
                "userId": user_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowListResponse,
                    construct_type(
                        type_=WorkflowListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_workflow(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Create a new workflow. The workflow YAML should be uploaded separately via the update endpoint.

        Parameters
        ----------
        name : str
            Name of the workflow

        description : typing.Optional[str]
            Optional description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows",
            method="POST",
            json={
                "name": name,
                "description": description,
                "variables": variables,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Get detailed workflow information including presigned URL to download YAML.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Archive a workflow (soft delete).

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_workflow(
        self,
        workflow_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Update workflow metadata.

        Parameters
        ----------
        workflow_id : str

        name : typing.Optional[str]
            Name of the workflow

        description : typing.Optional[str]
            Description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "variables": variables,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_workflow_yaml_presigned_url(
        self,
        workflow_id: str,
        *,
        size_bytes: int,
        file_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowYamlPresignedUploadResponse]:
        """
        Get a presigned URL to upload workflow YAML directly to S3 from the browser.

        This avoids sending the YAML content through the backend, reducing latency
        and avoiding KMS permission issues in local development.

        Parameters
        ----------
        workflow_id : str

        size_bytes : int
            Size of the YAML file in bytes

        file_name : typing.Optional[str]
            The name of the YAML file to upload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowYamlPresignedUploadResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/yaml/presigned-url",
            method="POST",
            json={
                "fileName": file_name,
                "sizeBytes": size_bytes,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowYamlPresignedUploadResponse,
                    construct_type(
                        type_=WorkflowYamlPresignedUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def execute_workflow(
        self,
        workflow_id: str,
        *,
        input: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        mode: typing.Optional[ExecutionMode] = OMIT,
        execution_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ExecuteWorkflowWorkflowsWorkflowIdExecutePostResponse]:
        """
        Execute a workflow either synchronously or asynchronously.

        - ASYNC mode: Returns execution ID immediately and processes in background via Lambda
        - SYNC mode: Waits for execution to complete and returns results inline (max 5 min timeout)

        Parameters
        ----------
        workflow_id : str

        input : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Input parameters for the workflow execution

        mode : typing.Optional[ExecutionMode]
            Execution mode (sync or async)

        execution_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional metadata for this execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ExecuteWorkflowWorkflowsWorkflowIdExecutePostResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/execute",
            method="POST",
            json={
                "input": input,
                "mode": mode,
                "executionMetadata": execution_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ExecuteWorkflowWorkflowsWorkflowIdExecutePostResponse,
                    construct_type(
                        type_=ExecuteWorkflowWorkflowsWorkflowIdExecutePostResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_workflow(
        self,
        workflow_id: str,
        *,
        task_prompt: str,
        workflow_name: typing.Optional[str] = OMIT,
        enable_variable_extraction: typing.Optional[bool] = OMIT,
        use_deterministic_conversion: typing.Optional[bool] = OMIT,
        use_cloud_browser: typing.Optional[bool] = OMIT,
        enable_pattern_variable_identification: typing.Optional[bool] = OMIT,
        pattern_variable_confidence: typing.Optional[float] = OMIT,
        enable_ai_validation: typing.Optional[bool] = OMIT,
        cleanup_yaml: typing.Optional[bool] = OMIT,
        remove_descriptions: typing.Optional[bool] = OMIT,
        remove_verification_checks: typing.Optional[bool] = OMIT,
        remove_expected_outcomes: typing.Optional[bool] = OMIT,
        remove_agent_reasoning: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowGenerateResponse]:
        """
        Generate a workflow from a natural language task description.

        This endpoint uses the workflow-use library's HealingService to:
        1. Record browser interactions for the task
        2. Convert interactions to a reusable workflow
        3. Extract variables for parameterization
        4. Save the generated YAML to S3

        The generation happens asynchronously via the workflow_worker Lambda.

        Parameters
        ----------
        workflow_id : str

        task_prompt : str
            Natural language description of the task to automate

        workflow_name : typing.Optional[str]
            Optional name for the generated workflow. If not provided, will be inferred from prompt.

        enable_variable_extraction : typing.Optional[bool]
            Whether to extract reusable variables from the workflow

        use_deterministic_conversion : typing.Optional[bool]
            Whether to use deterministic conversion (faster and cheaper)

        use_cloud_browser : typing.Optional[bool]
            Whether to use cloud browser for recording (recommended for production)

        enable_pattern_variable_identification : typing.Optional[bool]
            Enable pattern-based variable identification (no LLM, $0 cost)

        pattern_variable_confidence : typing.Optional[float]
            Minimum confidence threshold for pattern-based detection (0.0 to 1.0)

        enable_ai_validation : typing.Optional[bool]
            Enable AI validation to review and fix generated workflow

        cleanup_yaml : typing.Optional[bool]
            Remove verbose fields from generated YAML

        remove_descriptions : typing.Optional[bool]
            Remove step descriptions (only if cleanup_yaml=True)

        remove_verification_checks : typing.Optional[bool]
            Remove verification_checks (only if cleanup_yaml=True)

        remove_expected_outcomes : typing.Optional[bool]
            Remove expected_outcome fields (only if cleanup_yaml=True)

        remove_agent_reasoning : typing.Optional[bool]
            Remove agent_reasoning fields (only if cleanup_yaml=True)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowGenerateResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/generate",
            method="POST",
            json={
                "taskPrompt": task_prompt,
                "workflowName": workflow_name,
                "enableVariableExtraction": enable_variable_extraction,
                "useDeterministicConversion": use_deterministic_conversion,
                "useCloudBrowser": use_cloud_browser,
                "enablePatternVariableIdentification": enable_pattern_variable_identification,
                "patternVariableConfidence": pattern_variable_confidence,
                "enableAiValidation": enable_ai_validation,
                "cleanupYaml": cleanup_yaml,
                "removeDescriptions": remove_descriptions,
                "removeVerificationChecks": remove_verification_checks,
                "removeExpectedOutcomes": remove_expected_outcomes,
                "removeAgentReasoning": remove_agent_reasoning,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowGenerateResponse,
                    construct_type(
                        type_=WorkflowGenerateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowExecutionResponse]:
        """
        Get detailed execution information including status, results, and costs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionResponse,
                    construct_type(
                        type_=WorkflowExecutionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_workflow_executions(
        self,
        workflow_id_: str,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowExecutionListResponse]:
        """
        Get paginated list of executions for a specific workflow.

        Parameters
        ----------
        workflow_id_ : str

        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionListResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id_)}/executions",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "status": status,
                "workflowId": workflow_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionListResponse,
                    construct_type(
                        type_=WorkflowExecutionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_all_executions(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowExecutionListResponse]:
        """
        Get paginated list of all workflow executions for a project.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionListResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows/executions",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "status": status,
                "workflowId": workflow_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionListResponse,
                    construct_type(
                        type_=WorkflowExecutionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def cancel_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowExecutionResponse]:
        """
        Cancel a pending or running workflow execution.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/cancel",
            method="PATCH",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionResponse,
                    construct_type(
                        type_=WorkflowExecutionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_execution_logs(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowExecutionLogResponse]:
        """
        Get presigned URL to download execution logs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionLogResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/logs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionLogResponse,
                    construct_type(
                        type_=WorkflowExecutionLogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
