"""Code Block Storage Manager for FastStreamingAgent.

This module provides temporary file storage for code blocks generated by the
FastStreamingAgent, enabling code_apply functionality with unique IDs.
"""

import os
import secrets
import string
import threading
import time
import logging
from pathlib import Path
from typing import Dict, Tuple, Optional
import traceback

# Configure logging
logger = logging.getLogger(__name__)


class CodeBlockStorage:
    """Thread-safe storage manager for temporary code blocks.
    
    This class manages temporary storage of code blocks with unique IDs,
    providing save, retrieve, and cleanup functionality for the code_apply system.
    """
    
    def __init__(self, base_dir: Optional[str] = None):
        """Initialize storage with optional base directory.
        
        Args:
            base_dir: Base directory for temp files. Defaults to /tmp/faststream_code/
        """
        self.base_dir = Path(base_dir) if base_dir else Path("/tmp/faststream_code")
        self._id_to_filepath: Dict[str, str] = {}
        self._lock = threading.Lock()
        
        # Create base directory if it doesn't exist
        try:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            logger.info(f"Initialized CodeBlockStorage with base directory: {self.base_dir}")
        except Exception as e:
            logger.error(f"Failed to create base directory {self.base_dir}: {traceback.format_exc()}")
            raise Exception(f"Failed to initialize CodeBlockStorage: {traceback.format_exc()}")
    
    def get_code_id(self) -> str:
        """Generate unique 6-character alphanumeric ID.
        
        Returns:
            6-character string containing letters and numbers only
        """
        # Use secrets for cryptographically secure random generation
        # Use only letters and numbers (no symbols)
        alphabet = string.ascii_letters + string.digits
        return ''.join(secrets.choice(alphabet) for _ in range(6))
    
    def save_code(self, code: str, language: str = "python") -> Tuple[str, str]:
        """Save code block to temporary file.
        
        Args:
            code: Code content to save
            language: Programming language for file extension
            
        Returns:
            Tuple of (code_id, filepath)
            
        Raises:
            Exception: If file creation or writing fails
        """
        # Map language to file extension
        extension_map = {
            'python': 'py',
            'javascript': 'js',
            'typescript': 'ts',
            'jsx': 'jsx',
            'tsx': 'tsx',
            'java': 'java',
            'cpp': 'cpp',
            'c': 'c',
            'csharp': 'cs',
            'php': 'php',
            'ruby': 'rb',
            'go': 'go',
            'rust': 'rs',
            'sql': 'sql',
            'html': 'html',
            'css': 'css',
            'json': 'json',
            'xml': 'xml',
            'yaml': 'yaml',
            'yml': 'yaml',
            'markdown': 'md',
            'text': 'txt'
        }
        
        extension = extension_map.get(language.lower(), 'txt')
        
        with self._lock:
            # Generate unique ID
            code_id = self.get_code_id()
            
            # Ensure ID is unique (extremely unlikely collision, but be safe)
            max_attempts = 100
            attempts = 0
            while code_id in self._id_to_filepath and attempts < max_attempts:
                code_id = self.get_code_id()
                attempts += 1
            
            if attempts >= max_attempts:
                raise Exception("Failed to generate unique code ID after 100 attempts")
            
            # Create file path
            filename = f"{code_id}.{extension}"
            filepath = self.base_dir / filename
            
            try:
                # Write code to file
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(code)
                
                # Store mapping
                self._id_to_filepath[code_id] = str(filepath)
                
                logger.info(f"Saved code block {code_id} to {filepath} ({len(code)} chars)")
                return code_id, str(filepath)
                
            except Exception as e:
                logger.error(f"Failed to save code block {code_id}: {traceback.format_exc()}")
                raise Exception(f"Failed to save code block: {traceback.format_exc()}")
    
    def get_filepath(self, code_id: str) -> str:
        """Get filepath for given code ID.
        
        Args:
            code_id: 6-character code identifier
            
        Returns:
            Full filepath as string
            
        Raises:
            ValueError: If code_id is not found
        """
        with self._lock:
            if code_id not in self._id_to_filepath:
                raise ValueError(f"Code ID '{code_id}' not found in storage")
            
            filepath = self._id_to_filepath[code_id]
            
            # Verify file still exists
            if not os.path.exists(filepath):
                # Clean up stale mapping
                del self._id_to_filepath[code_id]
                raise ValueError(f"Code file for ID '{code_id}' no longer exists at {filepath}")
            
            return filepath
    
    def cleanup_old_files(self, max_age_seconds: int = 3600):
        """Remove files older than max_age_seconds.
        
        Args:
            max_age_seconds: Maximum age in seconds. Defaults to 1 hour (3600s).
        """
        current_time = time.time()
        removed_count = 0
        error_count = 0
        
        with self._lock:
            # Get list of files to check (create copy to avoid dict modification during iteration)
            ids_to_check = list(self._id_to_filepath.keys())
            
            for code_id in ids_to_check:
                filepath = self._id_to_filepath[code_id]
                
                try:
                    # Check if file exists and get its age
                    if os.path.exists(filepath):
                        file_mtime = os.path.getmtime(filepath)
                        file_age = current_time - file_mtime
                        
                        if file_age > max_age_seconds:
                            # Try to remove the file (non-blocking - don't fail if file is in use)
                            try:
                                os.unlink(filepath)
                                logger.debug(f"Removed old code file: {filepath} (age: {file_age:.1f}s)")
                                removed_count += 1
                            except OSError as e:
                                # File might be in use, log but don't fail
                                logger.debug(f"Could not remove file {filepath}: {e}")
                                error_count += 1
                                continue
                    
                    # If file was removed or doesn't exist, clean up mapping
                    if not os.path.exists(filepath):
                        del self._id_to_filepath[code_id]
                        
                except Exception as e:
                    logger.debug(f"Error checking file {filepath}: {e}")
                    error_count += 1
                    continue
        
        if removed_count > 0 or error_count > 0:
            logger.info(f"Cleanup completed: removed {removed_count} files, {error_count} errors")
    
    def get_stats(self) -> Dict[str, int]:
        """Get storage statistics.
        
        Returns:
            Dictionary with storage statistics
        """
        with self._lock:
            total_files = len(self._id_to_filepath)
            existing_files = 0
            total_size = 0
            
            for filepath in self._id_to_filepath.values():
                if os.path.exists(filepath):
                    existing_files += 1
                    try:
                        total_size += os.path.getsize(filepath)
                    except OSError:
                        pass
            
            return {
                'tracked_files': total_files,
                'existing_files': existing_files,
                'total_size_bytes': total_size
            }


# Global instance for easy access
_global_storage: Optional[CodeBlockStorage] = None


def get_global_storage() -> CodeBlockStorage:
    """Get or create global CodeBlockStorage instance.
    
    Returns:
        Global CodeBlockStorage instance
    """
    global _global_storage
    if _global_storage is None:
        _global_storage = CodeBlockStorage()
    return _global_storage


def save_code_block(code: str, language: str = "python") -> Tuple[str, str]:
    """Convenience function to save code using global storage.
    
    Args:
        code: Code content to save
        language: Programming language for file extension
        
    Returns:
        Tuple of (code_id, filepath)
    """
    return get_global_storage().save_code(code, language)


def get_code_filepath(code_id: str) -> str:
    """Convenience function to get filepath using global storage.
    
    Args:
        code_id: 6-character code identifier
        
    Returns:
        Full filepath as string
    """
    return get_global_storage().get_filepath(code_id)


def cleanup_old_code_files(max_age_seconds: int = 3600):
    """Convenience function to cleanup old files using global storage.
    
    Args:
        max_age_seconds: Maximum age in seconds. Defaults to 1 hour.
    """
    get_global_storage().cleanup_old_files(max_age_seconds)