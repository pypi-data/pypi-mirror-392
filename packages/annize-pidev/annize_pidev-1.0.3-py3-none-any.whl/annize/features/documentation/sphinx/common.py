# SPDX-FileCopyrightText: Â© 2021 Josef Hahn
# SPDX-License-Identifier: AGPL-3.0-only
"""
Sphinx-based documentation. See :py:class:`Document`.
"""
import abc
import dataclasses
import datetime
import subprocess
import typing as t

import hallyd

import annize.asset
import annize.data
import annize.features._pidev.common
import annize.features._pidev.i18n
import annize.features.authors
import annize.features.base
import annize.features.dependencies.common
import annize.features.documentation.common
import annize.features.documentation.sphinx.output.common
import annize.features.documentation.sphinx.output.html as _
import annize.features.documentation.sphinx.output.pdf as _
import annize.features.documentation.sphinx.output.plaintext as _
import annize.features.documentation.sphinx.rst
import annize.features.i18n.common
import annize.features.licensing
import annize.features.version
import annize.flow.run_context
import annize.fs
import annize.i18n


class Document(annize.features.documentation.common.Document, abc.ABC):
    """
    Base class for documents generated by 'Sphinx'.
    """

    def __init__(self, *, project_name: annize.i18n.TrStr|None, title: annize.i18n.TrStr|None,
                 short_title: annize.i18n.TrStr|None, title_tagline: annize.i18n.TrStr|None, authors: t.Sequence[annize.features.authors.Author],
                 version: annize.data.Version|None, release: annize.i18n.TrStr|None):
        """
        :param project_name: The project name.
        :param title: The document title. Note: This is only used by some output formats in some circumstances. It does
                      not replace a header inside the document content.
        :param short_title: The short variant of the document title. See :code:`title`.
        :param title_tagline: The additional title tagline text. See :code:`title`.
        :param authors: The project authors.
        :param version: The project version.
        :param release: The project release. This may contain the version number in a more detailed way than
                        :code:`version`.
        """
        super().__init__()
        self.__project_name = project_name
        self.__title = title
        self.__short_title = short_title
        self.__title_tagline = title_tagline
        self.__authors = tuple(authors)
        self.__version = version
        self.__release = release

    @property
    def project_name(self) -> annize.i18n.TrStr:
        """
        The project name as it will actually be used for the document.
        This is the same as :py:attr:`original_project_name` if not empty, but falls back to project level data.
        """
        return (self.original_project_name or annize.features.base.pretty_project_name()
                or annize.features._pidev.i18n.TrStr.tr("an_ThisProject"))

    @property
    def original_project_name(self) -> annize.i18n.TrStr|None:
        """
        The project name as originally specified for this document. See also :py:attr:`project_name`.
        """
        return self.__project_name

    @property
    def title(self) -> annize.i18n.TrStr:
        """
        The document title. Note: This is only used by some output formats in some circumstances. It does not replace a
        header inside the document content.
        This is the same as :py:attr:`original_title` if not empty, but falls back to project level data.
        """
        return self.original_title or self.project_name

    @property
    def original_title(self) -> annize.i18n.TrStr|None:
        """
        The project title as originally specified for this document. See also :py:attr:`title`.
        """
        return self.__title

    @property
    def short_title(self) -> annize.i18n.TrStr:
        """
        The short variant of the document title.
        This is the same as :py:attr:`original_short_title` if not empty, but falls back to project level data.
        """
        return self.original_short_title or self.title

    @property
    def original_short_title(self) -> annize.i18n.TrStr|None:
        """
        The short variant of the document title as originally specified for this document. See also
        :py:attr:`short_title`.
        """
        return self.__short_title

    @property
    def title_tagline(self) -> annize.i18n.TrStr|None:
        """
        The additional title tagline text.
        """
        return self.__title_tagline

    @property
    def authors(self) -> t.Sequence[annize.features.authors.Author]:
        """
        The project authors.
        """
        return self.__authors

    @property
    def version(self) -> annize.data.Version|None:
        """
        The project version.
        """
        return self.__version

    @property
    def release(self) -> annize.i18n.TrStr|None:
        """
        The project release.
        This may contain the version number in a more detailed way than :py:attr:`version`.
        """
        return self.__release

    def generate_all_cultures(self, output_spec):
        return annize.features.documentation.sphinx.output.common.output_generator(
            output_spec).multi_language_frame(self)

    def generate(self, output_spec, *, culture=None):
        with culture or annize.i18n.current_culture() as culture:
            generator = annize.features.documentation.sphinx.output.common.output_generator(
                output_spec)

            with annize.fs.fresh_temp_directory() as temp_config_dir:
                with annize.fs.fresh_temp_directory() as temp_source_dir:
                    out_dir = annize.fs.fresh_temp_directory().path
                    info = Document.GenerateInfo(self, temp_config_dir, temp_source_dir, culture, {}, [])
                    self.__generate__set_misc(info)
                    self.__generate__short_snippets(info)
                    self.__generate__prepare_annize_icons(info)
                    self.__generate__set_version_and_release(info)

                    info.config_values["master_doc"] = self._generate_sources(info)
                    generator.prepare_generate(info)
                    (temp_config_dir / "conf.py").write_text(self.__generate__info_to_conf_py(info))
                    subprocess.check_call(("sphinx-build", "-c", temp_config_dir, "-b", generator.format_name(),
                                           temp_source_dir, out_dir), stderr=subprocess.STDOUT)

            out_dir = generator.postprocess(out_dir)
            return annize.features.documentation.common.Document.GeneratedResult(out_dir, info.entry_path)

    @abc.abstractmethod
    def _generate_sources(self, info: "Document.GenerateInfo") -> str:
        """
        Generate Sphinx document sources in :code:`info.document_source_dir` and return its file name without extension.

        :param info: The generate info.
        """

    def __generate__set_misc(self, info):
        info.config_values.update({
            "project": str(self.project_name or annize.features.base.pretty_project_name()),
            "nitpicky": True,
            "rst_epilog": "",
            "extensions": ["sphinx.ext.autosummary", "sphinx.ext.graphviz", "sphinx.ext.inheritance_diagram"],
            "autoclass_content": "both",
            "autodoc_typehints": "description",
            "text_sectionchars": "#*=-^\"~",
            "html_show_sphinx": False,
            "html_static_path": [],
            "html_theme_options": dict(),
            "html_sidebars": {"**": ["globaltoc.html", "searchbox.html"]},
            "language": info.culture.iso_639_1_language_code,
            "latex_elements": {"maxlistdepth": "99"}})

        author = annize.features.authors.join_authors(
            self.__authors or annize.features.authors.project_authors()).full_name
        info.config_values["copyright"] = f"{datetime.datetime.now().year}, {author}"

    @staticmethod
    def __generate__short_snippets(info):
        short_snippets = {}
        substitutions = "\n".join([f".. |{k}| replace:: {v}" for k, v in short_snippets.items()])
        info.config_values["rst_epilog"] += substitutions + "\n"

    @staticmethod
    def __generate__prepare_annize_icons(info):
        icons_dir = annize.features._pidev.common.data_dir("icons")
        substitutions = "\n".join((f".. |annizeicon_{icon_name}| image:: /_annize_icons/{icon_name}.png"
                                   for icon_name in sorted(_.stem for _ in icons_dir.iterdir())))
        info.config_values["rst_epilog"] += substitutions + "\n"
        icons_dir.copy_to(info.document_source_dir("_annize_icons"))

    def __generate__set_version_and_release(self, info):
        version = self.version
        if not version:
            project_versions = annize.features.version.project_versions()
            if len(project_versions) == 1:
                version = project_versions[0]
        if version:
            info.config_values["version"] = str(version)
        release = self.release or version
        if release:
            info.config_values["release"] = str(release)

    @staticmethod
    def __generate__info_to_conf_py(info):
        return "\n".join(("import base64, json",
                          *(f"{key} = {value!r}" for key, value in info.config_values.items()),
                          *info.config_lines))

    @dataclasses.dataclass
    class GenerateInfo:
        """
        Various internal information about the generation of a document.
        """

        #: The document.
        document: "Document"

        #: The directory where Sphinx configuration files are generated during the generation. This is a temporary one.
        document_config_dir: annize.fs.Path

        #: The directory where source files are generated and collected during the generation. This is a temporary one.
        document_source_dir: annize.fs.Path

        #: The culture to generate the document for.
        culture: annize.i18n.Culture

        #: Sphinx config values.
        config_values: dict

        #: Sphinx config code lines.
        config_lines: list

        #: The entry path, i.e. the path relative to the output root that points to the main part (like
        #: :file:`.../index.html`)
        entry_path: str = ""

        def _to_dict(self):
            return {key: getattr(self, key) for key in dir(self) if not key.startswith("_")}


class CompositeDocument(Document):
    """
    A composite document, composed of some other documents.
    """

    def __init__(self, *, project_name: annize.i18n.TrStr|None, title: annize.i18n.TrStr|None,
                 short_title: annize.i18n.TrStr|None, title_tagline: annize.i18n.TrStr|None,
                 authors: t.Sequence[annize.features.authors.Author], version: annize.data.Version|None,
                 release: annize.i18n.TrStr|None, documents: t.Sequence[Document]):
        """
        :param documents: The documents to compose.
        """
        super().__init__(project_name=project_name, title=title, short_title=short_title, title_tagline=title_tagline, authors=authors, version=version, release=release)
        self.__documents = tuple(documents)

    def _generate_sources(self, info):
        toc_tree_str = (".. toctree::\n"
                        "    :glob:\n"
                        "\n")
        for document in self.__documents:
            inner_info = self.__get_inner_info(info, document)
            inner_info.document_source_dir.mkdir(exist_ok=False)
            document_source_dir_name = document._generate_sources(inner_info)
            toc_tree_str += f"    {annize.flow.run_context.object_name(document)}/{document_source_dir_name}\n"
        name = annize.flow.run_context.object_name(self)
        info.document_source_dir(f"{name}.rst").write_text(toc_tree_str)
        return name

    @staticmethod
    def __get_inner_info(info: Document.GenerateInfo, inner_document: Document):
        info_kwargs = info._to_dict()
        info_kwargs["document_source_dir"] = info.document_source_dir(
            annize.flow.run_context.object_name(inner_document))
        return Document.GenerateInfo(**info_kwargs)


class ApiReferenceLanguage(abc.ABC):
    """
    Base class for a programming language in API references. See :py:class:`ApiReferenceDocument`.
    """

    @abc.abstractmethod
    def generate_sources(self, info: "ApiReferenceDocument.ApiReferenceGenerateInfo") -> str:
        pass


class ApiReferenceDocument(Document):
    """
    An API reference document.
    """

    def __init__(self, *, project_name: annize.i18n.TrStr|None, title: annize.i18n.TrStr|None,
                 short_title: annize.i18n.TrStr|None, title_tagline: annize.i18n.TrStr|None,
                 authors: t.Sequence[annize.features.authors.Author], version: annize.data.Version|None,
                 release: annize.i18n.TrStr|None, language: ApiReferenceLanguage, heading: annize.i18n.TrStr|None,
                 source: annize.fs.TFilesystemContent, cultures: t.Sequence[annize.i18n.Culture]):
        """
        :param language: The underlying programming language.
        :param heading: The heading (optional).
        :param source: The source code location.
        :param cultures: The document cultures.
        """
        super().__init__(project_name=project_name, title=title, short_title=short_title, title_tagline=title_tagline, authors=authors, version=version, release=release)
        self.__language = language
        self.__heading = heading or annize.features._pidev.i18n.TrStr.tr("an_Doc_APIRefTitle")
        self.__source = annize.fs.content(source)
        self.__source_clone = None
        self.__cultures = tuple(cultures)

    def available_cultures(self):
        return self.__cultures or annize.features.i18n.common.project_cultures()

    def _generate_sources(self, info):
        info.config_lines.append(f"import sys; sys.path.append({repr(str(self.__cloned_source().parent))})")
        return self.__language.generate_sources(self.__info(info))

    def __info(self, info: Document.GenerateInfo) -> "ApiReferenceGenerateInfo":
        return ApiReferenceDocument.ApiReferenceGenerateInfo(info, self.__cloned_source(), self.__heading)

    def __cloned_source(self):
        if not self.__source_clone:
            self.__source_clone = self.__source.path().temp_clone()
        return self.__source_clone

    class ApiReferenceGenerateInfo(Document.GenerateInfo):

        def __init__(self, info: Document.GenerateInfo, source: annize.fs.Path,
                     heading: annize.i18n.TrStr):
            super().__init__(**info._to_dict())
            self.__source = source
            self.__heading = heading

        @property
        def source(self) -> annize.fs.Path:
            return self.__source

        @property
        def heading(self) -> annize.i18n.TrStr:
            return self.__heading


class ArgparseCommandLineInterfaceDocument(Document):
    """
    A reference document about an argparse-based command line interface.
    """

    def __init__(self, *, project_name: annize.i18n.TrStr|None, title: annize.i18n.TrStr|None,
                 short_title: annize.i18n.TrStr|None, title_tagline: annize.i18n.TrStr|None,
                 authors: t.Sequence[annize.features.authors.Author], version: annize.data.Version|None,
                 release: annize.i18n.TrStr|None, parser_factory: str, program_name: str, heading: str|None,
                 source_directory: annize.fs.TFilesystemContent, cultures: t.Sequence[annize.i18n.Culture]):
        """
        :param parser_factory: The argparse parse factory name.
        :param program_name: The program executable name.
        :param heading: The heading (optional).
        :param source_directory: The source code location.
        :param cultures: The document cultures.
        """
        super().__init__(project_name=project_name, title=title, short_title=short_title, title_tagline=title_tagline, authors=authors, version=version, release=release)
        self.__parser_factory = parser_factory
        self.__program_name = program_name
        self.__heading = heading or annize.features._pidev.i18n.TrStr.tr("an_Doc_CLIRefTitle")
        self.__source = annize.fs.content(source_directory)
        self.__source_clone = None
        self.__cultures = tuple(cultures)

    def available_cultures(self):
        return self.__cultures or annize.features.i18n.common.project_cultures()

    def _generate_sources(self, info):
        info.config_values["extensions"].append("sphinxarg.ext")
        info.config_lines.append(f"import sys; sys.path.append({repr(str(self.__cloned_source()))})")
        name = annize.flow.run_context.object_name(self)

        info.document_source_dir(f"{name}.rst").write_text(
            f"{annize.features.documentation.sphinx.rst.heading(self.__heading, level=0)}"
            f".. argparse::\n"
            f"    :ref: {self.__parser_factory}\n"
            f"    :prog: {self.__program_name}\n")

        return name

    def __cloned_source(self):
        if not self.__source_clone:
            self.__source_clone = self.__source.path().temp_clone()
        return self.__source_clone


class RstDocument(Document):
    """
    A reStructuredText formatted file or a directory of such files.
    """

    def __init__(self, *, project_name: annize.i18n.TrStr|None, title: annize.i18n.TrStr|None,
                 short_title: annize.i18n.TrStr|None, title_tagline: annize.i18n.TrStr|None,
                 authors: t.Sequence[annize.features.authors.Author], version: annize.data.Version|None,
                 release: annize.i18n.TrStr|None, variants: t.Sequence["RstDocumentVariant"]):
        """
        :param variants: The variants of this document for its available cultures.
        """
        super().__init__(project_name=project_name, title=title, short_title=short_title, title_tagline=title_tagline, authors=authors, version=version, release=release)
        self.__variants = tuple(variants)

    def available_cultures(self):
        return tuple(set(v.culture for v in self.__variants))

    def _generate_sources(self, info):
        source = annize.fs.Path(self.__variant(info.culture).source)
        basename = source.name
        if not basename.lower().endswith(".rst"):
            basename += ".rst"
        source.copy_to(info.document_source_dir(basename))
        return basename[:-4]

    def __variant(self, culture: annize.i18n.Culture) -> "RstDocumentVariant|None":
        for variant in self.__variants:
            if variant.culture == culture:
                return variant
        return None


class RstDocumentVariant:
    """
    One variant of an :py:class:`RstDocument` for a particular culture.
    """

    def __init__(self, *, culture: annize.i18n.Culture = annize.i18n.unspecified_culture,
                 source: annize.fs.TFilesystemContent):
        """
        :param culture: The culture.
        :param source: The source location.
        """
        self.__culture = culture
        self.__source = annize.fs.content(source)

    @property
    def culture(self) -> annize.i18n.Culture:
        return self.__culture

    @property
    def source(self) -> annize.fs.FilesystemContent:
        return self.__source


class AboutProjectDocument(Document):
    """
    A document that gives a short overview about a project, including dependency information, license information, and
    some more, up to the project's :code:`long_description`.
    """

    def __init__(self, *, project_name: annize.i18n.TrStr|None, title: annize.i18n.TrStr|None,
                 short_title: annize.i18n.TrStr|None, title_tagline: annize.i18n.TrStr|None,
                 authors: t.Sequence[annize.features.authors.Author], version: annize.data.Version|None,
                 release: annize.i18n.TrStr|None,
                 dependencies: t.Sequence[annize.features.dependencies.common.Dependency],
                 cultures: t.Sequence[annize.i18n.Culture]):
        """
        :param dependencies: Project dependencies to mention.
        :param cultures: The cultures.
        """
        super().__init__(project_name=project_name, title=title, short_title=short_title, title_tagline=title_tagline, authors=authors, version=version, release=release)
        self.__dependencies = tuple(dependencies)
        self.__cultures = tuple(cultures)

    def available_cultures(self):
        return self.__cultures or annize.features.i18n.common.project_cultures()

    def _generate_sources(self, info):
        head_about = annize.features._pidev.i18n.tr("an_Doc_ReadmeHeadAbout")
        head_license = annize.features._pidev.i18n.tr("an_Doc_ReadmeHeadLicense")
        head_uptodate = annize.features._pidev.i18n.tr("an_Doc_ReadmeHeadUpToDate")
        head_dependencies = annize.features._pidev.i18n.tr("an_Doc_ReadmeHeadDependencies")
        content_license = annize.features._pidev.i18n.tr("an_HP_Lic_Text")
        content_uptodate = annize.features._pidev.i18n.tr("an_Doc_ReadmeUpToDate")
        content_dependencies = annize.features._pidev.i18n.tr("an_HP_DL_Uses3rdParty")
        content_readme_for_version = annize.features._pidev.i18n.tr("an_Doc_ReadmeUpToDateCurrentVersion")

        project_version = self.version
        if not project_version:
            project_versions = annize.features.version.project_versions()
            if len(project_versions) == 1:
                project_version = project_versions[0]
        project_name = self.project_name
        dependencies = self.__dependencies or ()  # TODO

        content = (f"{annize.features.documentation.sphinx.rst.heading(head_about, level=1)}"
                   f"{annize.features.base.long_description()}")

        licenses = annize.features.licensing.project_licenses()
        if len(licenses) > 0:
            license_names = annize.i18n.friendly_join_string_list([str(lic.name) for lic in licenses])
            content += (f"{annize.features.documentation.sphinx.rst.heading(head_license, level=0)}"
                        f"{content_license.format(project_name=project_name, license_names=license_names)}")

        content += (f"{annize.features.documentation.sphinx.rst.heading(head_uptodate, level=0)}"
                    f"{content_uptodate}")
        if project_version:
            content += f" {content_readme_for_version.format(project_version=project_version)}"

        if len(dependencies) > 0:
            content += (f"{annize.features.documentation.sphinx.rst.heading(head_dependencies, level=0)}"
                        f"{content_dependencies.format(project_name=project_name)}\n\n"
                        f"{annize.features.dependencies.common.dependencies_to_rst_text(dependencies)}")

        info.document_source_dir("readme.rst").write_file(content)
        return "readme"


class ReadmeDocument(CompositeDocument):  # TODO noh maturity flags?!
    """
    A project readme document, including :py:class:`AboutProjectDocument` and optionally more documents.
    """

    _ABOUT_NAME = f"__{hallyd.lang.unique_id()}"

    def __init__(self, *, project_name, title, short_title: annize.i18n.TrStr|None, title_tagline: annize.i18n.TrStr|None, authors, version, release, documents: t.Iterable[Document],
                 dependencies: list[annize.features.dependencies.common.Dependency],
                 cultures: list[annize.i18n.Culture]):
        """
        :param project_name: The project name.
        :param title: The document title. Note: There might be output formats that do not use it. So it does not replace
                      a header inside the document content.
        :param authors: The project authors.
        :param version: The project version.
        :param release: The project release. This may contain the version number in a more detailed way than
                        :code:`version`.
        :param documents: Additional documents.
        :param dependencies: Project dependencies to mention.
        :param cultures: The cultures.
        """
        about_document = AboutProjectDocument(project_name=project_name, authors=authors, version=version,
                                              release=release, dependencies=dependencies, cultures=cultures, title=None,
                                              short_title=None, title_tagline=None)
        super().__init__(project_name=project_name, authors=authors, version=version, release=release, title=title,
                         short_title=short_title, title_tagline=title_tagline, documents=[about_document, *documents])
        annize.flow.run_context.set_object_name(about_document, self._ABOUT_NAME)
        self.__cultures = cultures

    def available_cultures(self):
        return self.__cultures or annize.features.i18n.common.project_cultures()

    @property
    def title(self):
        project_name = self.project_name
        return self.original_title or annize.features._pidev.i18n.TrStr.tr("an_Doc_ReadmeTitle").format(project_name=project_name)


# TODO noh      f"exclude_patterns = ['.directory', 'Thumbs.db', '.DS_Store', '.git', '.svn', '.piget', '.idea']\n"

