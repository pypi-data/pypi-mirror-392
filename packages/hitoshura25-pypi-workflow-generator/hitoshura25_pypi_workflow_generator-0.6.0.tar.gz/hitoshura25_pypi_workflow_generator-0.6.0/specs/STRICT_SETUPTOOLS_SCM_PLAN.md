# Strict setuptools_scm Implementation Plan

## Executive Summary

This document outlines the implementation plan for fixing version detection issues in the pypi-workflow-generator project by enforcing strict setuptools_scm best practices. The core principle: **ONE tag per commit**, which aligns with modern Python packaging standards.

## Problem Statement

### Current Issues

1. **Multiple Tags on Same Commit**
   ```
   Commit 56c3695: v0.2.3 AND v0.2.4
   Commit 53cf0d7: v0.1.0 AND v0.1.1
   Commit 901caae: v0.2.5 AND v0.2.6
   ```

2. **Unpredictable Version Detection**
   - setuptools_scm picks one tag arbitrarily (alphabetically first)
   - May build v0.2.3 when v0.2.4 was intended
   - Debug output showed: "Tags at HEAD: v0.2.5, v0.2.6"

3. **Misleading Runtime Version**
   ```python
   # Current __init__.py
   __version__ = "0.1.0"  # Will be overridden by setuptools_scm
   ```
   - This is **not** overridden at runtime
   - Only overridden during package builds
   - Runtime always shows "0.1.0" regardless of actual version

4. **Missing Best Practices**
   - No `version_file` configured
   - No `.gitignore` entry for generated version file
   - CLI allows `--overwrite` flag (enables duplicate tags)

### Root Cause

The project uses tag-based versioning (setuptools_scm) but **doesn't enforce the fundamental requirement**: one tag per commit. This happens when:
- Release workflows fail and are retried without code changes
- Testing multiple release attempts on same commit
- Using `--overwrite` flag to replace tags

### Why This Matters

**setuptools_scm has a documented limitation**: When multiple tags point to the same commit, it picks the first one alphabetically, NOT chronologically. This breaks version detection.

## Solution Overview

### Philosophy

Adopt the **modern Python approach** used by Black, many PyPA projects, and recommended in setuptools_scm documentation:

- **Single Source of Truth**: Git tags
- **Strict Enforcement**: ONE tag per commit
- **Generated Artifacts**: Create `_version.py` during build (not committed)
- **Clear Boundaries**: No manual version management

### Key Principle

**Accept the trade-off**: Failed releases require bumping to a new version. This is the standard practice in the modern Python ecosystem and prevents the multi-tag problem entirely.

### Alignment with Python Ecosystem

This approach aligns with:
- PyPA (Python Packaging Authority) recommendations
- setuptools_scm best practices
- Black, pytest, and other major Python projects
- Modern CI/CD workflows (fail fast, bump version, retry)

## Implementation Details

### Phase 1: Configuration Updates

#### 1.1. Update pyproject.toml

**File**: `pyproject.toml`

**Current configuration**:
```toml
[tool.setuptools_scm]
version_scheme = "post-release"
```

**Updated configuration**:
```toml
[tool.setuptools_scm]
version_scheme = "post-release"
version_file = "pypi_workflow_generator/_version.py"
```

**What this does**:
- Tells setuptools_scm to generate `_version.py` during builds
- File contains version derived from git tags
- Allows fast runtime version access without calling git
- File is NOT committed to repository (build artifact only)

**Example generated file**:
```python
# file generated by setuptools_scm
# don't change, don't track in version control
__version__ = version = '0.2.6'
__version_tuple__ = version_tuple = (0, 2, 6)
```

#### 1.2. Update .gitignore

**File**: `.gitignore`

**Add**:
```gitignore
# setuptools_scm generated version file
pypi_workflow_generator/_version.py
```

**Why**: The version file is generated during builds and should never be committed to git.

#### 1.3. Update __init__.py

**File**: `pypi_workflow_generator/__init__.py`

**Current code**:
```python
"""PyPI Workflow Generator - Tool for generating GitHub Actions workflows."""

__version__ = "0.1.0"  # Will be overridden by setuptools_scm during build
```

**Updated code**:
```python
"""PyPI Workflow Generator - Tool for generating GitHub Actions workflows."""

try:
    from ._version import __version__
except ImportError:
    # Version file not generated yet (e.g., running from source)
    try:
        from importlib.metadata import version, PackageNotFoundError
        try:
            __version__ = version("pypi-workflow-generator")
        except PackageNotFoundError:
            # Package not installed, running from source without build
            __version__ = "0.0.0+unknown"
    except ImportError:
        # Python < 3.8
        __version__ = "0.0.0+unknown"
```

**Fallback chain**:
1. Try to import from `_version.py` (generated during build)
2. Try to get version from package metadata (if installed)
3. Fall back to `0.0.0+unknown` (development mode)

**Why this is better**:
- ‚úÖ Accurate version at runtime
- ‚úÖ Works in development, installed, and built contexts
- ‚úÖ Clear fallback behavior
- ‚úÖ No misleading comments

### Phase 2: CLI Updates

#### 2.1. Remove --overwrite Flag

**File**: `pypi_workflow_generator/create_release.py`

**Current code** (around line 90):
```python
parser.add_argument(
    '--overwrite',
    action='store_true',
    help='Overwrite an existing tag'
)

# Later in code:
if args.overwrite:
    # Delete existing tag logic
```

**Updated code**:
```python
# REMOVE the --overwrite argument entirely
# REMOVE the overwrite logic

# Instead, add explicit check that fails if tag exists:
def check_tag_exists(version: str) -> bool:
    """Check if a tag already exists."""
    result = subprocess.run(
        ['git', 'tag', '-l', version],
        capture_output=True,
        text=True
    )
    return bool(result.stdout.strip())

# In main():
if check_tag_exists(version):
    print(f"Error: Tag {version} already exists.", file=sys.stderr)
    print(f"To create a new release:", file=sys.stderr)
    print(f"  - Use a different version (e.g., bump to next version)", file=sys.stderr)
    print(f"  - Or manually delete the tag: git tag -d {version} && git push origin :refs/tags/{version}", file=sys.stderr)
    return 1
```

**Why**:
- ‚úÖ Prevents accidental duplicate tags
- ‚úÖ Forces user to make conscious decision
- ‚úÖ Clear error messages guide users
- ‚úÖ Enforces one-tag-per-commit principle

#### 2.2. Update CLI Help Text

**File**: `pypi_workflow_generator/create_release.py`

**Update the module docstring** to explain the new behavior:

```python
"""
CLI for creating release tags.

This tool creates annotated git tags for releases. It enforces strict
tag management: each tag must point to a unique commit.

If a release fails:
1. Fix the issue
2. Create a NEW version tag (e.g., if v1.0.0 failed, use v1.0.1)
3. Do NOT reuse the same version number

This approach aligns with Python packaging best practices and ensures
setuptools_scm can reliably detect versions.
"""
```

### Phase 3: Workflow Updates

#### 3.1. Update create-release.yml Workflow

**File**: `.github/workflows/create-release.yml` (and template)

**Add validation step** after "Calculate new version":

```yaml
- name: Check if tag already exists
  id: check_tag
  run: |
    new_version="${{ steps.calc_version.outputs.new_version }}"
    if git rev-parse "$new_version" >/dev/null 2>&1; then
      echo "::error::Tag $new_version already exists"
      echo "::error::This indicates a previous release attempt"
      echo "::error::To proceed, either:"
      echo "::error::  1. Delete the existing tag: git tag -d $new_version && git push origin :refs/tags/$new_version"
      echo "::error::  2. Create a new patch release instead"
      exit 1
    fi
    echo "Tag $new_version does not exist, proceeding..."
```

**Update the template** (`create_release.yml.j2`) to include this check.

**Why**:
- ‚úÖ Prevents workflow from creating duplicate tags
- ‚úÖ Fails early with clear message
- ‚úÖ Guides users on how to resolve

#### 3.2. Update pypi-publish.yml Debug Output

**File**: `.github/workflows/pypi-publish.yml`

**Current debug step** is good but add warning for multiple tags:

```yaml
- name: Debug git state for version detection
  run: |
    echo "=== Git Describe Output ==="
    git describe --tags --long --dirty --always
    echo ""
    echo "=== Current HEAD ==="
    git rev-parse HEAD
    echo ""
    echo "=== All Tags (last 10) ==="
    git tag -l | sort -V | tail -10
    echo ""
    echo "=== Tags at HEAD ==="
    tags_at_head=$(git tag --points-at HEAD)
    echo "$tags_at_head"

    # Check for multiple tags (indicates problem)
    tag_count=$(echo "$tags_at_head" | wc -l)
    if [ "$tag_count" -gt 1 ]; then
      echo ""
      echo "::warning::Multiple tags point to this commit!"
      echo "::warning::This may cause unpredictable version detection."
      echo "::warning::setuptools_scm will pick one arbitrarily."
      echo "::warning::See STRICT_SETUPTOOLS_SCM_PLAN.md for resolution."
    fi
    echo ""
    echo "=== GitHub Context ==="
    echo "github.ref: ${{ github.ref }}"
    echo "github.sha: ${{ github.sha }}"
    echo "github.event_name: ${{ github.event_name }}"
```

**Why**:
- ‚úÖ Detects multi-tag situation automatically
- ‚úÖ Warns developers during CI
- ‚úÖ Links to resolution documentation

### Phase 4: Documentation Updates

#### 4.1. Update README.md

**File**: `README.md`

**Add new section** after "Creating Releases":

```markdown
## Version Management Best Practices

This project uses [setuptools_scm](https://github.com/pypa/setuptools_scm) for automatic version management based on git tags.

### Important Rules

1. **One Tag Per Commit**: Each commit should have at most ONE release tag
2. **No Tag Reuse**: Once a tag is created, don't delete/recreate it
3. **Failed Releases**: If a release fails, bump to a new version (don't retry same version)

### Why These Rules?

setuptools_scm derives the package version from git tags. If multiple tags point to the same commit, it picks one arbitrarily (alphabetically first), which can cause:
- Wrong version being packaged
- Unpredictable builds
- Confusion in CI/CD

### Example: Handling Failed Releases

**Scenario**: You create v1.0.0, but PyPI publishing fails.

‚ùå **Wrong approach**:
```bash
git tag -d v1.0.0  # Delete the tag
git push origin :refs/tags/v1.0.0
# Try v1.0.0 again
```

‚úÖ **Correct approach**:
```bash
# Fix the issue, then bump to v1.0.1
pypi-release patch  # Creates v1.0.1
# Or use GitHub Actions UI to create v1.0.1
```

### Development vs. Production Versions

**Development mode** (running from source):
```bash
$ python -c "from pypi_workflow_generator import __version__; print(__version__)"
0.2.6+g901caae.d20250103  # Includes git hash and date
```

**Installed package**:
```bash
$ pip install pypi-workflow-generator
$ python -c "from pypi_workflow_generator import __version__; print(__version__)"
0.2.6  # Clean version from tag
```
```

#### 4.2. Update MCP-USAGE.md

**File**: `MCP-USAGE.md`

**Update FAQ section**:

```markdown
**Q: What happens if a release fails?**
A: If the release workflow fails (e.g., PyPI publishing errors), do NOT retry with the same version. Instead:
1. Fix the underlying issue
2. Create a new patch release (e.g., if v1.0.0 failed, create v1.0.1)
3. The project uses setuptools_scm which requires unique tags per commit

This aligns with Python packaging best practices and ensures reliable version detection.
```

#### 4.3. Update CONTRIBUTING.md (if exists) or Create It

**File**: `CONTRIBUTING.md` (create if doesn't exist)

**Add versioning section**:

```markdown
## Versioning

This project uses [semantic versioning](https://semver.org/) with automatic version management via [setuptools_scm](https://github.com/pypa/setuptools_scm).

### Version Sources

- **Git tags**: Source of truth (e.g., v0.2.6)
- **_version.py**: Generated during build (not committed)
- **Runtime**: Imported from `_version.py` or package metadata

### Creating Releases

**Via GitHub Actions** (recommended):
1. Go to Actions ‚Üí Create Release
2. Select patch/minor/major
3. Workflow creates tag and publishes

**Via CLI**:
```bash
pypi-release patch  # v0.2.6 ‚Üí v0.2.7
```

### Important: Tag Management

- ‚úÖ Each tag must point to a unique commit
- ‚ùå Never create multiple tags on the same commit
- ‚ùå Never reuse tag names

If you see this error:
```
Error: Tag v1.0.0 already exists
```

**Do NOT delete the tag**. Instead:
1. If the release succeeded: Nothing to do, tag is valid
2. If the release failed: Create v1.0.1 instead

See [STRICT_SETUPTOOLS_SCM_PLAN.md](./STRICT_SETUPTOOLS_SCM_PLAN.md) for rationale.
```

### Phase 5: Template Updates

#### 5.1. Update create_release.yml.j2

**File**: `pypi_workflow_generator/create_release.yml.j2`

**Add tag existence check** after "Calculate new version" step:

```yaml
- name: Check if tag already exists
  id: check_tag_exists
  run: |
    new_version="${{ steps.calc_version.outputs.new_version }}"

    if git rev-parse "$new_version" >/dev/null 2>&1; then
      echo "::error::‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
      echo "::error::‚îÇ  Tag $new_version already exists               ‚îÇ"
      echo "::error::‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
      echo "::error::"
      echo "::error::This project uses strict tag management (one tag per commit)."
      echo "::error::"
      echo "::error::If the previous release failed, please:"
      echo "::error::  1. Investigate why it failed"
      echo "::error::  2. Fix the issue (if needed)"
      echo "::error::  3. Create a NEW patch release"
      echo "::error::"
      echo "::error::If the previous release succeeded:"
      echo "::error::  - This is already released, no action needed"
      echo "::error::"
      echo "::error::For more information:"
      echo "::error::  https://github.com/${{ github.repository }}/blob/main/STRICT_SETUPTOOLS_SCM_PLAN.md"
      exit 1
    fi

    echo "‚úÖ Tag $new_version does not exist, proceeding with release"
```

**Update the error box in the summary** step to include this information.

### Phase 6: Migration - Cleanup Existing Duplicate Tags

#### 6.1. Identify Duplicate Tags

**Run locally**:
```bash
# List all commits with multiple tags
git log --oneline --decorate | grep -E 'tag:.*tag:'
```

**Expected output**:
```
56c3695 (tag: v0.2.4, tag: v0.2.3) Fix workflow trigger issue
53cf0d7 (tag: v0.1.1, tag: v0.1.0) Initial Setup
901caae (tag: v0.2.6, tag: v0.2.5) Add debug output
```

#### 6.2. Decide Which Tags to Keep

**Strategy**: Keep the **LATEST** (highest version) tag for each commit, delete the older ones.

**Rationale**:
- The latest tag represents the final successful state
- Older tags were likely failed attempts or intermediate states
- Published packages (if any) are under the latest tag

**Recommended deletions**:
```
Delete: v0.2.3 (keep v0.2.4)
Delete: v0.1.0 (keep v0.1.1)
Delete: v0.2.5 (keep v0.2.6)
```

#### 6.3. Delete Duplicate Tags Locally

```bash
# Delete local tags
git tag -d v0.2.3
git tag -d v0.1.0
git tag -d v0.2.5
```

#### 6.4. Delete Duplicate Tags from Remote

```bash
# Delete remote tags
git push origin :refs/tags/v0.2.3
git push origin :refs/tags/v0.1.0
git push origin :refs/tags/v0.2.5
```

#### 6.5. Verify Cleanup

```bash
# Check that each commit now has only one tag
git log --oneline --decorate | grep 'tag:'

# Expected output (one tag per line):
901caae (tag: v0.2.6) Add debug output
56c3695 (tag: v0.2.4) Fix workflow trigger issue
53cf0d7 (tag: v0.1.1) Initial Setup
```

#### 6.6. Check PyPI Published Versions

**Before deleting tags**, verify which versions are published on PyPI:

```bash
# Check PyPI
pip index versions pypi-workflow-generator
```

**If a version is published on PyPI but you're deleting its tag**:
- That's okay - the published package remains on PyPI
- The git tag is just metadata
- Users can still install the published version
- Future builds won't be confused by duplicate tags

### Phase 7: Testing Strategy

#### 7.1. Unit Tests

**No new unit tests needed** because:
- setuptools_scm handles version detection
- We're enforcing process, not adding logic
- Existing 23 tests should continue to pass

**Verification**:
```bash
pytest pypi_workflow_generator/tests/ -v
# Expected: 23 passed
```

#### 7.2. Integration Testing (Manual)

**Test 1: Version Detection in Development**
```bash
# Run from source (no build)
python -c "from pypi_workflow_generator import __version__; print(__version__)"
# Expected: 0.2.6+g901caae.d20250103 or similar
```

**Test 2: Version Detection in Built Package**
```bash
# Build package
python -m build

# Check version in built package
cd dist
tar -xzf pypi_workflow_generator-*.tar.gz
cd pypi_workflow_generator-*
cat pypi_workflow_generator/_version.py
# Expected: __version__ = version = '0.2.6'
```

**Test 3: Duplicate Tag Prevention (CLI)**
```bash
# Try to create tag that already exists
pypi-release patch  # Assuming v0.2.7 exists
# Expected: Error message about existing tag
```

**Test 4: Duplicate Tag Prevention (Workflow)**
```bash
# Trigger create-release workflow for existing tag
# Expected: Workflow fails with clear error message
```

**Test 5: Version File Not Committed**
```bash
# After build, check git status
git status
# Expected: _version.py should NOT appear (ignored)
```

**Test 6: Fresh Build After Tag Cleanup**
```bash
# Clean build directory
rm -rf dist build *.egg-info

# Create new build
python -m build

# Verify version is correct
unzip -p dist/pypi_workflow_generator-*-py3-none-any.whl pypi_workflow_generator/_version.py
# Expected: Shows version from latest tag only
```

### Phase 8: Rollout Plan

#### 8.1. Pre-Deployment Checklist

- [ ] All code changes committed
- [ ] Duplicate tags identified
- [ ] Backup of current tags (just in case)
  ```bash
  git tag > tags_backup.txt
  ```
- [ ] All tests passing
- [ ] Documentation updated

#### 8.2. Deployment Steps

**Step 1: Commit Configuration Changes**
```bash
git add pyproject.toml .gitignore pypi_workflow_generator/__init__.py
git commit -m "Configure strict setuptools_scm enforcement

- Add version_file to pyproject.toml
- Update __init__.py to import from _version.py
- Add _version.py to .gitignore
- Implement proper version fallback chain

See STRICT_SETUPTOOLS_SCM_PLAN.md for rationale"
```

**Step 2: Commit CLI Changes**
```bash
git add pypi_workflow_generator/create_release.py
git commit -m "Remove --overwrite flag to prevent duplicate tags

- Remove --overwrite argument
- Add explicit tag existence check
- Provide clear error messages
- Enforce one-tag-per-commit principle

See STRICT_SETUPTOOLS_SCM_PLAN.md for rationale"
```

**Step 3: Commit Workflow Changes**
```bash
git add .github/workflows/create-release.yml .github/workflows/pypi-publish.yml
git add pypi_workflow_generator/create_release.yml.j2 pypi_workflow_generator/pypi_publish.yml.j2
git commit -m "Add duplicate tag prevention to workflows

- Check for existing tags before creating
- Enhance debug output to detect multi-tag situations
- Provide clear error messages and guidance

See STRICT_SETUPTOOLS_SCM_PLAN.md for rationale"
```

**Step 4: Commit Documentation**
```bash
git add README.md MCP-USAGE.md CONTRIBUTING.md STRICT_SETUPTOOLS_SCM_PLAN.md
git commit -m "Document strict tag management policy

- Add version management best practices to README
- Update FAQ in MCP-USAGE.md
- Create/update CONTRIBUTING.md with tag guidelines
- Add comprehensive implementation plan

See STRICT_SETUPTOOLS_SCM_PLAN.md for rationale"
```

**Step 5: Push Changes**
```bash
git push origin main  # or current branch
```

**Step 6: Clean Up Duplicate Tags**
```bash
# Local cleanup
git tag -d v0.2.3 v0.1.0 v0.2.5

# Remote cleanup
git push origin :refs/tags/v0.2.3
git push origin :refs/tags/v0.1.0
git push origin :refs/tags/v0.2.5
```

**Step 7: Verify Cleanup**
```bash
git log --oneline --decorate | grep 'tag:'
# Verify only one tag per commit
```

**Step 8: Create Release of These Changes**
```bash
# Use the new workflow (with duplicate tag prevention)
# Via GitHub Actions UI or:
pypi-release patch
```

**Step 9: Verify New Release**
```bash
# Check that publish workflow succeeded
# Check version detection worked correctly
# Verify package on PyPI has correct version
```

#### 8.3. Post-Deployment Verification

**Checklist**:
- [ ] All duplicate tags removed
- [ ] Each commit has at most one tag
- [ ] New release created successfully
- [ ] Version detection working in built package
- [ ] CLI prevents creating duplicate tags
- [ ] Workflow prevents creating duplicate tags
- [ ] Documentation reflects new policy

## Trade-offs and Limitations

### What You Gain

‚úÖ **Reliable version detection**: setuptools_scm always picks the correct version
‚úÖ **Aligns with Python ecosystem**: Follows best practices of Black, PyPA, etc.
‚úÖ **Clearer semantics**: One tag = one release attempt
‚úÖ **Better audit trail**: Git history is cleaner
‚úÖ **Prevents confusion**: No ambiguity about which tag is "real"

### What You Accept

‚ö†Ô∏è **Cannot retry same version**: If v1.0.0 fails, must create v1.0.1
‚ö†Ô∏è **Version number gaps**: May skip versions (v1.0.0 ‚Üí v1.0.2 if v1.0.1 failed)
‚ö†Ô∏è **Requires good CI/CD**: Need to catch failures early to avoid wasted versions
‚ö†Ô∏è **Tag cleanup needed**: Manual intervention if duplicate tags already exist

### When This Approach Is Appropriate

‚úÖ **Good fit**:
- Modern Python projects using setuptools_scm
- Projects with reliable CI/CD
- Teams comfortable with semantic versioning
- Projects that value clean git history

‚ùå **May not fit**:
- Projects needing "retry same version" semantics
- Legacy projects with existing duplicate-tag patterns
- Projects where version numbers are legally significant
- Teams preferring file-based versioning (Maven-style)

## Comparison with Alternatives

### This Approach (Option A): Strict setuptools_scm

**Philosophy**: Pure tag-based, strict enforcement
**Version Source**: Git tags only
**On Failed Release**: Bump version (v1.0.0 ‚Üí v1.0.1)
**Commit per Release**: No (tag only, no version file)
**Python Ecosystem Alignment**: High (modern approach)
**Complexity**: Low (minimal config)
**Retry Ability**: Cannot retry same version

### Alternative (Option B): python-semantic-release

**Philosophy**: File-based versioning (Maven-style)
**Version Source**: pyproject.toml + git tags
**On Failed Release**: Can retry same version
**Commit per Release**: Yes (version file change)
**Python Ecosystem Alignment**: High (automation standard)
**Complexity**: Medium (more tooling)
**Retry Ability**: Can retry same version

### Alternative (Option C): Hybrid

**Philosophy**: Belt and suspenders
**Version Source**: Git tags + committed _version.py
**On Failed Release**: Can retry same version
**Commit per Release**: Yes (_version.py change)
**Python Ecosystem Alignment**: Low (unusual pattern)
**Complexity**: Medium (custom workflow)
**Retry Ability**: Can retry same version

## Success Criteria

### Implementation Complete When:

1. ‚úÖ `version_file` configured in pyproject.toml
2. ‚úÖ `__init__.py` imports from `_version.py` with fallbacks
3. ‚úÖ `_version.py` added to `.gitignore`
4. ‚úÖ `--overwrite` flag removed from CLI
5. ‚úÖ Workflows check for duplicate tags
6. ‚úÖ All duplicate tags cleaned up
7. ‚úÖ Documentation updated
8. ‚úÖ All 23 tests pass
9. ‚úÖ Fresh release created successfully
10. ‚úÖ Version detection working correctly

### Validation Tests Pass:

1. ‚úÖ Build from source shows correct version
2. ‚úÖ Installed package shows correct version
3. ‚úÖ `_version.py` generated during build
4. ‚úÖ `_version.py` not committed to git
5. ‚úÖ CLI rejects duplicate tag creation
6. ‚úÖ Workflow rejects duplicate tag creation
7. ‚úÖ Git history has one tag per commit

## FAQ

### Q: What if I need to retry a failed release?

**A**: Bump to the next version. If v1.0.0 failed, create v1.0.1.

**Rationale**: This is standard practice in Python ecosystem. It:
- Keeps git history clean
- Prevents setuptools_scm confusion
- Aligns with semantic versioning (patches are cheap)

### Q: Won't I "waste" version numbers?

**A**: Version numbers are infinite and free. Skipping a few is fine.

**Examples from major projects**:
- Django skipped many patch versions due to failed builds
- Black has gaps in version history
- This is normal and expected

### Q: What about semantic versioning rules?

**A**: Still applies. Version jumps indicate:
- v1.0.0 ‚Üí v1.0.2: Two patch releases (v1.0.1 may have failed)
- Semantic meaning preserved (v1.0.0 ‚Üí v1.0.1 ‚Üí v1.0.2 are all compatible)

### Q: Can I delete tags after they're published to PyPI?

**A**: Yes, safely:
- Published PyPI packages persist independently
- Users can still install published versions
- Git tags are just metadata
- Cleaning up duplicate tags is recommended

### Q: What if I really need to retry the same version?

**A**: Consider Option B (python-semantic-release) instead:
- Commits version changes before tagging
- Each release is a unique commit
- Can retry same version on different commit
- Trade-off: More complex, requires adopting conventional commits

### Q: How does this affect my existing releases?

**A**: Doesn't affect them:
- Published PyPI packages remain unchanged
- Cleaning up git tags only affects future builds
- Users can still install any published version
- Only future releases follow new policy

## Timeline

**Estimated Implementation Time**: 2-3 hours
- Configuration changes: 30 minutes
- CLI and workflow updates: 60 minutes
- Documentation: 45 minutes
- Testing and verification: 45 minutes

**Tag Cleanup Time**: 15 minutes
- Identify duplicates: 5 minutes
- Delete locally and remotely: 5 minutes
- Verify cleanup: 5 minutes

**Total**: 2.5-3.5 hours

## Next Steps

1. ‚úÖ Review this implementation plan
2. üîÑ Implement Phase 1: Configuration updates
3. üîÑ Implement Phase 2: CLI updates
4. üîÑ Implement Phase 3: Workflow updates
5. üîÑ Implement Phase 4: Documentation updates
6. üîÑ Implement Phase 5: Template updates
7. üîÑ Execute Phase 6: Cleanup duplicate tags
8. üîÑ Execute Phase 7: Testing
9. üîÑ Execute Phase 8: Rollout
10. üîÑ Verify success criteria met

## References

- [setuptools_scm Documentation](https://setuptools-scm.readthedocs.io/)
- [PyPA Packaging Guide](https://packaging.python.org/)
- [Semantic Versioning](https://semver.org/)
- [Black's use of hatch-vcs](https://github.com/psf/black/blob/main/pyproject.toml)
- [setuptools_scm Issue #571](https://github.com/pypa/setuptools_scm/issues/571) - Multiple tags on same commit
