#!/usr/bin/env python3
import argparse
import keyword
import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Tuple

try:
    import yaml  # PyYAML
except Exception as e:
    print("This script requires PyYAML. `pip install pyyaml`", file=sys.stderr)
    raise

# ----------------------------
# YAML -> normalized tree
# ----------------------------


def load_yaml(p: Path) -> Dict[str, Any]:
    data = yaml.safe_load(p.read_text(encoding="utf-8"))
    if not isinstance(data, dict):
        raise ValueError("YAML must be a mapping at the top level.")
    # current format is a mapping of stage-name -> dict (or None)
    return {"stages": _normalize_mapping_to_nodes(data)}


def _normalize_mapping_to_nodes(root_map: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Translate your current YAML shape into a normalized list of stage dicts."""
    nodes: List[Dict[str, Any]] = []
    for idx, (name, body) in enumerate(root_map.items()):
        if body is None:
            body = {}
        if not isinstance(body, dict):
            raise ValueError(f"Stage '{name}' must be a mapping or null.")
        nodes.append(_normalize_node(name, body, idx))
    return nodes


def _normalize_node(name: str, d: Dict[str, Any], default_index: int) -> Dict[str, Any]:
    # Extract meta
    doc = (d.get("__doc__") or "").strip()
    order_val = d.get("order", False)
    if isinstance(order_val, str):
        order_fixed = order_val.strip().lower() == "fixed"
    else:
        order_fixed = bool(order_val)
    order_index = int(d.get("order_index", default_index))

    # Children are all keys except meta
    children: List[Dict[str, Any]] = []
    for k, v in d.items():
        if k in ("__doc__", "order", "order_index"):
            continue
        if v is None:
            v = {}
        if not isinstance(v, dict):
            raise ValueError(f"Child stage '{k}' of '{name}' must be a mapping or null.")
        children.append(_normalize_node(k, v, 0))

    return {
        "display": name,  # human title
        "class": to_identifier(name),  # PascalCase identifier
        "doc": doc,
        "order_fixed": order_fixed,  # only meaningful at top level
        "order_index": order_index,  # only meaningful at top level
        "children": children,
    }


# ----------------------------
# Identifiers & qualified names
# ----------------------------


def to_identifier(display: str) -> str:
    """'Global Rules' -> 'GlobalRules'; 'Output Template' -> 'OutputTemplate'"""
    parts = [p for p in re.split(r"[^0-9A-Za-z]+", str(display).strip()) if p]
    base = "".join(p[:1].upper() + p[1:] for p in parts) or "Stage"
    if base[0].isdigit():
        base = "_" + base
    if keyword.iskeyword(base):
        base += "_"
    return base


def humanize_class_name(name: str) -> str:
    """Convert camelCase to human-readable title."""
    # Split on camelCase boundaries
    parts = re.split(r"(?<!^)(?=[A-Z])", name)
    return " ".join(part.capitalize() for part in parts if part)


def qname(chain: List[str]) -> str:
    """['Stages','DynamicExecution','AfterToolExecution'] -> 'Stages.DynamicExecution.AfterToolExecution'"""
    return ".".join(chain)


# ----------------------------
# Emit classes (Phase A)
# ----------------------------


def emit_class_tree(top_nodes: List[Dict[str, Any]]) -> List[str]:
    lines: List[str] = []
    lines.append("# AUTO-GENERATED: DO NOT EDIT BY HAND")
    lines.append("# Generated by src/dynamic_prompt/generator/prompt_structure_generator.py")
    # Sample usage (kept as comments to avoid syntax issues)
    lines.append("# python src/dynamic_prompt/generator/prompt_structure_generator.py  \\")
    lines.append("#   --in specs/prompt_structure/prompt_structure.yaml \\")
    lines.append("#   --out src/hyper_reasoning/prompts/prompt_structure.py")
    lines.append("")
    lines.append("class Stages:")
    lines.append('    """Auto-generated hierarchical stage tree."""')
    lines.append("    pass")
    lines.append("")

    def emit(node: Dict[str, Any], indent: int):
        cls = node["class"]
        doc = node["doc"].replace('"""', '\\"""') if node["doc"] else ""
        lines.append(" " * indent + f"class {cls}:")
        if doc:
            lines.append(" " * (indent + 4) + f'""" {doc} """')
        else:
            lines.append(" " * (indent + 4) + '""" """')
        # Use humanized display name instead of raw class name
        humanized_display = humanize_class_name(cls)
        lines.append(" " * (indent + 4) + f"__stage_display__ = {humanized_display!r}")
        lines.append(" " * (indent + 4) + "pass")
        lines.append("")
        for child in node["children"]:
            emit(child, indent + 4)

    for n in top_nodes:
        emit(n, 4)
    return lines


# ----------------------------
# Emit wiring (Phase B)
# ----------------------------


def collect_paths(top_nodes: List[Dict[str, Any]]) -> List[Tuple[List[str], Dict[str, Any]]]:
    """Return [(path_chain, node_dict)] with Stages as root in the chain."""
    acc: List[Tuple[List[str], Dict[str, Any]]] = []

    def walk(node: Dict[str, Any], chain: List[str]):
        mine = chain + [node["class"]]
        acc.append((mine, node))
        for c in node["children"]:
            walk(c, mine)

    for n in top_nodes:
        walk(n, ["Stages"])
    return acc


def emit_wiring(top_nodes: List[Dict[str, Any]]) -> List[str]:
    lines: List[str] = []
    all_paths = collect_paths(top_nodes)

    # parent/children wiring
    for path, node in all_paths:
        qual = qname(path)
        # root + parent
        lines.append(f"{qual}.__stage_root__ = Stages")
        parent_qual = "Stages" if len(path) == 2 else qname(path[:-1])
        lines.append(f"{qual}.__stage_parent__ = {parent_qual}")
        # children tuple
        child_quals = [qname(path + [c["class"]]) for c in node["children"]]
        if child_quals:
            lines.append(f"{qual}.__children__ = ({', '.join(child_quals)},)")
        else:
            lines.append(f"{qual}.__children__ = ()")
        lines.append("")

    # top-level order wiring and Stages.__top_levels__
    top_level_quals: List[str] = []
    ordered: List[Tuple[int, str, bool]] = []  # (order_index, qual, fixed)
    for node in top_nodes:
        qual = qname(["Stages", node["class"]])
        top_level_quals.append(qual)
        fixed = bool(node["order_fixed"])
        index = int(node["order_index"])
        lines.append(f"{qual}.__order_fixed__ = {repr(fixed)}")
        lines.append(f"{qual}.__order_index__ = {index}")
        ordered.append((index, qual, fixed))
        lines.append("")

    # Provide a stable tuple of top-level classes in declaration order
    lines.append(f"Stages.__top_levels__ = ({', '.join(top_level_quals)},)")
    lines.append("")

    # (Optional) also expose a fixed-order list by YAML index for consumers who want it
    # Only include those with order_fixed=True; keep YAML order (by index)
    fixed_sorted = [qual for _, qual, fixed in sorted(ordered, key=lambda t: t[0]) if fixed]
    lines.append(f"Stages.__fixed_top_order__ = ({', '.join(fixed_sorted)},)")
    lines.append("")
    return lines


# ----------------------------
# Module assembly
# ----------------------------


def generate_stages_module(yaml_path: Path, out_path: Path) -> None:
    model = load_yaml(yaml_path)  # {"stages": [...]}
    top_nodes = model["stages"]

    lines: List[str] = []
    lines += emit_class_tree(top_nodes)
    lines += emit_wiring(top_nodes)

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text("\n".join(lines), encoding="utf-8")
    print(f"Generated {out_path}")


# ----------------------------
# CLI
# ----------------------------


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--in", dest="inp", required=True, help="Path to stages.yaml")
    ap.add_argument("--out", dest="out", required=True, help="Output .py path")
    args = ap.parse_args()
    generate_stages_module(Path(args.inp), Path(args.out))


if __name__ == "__main__":
    main()
