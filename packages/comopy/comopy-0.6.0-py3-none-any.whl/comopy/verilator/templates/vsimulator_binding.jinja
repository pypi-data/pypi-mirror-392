// Python binding for Verilated {{ module_name }} module.
//
// Generated by the ComoPy Verilator binding pass.
// DO NOT EDIT.

#include <verilated.h>
#include "V{{ module_name }}.h"

#include <pybind11/pybind11.h>
#include <pybind11/operators.h>

namespace py = pybind11;

struct VSimulator{
    V{{ module_name }} *top = nullptr;

    void start()
    {
        top = new V{{ module_name }};
    }

    void eval()
    {
        top->eval();
    }

    void finish()
    {
        delete top;
        top = nullptr;
    }
};

PYBIND11_MODULE(V{{ module_name }}, m){
    m.doc() = "Python binding for Verilated {{ module_name }} module";

    py::class_<V{{ module_name }}>(m, "V{{ module_name }}")
        .def(py::init<const char*>(), py::arg("name") = "V{{ module_name }}")

        // Port members in Verilator-generated classes are aliases that require
        // lambda wrapper functions for proper access from Python.
        {%- for input, type in top_inputs %}
        .def_property("{{ input }}",
            [](V{{ module_name }}& self){ return self.{{ input }}; },
            [](V{{ module_name }}& self, {{ type }} val){ self.{{ input }} = val; }
        )
        {%- endfor %}
        {%- for output, _ in top_outputs %}
        .def_property_readonly("{{ output }}",
            [](V{{ module_name }}& self){ return self.{{ output }}; }
        )
        {%- endfor %}
        ;

    py::class_<VSimulator>(m, "VSimulator")
        .def(py::init<>())
        .def("start", &VSimulator::start)
        .def("eval", &VSimulator::eval)
        .def("finish", &VSimulator::finish)
        .def_readonly("top", &VSimulator::top)
        ;
}
