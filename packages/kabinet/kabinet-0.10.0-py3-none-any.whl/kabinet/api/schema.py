"""This file was code generated by turms. If you want to change the contents of this file, you should make sure to add the MergeProcessor to your config will keep your changes when you re-run turms)."""

from typing import Any, Literal, Union, Tuple, Optional, Annotated, List, Iterable
from pydantic import Field, ConfigDict, BaseModel
from rath.scalars import ID, IDCoercible
from kabinet.scalars import SearchQuery, ValidatorFunction, ActionHash
from enum import Enum
from datetime import datetime
from kabinet.funcs import aexecute, execute
from kabinet.rath import KabinetRath


class ActionKind(str, Enum):
    """The kind of action."""

    FUNCTION = "FUNCTION"
    GENERATOR = "GENERATOR"


class AssignWidgetKind(str, Enum):
    """The kind of assign widget."""

    SEARCH = "SEARCH"
    CHOICE = "CHOICE"
    SLIDER = "SLIDER"
    CUSTOM = "CUSTOM"
    STRING = "STRING"
    STATE_CHOICE = "STATE_CHOICE"


class ContainerType(str, Enum):
    """The state of a dask cluster"""

    APPTAINER = "APPTAINER"
    DOCKER = "DOCKER"


class EffectKind(str, Enum):
    """The kind of effect."""

    MESSAGE = "MESSAGE"
    HIDE = "HIDE"
    CUSTOM = "CUSTOM"


class Ordering(str, Enum):
    """No documentation"""

    ASC = "ASC"
    ASC_NULLS_FIRST = "ASC_NULLS_FIRST"
    ASC_NULLS_LAST = "ASC_NULLS_LAST"
    DESC = "DESC"
    DESC_NULLS_FIRST = "DESC_NULLS_FIRST"
    DESC_NULLS_LAST = "DESC_NULLS_LAST"


class PodStatus(str, Enum):
    """The state of a dask cluster"""

    PENDING = "PENDING"
    RUNNING = "RUNNING"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"
    FAILED = "FAILED"
    UNKOWN = "UNKOWN"


class PortKind(str, Enum):
    """The kind of port."""

    INT = "INT"
    STRING = "STRING"
    STRUCTURE = "STRUCTURE"
    LIST = "LIST"
    BOOL = "BOOL"
    DICT = "DICT"
    FLOAT = "FLOAT"
    DATE = "DATE"
    UNION = "UNION"
    ENUM = "ENUM"
    MODEL = "MODEL"
    MEMORY_STRUCTURE = "MEMORY_STRUCTURE"
    INTERFACE = "INTERFACE"


class ReturnWidgetKind(str, Enum):
    """The kind of return widget."""

    CHOICE = "CHOICE"
    CUSTOM = "CUSTOM"


class ActionDependencyInput(BaseModel):
    """A dependency for a implementation. By defining dependencies, you can
    create a dependency graph for your implementations and actions"""

    key: str
    hash: Optional[ActionHash] = None
    name: Optional[str] = None
    description: Optional[str] = None
    arg_matches: Optional[Tuple["PortMatchInput", ...]] = Field(
        alias="argMatches", default=None
    )
    return_matches: Optional[Tuple["PortMatchInput", ...]] = Field(
        alias="returnMatches", default=None
    )
    protocols: Optional[Tuple[ID, ...]] = None
    force_arg_length: Optional[int] = Field(alias="forceArgLength", default=None)
    force_return_length: Optional[int] = Field(alias="forceReturnLength", default=None)
    optional: bool
    allow_inactive: Optional[bool] = Field(alias="allowInactive", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class AppImageInput(BaseModel):
    """Create a new Github repository input"""

    flavour_name: Optional[str] = Field(alias="flavourName", default=None)
    manifest: "ManifestInput"
    selectors: Tuple["SelectorInput", ...]
    app_image_id: str = Field(alias="appImageId")
    inspection: "InspectionInput"
    image: "DockerImageInput"
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class AssignWidgetInput(BaseModel):
    """No documentation"""

    as_paragraph: Optional[bool] = Field(alias="asParagraph", default=None)
    "Whether to display the input as a paragraph or not. This is used for text inputs and dropdowns"
    kind: AssignWidgetKind
    query: Optional[SearchQuery] = None
    choices: Optional[Tuple["ChoiceInput", ...]] = None
    min: Optional[float] = None
    max: Optional[float] = None
    step: Optional[float] = None
    placeholder: Optional[str] = None
    hook: Optional[str] = None
    ward: Optional[str] = None
    fallback: Optional["AssignWidgetInput"] = None
    filters: Optional[Tuple["PortInput", ...]] = None
    dependencies: Optional[Tuple[str, ...]] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class BackendFilter(BaseModel):
    """Filter for Resources"""

    ids: Optional[Tuple[ID, ...]] = None
    search: Optional[str] = None
    and_: Optional["BackendFilter"] = Field(alias="AND", default=None)
    or_: Optional["BackendFilter"] = Field(alias="OR", default=None)
    not_: Optional["BackendFilter"] = Field(alias="NOT", default=None)
    distinct: Optional[bool] = Field(alias="DISTINCT", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ChoiceInput(BaseModel):
    """
    A choice is a value that can be selected in a dropdown.

    It is composed of a value, a label, and a description. The value is the
    value that is returned when the choice is selected. The label is the
    text that is displayed in the dropdown. The description is the text
    that is displayed when the user hovers over the choice.

    """

    value: Any
    label: str
    image: Optional[str] = None
    description: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreateDeploymentInput(BaseModel):
    """Create a new Github repository input"""

    instance_id: str = Field(alias="instanceId")
    local_id: ID = Field(alias="localId")
    flavour: ID
    last_pulled: Optional[datetime] = Field(alias="lastPulled", default=None)
    secret_params: Optional[Any] = Field(alias="secretParams", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreateGithubRepoInput(BaseModel):
    """Create a new Github repository input"""

    name: Optional[str] = None
    user: Optional[str] = None
    branch: Optional[str] = None
    repo: Optional[str] = None
    identifier: Optional[str] = None
    auto_scan: Optional[bool] = Field(alias="autoScan", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreatePodInput(BaseModel):
    """Create a new Github repository input"""

    deployment: ID
    local_id: ID = Field(alias="localId")
    resource: Optional[ID] = None
    instance_id: str = Field(alias="instanceId")
    client_id: Optional[str] = Field(alias="clientId", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DeclareBackendInput(BaseModel):
    """Create a new Github repository input"""

    instance_id: str = Field(alias="instanceId")
    name: str
    kind: str
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DeclareResourceInput(BaseModel):
    """Create a resource"""

    backend: ID
    name: Optional[str] = None
    local_id: str = Field(alias="localId")
    qualifiers: Optional[Tuple["QualifierInput", ...]] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DefinitionInput(BaseModel):
    """A definition

    Definitions are the building implementation for Actions and provide the
    information needed to create a action. They are primarly composed of a name,
    a description, and a list of ports.

    Definitions provide a protocol of input and output, and do not contain
    any information about the actual implementation of the action ( this is handled
    by a implementation that implements a action).




    """

    description: Optional[str] = None
    "The description of the definition. This is the text that is displayed in the UI"
    collections: Tuple[str, ...]
    "The collections of the definition. This is used to group definitions together in the UI"
    name: str
    "The name of the actions. This is used to uniquely identify the definition"
    stateful: bool
    "Whether the definition is stateful or not. If the definition is stateful, it can be used to create a stateful action. If the definition is not stateful, it cannot be used to create a stateful action"
    port_groups: Tuple["PortGroupInput", ...] = Field(alias="portGroups")
    "The port groups of the definition. This is used to group ports together in the UI"
    args: Tuple["PortInput", ...]
    "The args of the definition. This is the input ports of the definition"
    returns: Tuple["PortInput", ...]
    "The returns of the definition. This is the output ports of the definition"
    kind: ActionKind
    "The kind of the definition. This is the type of the definition. Can be either a function or a generator"
    is_test_for: Tuple[str, ...] = Field(alias="isTestFor")
    "The tests for the definition. This is used to group definitions together in the UI"
    interfaces: Tuple[str, ...]
    "The interfaces of the definition. This is used to group definitions together in the UI"
    is_dev: bool = Field(alias="isDev")
    "Whether the definition is a dev definition or not. If the definition is a dev definition, it can be used to create a dev action. If the definition is not a dev definition, it cannot be used to create a dev action"
    logo: Optional[str] = None
    "The logo of the definition. This is used to display the logo in the UI"
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DeletePodInput(BaseModel):
    """No documentation"""

    id: ID
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DescriptorInput(BaseModel):
    """No documentation"""

    key: str
    value: Any
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DeviceFeature(BaseModel):
    """The Feature you are trying to match"""

    kind: str
    cpu_count: str = Field(alias="cpuCount")
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DockerImageInput(BaseModel):
    """No documentation"""

    image_string: str = Field(alias="imageString")
    build_at: datetime = Field(alias="buildAt")
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DumpLogsInput(BaseModel):
    """Create a new Github repository input"""

    pod: ID
    logs: str
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class EffectInput(BaseModel):
    """
                 An effect is a way to modify a port based on a condition. For example,
    you could have an effect that sets a port to null if another port is null.

    Or, you could have an effect that hides the port if another port meets a condition.
    E.g when the user selects a certain option in a dropdown, another port is hidden.


    """

    function: ValidatorFunction
    dependencies: Optional[Tuple[str, ...]] = None
    message: Optional[str] = None
    kind: EffectKind
    fade: Optional[bool] = None
    hook: Optional[str] = None
    ward: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class EnvironmentInput(BaseModel):
    """Which environment do you want to match against?"""

    features: Optional[Tuple[DeviceFeature, ...]] = None
    container_type: ContainerType = Field(alias="containerType")
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class FlavourFilter(BaseModel):
    """Filter for Dask Clusters"""

    ids: Optional[Tuple[ID, ...]] = None
    search: Optional[str] = None
    has_definitions: Optional[Tuple[ID, ...]] = Field(
        alias="hasDefinitions", default=None
    )
    and_: Optional["FlavourFilter"] = Field(alias="AND", default=None)
    or_: Optional["FlavourFilter"] = Field(alias="OR", default=None)
    not_: Optional["FlavourFilter"] = Field(alias="NOT", default=None)
    distinct: Optional[bool] = Field(alias="DISTINCT", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class FlavourOrder(BaseModel):
    """No documentation"""

    released_at: Optional[Ordering] = Field(alias="releasedAt", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ImplementationInput(BaseModel):
    """A implementation is a blueprint for a action. It is composed of a definition, a list of dependencies, and a list of params."""

    definition: DefinitionInput
    dependencies: Tuple[ActionDependencyInput, ...]
    interface: Optional[str] = None
    params: Optional[Any] = None
    dynamic: bool
    logo: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class InspectionInput(BaseModel):
    """No documentation"""

    size: Optional[int] = None
    implementations: Tuple[ImplementationInput, ...]
    requirements: Tuple["RequirementInput", ...]
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ManifestInput(BaseModel):
    """No documentation"""

    entrypoint: Optional[str] = None
    "The entrypoint of the app, defaults to 'app'"
    identifier: str
    version: str
    author: str
    logo: Optional[str] = None
    scopes: Tuple[str, ...]
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class OffsetPaginationInput(BaseModel):
    """No documentation"""

    offset: int
    limit: Optional[int] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class PortGroupInput(BaseModel):
    """A Port Group is a group of ports that are related to each other. It is used to group ports together in the UI and provide a better user experience."""

    key: str
    "The key of the port group. This is used to uniquely identify the port group"
    title: Optional[str] = None
    description: Optional[str] = None
    effects: Optional[Tuple[EffectInput, ...]] = None
    ports: Optional[Tuple[str, ...]] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class PortInput(BaseModel):
    """Port

    A Port is a single input or output of a action. It is composed of a key and a kind
    which are used to uniquely identify the port.

    If the Port is a structure, we need to define a identifier and scope,
    Identifiers uniquely identify a specific type of model for the scopes (e.g
    all the ports that have the identifier "@mikro/image" are of the same type, and
    are hence compatible with each other). Scopes are used to define in which context
    the identifier is valid (e.g. a port with the identifier "@mikro/image" and the
    scope "local", can only be wired to other ports that have the same identifier and
    are running in the same app). Global ports are ports that have the scope "global",
    and can be wired to any other port that has the same identifier, as there exists a
    mechanism to resolve and retrieve the object for each app. Please check the rekuest
    documentation for more information on how this works.


    """

    validators: Optional[Tuple["ValidatorInput", ...]] = None
    key: str
    label: Optional[str] = None
    kind: PortKind
    description: Optional[str] = None
    identifier: Optional[str] = None
    nullable: bool
    effects: Optional[Tuple[EffectInput, ...]] = None
    default: Optional[Any] = None
    children: Optional[Tuple["PortInput", ...]] = None
    choices: Optional[Tuple[ChoiceInput, ...]] = None
    assign_widget: Optional[AssignWidgetInput] = Field(
        alias="assignWidget", default=None
    )
    return_widget: Optional["ReturnWidgetInput"] = Field(
        alias="returnWidget", default=None
    )
    descriptors: Optional[Tuple[DescriptorInput, ...]] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class PortMatchInput(BaseModel):
    """A dependency for a implementation. By defining dependencies, you can
    create a dependency graph for your implementations and actions"""

    at: Optional[int] = None
    key: Optional[str] = None
    kind: Optional[PortKind] = None
    identifier: Optional[str] = None
    nullable: Optional[bool] = None
    children: Optional[Tuple["PortMatchInput", ...]] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class QualifierInput(BaseModel):
    """A qualifier that describes some property of the action"""

    key: str
    value: str
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class RequirementInput(BaseModel):
    """No documentation"""

    key: str
    service: str
    optional: bool
    description: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ResourceFilter(BaseModel):
    """Filter for Resources"""

    ids: Optional[Tuple[ID, ...]] = None
    search: Optional[str] = None
    and_: Optional["ResourceFilter"] = Field(alias="AND", default=None)
    or_: Optional["ResourceFilter"] = Field(alias="OR", default=None)
    not_: Optional["ResourceFilter"] = Field(alias="NOT", default=None)
    distinct: Optional[bool] = Field(alias="DISTINCT", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ReturnWidgetInput(BaseModel):
    """A Return Widget is a UI element that is used to display the value of a port.

    Return Widgets get displayed both if we show the return values of an assignment,
    but also when we inspect the given arguments of a previous run task. Their primary
    usecase is to adequately display the value of a port, in a user readable way.

    Return Widgets are often overwriten by the underlying UI framework (e.g. Orkestrator)
    to provide a better user experience. For example, a return widget that displays a
    date could be overwriten to display a calendar widget.

    Return Widgets provide more a way to customize this overwriten behavior.

    """

    kind: ReturnWidgetKind
    query: Optional[SearchQuery] = None
    choices: Optional[Tuple[ChoiceInput, ...]] = None
    min: Optional[int] = None
    max: Optional[int] = None
    step: Optional[int] = None
    placeholder: Optional[str] = None
    hook: Optional[str] = None
    ward: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class SelectorInput(BaseModel):
    """No documentation"""

    kind: str
    "The kind of the selector"
    api_version: Optional[str] = Field(alias="apiVersion", default=None)
    "The api version of the selector"
    api_thing: Optional[str] = Field(alias="apiThing", default=None)
    "The api thing of the selector"
    oneapi_version: Optional[str] = Field(alias="oneapiVersion", default=None)
    "The api version of the selector"
    cuda_cores: Optional[int] = Field(alias="cudaCores", default=None)
    "The cuda cores"
    frequency: Optional[int] = None
    "The frequency in MHz"
    memory: Optional[int] = None
    "The memory in MB"
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class UpdatePodInput(BaseModel):
    """Create a new Github repository input"""

    pod: Optional[ID] = None
    local_id: Optional[ID] = Field(alias="localId", default=None)
    status: PodStatus
    instance_id: str = Field(alias="instanceId")
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ValidatorInput(BaseModel):
    """
    A validating function for a port. Can specify a function that will run when validating values of the port.
    If outside dependencies are needed they need to be specified in the dependencies field. With the .. syntax
    when transversing the tree of ports.

    """

    function: ValidatorFunction
    dependencies: Optional[Tuple[str, ...]] = None
    label: Optional[str] = None
    error_message: Optional[str] = Field(alias="errorMessage", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class Backend(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Backend"] = Field(
        alias="__typename", default="Backend", exclude=True
    )
    id: ID
    name: str
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for Backend"""

        document = "fragment Backend on Backend {\n  id\n  name\n  __typename\n}"
        name = "Backend"
        type = "Backend"


class ListBackend(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Backend"] = Field(
        alias="__typename", default="Backend", exclude=True
    )
    id: ID
    name: str
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for ListBackend"""

        document = "fragment ListBackend on Backend {\n  id\n  name\n  __typename\n}"
        name = "ListBackend"
        type = "Backend"


class ListDefinition(BaseModel):
    """No documentation"""

    typename: Literal["Definition"] = Field(
        alias="__typename", default="Definition", exclude=True
    )
    id: ID
    name: str
    hash: ActionHash
    description: Optional[str] = Field(default=None)
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for ListDefinition"""

        document = "fragment ListDefinition on Definition {\n  id\n  name\n  hash\n  description\n  __typename\n}"
        name = "ListDefinition"
        type = "Definition"


class Definition(BaseModel):
    """No documentation"""

    typename: Literal["Definition"] = Field(
        alias="__typename", default="Definition", exclude=True
    )
    id: ID
    name: str
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for Definition"""

        document = "fragment Definition on Definition {\n  id\n  name\n  __typename\n}"
        name = "Definition"
        type = "Definition"


class Deployment(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Deployment"] = Field(
        alias="__typename", default="Deployment", exclude=True
    )
    id: ID
    local_id: ID = Field(alias="localId")
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for Deployment"""

        document = (
            "fragment Deployment on Deployment {\n  id\n  localId\n  __typename\n}"
        )
        name = "Deployment"
        type = "Deployment"


class ListDeployment(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Deployment"] = Field(
        alias="__typename", default="Deployment", exclude=True
    )
    id: ID
    local_id: ID = Field(alias="localId")
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for ListDeployment"""

        document = (
            "fragment ListDeployment on Deployment {\n  id\n  localId\n  __typename\n}"
        )
        name = "ListDeployment"
        type = "Deployment"


class CudaSelector(BaseModel):
    """A selector is a way to select a release"""

    typename: Literal["CudaSelector"] = Field(
        alias="__typename", default="CudaSelector", exclude=True
    )
    cuda_version: Optional[str] = Field(default=None, alias="cudaVersion")
    "The minimum cuda version"
    cuda_cores: Optional[int] = Field(default=None, alias="cudaCores")
    "The number of cuda cores"
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for CudaSelector"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}"
        name = "CudaSelector"
        type = "CudaSelector"


class RocmSelector(BaseModel):
    """A selector is a way to select a release"""

    typename: Literal["RocmSelector"] = Field(
        alias="__typename", default="RocmSelector", exclude=True
    )
    api_version: Optional[str] = Field(default=None, alias="apiVersion")
    api_thing: Optional[str] = Field(default=None, alias="apiThing")
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for RocmSelector"""

        document = "fragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}"
        name = "RocmSelector"
        type = "RocmSelector"


class ListPod(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Pod"] = Field(alias="__typename", default="Pod", exclude=True)
    id: ID
    pod_id: str = Field(alias="podId")
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for ListPod"""

        document = "fragment ListPod on Pod {\n  id\n  podId\n  __typename\n}"
        name = "ListPod"
        type = "Pod"


class GithubRepoFlavoursDefinitions(BaseModel):
    """No documentation"""

    typename: Literal["Definition"] = Field(
        alias="__typename", default="Definition", exclude=True
    )
    id: ID
    hash: ActionHash
    model_config = ConfigDict(frozen=True)


class GithubRepoFlavours(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Flavour"] = Field(
        alias="__typename", default="Flavour", exclude=True
    )
    definitions: Tuple[GithubRepoFlavoursDefinitions, ...]
    model_config = ConfigDict(frozen=True)


class GithubRepo(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["GithubRepo"] = Field(
        alias="__typename", default="GithubRepo", exclude=True
    )
    id: ID
    branch: str
    user: str
    repo: str
    flavours: Tuple[GithubRepoFlavours, ...]
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for GithubRepo"""

        document = "fragment GithubRepo on GithubRepo {\n  id\n  branch\n  user\n  repo\n  flavours {\n    definitions {\n      id\n      hash\n      __typename\n    }\n    __typename\n  }\n  __typename\n}"
        name = "GithubRepo"
        type = "GithubRepo"


class ResourceBackend(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Backend"] = Field(
        alias="__typename", default="Backend", exclude=True
    )
    id: ID
    name: str
    model_config = ConfigDict(frozen=True)


class ResourcePods(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Pod"] = Field(alias="__typename", default="Pod", exclude=True)
    id: ID
    pod_id: str = Field(alias="podId")
    model_config = ConfigDict(frozen=True)


class Resource(BaseModel):
    """A resource on a backend. Resource define allocated resources on a backend. E.g a computational action"""

    typename: Literal["Resource"] = Field(
        alias="__typename", default="Resource", exclude=True
    )
    id: ID
    name: str
    qualifiers: Optional[Any] = Field(default=None)
    backend: ResourceBackend
    pods: Tuple[ResourcePods, ...]
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for Resource"""

        document = "fragment Resource on Resource {\n  id\n  name\n  qualifiers\n  backend {\n    id\n    name\n    __typename\n  }\n  pods {\n    id\n    podId\n    __typename\n  }\n  __typename\n}"
        name = "Resource"
        type = "Resource"


class ListResourceBackend(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Backend"] = Field(
        alias="__typename", default="Backend", exclude=True
    )
    id: ID
    name: str
    model_config = ConfigDict(frozen=True)


class ListResource(BaseModel):
    """A resource on a backend. Resource define allocated resources on a backend. E.g a computational action"""

    typename: Literal["Resource"] = Field(
        alias="__typename", default="Resource", exclude=True
    )
    id: ID
    name: str
    qualifiers: Optional[Any] = Field(default=None)
    backend: ListResourceBackend
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for ListResource"""

        document = "fragment ListResource on Resource {\n  id\n  name\n  qualifiers\n  backend {\n    id\n    name\n    __typename\n  }\n  __typename\n}"
        name = "ListResource"
        type = "Resource"


class ListFlavourImage(BaseModel):
    """A docker image descriptor"""

    typename: Literal["DockerImage"] = Field(
        alias="__typename", default="DockerImage", exclude=True
    )
    image_string: str = Field(alias="imageString")
    build_at: datetime = Field(alias="buildAt")
    model_config = ConfigDict(frozen=True)


class ListFlavourRequirements(BaseModel):
    """A requirement"""

    typename: Literal["Requirement"] = Field(
        alias="__typename", default="Requirement", exclude=True
    )
    key: str
    service: str
    description: Optional[str] = Field(default=None)
    optional: bool
    model_config = ConfigDict(frozen=True)


class ListFlavourImage(BaseModel):
    """A docker image descriptor"""

    typename: Literal["DockerImage"] = Field(
        alias="__typename", default="DockerImage", exclude=True
    )
    image_string: str = Field(alias="imageString")
    build_at: datetime = Field(alias="buildAt")
    model_config = ConfigDict(frozen=True)


class ListFlavourRepo(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["GithubRepo"] = Field(
        alias="__typename", default="GithubRepo", exclude=True
    )
    url: str
    model_config = ConfigDict(frozen=True)


class ListFlavourSelectorsBase(BaseModel):
    """A selector is a way to select a release"""

    model_config = ConfigDict(frozen=True)


class ListFlavourSelectorsBaseCPUSelector(ListFlavourSelectorsBase, BaseModel):
    """A selector is a way to select a release"""

    typename: Literal["CPUSelector"] = Field(
        alias="__typename", default="CPUSelector", exclude=True
    )


class ListFlavourSelectorsBaseCudaSelector(
    CudaSelector, ListFlavourSelectorsBase, BaseModel
):
    """A selector is a way to select a release"""

    typename: Literal["CudaSelector"] = Field(
        alias="__typename", default="CudaSelector", exclude=True
    )


class ListFlavourSelectorsBaseRocmSelector(
    RocmSelector, ListFlavourSelectorsBase, BaseModel
):
    """A selector is a way to select a release"""

    typename: Literal["RocmSelector"] = Field(
        alias="__typename", default="RocmSelector", exclude=True
    )


class ListFlavourSelectorsBaseCatchAll(ListFlavourSelectorsBase, BaseModel):
    """Catch all class for ListFlavourSelectorsBase"""

    typename: str = Field(alias="__typename", exclude=True)


class ListFlavour(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Flavour"] = Field(
        alias="__typename", default="Flavour", exclude=True
    )
    id: ID
    name: str
    image: ListFlavourImage
    manifest: Any
    requirements: Tuple[ListFlavourRequirements, ...]
    image: ListFlavourImage
    repo: ListFlavourRepo
    selectors: Tuple[
        Union[
            Annotated[
                Union[
                    ListFlavourSelectorsBaseCPUSelector,
                    ListFlavourSelectorsBaseCudaSelector,
                    ListFlavourSelectorsBaseRocmSelector,
                ],
                Field(discriminator="typename"),
            ],
            ListFlavourSelectorsBaseCatchAll,
        ],
        ...,
    ]
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for ListFlavour"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}"
        name = "ListFlavour"
        type = "Flavour"


class FlavourReleaseApp(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["App"] = Field(alias="__typename", default="App", exclude=True)
    identifier: str
    model_config = ConfigDict(frozen=True)


class FlavourRelease(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Release"] = Field(
        alias="__typename", default="Release", exclude=True
    )
    id: ID
    version: str
    app: FlavourReleaseApp
    scopes: Tuple[str, ...]
    colour: str
    "Is this release deployed"
    description: str
    "Is this release deployed"
    model_config = ConfigDict(frozen=True)


class Flavour(ListFlavour, BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Flavour"] = Field(
        alias="__typename", default="Flavour", exclude=True
    )
    release: FlavourRelease
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for Flavour"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Flavour on Flavour {\n  ...ListFlavour\n  release {\n    id\n    version\n    app {\n      identifier\n      __typename\n    }\n    scopes\n    colour\n    description\n    __typename\n  }\n  __typename\n}"
        name = "Flavour"
        type = "Flavour"


class ReleaseApp(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["App"] = Field(alias="__typename", default="App", exclude=True)
    identifier: str
    model_config = ConfigDict(frozen=True)


class Release(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Release"] = Field(
        alias="__typename", default="Release", exclude=True
    )
    id: ID
    version: str
    app: ReleaseApp
    scopes: Tuple[str, ...]
    colour: str
    "Is this release deployed"
    description: str
    "Is this release deployed"
    flavours: Tuple[ListFlavour, ...]
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for Release"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Release on Release {\n  id\n  version\n  app {\n    identifier\n    __typename\n  }\n  scopes\n  colour\n  description\n  flavours {\n    ...ListFlavour\n    __typename\n  }\n  __typename\n}"
        name = "Release"
        type = "Release"


class ListReleaseApp(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["App"] = Field(alias="__typename", default="App", exclude=True)
    identifier: str
    model_config = ConfigDict(frozen=True)


class ListRelease(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Release"] = Field(
        alias="__typename", default="Release", exclude=True
    )
    id: ID
    version: str
    app: ListReleaseApp
    installed: bool
    "Is this release deployed"
    scopes: Tuple[str, ...]
    flavours: Tuple[ListFlavour, ...]
    colour: str
    "Is this release deployed"
    description: str
    "Is this release deployed"
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for ListRelease"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment ListRelease on Release {\n  id\n  version\n  app {\n    identifier\n    __typename\n  }\n  installed\n  scopes\n  flavours {\n    ...ListFlavour\n    __typename\n  }\n  colour\n  description\n  __typename\n}"
        name = "ListRelease"
        type = "Release"


class PodDeployment(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Deployment"] = Field(
        alias="__typename", default="Deployment", exclude=True
    )
    flavour: Flavour
    model_config = ConfigDict(frozen=True)


class Pod(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Pod"] = Field(alias="__typename", default="Pod", exclude=True)
    id: ID
    pod_id: str = Field(alias="podId")
    deployment: PodDeployment
    model_config = ConfigDict(frozen=True)

    class Meta:
        """Meta class for Pod"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Flavour on Flavour {\n  ...ListFlavour\n  release {\n    id\n    version\n    app {\n      identifier\n      __typename\n    }\n    scopes\n    colour\n    description\n    __typename\n  }\n  __typename\n}\n\nfragment Pod on Pod {\n  id\n  podId\n  deployment {\n    flavour {\n      ...Flavour\n      __typename\n    }\n    __typename\n  }\n  __typename\n}"
        name = "Pod"
        type = "Pod"


class DeclareBackendMutation(BaseModel):
    """No documentation found for this operation."""

    declare_backend: Backend = Field(alias="declareBackend")
    "Create a new dask cluster on a bridge server"

    class Arguments(BaseModel):
        """Arguments for DeclareBackend"""

        input: DeclareBackendInput
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for DeclareBackend"""

        document = "fragment Backend on Backend {\n  id\n  name\n  __typename\n}\n\nmutation DeclareBackend($input: DeclareBackendInput!) {\n  declareBackend(input: $input) {\n    ...Backend\n    __typename\n  }\n}"


class CreateDeploymentMutation(BaseModel):
    """No documentation found for this operation."""

    create_deployment: Deployment = Field(alias="createDeployment")
    "Create a new dask cluster on a bridge server"

    class Arguments(BaseModel):
        """Arguments for CreateDeployment"""

        input: CreateDeploymentInput
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for CreateDeployment"""

        document = "fragment Deployment on Deployment {\n  id\n  localId\n  __typename\n}\n\nmutation CreateDeployment($input: CreateDeploymentInput!) {\n  createDeployment(input: $input) {\n    ...Deployment\n    __typename\n  }\n}"


class CreateAppImageMutation(BaseModel):
    """No documentation found for this operation."""

    create_app_image: Release = Field(alias="createAppImage")
    "Create a new release"

    class Arguments(BaseModel):
        """Arguments for CreateAppImage"""

        input: AppImageInput
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for CreateAppImage"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Release on Release {\n  id\n  version\n  app {\n    identifier\n    __typename\n  }\n  scopes\n  colour\n  description\n  flavours {\n    ...ListFlavour\n    __typename\n  }\n  __typename\n}\n\nmutation CreateAppImage($input: AppImageInput!) {\n  createAppImage(input: $input) {\n    ...Release\n    __typename\n  }\n}"


class CreatePodMutation(BaseModel):
    """No documentation found for this operation."""

    create_pod: Pod = Field(alias="createPod")
    "Create a new dask cluster on a bridge server"

    class Arguments(BaseModel):
        """Arguments for CreatePod"""

        input: CreatePodInput
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for CreatePod"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Flavour on Flavour {\n  ...ListFlavour\n  release {\n    id\n    version\n    app {\n      identifier\n      __typename\n    }\n    scopes\n    colour\n    description\n    __typename\n  }\n  __typename\n}\n\nfragment Pod on Pod {\n  id\n  podId\n  deployment {\n    flavour {\n      ...Flavour\n      __typename\n    }\n    __typename\n  }\n  __typename\n}\n\nmutation CreatePod($input: CreatePodInput!) {\n  createPod(input: $input) {\n    ...Pod\n    __typename\n  }\n}"


class UpdatePodMutation(BaseModel):
    """No documentation found for this operation."""

    update_pod: Pod = Field(alias="updatePod")
    "Create a new dask cluster on a bridge server"

    class Arguments(BaseModel):
        """Arguments for UpdatePod"""

        input: UpdatePodInput
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for UpdatePod"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Flavour on Flavour {\n  ...ListFlavour\n  release {\n    id\n    version\n    app {\n      identifier\n      __typename\n    }\n    scopes\n    colour\n    description\n    __typename\n  }\n  __typename\n}\n\nfragment Pod on Pod {\n  id\n  podId\n  deployment {\n    flavour {\n      ...Flavour\n      __typename\n    }\n    __typename\n  }\n  __typename\n}\n\nmutation UpdatePod($input: UpdatePodInput!) {\n  updatePod(input: $input) {\n    ...Pod\n    __typename\n  }\n}"


class DeletePodMutation(BaseModel):
    """No documentation found for this operation."""

    delete_pod: ID = Field(alias="deletePod")
    "Create a new dask cluster on a bridge server"

    class Arguments(BaseModel):
        """Arguments for DeletePod"""

        input: DeletePodInput
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for DeletePod"""

        document = "mutation DeletePod($input: DeletePodInput!) {\n  deletePod(input: $input)\n}"


class DumpLogsMutationDumplogsPod(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Pod"] = Field(alias="__typename", default="Pod", exclude=True)
    id: ID
    model_config = ConfigDict(frozen=True)


class DumpLogsMutationDumplogs(BaseModel):
    """The logs of a pod"""

    typename: Literal["LogDump"] = Field(
        alias="__typename", default="LogDump", exclude=True
    )
    pod: DumpLogsMutationDumplogsPod
    logs: str
    model_config = ConfigDict(frozen=True)


class DumpLogsMutation(BaseModel):
    """No documentation found for this operation."""

    dump_logs: DumpLogsMutationDumplogs = Field(alias="dumpLogs")
    "Create a new dask cluster on a bridge server"

    class Arguments(BaseModel):
        """Arguments for DumpLogs"""

        input: DumpLogsInput
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for DumpLogs"""

        document = "mutation DumpLogs($input: DumpLogsInput!) {\n  dumpLogs(input: $input) {\n    pod {\n      id\n      __typename\n    }\n    logs\n    __typename\n  }\n}"


class CreateGithubRepoMutation(BaseModel):
    """No documentation found for this operation."""

    create_github_repo: GithubRepo = Field(alias="createGithubRepo")
    "Create a new Github repository on a bridge server"

    class Arguments(BaseModel):
        """Arguments for CreateGithubRepo"""

        input: CreateGithubRepoInput
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for CreateGithubRepo"""

        document = "fragment GithubRepo on GithubRepo {\n  id\n  branch\n  user\n  repo\n  flavours {\n    definitions {\n      id\n      hash\n      __typename\n    }\n    __typename\n  }\n  __typename\n}\n\nmutation CreateGithubRepo($input: CreateGithubRepoInput!) {\n  createGithubRepo(input: $input) {\n    ...GithubRepo\n    __typename\n  }\n}"


class DeclareResourceMutation(BaseModel):
    """No documentation found for this operation."""

    declare_resource: Resource = Field(alias="declareResource")
    "Create a new resource for your backend"

    class Arguments(BaseModel):
        """Arguments for DeclareResource"""

        input: DeclareResourceInput
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for DeclareResource"""

        document = "fragment Resource on Resource {\n  id\n  name\n  qualifiers\n  backend {\n    id\n    name\n    __typename\n  }\n  pods {\n    id\n    podId\n    __typename\n  }\n  __typename\n}\n\nmutation DeclareResource($input: DeclareResourceInput!) {\n  declareResource(input: $input) {\n    ...Resource\n    __typename\n  }\n}"


class ListBackendsQuery(BaseModel):
    """No documentation found for this operation."""

    backends: Tuple[ListBackend, ...]

    class Arguments(BaseModel):
        """Arguments for ListBackends"""

        filters: Optional[BackendFilter] = Field(default=None)
        pagination: Optional[OffsetPaginationInput] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for ListBackends"""

        document = "fragment ListBackend on Backend {\n  id\n  name\n  __typename\n}\n\nquery ListBackends($filters: BackendFilter, $pagination: OffsetPaginationInput) {\n  backends(filters: $filters, pagination: $pagination) {\n    ...ListBackend\n    __typename\n  }\n}"


class GetBackendQuery(BaseModel):
    """No documentation found for this operation."""

    backend: Backend
    "Return all dask clusters"

    class Arguments(BaseModel):
        """Arguments for GetBackend"""

        id: ID
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for GetBackend"""

        document = "fragment Backend on Backend {\n  id\n  name\n  __typename\n}\n\nquery GetBackend($id: ID!) {\n  backend(id: $id) {\n    ...Backend\n    __typename\n  }\n}"


class SearchBackendsQueryOptions(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Backend"] = Field(
        alias="__typename", default="Backend", exclude=True
    )
    value: ID
    label: str
    model_config = ConfigDict(frozen=True)


class SearchBackendsQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[SearchBackendsQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for SearchBackends"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for SearchBackends"""

        document = "query SearchBackends($search: String, $values: [ID!]) {\n  options: backends(\n    filters: {search: $search, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    value: id\n    label: name\n    __typename\n  }\n}"


class ListDefinitionsQuery(BaseModel):
    """No documentation found for this operation."""

    definitions: Tuple[ListDefinition, ...]

    class Arguments(BaseModel):
        """Arguments for ListDefinitions"""

        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for ListDefinitions"""

        document = "fragment ListDefinition on Definition {\n  id\n  name\n  hash\n  description\n  __typename\n}\n\nquery ListDefinitions {\n  definitions {\n    ...ListDefinition\n    __typename\n  }\n}"


class GetDefinitionByHashQuery(BaseModel):
    """No documentation found for this operation."""

    definition: Definition
    "Return all dask clusters"

    class Arguments(BaseModel):
        """Arguments for GetDefinitionByHash"""

        hash: Optional[ActionHash] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for GetDefinitionByHash"""

        document = "fragment Definition on Definition {\n  id\n  name\n  __typename\n}\n\nquery GetDefinitionByHash($hash: ActionHash) {\n  definition(hash: $hash) {\n    ...Definition\n    __typename\n  }\n}"


class GetDefinitionQuery(BaseModel):
    """No documentation found for this operation."""

    definition: Definition
    "Return all dask clusters"

    class Arguments(BaseModel):
        """Arguments for GetDefinition"""

        id: ID
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for GetDefinition"""

        document = "fragment Definition on Definition {\n  id\n  name\n  __typename\n}\n\nquery GetDefinition($id: ID!) {\n  definition(id: $id) {\n    ...Definition\n    __typename\n  }\n}"


class SearchDefinitionsQueryOptions(BaseModel):
    """No documentation"""

    typename: Literal["Definition"] = Field(
        alias="__typename", default="Definition", exclude=True
    )
    value: ID
    label: str
    model_config = ConfigDict(frozen=True)


class SearchDefinitionsQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[SearchDefinitionsQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for SearchDefinitions"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for SearchDefinitions"""

        document = "query SearchDefinitions($search: String, $values: [ID!]) {\n  options: definitions(\n    filters: {search: $search, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    value: id\n    label: name\n    __typename\n  }\n}"


class GetDeploymentQuery(BaseModel):
    """No documentation found for this operation."""

    deployment: Deployment
    "Return all dask clusters"

    class Arguments(BaseModel):
        """Arguments for GetDeployment"""

        id: ID
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for GetDeployment"""

        document = "fragment Deployment on Deployment {\n  id\n  localId\n  __typename\n}\n\nquery GetDeployment($id: ID!) {\n  deployment(id: $id) {\n    ...Deployment\n    __typename\n  }\n}"


class ListDeploymentsQuery(BaseModel):
    """No documentation found for this operation."""

    deployments: Tuple[ListDeployment, ...]

    class Arguments(BaseModel):
        """Arguments for ListDeployments"""

        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for ListDeployments"""

        document = "fragment ListDeployment on Deployment {\n  id\n  localId\n  __typename\n}\n\nquery ListDeployments {\n  deployments {\n    ...ListDeployment\n    __typename\n  }\n}"


class SearchDeploymentsQueryOptions(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Deployment"] = Field(
        alias="__typename", default="Deployment", exclude=True
    )
    value: ID
    label: str
    model_config = ConfigDict(frozen=True)


class SearchDeploymentsQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[SearchDeploymentsQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for SearchDeployments"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for SearchDeployments"""

        document = "query SearchDeployments($search: String, $values: [ID!]) {\n  options: deployments(\n    filters: {search: $search, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    value: id\n    label: name\n    __typename\n  }\n}"


class MatchFlavourQueryMatchflavourImage(BaseModel):
    """A docker image descriptor"""

    typename: Literal["DockerImage"] = Field(
        alias="__typename", default="DockerImage", exclude=True
    )
    image_string: str = Field(alias="imageString")
    build_at: datetime = Field(alias="buildAt")
    model_config = ConfigDict(frozen=True)


class MatchFlavourQueryMatchflavour(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Flavour"] = Field(
        alias="__typename", default="Flavour", exclude=True
    )
    id: ID
    image: MatchFlavourQueryMatchflavourImage
    model_config = ConfigDict(frozen=True)


class MatchFlavourQuery(BaseModel):
    """No documentation found for this operation."""

    match_flavour: MatchFlavourQueryMatchflavour = Field(alias="matchFlavour")
    "Return the currently logged in user"

    class Arguments(BaseModel):
        """Arguments for MatchFlavour"""

        actions: Optional[List[ActionHash]] = Field(default=None)
        environment: Optional[EnvironmentInput] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for MatchFlavour"""

        document = "query MatchFlavour($actions: [ActionHash!], $environment: EnvironmentInput) {\n  matchFlavour(input: {actions: $actions, environment: $environment}) {\n    id\n    image {\n      imageString\n      buildAt\n      __typename\n    }\n    __typename\n  }\n}"


class ListFlavoursQuery(BaseModel):
    """No documentation found for this operation."""

    flavours: Tuple[ListFlavour, ...]

    class Arguments(BaseModel):
        """Arguments for ListFlavours"""

        filters: Optional[FlavourFilter] = Field(default=None)
        pagination: Optional[OffsetPaginationInput] = Field(default=None)
        order: Optional[FlavourOrder] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for ListFlavours"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nquery ListFlavours($filters: FlavourFilter, $pagination: OffsetPaginationInput, $order: FlavourOrder) {\n  flavours(filters: $filters, pagination: $pagination, order: $order) {\n    ...ListFlavour\n    __typename\n  }\n}"


class GetFlavourQuery(BaseModel):
    """No documentation found for this operation."""

    flavour: Flavour
    "Return all dask clusters"

    class Arguments(BaseModel):
        """Arguments for GetFlavour"""

        id: ID
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for GetFlavour"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Flavour on Flavour {\n  ...ListFlavour\n  release {\n    id\n    version\n    app {\n      identifier\n      __typename\n    }\n    scopes\n    colour\n    description\n    __typename\n  }\n  __typename\n}\n\nquery GetFlavour($id: ID!) {\n  flavour(id: $id) {\n    ...Flavour\n    __typename\n  }\n}"


class SearchFlavoursQueryOptions(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Flavour"] = Field(
        alias="__typename", default="Flavour", exclude=True
    )
    value: ID
    label: str
    model_config = ConfigDict(frozen=True)


class SearchFlavoursQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[SearchFlavoursQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for SearchFlavours"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for SearchFlavours"""

        document = "query SearchFlavours($search: String, $values: [ID!]) {\n  options: flavours(\n    filters: {search: $search, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    value: id\n    label: name\n    __typename\n  }\n}"


class ListPodQuery(BaseModel):
    """No documentation found for this operation."""

    pods: Tuple[ListPod, ...]

    class Arguments(BaseModel):
        """Arguments for ListPod"""

        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for ListPod"""

        document = "fragment ListPod on Pod {\n  id\n  podId\n  __typename\n}\n\nquery ListPod {\n  pods {\n    ...ListPod\n    __typename\n  }\n}"


class GetPodQuery(BaseModel):
    """No documentation found for this operation."""

    pod: Pod
    "Return all dask clusters"

    class Arguments(BaseModel):
        """Arguments for GetPod"""

        id: ID
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for GetPod"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Flavour on Flavour {\n  ...ListFlavour\n  release {\n    id\n    version\n    app {\n      identifier\n      __typename\n    }\n    scopes\n    colour\n    description\n    __typename\n  }\n  __typename\n}\n\nfragment Pod on Pod {\n  id\n  podId\n  deployment {\n    flavour {\n      ...Flavour\n      __typename\n    }\n    __typename\n  }\n  __typename\n}\n\nquery GetPod($id: ID!) {\n  pod(id: $id) {\n    ...Pod\n    __typename\n  }\n}"


class MyPodAtQuery(BaseModel):
    """No documentation found for this operation."""

    my_pod_at: Pod = Field(alias="myPodAt")
    "Let a backend discover its own pods"

    class Arguments(BaseModel):
        """Arguments for MyPodAt"""

        instance_id: ID = Field(alias="instanceId")
        local_id: ID = Field(alias="localId")
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for MyPodAt"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Flavour on Flavour {\n  ...ListFlavour\n  release {\n    id\n    version\n    app {\n      identifier\n      __typename\n    }\n    scopes\n    colour\n    description\n    __typename\n  }\n  __typename\n}\n\nfragment Pod on Pod {\n  id\n  podId\n  deployment {\n    flavour {\n      ...Flavour\n      __typename\n    }\n    __typename\n  }\n  __typename\n}\n\nquery MyPodAt($instanceId: ID!, $localId: ID!) {\n  myPodAt(instanceId: $instanceId, localId: $localId) {\n    ...Pod\n    __typename\n  }\n}"


class SearchPodsQueryOptions(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Pod"] = Field(alias="__typename", default="Pod", exclude=True)
    value: ID
    label: str
    model_config = ConfigDict(frozen=True)


class SearchPodsQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[SearchPodsQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for SearchPods"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)
        backend: Optional[ID] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for SearchPods"""

        document = "query SearchPods($search: String, $values: [ID!], $backend: ID) {\n  options: pods(\n    filters: {search: $search, ids: $values, backend: $backend}\n    pagination: {limit: 10}\n  ) {\n    value: id\n    label: name\n    __typename\n  }\n}"


class ListReleasesQuery(BaseModel):
    """No documentation found for this operation."""

    releases: Tuple[ListRelease, ...]

    class Arguments(BaseModel):
        """Arguments for ListReleases"""

        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for ListReleases"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment ListRelease on Release {\n  id\n  version\n  app {\n    identifier\n    __typename\n  }\n  installed\n  scopes\n  flavours {\n    ...ListFlavour\n    __typename\n  }\n  colour\n  description\n  __typename\n}\n\nquery ListReleases {\n  releases {\n    ...ListRelease\n    __typename\n  }\n}"


class GetReleaseQuery(BaseModel):
    """No documentation found for this operation."""

    release: Release
    "Return all dask clusters"

    class Arguments(BaseModel):
        """Arguments for GetRelease"""

        id: ID
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for GetRelease"""

        document = "fragment CudaSelector on CudaSelector {\n  cudaVersion\n  cudaCores\n  __typename\n}\n\nfragment RocmSelector on RocmSelector {\n  apiVersion\n  apiThing\n  __typename\n}\n\nfragment ListFlavour on Flavour {\n  id\n  name\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  manifest\n  requirements {\n    key\n    service\n    description\n    optional\n    __typename\n  }\n  image {\n    imageString\n    buildAt\n    __typename\n  }\n  repo {\n    url\n    __typename\n  }\n  selectors {\n    ...CudaSelector\n    ...RocmSelector\n    __typename\n  }\n  __typename\n}\n\nfragment Release on Release {\n  id\n  version\n  app {\n    identifier\n    __typename\n  }\n  scopes\n  colour\n  description\n  flavours {\n    ...ListFlavour\n    __typename\n  }\n  __typename\n}\n\nquery GetRelease($id: ID!) {\n  release(id: $id) {\n    ...Release\n    __typename\n  }\n}"


class SearchReleasesQueryOptions(BaseModel):
    """A user of the bridge server. Maps to an authentikate user"""

    typename: Literal["Release"] = Field(
        alias="__typename", default="Release", exclude=True
    )
    value: ID
    label: str
    "Is this release deployed"
    model_config = ConfigDict(frozen=True)


class SearchReleasesQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[SearchReleasesQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for SearchReleases"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for SearchReleases"""

        document = "query SearchReleases($search: String, $values: [ID!]) {\n  options: releases(\n    filters: {search: $search, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    value: id\n    label: name\n    __typename\n  }\n}"


class ListResourcesQuery(BaseModel):
    """No documentation found for this operation."""

    resources: Tuple[ListResource, ...]

    class Arguments(BaseModel):
        """Arguments for ListResources"""

        filters: Optional[ResourceFilter] = Field(default=None)
        pagination: Optional[OffsetPaginationInput] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for ListResources"""

        document = "fragment ListResource on Resource {\n  id\n  name\n  qualifiers\n  backend {\n    id\n    name\n    __typename\n  }\n  __typename\n}\n\nquery ListResources($filters: ResourceFilter, $pagination: OffsetPaginationInput) {\n  resources(filters: $filters, pagination: $pagination) {\n    ...ListResource\n    __typename\n  }\n}"


class GeResourceQuery(BaseModel):
    """No documentation found for this operation."""

    resource: Resource
    "Return all dask clusters"

    class Arguments(BaseModel):
        """Arguments for GeResource"""

        id: ID
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for GeResource"""

        document = "fragment Resource on Resource {\n  id\n  name\n  qualifiers\n  backend {\n    id\n    name\n    __typename\n  }\n  pods {\n    id\n    podId\n    __typename\n  }\n  __typename\n}\n\nquery GeResource($id: ID!) {\n  resource(id: $id) {\n    ...Resource\n    __typename\n  }\n}"


class SearchResourcesQueryOptions(BaseModel):
    """A resource on a backend. Resource define allocated resources on a backend. E.g a computational action"""

    typename: Literal["Resource"] = Field(
        alias="__typename", default="Resource", exclude=True
    )
    value: ID
    label: str
    model_config = ConfigDict(frozen=True)


class SearchResourcesQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[SearchResourcesQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for SearchResources"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)
        model_config = ConfigDict(populate_by_name=True)

    class Meta:
        """Meta class for SearchResources"""

        document = "query SearchResources($search: String, $values: [ID!]) {\n  options: resources(\n    filters: {search: $search, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    value: id\n    label: name\n    __typename\n  }\n}"


async def adeclare_backend(
    instance_id: str, name: str, kind: str, rath: Optional[KabinetRath] = None
) -> Backend:
    """DeclareBackend

    Create a new dask cluster on a bridge server

    Args:
        instance_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        kind: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Backend
    """
    return (
        await aexecute(
            DeclareBackendMutation,
            {"input": {"instanceId": instance_id, "name": name, "kind": kind}},
            rath=rath,
        )
    ).declare_backend


def declare_backend(
    instance_id: str, name: str, kind: str, rath: Optional[KabinetRath] = None
) -> Backend:
    """DeclareBackend

    Create a new dask cluster on a bridge server

    Args:
        instance_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        kind: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Backend
    """
    return execute(
        DeclareBackendMutation,
        {"input": {"instanceId": instance_id, "name": name, "kind": kind}},
        rath=rath,
    ).declare_backend


async def acreate_deployment(
    instance_id: str,
    local_id: IDCoercible,
    flavour: IDCoercible,
    last_pulled: Optional[datetime] = None,
    secret_params: Optional[Any] = None,
    rath: Optional[KabinetRath] = None,
) -> Deployment:
    """CreateDeployment

    Create a new dask cluster on a bridge server

    Args:
        instance_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        local_id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        flavour: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        last_pulled: Date with time (isoformat)
        secret_params: UntypedParams represents an untyped options object returned by the Dask Gateway API.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Deployment
    """
    return (
        await aexecute(
            CreateDeploymentMutation,
            {
                "input": {
                    "instanceId": instance_id,
                    "localId": local_id,
                    "flavour": flavour,
                    "lastPulled": last_pulled,
                    "secretParams": secret_params,
                }
            },
            rath=rath,
        )
    ).create_deployment


def create_deployment(
    instance_id: str,
    local_id: IDCoercible,
    flavour: IDCoercible,
    last_pulled: Optional[datetime] = None,
    secret_params: Optional[Any] = None,
    rath: Optional[KabinetRath] = None,
) -> Deployment:
    """CreateDeployment

    Create a new dask cluster on a bridge server

    Args:
        instance_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        local_id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        flavour: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        last_pulled: Date with time (isoformat)
        secret_params: UntypedParams represents an untyped options object returned by the Dask Gateway API.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Deployment
    """
    return execute(
        CreateDeploymentMutation,
        {
            "input": {
                "instanceId": instance_id,
                "localId": local_id,
                "flavour": flavour,
                "lastPulled": last_pulled,
                "secretParams": secret_params,
            }
        },
        rath=rath,
    ).create_deployment


async def acreate_app_image(
    manifest: ManifestInput,
    selectors: Iterable[SelectorInput],
    app_image_id: str,
    inspection: InspectionInput,
    image: DockerImageInput,
    flavour_name: Optional[str] = None,
    rath: Optional[KabinetRath] = None,
) -> Release:
    """CreateAppImage

    Create a new release

    Args:
        flavour_name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        manifest:  (required)
        selectors:  (required) (list) (required)
        app_image_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        inspection:  (required)
        image:  (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Release
    """
    return (
        await aexecute(
            CreateAppImageMutation,
            {
                "input": {
                    "flavourName": flavour_name,
                    "manifest": manifest,
                    "selectors": selectors,
                    "appImageId": app_image_id,
                    "inspection": inspection,
                    "image": image,
                }
            },
            rath=rath,
        )
    ).create_app_image


def create_app_image(
    manifest: ManifestInput,
    selectors: Iterable[SelectorInput],
    app_image_id: str,
    inspection: InspectionInput,
    image: DockerImageInput,
    flavour_name: Optional[str] = None,
    rath: Optional[KabinetRath] = None,
) -> Release:
    """CreateAppImage

    Create a new release

    Args:
        flavour_name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        manifest:  (required)
        selectors:  (required) (list) (required)
        app_image_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        inspection:  (required)
        image:  (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Release
    """
    return execute(
        CreateAppImageMutation,
        {
            "input": {
                "flavourName": flavour_name,
                "manifest": manifest,
                "selectors": selectors,
                "appImageId": app_image_id,
                "inspection": inspection,
                "image": image,
            }
        },
        rath=rath,
    ).create_app_image


async def acreate_pod(
    deployment: IDCoercible,
    local_id: IDCoercible,
    instance_id: str,
    resource: Optional[IDCoercible] = None,
    client_id: Optional[str] = None,
    rath: Optional[KabinetRath] = None,
) -> Pod:
    """CreatePod

    Create a new dask cluster on a bridge server

    Args:
        deployment: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        local_id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        resource: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        instance_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        client_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Pod
    """
    return (
        await aexecute(
            CreatePodMutation,
            {
                "input": {
                    "deployment": deployment,
                    "localId": local_id,
                    "resource": resource,
                    "instanceId": instance_id,
                    "clientId": client_id,
                }
            },
            rath=rath,
        )
    ).create_pod


def create_pod(
    deployment: IDCoercible,
    local_id: IDCoercible,
    instance_id: str,
    resource: Optional[IDCoercible] = None,
    client_id: Optional[str] = None,
    rath: Optional[KabinetRath] = None,
) -> Pod:
    """CreatePod

    Create a new dask cluster on a bridge server

    Args:
        deployment: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        local_id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        resource: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        instance_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        client_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Pod
    """
    return execute(
        CreatePodMutation,
        {
            "input": {
                "deployment": deployment,
                "localId": local_id,
                "resource": resource,
                "instanceId": instance_id,
                "clientId": client_id,
            }
        },
        rath=rath,
    ).create_pod


async def aupdate_pod(
    status: PodStatus,
    instance_id: str,
    pod: Optional[IDCoercible] = None,
    local_id: Optional[IDCoercible] = None,
    rath: Optional[KabinetRath] = None,
) -> Pod:
    """UpdatePod

    Create a new dask cluster on a bridge server

    Args:
        pod: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        local_id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        status: PodStatus (required)
        instance_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Pod
    """
    return (
        await aexecute(
            UpdatePodMutation,
            {
                "input": {
                    "pod": pod,
                    "localId": local_id,
                    "status": status,
                    "instanceId": instance_id,
                }
            },
            rath=rath,
        )
    ).update_pod


def update_pod(
    status: PodStatus,
    instance_id: str,
    pod: Optional[IDCoercible] = None,
    local_id: Optional[IDCoercible] = None,
    rath: Optional[KabinetRath] = None,
) -> Pod:
    """UpdatePod

    Create a new dask cluster on a bridge server

    Args:
        pod: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        local_id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        status: PodStatus (required)
        instance_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Pod
    """
    return execute(
        UpdatePodMutation,
        {
            "input": {
                "pod": pod,
                "localId": local_id,
                "status": status,
                "instanceId": instance_id,
            }
        },
        rath=rath,
    ).update_pod


async def adelete_pod(id: IDCoercible, rath: Optional[KabinetRath] = None) -> ID:
    """DeletePod

    Create a new dask cluster on a bridge server

    Args:
        id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        ID
    """
    return (
        await aexecute(DeletePodMutation, {"input": {"id": id}}, rath=rath)
    ).delete_pod


def delete_pod(id: IDCoercible, rath: Optional[KabinetRath] = None) -> ID:
    """DeletePod

    Create a new dask cluster on a bridge server

    Args:
        id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        ID
    """
    return execute(DeletePodMutation, {"input": {"id": id}}, rath=rath).delete_pod


async def adump_logs(
    pod: IDCoercible, logs: str, rath: Optional[KabinetRath] = None
) -> DumpLogsMutationDumplogs:
    """DumpLogs

    Create a new dask cluster on a bridge server

    Args:
        pod: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        logs: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        DumpLogsMutationDumplogs
    """
    return (
        await aexecute(
            DumpLogsMutation, {"input": {"pod": pod, "logs": logs}}, rath=rath
        )
    ).dump_logs


def dump_logs(
    pod: IDCoercible, logs: str, rath: Optional[KabinetRath] = None
) -> DumpLogsMutationDumplogs:
    """DumpLogs

    Create a new dask cluster on a bridge server

    Args:
        pod: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        logs: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        DumpLogsMutationDumplogs
    """
    return execute(
        DumpLogsMutation, {"input": {"pod": pod, "logs": logs}}, rath=rath
    ).dump_logs


async def acreate_github_repo(
    name: Optional[str] = None,
    user: Optional[str] = None,
    branch: Optional[str] = None,
    repo: Optional[str] = None,
    identifier: Optional[str] = None,
    auto_scan: Optional[bool] = True,
    rath: Optional[KabinetRath] = None,
) -> GithubRepo:
    """CreateGithubRepo

    Create a new Github repository on a bridge server

    Args:
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        user: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        branch: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        repo: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        identifier: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        auto_scan: The `Boolean` scalar type represents `true` or `false`.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        GithubRepo
    """
    return (
        await aexecute(
            CreateGithubRepoMutation,
            {
                "input": {
                    "name": name,
                    "user": user,
                    "branch": branch,
                    "repo": repo,
                    "identifier": identifier,
                    "autoScan": auto_scan,
                }
            },
            rath=rath,
        )
    ).create_github_repo


def create_github_repo(
    name: Optional[str] = None,
    user: Optional[str] = None,
    branch: Optional[str] = None,
    repo: Optional[str] = None,
    identifier: Optional[str] = None,
    auto_scan: Optional[bool] = True,
    rath: Optional[KabinetRath] = None,
) -> GithubRepo:
    """CreateGithubRepo

    Create a new Github repository on a bridge server

    Args:
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        user: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        branch: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        repo: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        identifier: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        auto_scan: The `Boolean` scalar type represents `true` or `false`.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        GithubRepo
    """
    return execute(
        CreateGithubRepoMutation,
        {
            "input": {
                "name": name,
                "user": user,
                "branch": branch,
                "repo": repo,
                "identifier": identifier,
                "autoScan": auto_scan,
            }
        },
        rath=rath,
    ).create_github_repo


async def adeclare_resource(
    backend: IDCoercible,
    local_id: str,
    name: Optional[str] = None,
    qualifiers: Optional[Iterable[QualifierInput]] = None,
    rath: Optional[KabinetRath] = None,
) -> Resource:
    """DeclareResource

    Create a new resource for your backend

    Args:
        backend: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        local_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        qualifiers: A qualifier that describes some property of the action (required) (list)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Resource
    """
    return (
        await aexecute(
            DeclareResourceMutation,
            {
                "input": {
                    "backend": backend,
                    "name": name,
                    "localId": local_id,
                    "qualifiers": qualifiers,
                }
            },
            rath=rath,
        )
    ).declare_resource


def declare_resource(
    backend: IDCoercible,
    local_id: str,
    name: Optional[str] = None,
    qualifiers: Optional[Iterable[QualifierInput]] = None,
    rath: Optional[KabinetRath] = None,
) -> Resource:
    """DeclareResource

    Create a new resource for your backend

    Args:
        backend: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        local_id: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        qualifiers: A qualifier that describes some property of the action (required) (list)
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Resource
    """
    return execute(
        DeclareResourceMutation,
        {
            "input": {
                "backend": backend,
                "name": name,
                "localId": local_id,
                "qualifiers": qualifiers,
            }
        },
        rath=rath,
    ).declare_resource


async def alist_backends(
    filters: Optional[BackendFilter] = None,
    pagination: Optional[OffsetPaginationInput] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[ListBackend, ...]:
    """ListBackends


    Args:
        filters (Optional[BackendFilter], optional): No description.
        pagination (Optional[OffsetPaginationInput], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListBackend]
    """
    return (
        await aexecute(
            ListBackendsQuery, {"filters": filters, "pagination": pagination}, rath=rath
        )
    ).backends


def list_backends(
    filters: Optional[BackendFilter] = None,
    pagination: Optional[OffsetPaginationInput] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[ListBackend, ...]:
    """ListBackends


    Args:
        filters (Optional[BackendFilter], optional): No description.
        pagination (Optional[OffsetPaginationInput], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListBackend]
    """
    return execute(
        ListBackendsQuery, {"filters": filters, "pagination": pagination}, rath=rath
    ).backends


async def aget_backend(id: ID, rath: Optional[KabinetRath] = None) -> Backend:
    """GetBackend

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Backend
    """
    return (await aexecute(GetBackendQuery, {"id": id}, rath=rath)).backend


def get_backend(id: ID, rath: Optional[KabinetRath] = None) -> Backend:
    """GetBackend

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Backend
    """
    return execute(GetBackendQuery, {"id": id}, rath=rath).backend


async def asearch_backends(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchBackendsQueryOptions, ...]:
    """SearchBackends


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchBackendsQueryBackends]
    """
    return (
        await aexecute(
            SearchBackendsQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_backends(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchBackendsQueryOptions, ...]:
    """SearchBackends


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchBackendsQueryBackends]
    """
    return execute(
        SearchBackendsQuery, {"search": search, "values": values}, rath=rath
    ).options


async def alist_definitions(
    rath: Optional[KabinetRath] = None,
) -> Tuple[ListDefinition, ...]:
    """ListDefinitions


    Args:
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListDefinition]
    """
    return (await aexecute(ListDefinitionsQuery, {}, rath=rath)).definitions


def list_definitions(rath: Optional[KabinetRath] = None) -> Tuple[ListDefinition, ...]:
    """ListDefinitions


    Args:
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListDefinition]
    """
    return execute(ListDefinitionsQuery, {}, rath=rath).definitions


async def aget_definition_by_hash(
    hash: Optional[ActionHash] = None, rath: Optional[KabinetRath] = None
) -> Definition:
    """GetDefinitionByHash

    Return all dask clusters

    Args:
        hash (Optional[ActionHash], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Definition
    """
    return (
        await aexecute(GetDefinitionByHashQuery, {"hash": hash}, rath=rath)
    ).definition


def get_definition_by_hash(
    hash: Optional[ActionHash] = None, rath: Optional[KabinetRath] = None
) -> Definition:
    """GetDefinitionByHash

    Return all dask clusters

    Args:
        hash (Optional[ActionHash], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Definition
    """
    return execute(GetDefinitionByHashQuery, {"hash": hash}, rath=rath).definition


async def aget_definition(id: ID, rath: Optional[KabinetRath] = None) -> Definition:
    """GetDefinition

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Definition
    """
    return (await aexecute(GetDefinitionQuery, {"id": id}, rath=rath)).definition


def get_definition(id: ID, rath: Optional[KabinetRath] = None) -> Definition:
    """GetDefinition

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Definition
    """
    return execute(GetDefinitionQuery, {"id": id}, rath=rath).definition


async def asearch_definitions(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchDefinitionsQueryOptions, ...]:
    """SearchDefinitions


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchDefinitionsQueryDefinitions]
    """
    return (
        await aexecute(
            SearchDefinitionsQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_definitions(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchDefinitionsQueryOptions, ...]:
    """SearchDefinitions


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchDefinitionsQueryDefinitions]
    """
    return execute(
        SearchDefinitionsQuery, {"search": search, "values": values}, rath=rath
    ).options


async def aget_deployment(id: ID, rath: Optional[KabinetRath] = None) -> Deployment:
    """GetDeployment

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Deployment
    """
    return (await aexecute(GetDeploymentQuery, {"id": id}, rath=rath)).deployment


def get_deployment(id: ID, rath: Optional[KabinetRath] = None) -> Deployment:
    """GetDeployment

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Deployment
    """
    return execute(GetDeploymentQuery, {"id": id}, rath=rath).deployment


async def alist_deployments(
    rath: Optional[KabinetRath] = None,
) -> Tuple[ListDeployment, ...]:
    """ListDeployments


    Args:
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListDeployment]
    """
    return (await aexecute(ListDeploymentsQuery, {}, rath=rath)).deployments


def list_deployments(rath: Optional[KabinetRath] = None) -> Tuple[ListDeployment, ...]:
    """ListDeployments


    Args:
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListDeployment]
    """
    return execute(ListDeploymentsQuery, {}, rath=rath).deployments


async def asearch_deployments(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchDeploymentsQueryOptions, ...]:
    """SearchDeployments


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchDeploymentsQueryDeployments]
    """
    return (
        await aexecute(
            SearchDeploymentsQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_deployments(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchDeploymentsQueryOptions, ...]:
    """SearchDeployments


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchDeploymentsQueryDeployments]
    """
    return execute(
        SearchDeploymentsQuery, {"search": search, "values": values}, rath=rath
    ).options


async def amatch_flavour(
    actions: Optional[List[ActionHash]] = None,
    environment: Optional[EnvironmentInput] = None,
    rath: Optional[KabinetRath] = None,
) -> MatchFlavourQueryMatchflavour:
    """MatchFlavour

    Return the currently logged in user

    Args:
        actions (Optional[List[ActionHash]], optional): No description.
        environment (Optional[EnvironmentInput], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        MatchFlavourQueryMatchflavour
    """
    return (
        await aexecute(
            MatchFlavourQuery,
            {"actions": actions, "environment": environment},
            rath=rath,
        )
    ).match_flavour


def match_flavour(
    actions: Optional[List[ActionHash]] = None,
    environment: Optional[EnvironmentInput] = None,
    rath: Optional[KabinetRath] = None,
) -> MatchFlavourQueryMatchflavour:
    """MatchFlavour

    Return the currently logged in user

    Args:
        actions (Optional[List[ActionHash]], optional): No description.
        environment (Optional[EnvironmentInput], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        MatchFlavourQueryMatchflavour
    """
    return execute(
        MatchFlavourQuery, {"actions": actions, "environment": environment}, rath=rath
    ).match_flavour


async def alist_flavours(
    filters: Optional[FlavourFilter] = None,
    pagination: Optional[OffsetPaginationInput] = None,
    order: Optional[FlavourOrder] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[ListFlavour, ...]:
    """ListFlavours


    Args:
        filters (Optional[FlavourFilter], optional): No description.
        pagination (Optional[OffsetPaginationInput], optional): No description.
        order (Optional[FlavourOrder], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListFlavour]
    """
    return (
        await aexecute(
            ListFlavoursQuery,
            {"filters": filters, "pagination": pagination, "order": order},
            rath=rath,
        )
    ).flavours


def list_flavours(
    filters: Optional[FlavourFilter] = None,
    pagination: Optional[OffsetPaginationInput] = None,
    order: Optional[FlavourOrder] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[ListFlavour, ...]:
    """ListFlavours


    Args:
        filters (Optional[FlavourFilter], optional): No description.
        pagination (Optional[OffsetPaginationInput], optional): No description.
        order (Optional[FlavourOrder], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListFlavour]
    """
    return execute(
        ListFlavoursQuery,
        {"filters": filters, "pagination": pagination, "order": order},
        rath=rath,
    ).flavours


async def aget_flavour(id: ID, rath: Optional[KabinetRath] = None) -> Flavour:
    """GetFlavour

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Flavour
    """
    return (await aexecute(GetFlavourQuery, {"id": id}, rath=rath)).flavour


def get_flavour(id: ID, rath: Optional[KabinetRath] = None) -> Flavour:
    """GetFlavour

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Flavour
    """
    return execute(GetFlavourQuery, {"id": id}, rath=rath).flavour


async def asearch_flavours(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchFlavoursQueryOptions, ...]:
    """SearchFlavours


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchFlavoursQueryFlavours]
    """
    return (
        await aexecute(
            SearchFlavoursQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_flavours(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchFlavoursQueryOptions, ...]:
    """SearchFlavours


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchFlavoursQueryFlavours]
    """
    return execute(
        SearchFlavoursQuery, {"search": search, "values": values}, rath=rath
    ).options


async def alist_pod(rath: Optional[KabinetRath] = None) -> Tuple[ListPod, ...]:
    """ListPod


    Args:
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListPod]
    """
    return (await aexecute(ListPodQuery, {}, rath=rath)).pods


def list_pod(rath: Optional[KabinetRath] = None) -> Tuple[ListPod, ...]:
    """ListPod


    Args:
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListPod]
    """
    return execute(ListPodQuery, {}, rath=rath).pods


async def aget_pod(id: ID, rath: Optional[KabinetRath] = None) -> Pod:
    """GetPod

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Pod
    """
    return (await aexecute(GetPodQuery, {"id": id}, rath=rath)).pod


def get_pod(id: ID, rath: Optional[KabinetRath] = None) -> Pod:
    """GetPod

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Pod
    """
    return execute(GetPodQuery, {"id": id}, rath=rath).pod


async def amy_pod_at(
    instance_id: ID, local_id: ID, rath: Optional[KabinetRath] = None
) -> Pod:
    """MyPodAt

    Let a backend discover its own pods

    Args:
        instance_id (ID): No description
        local_id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Pod
    """
    return (
        await aexecute(
            MyPodAtQuery, {"instanceId": instance_id, "localId": local_id}, rath=rath
        )
    ).my_pod_at


def my_pod_at(instance_id: ID, local_id: ID, rath: Optional[KabinetRath] = None) -> Pod:
    """MyPodAt

    Let a backend discover its own pods

    Args:
        instance_id (ID): No description
        local_id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Pod
    """
    return execute(
        MyPodAtQuery, {"instanceId": instance_id, "localId": local_id}, rath=rath
    ).my_pod_at


async def asearch_pods(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    backend: Optional[ID] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchPodsQueryOptions, ...]:
    """SearchPods


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        backend (Optional[ID], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchPodsQueryPods]
    """
    return (
        await aexecute(
            SearchPodsQuery,
            {"search": search, "values": values, "backend": backend},
            rath=rath,
        )
    ).options


def search_pods(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    backend: Optional[ID] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchPodsQueryOptions, ...]:
    """SearchPods


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        backend (Optional[ID], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchPodsQueryPods]
    """
    return execute(
        SearchPodsQuery,
        {"search": search, "values": values, "backend": backend},
        rath=rath,
    ).options


async def alist_releases(rath: Optional[KabinetRath] = None) -> Tuple[ListRelease, ...]:
    """ListReleases


    Args:
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListRelease]
    """
    return (await aexecute(ListReleasesQuery, {}, rath=rath)).releases


def list_releases(rath: Optional[KabinetRath] = None) -> Tuple[ListRelease, ...]:
    """ListReleases


    Args:
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListRelease]
    """
    return execute(ListReleasesQuery, {}, rath=rath).releases


async def aget_release(id: ID, rath: Optional[KabinetRath] = None) -> Release:
    """GetRelease

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Release
    """
    return (await aexecute(GetReleaseQuery, {"id": id}, rath=rath)).release


def get_release(id: ID, rath: Optional[KabinetRath] = None) -> Release:
    """GetRelease

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Release
    """
    return execute(GetReleaseQuery, {"id": id}, rath=rath).release


async def asearch_releases(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchReleasesQueryOptions, ...]:
    """SearchReleases


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchReleasesQueryReleases]
    """
    return (
        await aexecute(
            SearchReleasesQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_releases(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchReleasesQueryOptions, ...]:
    """SearchReleases


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchReleasesQueryReleases]
    """
    return execute(
        SearchReleasesQuery, {"search": search, "values": values}, rath=rath
    ).options


async def alist_resources(
    filters: Optional[ResourceFilter] = None,
    pagination: Optional[OffsetPaginationInput] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[ListResource, ...]:
    """ListResources


    Args:
        filters (Optional[ResourceFilter], optional): No description.
        pagination (Optional[OffsetPaginationInput], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListResource]
    """
    return (
        await aexecute(
            ListResourcesQuery,
            {"filters": filters, "pagination": pagination},
            rath=rath,
        )
    ).resources


def list_resources(
    filters: Optional[ResourceFilter] = None,
    pagination: Optional[OffsetPaginationInput] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[ListResource, ...]:
    """ListResources


    Args:
        filters (Optional[ResourceFilter], optional): No description.
        pagination (Optional[OffsetPaginationInput], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[ListResource]
    """
    return execute(
        ListResourcesQuery, {"filters": filters, "pagination": pagination}, rath=rath
    ).resources


async def age_resource(id: ID, rath: Optional[KabinetRath] = None) -> Resource:
    """GeResource

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Resource
    """
    return (await aexecute(GeResourceQuery, {"id": id}, rath=rath)).resource


def ge_resource(id: ID, rath: Optional[KabinetRath] = None) -> Resource:
    """GeResource

    Return all dask clusters

    Args:
        id (ID): No description
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        Resource
    """
    return execute(GeResourceQuery, {"id": id}, rath=rath).resource


async def asearch_resources(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchResourcesQueryOptions, ...]:
    """SearchResources


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchResourcesQueryResources]
    """
    return (
        await aexecute(
            SearchResourcesQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_resources(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[KabinetRath] = None,
) -> Tuple[SearchResourcesQueryOptions, ...]:
    """SearchResources


    Args:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (kabinet.rath.KabinetRath, optional): The client we want to use (defaults to the currently active client)

    Returns:
        List[SearchResourcesQueryResources]
    """
    return execute(
        SearchResourcesQuery, {"search": search, "values": values}, rath=rath
    ).options


ActionDependencyInput.model_rebuild()
AppImageInput.model_rebuild()
AssignWidgetInput.model_rebuild()
BackendFilter.model_rebuild()
DeclareResourceInput.model_rebuild()
DefinitionInput.model_rebuild()
FlavourFilter.model_rebuild()
InspectionInput.model_rebuild()
PortInput.model_rebuild()
PortMatchInput.model_rebuild()
ResourceFilter.model_rebuild()
