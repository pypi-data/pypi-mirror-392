"""
ServerCreator for generating MCP server packages.
"""

import logging
from datetime import datetime
from pathlib import Path
from typing import Optional

from god_mcp.config_manager import ConfigManager
from god_mcp.models import ServerSpec, ToolSpec

logger = logging.getLogger("godMCP.ServerCreator")


class ServerCreator:
    """
    Creates new MCP server packages with proper structure and logging.
    """
    
    def __init__(self, base_output_dir: Optional[Path] = None, config_manager: Optional[ConfigManager] = None):
        """
        Initialize ServerCreator.
        
        Args:
            base_output_dir: Base directory for generated servers.
                           Defaults to .mcp-servers in current directory.
            config_manager: ConfigManager instance for registering servers.
                          If None, a new instance will be created.
        """
        if base_output_dir is None:
            base_output_dir = Path.cwd() / ".mcp-servers"
        
        self.base_output_dir = Path(base_output_dir)
        self.config_manager = config_manager or ConfigManager()
        logger.info(f"ServerCreator initialized with output dir: {self.base_output_dir}")
    
    def generate_package_structure(self, spec: ServerSpec) -> Path:
        """
        Generate the directory structure for a new MCP server package.
        
        Creates:
        - server_name/
          - src/
            - package_name/
              - __init__.py
              - server.py
              - logging_config.py
          - pyproject.toml
          - README.md
          - server_name_debug.log (empty, will be populated at runtime)
        
        Args:
            spec: Server specification
        
        Returns:
            Path to the created package directory
        """
        package_name = spec.get_package_name()
        server_dir = self.base_output_dir / spec.name
        
        logger.info(f"Generating package structure for '{spec.name}' at {server_dir}")
        
        # Create main directories
        server_dir.mkdir(parents=True, exist_ok=True)
        src_dir = server_dir / "src"
        src_dir.mkdir(exist_ok=True)
        
        package_dir = src_dir / package_name
        package_dir.mkdir(exist_ok=True)
        
        # Create __init__.py files
        self._create_init_file(package_dir, spec)
        
        logger.info(f"Package structure created at {server_dir}")
        return server_dir
    
    def _create_init_file(self, package_dir: Path, spec: ServerSpec):
        """
        Create __init__.py file for the package.
        
        Args:
            package_dir: Path to the package directory
            spec: Server specification
        """
        init_content = f'''"""
{spec.description}

Generated by godMCP on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
"""

__version__ = "0.1.0"
'''
        
        init_file = package_dir / "__init__.py"
        init_file.write_text(init_content)
        logger.debug(f"Created {init_file}")

    
    def generate_pyproject_toml(self, spec: ServerSpec, server_dir: Path) -> Path:
        """
        Generate pyproject.toml file for the server package.
        
        Args:
            spec: Server specification
            server_dir: Path to the server directory
        
        Returns:
            Path to the created pyproject.toml file
        """
        package_name = spec.get_package_name()
        dependencies = spec.get_all_dependencies()
        
        # Format dependencies for TOML
        deps_lines = [f'    "{dep}",' for dep in dependencies]
        deps_str = "\n".join(deps_lines)
        
        content = f'''[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "{spec.name}"
version = "0.1.0"
description = "{spec.description}"
readme = "README.md"
requires-python = ">=3.10"
license = {{ text = "MIT" }}
authors = [
    {{ name = "godMCP", email = "generated@godmcp.local" }}
]
keywords = ["mcp", "model-context-protocol", "generated"]

dependencies = [
{deps_str}
]

[project.scripts]
{spec.name} = "{package_name}.server:main"

[tool.hatch.build.targets.wheel]
packages = ["src/{package_name}"]
'''
        
        pyproject_file = server_dir / "pyproject.toml"
        pyproject_file.write_text(content)
        logger.info(f"Created pyproject.toml at {pyproject_file}")
        
        return pyproject_file

    
    def generate_tool_code(self, tool: ToolSpec) -> str:
        """
        Generate code for a single tool function.
        
        Args:
            tool: Tool specification
        
        Returns:
            Python code for the tool function
        """
        # Generate parameter hints from JSON schema
        params_schema = tool.parameters
        params_str = ""
        
        if params_schema.get("properties"):
            param_list = []
            required = params_schema.get("required", [])
            
            for param_name, param_info in params_schema["properties"].items():
                param_type = param_info.get("type", "Any")
                # Map JSON schema types to Python types
                type_map = {
                    "string": "str",
                    "integer": "int",
                    "number": "float",
                    "boolean": "bool",
                    "array": "list",
                    "object": "dict"
                }
                python_type = type_map.get(param_type, "Any")
                
                if param_name in required:
                    param_list.append(f"{param_name}: {python_type}")
                else:
                    param_list.append(f"{param_name}: Optional[{python_type}] = None")
            
            params_str = ", ".join(param_list) if param_list else ""
        
        # Generate docstring
        docstring = f'''    """
    {tool.description}
    '''
        
        if params_schema.get("properties"):
            docstring += "\n    Args:\n"
            for param_name, param_info in params_schema["properties"].items():
                param_desc = param_info.get("description", "")
                docstring += f"        {param_name}: {param_desc}\n"
        
        docstring += f'''    
    Returns:
        {tool.return_type}: Tool execution result
    """'''
        
        # Generate implementation - check if implementation_hint contains actual code
        if tool.implementation_hint and (
            "return" in tool.implementation_hint or 
            "=" in tool.implementation_hint or
            len(tool.implementation_hint.split('\n')) > 1
        ):
            # Looks like actual implementation code - indent each line properly
            impl_lines = tool.implementation_hint.strip().split('\n')
            # Add 4 spaces of indentation to each line (function body level)
            indented_lines = []
            for line in impl_lines:
                if line.strip():  # Only indent non-empty lines
                    indented_lines.append('    ' + line)
                else:
                    indented_lines.append(line)  # Keep empty lines as-is
            indented_impl = '\n'.join(indented_lines)
            implementation = f'''    logger.info(f"[tool:{tool.name}] Executing")
{indented_impl}'''
        elif tool.implementation_hint:
            # Just a hint comment
            implementation = f'''    # Implementation hint: {tool.implementation_hint}
    logger.info(f"[tool:{tool.name}] Executing")
    
    # TODO: Implement tool logic here
    result = {{
        "status": "not_implemented",
        "message": "This tool needs implementation",
        "tool": "{tool.name}"
    }}
    
    return result'''
        else:
            # No hint at all
            implementation = f'''    logger.info(f"[tool:{tool.name}] Executing")
    
    # TODO: Implement tool logic here
    result = {{
        "status": "success",
        "message": "Tool executed successfully",
        "tool": "{tool.name}"
    }}
    
    return result'''
        
        tool_code = f'''

@mcp.tool()
@logged_tool
def {tool.name}({params_str}) -> {tool.return_type}:
{docstring}
{implementation}
'''
        
        return tool_code
    
    def generate_server_code(self, spec: ServerSpec, server_dir: Path) -> Path:
        """
        Generate server.py file with FastMCP initialization and tool implementations.
        
        Args:
            spec: Server specification
            server_dir: Path to the server directory
        
        Returns:
            Path to the created server.py file
        """
        package_name = spec.get_package_name()
        
        # Generate all tool functions
        tools_code = ""
        for tool in spec.tools:
            tools_code += self.generate_tool_code(tool)
        
        # Generate imports based on tool parameters
        imports = "from typing import Optional, Any"
        
        content = f'''"""
{spec.description}

Generated by godMCP on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
"""

import logging
from pathlib import Path
from functools import wraps
{imports}

from fastmcp import FastMCP

# Configure logging
log_file = Path(__file__).parent.parent.parent / "{spec.name}_debug.log"
log_file.parent.mkdir(parents=True, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s] [%(levelname)s] [%(name)s] %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler(),
    ],
)

logger = logging.getLogger("{spec.name}")

# Initialize FastMCP server
mcp = FastMCP("{spec.name}")


def logged_tool(func):
    """Decorator to add logging to tool functions."""
    @wraps(func)
    def wrapper(*args, **kwargs):
        logger.info(f"[tool:{{func.__name__}}] Executing with params: {{kwargs}}")
        try:
            result = func(*args, **kwargs)
            logger.info(f"[tool:{{func.__name__}}] Success")
            return result
        except Exception as e:
            logger.error(f"[tool:{{func.__name__}}] Failed: {{str(e)}}", exc_info=True)
            raise
    return wrapper

{tools_code}

def main():
    """Main entry point for the {spec.name} server."""
    logger.info("Starting {spec.name} server")
    mcp.run()


if __name__ == "__main__":
    main()
'''
        
        package_dir = server_dir / "src" / package_name
        server_file = package_dir / "server.py"
        server_file.write_text(content)
        logger.info(f"Created server.py at {server_file}")
        
        return server_file

    
    def generate_readme(self, spec: ServerSpec, server_dir: Path) -> Path:
        """
        Generate README.md file for the server package.
        
        Args:
            spec: Server specification
            server_dir: Path to the server directory
        
        Returns:
            Path to the created README.md file
        """
        package_name = spec.get_package_name()
        
        # Generate tool descriptions
        tool_descriptions = ""
        for tool in spec.tools:
            tool_descriptions += f"\n### {tool.name}\n\n"
            tool_descriptions += f"{tool.description}\n\n"
            
            if tool.parameters.get("properties"):
                tool_descriptions += "**Parameters:**\n"
                for param_name, param_info in tool.parameters["properties"].items():
                    param_type = param_info.get("type", "any")
                    param_desc = param_info.get("description", "")
                    required = " (required)" if param_name in tool.parameters.get("required", []) else ""
                    tool_descriptions += f"- `{param_name}` ({param_type}){required}: {param_desc}\n"
                tool_descriptions += "\n"
            
            tool_descriptions += f"**Returns:** {tool.return_type}\n"
        
        content = f'''# {spec.name}

{spec.description}

**Generated by godMCP** on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Installation

Install using UVX (recommended):

```bash
uvx {spec.name}
```

Or install with pip:

```bash
pip install {spec.name}
```

## Configuration

Add to your MCP configuration file (`.kiro/settings/mcp.json` or `~/.kiro/settings/mcp.json`):

```json
{{
  "mcpServers": {{
    "{spec.name}": {{
      "command": "uvx",
      "args": ["{spec.name}"],
      "disabled": false
    }}
  }}
}}
```

## Available Tools

{tool_descriptions}

## Debug Logs

This server writes debug logs to: `{spec.name}_debug.log`

You can access these logs using godMCP's `get_debug_logs` tool:

```python
get_debug_logs(server_name="{spec.name}")
```

## Troubleshooting

If you encounter issues:

1. Check the debug logs: `{spec.name}_debug.log`
2. Use godMCP's diagnostic tools:
   - `diagnose_server(server_name="{spec.name}")`
   - `verify_mcp_server(server_name="{spec.name}")`

## Development

This server was generated by godMCP. To modify:

1. Edit the source files in `src/{package_name}/`
2. The main server logic is in `src/{package_name}/server.py`
3. Rebuild and reinstall after changes

## License

MIT License
'''
        
        readme_file = server_dir / "README.md"
        readme_file.write_text(content)
        logger.info(f"Created README.md at {readme_file}")
        
        return readme_file

    
    def create_server(self, spec: ServerSpec, register: bool = True, config_level: str = "workspace", target_config_path: Optional[str] = None) -> dict:
        """
        Create a complete MCP server package from specification.
        
        This is the main method that orchestrates the entire server creation process:
        1. Generate package structure
        2. Create pyproject.toml
        3. Generate server code with logging
        4. Create README documentation
        5. Register in mcp.json (optional)
        
        Args:
            spec: Server specification
            register: Whether to register the server in mcp.json
            config_level: Configuration level for registration ("workspace" or "user")
        
        Returns:
            dict: Information about the created server package
        """
        logger.info(f"Creating MCP server: {spec.name}")
        
        try:
            # Generate package structure
            server_dir = self.generate_package_structure(spec)
            
            # Generate pyproject.toml
            pyproject_file = self.generate_pyproject_toml(spec, server_dir)
            
            # Generate server code
            server_file = self.generate_server_code(spec, server_dir)
            
            # Generate README
            readme_file = self.generate_readme(spec, server_dir)
            
            log_file = server_dir / f"{spec.name}_debug.log"
            
            result = {
                "success": True,
                "serverName": spec.name,
                "packageName": spec.get_package_name(),
                "serverDir": str(server_dir),
                "files": {
                    "pyproject": str(pyproject_file),
                    "server": str(server_file),
                    "readme": str(readme_file)
                },
                "toolCount": len(spec.tools),
                "tools": [tool.name for tool in spec.tools],
                "logFile": str(log_file)
            }
            
            # Register server in mcp.json if requested
            if register:
                registration_result = self.register_server(
                    spec.name,
                    server_dir,
                    log_file,
                    level=config_level,
                    target_config_path=target_config_path
                )
                result["registration"] = registration_result
            
            logger.info(f"Successfully created MCP server: {spec.name}")
            return result
            
        except Exception as e:
            logger.error(f"Failed to create MCP server: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e),
                "serverName": spec.name
            }

    
    def register_server(
        self,
        server_name: str,
        server_dir: Path,
        log_file: Path,
        level: str = "workspace",
        target_config_path: Optional[str] = None
    ) -> dict:
        """
        Register the created server in mcp.json configuration.
        
        Args:
            server_name: Name of the server
            server_dir: Path to the server directory
            log_file: Path to the server's log file
            level: Configuration level ("workspace" or "user")
            target_config_path: Explicit path to mcp.json (overrides level)
        
        Returns:
            dict: Registration result
        """
        logger.info(f"Registering server '{server_name}'")
        
        try:
            package_name = server_name.replace("-", "_")
            server_config = {
                "command": "uv",
                "args": [
                    "run",
                    "--directory",
                    str(server_dir),
                    "python",
                    "-m",
                    f"{package_name}.server"
                ],
                "disabled": False,
                "metadata": {
                    "createdBy": "godMCP",
                    "createdAt": datetime.now().isoformat(),
                    "serverDir": str(server_dir),
                    "logFile": str(log_file)
                }
            }
            
            # If explicit path provided, use it directly
            if target_config_path:
                import json
                target_path = Path(target_config_path).expanduser().resolve()
                
                if not target_path.exists():
                    target_path.parent.mkdir(parents=True, exist_ok=True)
                    config = {"mcpServers": {}}
                else:
                    with open(target_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                
                if "mcpServers" not in config:
                    config["mcpServers"] = {}
                
                config["mcpServers"][server_name] = server_config
                
                with open(target_path, 'w', encoding='utf-8') as f:
                    json.dump(config, f, indent=2)
                
                logger.info(f"Registered server '{server_name}' at {target_path}")
                return {
                    "success": True,
                    "message": f"Server '{server_name}' registered at {target_path}",
                    "config": server_config,
                    "configPath": str(target_path)
                }
            else:
                # Use config_manager with level
                self.config_manager.add_server(server_name, server_config, level)
                
                logger.info(f"Successfully registered server '{server_name}' in {level} configuration")
                return {
                    "success": True,
                    "message": f"Server '{server_name}' registered in {level} configuration",
                    "config": server_config
                }
            
        except Exception as e:
            logger.error(f"Failed to register server: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e),
                "message": f"Failed to register server: {e}"
            }
