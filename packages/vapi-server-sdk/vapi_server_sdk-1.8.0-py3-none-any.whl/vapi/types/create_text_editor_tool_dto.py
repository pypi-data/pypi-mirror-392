# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, update_forward_refs
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .create_text_editor_tool_dto_messages_item import CreateTextEditorToolDtoMessagesItem
from .create_text_editor_tool_dto_name import CreateTextEditorToolDtoName
from .create_text_editor_tool_dto_sub_type import CreateTextEditorToolDtoSubType
from .server import Server
from .tool_rejection_plan import ToolRejectionPlan


class CreateTextEditorToolDto(UncheckedBaseModel):
    messages: typing.Optional[typing.List[CreateTextEditorToolDtoMessagesItem]] = pydantic.Field(default=None)
    """
    These are the messages that will be spoken to the user as the tool is running.
    
    For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
    """

    type: typing.Literal["textEditor"] = "textEditor"
    sub_type: typing_extensions.Annotated[CreateTextEditorToolDtoSubType, FieldMetadata(alias="subType")] = (
        pydantic.Field()
    )
    """
    The sub type of tool.
    """

    server: typing.Optional[Server] = pydantic.Field(default=None)
    """
    
      This is the server where a `tool-calls` webhook will be sent.
    
      Notes:
      - Webhook is sent to this server when a tool call is made.
      - Webhook contains the call, assistant, and phone number objects.
      - Webhook contains the variables set on the assistant.
      - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.
      - Webhook expects a response with tool call result.
    """

    name: CreateTextEditorToolDtoName = pydantic.Field()
    """
    The name of the tool, fixed to 'str_replace_editor'
    """

    rejection_plan: typing_extensions.Annotated[
        typing.Optional[ToolRejectionPlan], FieldMetadata(alias="rejectionPlan")
    ] = pydantic.Field(default=None)
    """
    This is the plan to reject a tool call based on the conversation state.
    
    // Example 1: Reject endCall if user didn't say goodbye
    ```json
    {
      conditions: [{
        type: 'regex',
        regex: '(?i)\\\\b(bye|goodbye|farewell|see you later|take care)\\\\b',
        target: { position: -1, role: 'user' },
        negate: true  // Reject if pattern does NOT match
      }]
    }
    ```
    
    // Example 2: Reject transfer if user is actually asking a question
    ```json
    {
      conditions: [{
        type: 'regex',
        regex: '\\\\?',
        target: { position: -1, role: 'user' }
      }]
    }
    ```
    
    // Example 3: Reject transfer if user didn't mention transfer recently
    ```json
    {
      conditions: [{
        type: 'liquid',
        liquid: `{% assign recentMessages = messages | last: 5 %}
    {% assign userMessages = recentMessages | where: 'role', 'user' %}
    {% assign mentioned = false %}
    {% for msg in userMessages %}
      {% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
        {% assign mentioned = true %}
        {% break %}
      {% endif %}
    {% endfor %}
    {% if mentioned %}
      false
    {% else %}
      true
    {% endif %}`
      }]
    }
    ```
    
    // Example 4: Reject endCall if the bot is looping and trying to exit
    ```json
    {
      conditions: [{
        type: 'liquid',
        liquid: `{% assign recentMessages = messages | last: 6 %}
    {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
    {% if userMessages.size < 3 %}
      false
    {% else %}
      {% assign msg1 = userMessages[0].content | downcase %}
      {% assign msg2 = userMessages[1].content | downcase %}
      {% assign msg3 = userMessages[2].content | downcase %}
      {% comment %} Check for repetitive messages {% endcomment %}
      {% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
        true
      {% comment %} Check for common loop phrases {% endcomment %}
      {% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
        true
      {% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
        true
      {% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
        true
      {% else %}
        false
      {% endif %}
    {% endif %}`
      }]
    }
    ```
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


from .group_condition import GroupCondition  # noqa: E402, F401, I001

update_forward_refs(CreateTextEditorToolDto)
