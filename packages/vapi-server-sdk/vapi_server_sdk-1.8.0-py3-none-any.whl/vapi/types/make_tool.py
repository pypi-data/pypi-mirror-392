# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import datetime as dt
import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, update_forward_refs
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .make_tool_messages_item import MakeToolMessagesItem
from .make_tool_metadata import MakeToolMetadata
from .make_tool_type import MakeToolType
from .tool_rejection_plan import ToolRejectionPlan


class MakeTool(UncheckedBaseModel):
    messages: typing.Optional[typing.List[MakeToolMessagesItem]] = pydantic.Field(default=None)
    """
    These are the messages that will be spoken to the user as the tool is running.
    
    For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
    """

    type: MakeToolType = pydantic.Field()
    """
    The type of tool. "make" for Make tool.
    """

    id: str = pydantic.Field()
    """
    This is the unique identifier for the tool.
    """

    org_id: typing_extensions.Annotated[str, FieldMetadata(alias="orgId")] = pydantic.Field()
    """
    This is the unique identifier for the organization that this tool belongs to.
    """

    created_at: typing_extensions.Annotated[dt.datetime, FieldMetadata(alias="createdAt")] = pydantic.Field()
    """
    This is the ISO 8601 date-time string of when the tool was created.
    """

    updated_at: typing_extensions.Annotated[dt.datetime, FieldMetadata(alias="updatedAt")] = pydantic.Field()
    """
    This is the ISO 8601 date-time string of when the tool was last updated.
    """

    rejection_plan: typing_extensions.Annotated[
        typing.Optional[ToolRejectionPlan], FieldMetadata(alias="rejectionPlan")
    ] = pydantic.Field(default=None)
    """
    This is the plan to reject a tool call based on the conversation state.
    
    // Example 1: Reject endCall if user didn't say goodbye
    ```json
    {
      conditions: [{
        type: 'regex',
        regex: '(?i)\\\\b(bye|goodbye|farewell|see you later|take care)\\\\b',
        target: { position: -1, role: 'user' },
        negate: true  // Reject if pattern does NOT match
      }]
    }
    ```
    
    // Example 2: Reject transfer if user is actually asking a question
    ```json
    {
      conditions: [{
        type: 'regex',
        regex: '\\\\?',
        target: { position: -1, role: 'user' }
      }]
    }
    ```
    
    // Example 3: Reject transfer if user didn't mention transfer recently
    ```json
    {
      conditions: [{
        type: 'liquid',
        liquid: `{% assign recentMessages = messages | last: 5 %}
    {% assign userMessages = recentMessages | where: 'role', 'user' %}
    {% assign mentioned = false %}
    {% for msg in userMessages %}
      {% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
        {% assign mentioned = true %}
        {% break %}
      {% endif %}
    {% endfor %}
    {% if mentioned %}
      false
    {% else %}
      true
    {% endif %}`
      }]
    }
    ```
    
    // Example 4: Reject endCall if the bot is looping and trying to exit
    ```json
    {
      conditions: [{
        type: 'liquid',
        liquid: `{% assign recentMessages = messages | last: 6 %}
    {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
    {% if userMessages.size < 3 %}
      false
    {% else %}
      {% assign msg1 = userMessages[0].content | downcase %}
      {% assign msg2 = userMessages[1].content | downcase %}
      {% assign msg3 = userMessages[2].content | downcase %}
      {% comment %} Check for repetitive messages {% endcomment %}
      {% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
        true
      {% comment %} Check for common loop phrases {% endcomment %}
      {% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
        true
      {% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
        true
      {% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
        true
      {% else %}
        false
      {% endif %}
    {% endif %}`
      }]
    }
    ```
    """

    metadata: MakeToolMetadata

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


from .group_condition import GroupCondition  # noqa: E402, F401, I001

update_forward_refs(MakeTool)
