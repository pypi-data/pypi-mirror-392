# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .assistant_message_evaluation_continue_plan import AssistantMessageEvaluationContinuePlan
from .chat_eval_assistant_message_evaluation_judge_plan import ChatEvalAssistantMessageEvaluationJudgePlan
from .chat_eval_assistant_message_evaluation_role import ChatEvalAssistantMessageEvaluationRole


class ChatEvalAssistantMessageEvaluation(UncheckedBaseModel):
    role: ChatEvalAssistantMessageEvaluationRole = pydantic.Field()
    """
    This is the role of the message author.
    For an assistant message evaluation, the role is always 'assistant'
    @default 'assistant'
    """

    judge_plan: typing_extensions.Annotated[
        ChatEvalAssistantMessageEvaluationJudgePlan, FieldMetadata(alias="judgePlan")
    ] = pydantic.Field()
    """
    This is the judge plan that instructs how to evaluate the assistant message.
    The assistant message can be evaluated against fixed content (exact match or RegEx) or with an LLM-as-judge by defining the evaluation criteria in a prompt.
    """

    continue_plan: typing_extensions.Annotated[
        typing.Optional[AssistantMessageEvaluationContinuePlan], FieldMetadata(alias="continuePlan")
    ] = pydantic.Field(default=None)
    """
    This is the plan for how the overall evaluation will proceed after the assistant message is evaluated.
    This lets you configure whether to stop the evaluation if this message fails, and whether to override any content for future turns
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
