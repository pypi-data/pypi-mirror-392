# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .assistant_message_judge_plan_regex_type import AssistantMessageJudgePlanRegexType
from .chat_eval_assistant_message_mock_tool_call import ChatEvalAssistantMessageMockToolCall


class AssistantMessageJudgePlanRegex(UncheckedBaseModel):
    type: AssistantMessageJudgePlanRegexType = pydantic.Field()
    """
    This is the type of the judge plan.
    Use 'regex' for a regex match on the content and tool calls - without using LLM-as-a-judge.
    @default 'regex'
    """

    content: str = pydantic.Field()
    """
    This is what that will be used to evaluate the model's message content.
    The content will be evaluated against the regex pattern provided in the Judge Plan content field.
    Evaluation is considered successful if the regex pattern matches any part of the assistant message content.
    """

    tool_calls: typing_extensions.Annotated[
        typing.Optional[typing.List[ChatEvalAssistantMessageMockToolCall]], FieldMetadata(alias="toolCalls")
    ] = pydantic.Field(default=None)
    """
    This is the tool calls that will be used to evaluate the model's message content.
    The tool name must be a valid tool that the assistant is allowed to call.
    The values to the arguments for the tool call should be a Regular Expression.
    Evaluation is considered successful if the regex pattern matches any part of each tool call argument.
    
    For the Query tool, the arguments for the tool call are in the format - {knowledgeBaseNames: ['kb_name', 'kb_name_2']}
    
    For the DTMF tool, the arguments for the tool call are in the format - {dtmf: "1234*"}
    
    For the Handoff tool, the arguments for the tool call are in the format - {destination: "assistant_id"}
    
    For the Transfer Call tool, the arguments for the tool call are in the format - {destination: "phone_number_or_assistant_id"}
    
    For all other tools, they are called without arguments or with user-defined arguments
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
