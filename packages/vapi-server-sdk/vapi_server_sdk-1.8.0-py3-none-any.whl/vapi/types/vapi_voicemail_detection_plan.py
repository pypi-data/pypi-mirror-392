# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .vapi_voicemail_detection_plan_provider import VapiVoicemailDetectionPlanProvider
from .vapi_voicemail_detection_plan_type import VapiVoicemailDetectionPlanType
from .voicemail_detection_backoff_plan import VoicemailDetectionBackoffPlan


class VapiVoicemailDetectionPlan(UncheckedBaseModel):
    beep_max_await_seconds: typing_extensions.Annotated[
        typing.Optional[float], FieldMetadata(alias="beepMaxAwaitSeconds")
    ] = pydantic.Field(default=None)
    """
    This is the maximum duration from the start of the call that we will wait for a voicemail beep, before speaking our message
    
    - If we detect a voicemail beep before this, we will speak the message at that point.
    
    - Setting too low a value means that the bot will start speaking its voicemail message too early. If it does so before the actual beep, it will get cut off. You should definitely tune this to your use case.
    
    @default 30
    @min 0
    @max 60
    """

    provider: VapiVoicemailDetectionPlanProvider = pydantic.Field()
    """
    This is the provider to use for voicemail detection.
    """

    backoff_plan: typing_extensions.Annotated[
        typing.Optional[VoicemailDetectionBackoffPlan], FieldMetadata(alias="backoffPlan")
    ] = pydantic.Field(default=None)
    """
    This is the backoff plan for the voicemail detection.
    """

    type: typing.Optional[VapiVoicemailDetectionPlanType] = pydantic.Field(default=None)
    """
    This is the detection type to use for voicemail detection.
    - 'audio': Uses native audio models (default)
    - 'transcript': Uses ASR/transcript-based detection
    @default 'audio' (audio detection)
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
