# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..types.insight_paginated_response import InsightPaginatedResponse
from ..types.insight_run_format_plan import InsightRunFormatPlan
from ..types.insight_run_response import InsightRunResponse
from ..types.insight_time_range_with_step import InsightTimeRangeWithStep
from .types.insight_controller_create_request import InsightControllerCreateRequest
from .types.insight_controller_create_response import InsightControllerCreateResponse
from .types.insight_controller_find_all_request_sort_order import InsightControllerFindAllRequestSortOrder
from .types.insight_controller_find_one_response import InsightControllerFindOneResponse
from .types.insight_controller_preview_request import InsightControllerPreviewRequest
from .types.insight_controller_remove_response import InsightControllerRemoveResponse
from .types.insight_controller_update_request_body import InsightControllerUpdateRequestBody
from .types.insight_controller_update_response import InsightControllerUpdateResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawInsightClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def insight_controller_find_all(
        self,
        *,
        id: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[InsightControllerFindAllRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InsightPaginatedResponse]:
        """
        Parameters
        ----------
        id : typing.Optional[str]

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[InsightControllerFindAllRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InsightPaginatedResponse]

        """
        _response = self._client_wrapper.httpx_client.request(
            "reporting/insight",
            method="GET",
            params={
                "id": id,
                "page": page,
                "sortOrder": sort_order,
                "limit": limit,
                "createdAtGt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "createdAtLt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "createdAtGe": serialize_datetime(created_at_ge) if created_at_ge is not None else None,
                "createdAtLe": serialize_datetime(created_at_le) if created_at_le is not None else None,
                "updatedAtGt": serialize_datetime(updated_at_gt) if updated_at_gt is not None else None,
                "updatedAtLt": serialize_datetime(updated_at_lt) if updated_at_lt is not None else None,
                "updatedAtGe": serialize_datetime(updated_at_ge) if updated_at_ge is not None else None,
                "updatedAtLe": serialize_datetime(updated_at_le) if updated_at_le is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightPaginatedResponse,
                    construct_type(
                        type_=InsightPaginatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def insight_controller_create(
        self, *, request: InsightControllerCreateRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[InsightControllerCreateResponse]:
        """
        Parameters
        ----------
        request : InsightControllerCreateRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InsightControllerCreateResponse]

        """
        _response = self._client_wrapper.httpx_client.request(
            "reporting/insight",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=InsightControllerCreateRequest, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightControllerCreateResponse,
                    construct_type(
                        type_=InsightControllerCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def insight_controller_find_one(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[InsightControllerFindOneResponse]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InsightControllerFindOneResponse]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"reporting/insight/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightControllerFindOneResponse,
                    construct_type(
                        type_=InsightControllerFindOneResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def insight_controller_remove(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[InsightControllerRemoveResponse]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InsightControllerRemoveResponse]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"reporting/insight/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightControllerRemoveResponse,
                    construct_type(
                        type_=InsightControllerRemoveResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def insight_controller_update(
        self,
        id: str,
        *,
        request: InsightControllerUpdateRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InsightControllerUpdateResponse]:
        """
        Parameters
        ----------
        id : str

        request : InsightControllerUpdateRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InsightControllerUpdateResponse]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"reporting/insight/{jsonable_encoder(id)}",
            method="PATCH",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=InsightControllerUpdateRequestBody, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightControllerUpdateResponse,
                    construct_type(
                        type_=InsightControllerUpdateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def insight_controller_run(
        self,
        id: str,
        *,
        format_plan: typing.Optional[InsightRunFormatPlan] = OMIT,
        time_range_override: typing.Optional[InsightTimeRangeWithStep] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InsightRunResponse]:
        """
        Parameters
        ----------
        id : str

        format_plan : typing.Optional[InsightRunFormatPlan]

        time_range_override : typing.Optional[InsightTimeRangeWithStep]
            This is the optional time range override for the insight.
            If provided, overrides every field in the insight's timeRange.
            If this is provided with missing fields, defaults will be used, not the insight's timeRange.
            start default - "-7d"
            end default - "now"
            step default - "day"
            For Pie and Text Insights, step will be ignored even if provided.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InsightRunResponse]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"reporting/insight/{jsonable_encoder(id)}/run",
            method="POST",
            json={
                "formatPlan": convert_and_respect_annotation_metadata(
                    object_=format_plan, annotation=InsightRunFormatPlan, direction="write"
                ),
                "timeRangeOverride": convert_and_respect_annotation_metadata(
                    object_=time_range_override, annotation=InsightTimeRangeWithStep, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightRunResponse,
                    construct_type(
                        type_=InsightRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def insight_controller_preview(
        self, *, request: InsightControllerPreviewRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[InsightRunResponse]:
        """
        Parameters
        ----------
        request : InsightControllerPreviewRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InsightRunResponse]

        """
        _response = self._client_wrapper.httpx_client.request(
            "reporting/insight/preview",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=InsightControllerPreviewRequest, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightRunResponse,
                    construct_type(
                        type_=InsightRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawInsightClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def insight_controller_find_all(
        self,
        *,
        id: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[InsightControllerFindAllRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InsightPaginatedResponse]:
        """
        Parameters
        ----------
        id : typing.Optional[str]

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[InsightControllerFindAllRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InsightPaginatedResponse]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "reporting/insight",
            method="GET",
            params={
                "id": id,
                "page": page,
                "sortOrder": sort_order,
                "limit": limit,
                "createdAtGt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "createdAtLt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "createdAtGe": serialize_datetime(created_at_ge) if created_at_ge is not None else None,
                "createdAtLe": serialize_datetime(created_at_le) if created_at_le is not None else None,
                "updatedAtGt": serialize_datetime(updated_at_gt) if updated_at_gt is not None else None,
                "updatedAtLt": serialize_datetime(updated_at_lt) if updated_at_lt is not None else None,
                "updatedAtGe": serialize_datetime(updated_at_ge) if updated_at_ge is not None else None,
                "updatedAtLe": serialize_datetime(updated_at_le) if updated_at_le is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightPaginatedResponse,
                    construct_type(
                        type_=InsightPaginatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def insight_controller_create(
        self, *, request: InsightControllerCreateRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[InsightControllerCreateResponse]:
        """
        Parameters
        ----------
        request : InsightControllerCreateRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InsightControllerCreateResponse]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "reporting/insight",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=InsightControllerCreateRequest, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightControllerCreateResponse,
                    construct_type(
                        type_=InsightControllerCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def insight_controller_find_one(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[InsightControllerFindOneResponse]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InsightControllerFindOneResponse]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"reporting/insight/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightControllerFindOneResponse,
                    construct_type(
                        type_=InsightControllerFindOneResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def insight_controller_remove(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[InsightControllerRemoveResponse]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InsightControllerRemoveResponse]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"reporting/insight/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightControllerRemoveResponse,
                    construct_type(
                        type_=InsightControllerRemoveResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def insight_controller_update(
        self,
        id: str,
        *,
        request: InsightControllerUpdateRequestBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InsightControllerUpdateResponse]:
        """
        Parameters
        ----------
        id : str

        request : InsightControllerUpdateRequestBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InsightControllerUpdateResponse]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"reporting/insight/{jsonable_encoder(id)}",
            method="PATCH",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=InsightControllerUpdateRequestBody, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightControllerUpdateResponse,
                    construct_type(
                        type_=InsightControllerUpdateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def insight_controller_run(
        self,
        id: str,
        *,
        format_plan: typing.Optional[InsightRunFormatPlan] = OMIT,
        time_range_override: typing.Optional[InsightTimeRangeWithStep] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InsightRunResponse]:
        """
        Parameters
        ----------
        id : str

        format_plan : typing.Optional[InsightRunFormatPlan]

        time_range_override : typing.Optional[InsightTimeRangeWithStep]
            This is the optional time range override for the insight.
            If provided, overrides every field in the insight's timeRange.
            If this is provided with missing fields, defaults will be used, not the insight's timeRange.
            start default - "-7d"
            end default - "now"
            step default - "day"
            For Pie and Text Insights, step will be ignored even if provided.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InsightRunResponse]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"reporting/insight/{jsonable_encoder(id)}/run",
            method="POST",
            json={
                "formatPlan": convert_and_respect_annotation_metadata(
                    object_=format_plan, annotation=InsightRunFormatPlan, direction="write"
                ),
                "timeRangeOverride": convert_and_respect_annotation_metadata(
                    object_=time_range_override, annotation=InsightTimeRangeWithStep, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightRunResponse,
                    construct_type(
                        type_=InsightRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def insight_controller_preview(
        self, *, request: InsightControllerPreviewRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[InsightRunResponse]:
        """
        Parameters
        ----------
        request : InsightControllerPreviewRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InsightRunResponse]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "reporting/insight/preview",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=InsightControllerPreviewRequest, direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InsightRunResponse,
                    construct_type(
                        type_=InsightRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
