# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..types.compliance_override import ComplianceOverride
from ..types.create_structured_output_dto import CreateStructuredOutputDto
from ..types.create_structured_output_dto_model import CreateStructuredOutputDtoModel
from ..types.json_schema import JsonSchema
from ..types.structured_output import StructuredOutput
from ..types.structured_output_paginated_response import StructuredOutputPaginatedResponse
from .types.structured_output_controller_find_all_request_sort_order import (
    StructuredOutputControllerFindAllRequestSortOrder,
)
from .types.update_structured_output_dto_model import UpdateStructuredOutputDtoModel

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawStructuredOutputsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def structured_output_controller_find_all(
        self,
        *,
        id: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[StructuredOutputControllerFindAllRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StructuredOutputPaginatedResponse]:
        """
        Parameters
        ----------
        id : typing.Optional[str]
            This will return structured outputs where the id matches the specified value.

        name : typing.Optional[str]
            This will return structured outputs where the name matches the specified value.

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[StructuredOutputControllerFindAllRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutputPaginatedResponse]

        """
        _response = self._client_wrapper.httpx_client.request(
            "structured-output",
            method="GET",
            params={
                "id": id,
                "name": name,
                "page": page,
                "sortOrder": sort_order,
                "limit": limit,
                "createdAtGt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "createdAtLt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "createdAtGe": serialize_datetime(created_at_ge) if created_at_ge is not None else None,
                "createdAtLe": serialize_datetime(created_at_le) if created_at_le is not None else None,
                "updatedAtGt": serialize_datetime(updated_at_gt) if updated_at_gt is not None else None,
                "updatedAtLt": serialize_datetime(updated_at_lt) if updated_at_lt is not None else None,
                "updatedAtGe": serialize_datetime(updated_at_ge) if updated_at_ge is not None else None,
                "updatedAtLe": serialize_datetime(updated_at_le) if updated_at_le is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutputPaginatedResponse,
                    construct_type(
                        type_=StructuredOutputPaginatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_create(
        self,
        *,
        name: str,
        schema: JsonSchema,
        model: typing.Optional[CreateStructuredOutputDtoModel] = OMIT,
        compliance_plan: typing.Optional[ComplianceOverride] = OMIT,
        description: typing.Optional[str] = OMIT,
        assistant_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        workflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        name : str
            This is the name of the structured output.

        schema : JsonSchema
            This is the JSON Schema definition for the structured output.

            This is required when creating a structured output. Defines the structure and validation rules for the data that will be extracted. Supports all JSON Schema features including:
            - Objects and nested properties
            - Arrays and array validation
            - String, number, boolean, and null types
            - Enums and const values
            - Validation constraints (min/max, patterns, etc.)
            - Composition with allOf, anyOf, oneOf

        model : typing.Optional[CreateStructuredOutputDtoModel]
            This is the model that will be used to extract the structured output.

            To provide your own custom system and user prompts for structured output extraction, populate the messages array with your system and user messages. You can specify liquid templating in your system and user messages.
            Between the system or user messages, you must reference either 'transcript' or 'messages' with the '{{}}' syntax to access the conversation history.
            Between the system or user messages, you must reference a variation of the structured output with the '{{}}' syntax to access the structured output definition.
            i.e.:
            {{structuredOutput}}
            {{structuredOutput.name}}
            {{structuredOutput.description}}
            {{structuredOutput.schema}}

            If model is not specified, GPT-4.1 will be used by default for extraction, utilizing default system and user prompts.
            If messages or required fields are not specified, the default system and user prompts will be used.

        compliance_plan : typing.Optional[ComplianceOverride]
            Compliance configuration for this output. Only enable overrides if no sensitive data will be stored.

        description : typing.Optional[str]
            This is the description of what the structured output extracts.

            Use this to provide context about what data will be extracted and how it will be used.

        assistant_ids : typing.Optional[typing.Sequence[str]]
            These are the assistant IDs that this structured output is linked to.

            When linked to assistants, this structured output will be available for extraction during those assistant's calls.

        workflow_ids : typing.Optional[typing.Sequence[str]]
            These are the workflow IDs that this structured output is linked to.

            When linked to workflows, this structured output will be available for extraction during those workflow's execution.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutput]

        """
        _response = self._client_wrapper.httpx_client.request(
            "structured-output",
            method="POST",
            json={
                "model": convert_and_respect_annotation_metadata(
                    object_=model, annotation=CreateStructuredOutputDtoModel, direction="write"
                ),
                "compliancePlan": convert_and_respect_annotation_metadata(
                    object_=compliance_plan, annotation=ComplianceOverride, direction="write"
                ),
                "name": name,
                "schema": convert_and_respect_annotation_metadata(
                    object_=schema, annotation=JsonSchema, direction="write"
                ),
                "description": description,
                "assistantIds": assistant_ids,
                "workflowIds": workflow_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_find_one(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutput]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_remove(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutput]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_update(
        self,
        id: str,
        *,
        schema_override: str,
        model: typing.Optional[UpdateStructuredOutputDtoModel] = OMIT,
        compliance_plan: typing.Optional[ComplianceOverride] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        assistant_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        workflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        schema: typing.Optional[JsonSchema] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        schema_override : str

        model : typing.Optional[UpdateStructuredOutputDtoModel]
            This is the model that will be used to extract the structured output.

            To provide your own custom system and user prompts for structured output extraction, populate the messages array with your system and user messages. You can specify liquid templating in your system and user messages.
            Between the system or user messages, you must reference either 'transcript' or 'messages' with the '{{}}' syntax to access the conversation history.
            Between the system or user messages, you must reference a variation of the structured output with the '{{}}' syntax to access the structured output definition.
            i.e.:
            {{structuredOutput}}
            {{structuredOutput.name}}
            {{structuredOutput.description}}
            {{structuredOutput.schema}}

            If model is not specified, GPT-4.1 will be used by default for extraction, utilizing default system and user prompts.
            If messages or required fields are not specified, the default system and user prompts will be used.

        compliance_plan : typing.Optional[ComplianceOverride]
            Compliance configuration for this output. Only enable overrides if no sensitive data will be stored.

        name : typing.Optional[str]
            This is the name of the structured output.

        description : typing.Optional[str]
            This is the description of what the structured output extracts.

            Use this to provide context about what data will be extracted and how it will be used.

        assistant_ids : typing.Optional[typing.Sequence[str]]
            These are the assistant IDs that this structured output is linked to.

            When linked to assistants, this structured output will be available for extraction during those assistant's calls.

        workflow_ids : typing.Optional[typing.Sequence[str]]
            These are the workflow IDs that this structured output is linked to.

            When linked to workflows, this structured output will be available for extraction during those workflow's execution.

        schema : typing.Optional[JsonSchema]
            This is the JSON Schema definition for the structured output.

            Defines the structure and validation rules for the data that will be extracted. Supports all JSON Schema features including:
            - Objects and nested properties
            - Arrays and array validation
            - String, number, boolean, and null types
            - Enums and const values
            - Validation constraints (min/max, patterns, etc.)
            - Composition with allOf, anyOf, oneOf

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutput]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="PATCH",
            params={
                "schemaOverride": schema_override,
            },
            json={
                "model": convert_and_respect_annotation_metadata(
                    object_=model, annotation=UpdateStructuredOutputDtoModel, direction="write"
                ),
                "compliancePlan": convert_and_respect_annotation_metadata(
                    object_=compliance_plan, annotation=ComplianceOverride, direction="write"
                ),
                "name": name,
                "description": description,
                "assistantIds": assistant_ids,
                "workflowIds": workflow_ids,
                "schema": convert_and_respect_annotation_metadata(
                    object_=schema, annotation=JsonSchema, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_run(
        self,
        *,
        call_ids: typing.Sequence[str],
        preview_enabled: typing.Optional[bool] = OMIT,
        structured_output_id: typing.Optional[str] = OMIT,
        structured_output: typing.Optional[CreateStructuredOutputDto] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        call_ids : typing.Sequence[str]
            This is the array of callIds that will be updated with the new structured output value. If preview is true, this array must be provided and contain exactly 1 callId.
            If preview is false, up to 100 callIds may be provided.

        preview_enabled : typing.Optional[bool]
            This is the preview flag for the re-run. If true, the re-run will be executed and the response will be returned immediately and the call artifact will NOT be updated.
            If false (default), the re-run will be executed and the response will be updated in the call artifact.

        structured_output_id : typing.Optional[str]
            This is the ID of the structured output that will be run. This must be provided unless a transient structured output is provided.
            When the re-run is executed, only the value of this structured output will be replaced with the new value, or added if not present.

        structured_output : typing.Optional[CreateStructuredOutputDto]
            This is the transient structured output that will be run. This must be provided if a structured output ID is not provided.
            When the re-run is executed, the structured output value will be added to the existing artifact.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StructuredOutput]

        """
        _response = self._client_wrapper.httpx_client.request(
            "structured-output/run",
            method="POST",
            json={
                "previewEnabled": preview_enabled,
                "structuredOutputId": structured_output_id,
                "structuredOutput": convert_and_respect_annotation_metadata(
                    object_=structured_output, annotation=CreateStructuredOutputDto, direction="write"
                ),
                "callIds": call_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def structured_output_controller_suggest(
        self,
        *,
        assistant_id: str,
        count: typing.Optional[float] = OMIT,
        exclude_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        seed: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[typing.Dict[str, typing.Optional[typing.Any]]]]:
        """
        Analyzes assistant configuration and generates contextual structured output recommendations

        Parameters
        ----------
        assistant_id : str
            The assistant ID to analyze and generate suggestions for

        count : typing.Optional[float]
            Number of suggestions to generate

        exclude_ids : typing.Optional[typing.Sequence[str]]
            Existing structured output IDs to exclude from suggestions

        seed : typing.Optional[float]
            Iteration/seed for generating diverse suggestions (0 = first generation, 1+ = regenerations with increasing specificity)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[typing.Dict[str, typing.Optional[typing.Any]]]]

        """
        _response = self._client_wrapper.httpx_client.request(
            "structured-output/suggest",
            method="POST",
            json={
                "assistantId": assistant_id,
                "count": count,
                "excludeIds": exclude_ids,
                "seed": seed,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[typing.Dict[str, typing.Optional[typing.Any]]],
                    construct_type(
                        type_=typing.List[typing.Dict[str, typing.Optional[typing.Any]]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawStructuredOutputsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def structured_output_controller_find_all(
        self,
        *,
        id: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        page: typing.Optional[float] = None,
        sort_order: typing.Optional[StructuredOutputControllerFindAllRequestSortOrder] = None,
        limit: typing.Optional[float] = None,
        created_at_gt: typing.Optional[dt.datetime] = None,
        created_at_lt: typing.Optional[dt.datetime] = None,
        created_at_ge: typing.Optional[dt.datetime] = None,
        created_at_le: typing.Optional[dt.datetime] = None,
        updated_at_gt: typing.Optional[dt.datetime] = None,
        updated_at_lt: typing.Optional[dt.datetime] = None,
        updated_at_ge: typing.Optional[dt.datetime] = None,
        updated_at_le: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StructuredOutputPaginatedResponse]:
        """
        Parameters
        ----------
        id : typing.Optional[str]
            This will return structured outputs where the id matches the specified value.

        name : typing.Optional[str]
            This will return structured outputs where the name matches the specified value.

        page : typing.Optional[float]
            This is the page number to return. Defaults to 1.

        sort_order : typing.Optional[StructuredOutputControllerFindAllRequestSortOrder]
            This is the sort order for pagination. Defaults to 'DESC'.

        limit : typing.Optional[float]
            This is the maximum number of items to return. Defaults to 100.

        created_at_gt : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than the specified value.

        created_at_lt : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than the specified value.

        created_at_ge : typing.Optional[dt.datetime]
            This will return items where the createdAt is greater than or equal to the specified value.

        created_at_le : typing.Optional[dt.datetime]
            This will return items where the createdAt is less than or equal to the specified value.

        updated_at_gt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than the specified value.

        updated_at_lt : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than the specified value.

        updated_at_ge : typing.Optional[dt.datetime]
            This will return items where the updatedAt is greater than or equal to the specified value.

        updated_at_le : typing.Optional[dt.datetime]
            This will return items where the updatedAt is less than or equal to the specified value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutputPaginatedResponse]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "structured-output",
            method="GET",
            params={
                "id": id,
                "name": name,
                "page": page,
                "sortOrder": sort_order,
                "limit": limit,
                "createdAtGt": serialize_datetime(created_at_gt) if created_at_gt is not None else None,
                "createdAtLt": serialize_datetime(created_at_lt) if created_at_lt is not None else None,
                "createdAtGe": serialize_datetime(created_at_ge) if created_at_ge is not None else None,
                "createdAtLe": serialize_datetime(created_at_le) if created_at_le is not None else None,
                "updatedAtGt": serialize_datetime(updated_at_gt) if updated_at_gt is not None else None,
                "updatedAtLt": serialize_datetime(updated_at_lt) if updated_at_lt is not None else None,
                "updatedAtGe": serialize_datetime(updated_at_ge) if updated_at_ge is not None else None,
                "updatedAtLe": serialize_datetime(updated_at_le) if updated_at_le is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutputPaginatedResponse,
                    construct_type(
                        type_=StructuredOutputPaginatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_create(
        self,
        *,
        name: str,
        schema: JsonSchema,
        model: typing.Optional[CreateStructuredOutputDtoModel] = OMIT,
        compliance_plan: typing.Optional[ComplianceOverride] = OMIT,
        description: typing.Optional[str] = OMIT,
        assistant_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        workflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        name : str
            This is the name of the structured output.

        schema : JsonSchema
            This is the JSON Schema definition for the structured output.

            This is required when creating a structured output. Defines the structure and validation rules for the data that will be extracted. Supports all JSON Schema features including:
            - Objects and nested properties
            - Arrays and array validation
            - String, number, boolean, and null types
            - Enums and const values
            - Validation constraints (min/max, patterns, etc.)
            - Composition with allOf, anyOf, oneOf

        model : typing.Optional[CreateStructuredOutputDtoModel]
            This is the model that will be used to extract the structured output.

            To provide your own custom system and user prompts for structured output extraction, populate the messages array with your system and user messages. You can specify liquid templating in your system and user messages.
            Between the system or user messages, you must reference either 'transcript' or 'messages' with the '{{}}' syntax to access the conversation history.
            Between the system or user messages, you must reference a variation of the structured output with the '{{}}' syntax to access the structured output definition.
            i.e.:
            {{structuredOutput}}
            {{structuredOutput.name}}
            {{structuredOutput.description}}
            {{structuredOutput.schema}}

            If model is not specified, GPT-4.1 will be used by default for extraction, utilizing default system and user prompts.
            If messages or required fields are not specified, the default system and user prompts will be used.

        compliance_plan : typing.Optional[ComplianceOverride]
            Compliance configuration for this output. Only enable overrides if no sensitive data will be stored.

        description : typing.Optional[str]
            This is the description of what the structured output extracts.

            Use this to provide context about what data will be extracted and how it will be used.

        assistant_ids : typing.Optional[typing.Sequence[str]]
            These are the assistant IDs that this structured output is linked to.

            When linked to assistants, this structured output will be available for extraction during those assistant's calls.

        workflow_ids : typing.Optional[typing.Sequence[str]]
            These are the workflow IDs that this structured output is linked to.

            When linked to workflows, this structured output will be available for extraction during those workflow's execution.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutput]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "structured-output",
            method="POST",
            json={
                "model": convert_and_respect_annotation_metadata(
                    object_=model, annotation=CreateStructuredOutputDtoModel, direction="write"
                ),
                "compliancePlan": convert_and_respect_annotation_metadata(
                    object_=compliance_plan, annotation=ComplianceOverride, direction="write"
                ),
                "name": name,
                "schema": convert_and_respect_annotation_metadata(
                    object_=schema, annotation=JsonSchema, direction="write"
                ),
                "description": description,
                "assistantIds": assistant_ids,
                "workflowIds": workflow_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_find_one(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutput]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_remove(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutput]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_update(
        self,
        id: str,
        *,
        schema_override: str,
        model: typing.Optional[UpdateStructuredOutputDtoModel] = OMIT,
        compliance_plan: typing.Optional[ComplianceOverride] = OMIT,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        assistant_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        workflow_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        schema: typing.Optional[JsonSchema] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        id : str

        schema_override : str

        model : typing.Optional[UpdateStructuredOutputDtoModel]
            This is the model that will be used to extract the structured output.

            To provide your own custom system and user prompts for structured output extraction, populate the messages array with your system and user messages. You can specify liquid templating in your system and user messages.
            Between the system or user messages, you must reference either 'transcript' or 'messages' with the '{{}}' syntax to access the conversation history.
            Between the system or user messages, you must reference a variation of the structured output with the '{{}}' syntax to access the structured output definition.
            i.e.:
            {{structuredOutput}}
            {{structuredOutput.name}}
            {{structuredOutput.description}}
            {{structuredOutput.schema}}

            If model is not specified, GPT-4.1 will be used by default for extraction, utilizing default system and user prompts.
            If messages or required fields are not specified, the default system and user prompts will be used.

        compliance_plan : typing.Optional[ComplianceOverride]
            Compliance configuration for this output. Only enable overrides if no sensitive data will be stored.

        name : typing.Optional[str]
            This is the name of the structured output.

        description : typing.Optional[str]
            This is the description of what the structured output extracts.

            Use this to provide context about what data will be extracted and how it will be used.

        assistant_ids : typing.Optional[typing.Sequence[str]]
            These are the assistant IDs that this structured output is linked to.

            When linked to assistants, this structured output will be available for extraction during those assistant's calls.

        workflow_ids : typing.Optional[typing.Sequence[str]]
            These are the workflow IDs that this structured output is linked to.

            When linked to workflows, this structured output will be available for extraction during those workflow's execution.

        schema : typing.Optional[JsonSchema]
            This is the JSON Schema definition for the structured output.

            Defines the structure and validation rules for the data that will be extracted. Supports all JSON Schema features including:
            - Objects and nested properties
            - Arrays and array validation
            - String, number, boolean, and null types
            - Enums and const values
            - Validation constraints (min/max, patterns, etc.)
            - Composition with allOf, anyOf, oneOf

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutput]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"structured-output/{jsonable_encoder(id)}",
            method="PATCH",
            params={
                "schemaOverride": schema_override,
            },
            json={
                "model": convert_and_respect_annotation_metadata(
                    object_=model, annotation=UpdateStructuredOutputDtoModel, direction="write"
                ),
                "compliancePlan": convert_and_respect_annotation_metadata(
                    object_=compliance_plan, annotation=ComplianceOverride, direction="write"
                ),
                "name": name,
                "description": description,
                "assistantIds": assistant_ids,
                "workflowIds": workflow_ids,
                "schema": convert_and_respect_annotation_metadata(
                    object_=schema, annotation=JsonSchema, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_run(
        self,
        *,
        call_ids: typing.Sequence[str],
        preview_enabled: typing.Optional[bool] = OMIT,
        structured_output_id: typing.Optional[str] = OMIT,
        structured_output: typing.Optional[CreateStructuredOutputDto] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StructuredOutput]:
        """
        Parameters
        ----------
        call_ids : typing.Sequence[str]
            This is the array of callIds that will be updated with the new structured output value. If preview is true, this array must be provided and contain exactly 1 callId.
            If preview is false, up to 100 callIds may be provided.

        preview_enabled : typing.Optional[bool]
            This is the preview flag for the re-run. If true, the re-run will be executed and the response will be returned immediately and the call artifact will NOT be updated.
            If false (default), the re-run will be executed and the response will be updated in the call artifact.

        structured_output_id : typing.Optional[str]
            This is the ID of the structured output that will be run. This must be provided unless a transient structured output is provided.
            When the re-run is executed, only the value of this structured output will be replaced with the new value, or added if not present.

        structured_output : typing.Optional[CreateStructuredOutputDto]
            This is the transient structured output that will be run. This must be provided if a structured output ID is not provided.
            When the re-run is executed, the structured output value will be added to the existing artifact.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StructuredOutput]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "structured-output/run",
            method="POST",
            json={
                "previewEnabled": preview_enabled,
                "structuredOutputId": structured_output_id,
                "structuredOutput": convert_and_respect_annotation_metadata(
                    object_=structured_output, annotation=CreateStructuredOutputDto, direction="write"
                ),
                "callIds": call_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StructuredOutput,
                    construct_type(
                        type_=StructuredOutput,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def structured_output_controller_suggest(
        self,
        *,
        assistant_id: str,
        count: typing.Optional[float] = OMIT,
        exclude_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        seed: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[typing.Dict[str, typing.Optional[typing.Any]]]]:
        """
        Analyzes assistant configuration and generates contextual structured output recommendations

        Parameters
        ----------
        assistant_id : str
            The assistant ID to analyze and generate suggestions for

        count : typing.Optional[float]
            Number of suggestions to generate

        exclude_ids : typing.Optional[typing.Sequence[str]]
            Existing structured output IDs to exclude from suggestions

        seed : typing.Optional[float]
            Iteration/seed for generating diverse suggestions (0 = first generation, 1+ = regenerations with increasing specificity)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[typing.Dict[str, typing.Optional[typing.Any]]]]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "structured-output/suggest",
            method="POST",
            json={
                "assistantId": assistant_id,
                "count": count,
                "excludeIds": exclude_ids,
                "seed": seed,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[typing.Dict[str, typing.Optional[typing.Any]]],
                    construct_type(
                        type_=typing.List[typing.Dict[str, typing.Optional[typing.Any]]],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
