# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .get_chat_paginated_dto_sort_order import GetChatPaginatedDtoSortOrder


class GetChatPaginatedDto(UncheckedBaseModel):
    assistant_id: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="assistantId")] = (
        pydantic.Field(default=None)
    )
    """
    This is the unique identifier for the assistant that will be used for the chat.
    """

    squad_id: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="squadId")] = pydantic.Field(
        default=None
    )
    """
    This is the unique identifier for the squad that will be used for the chat.
    """

    session_id: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="sessionId")] = pydantic.Field(
        default=None
    )
    """
    This is the unique identifier for the session that will be used for the chat.
    """

    previous_chat_id: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="previousChatId")] = (
        pydantic.Field(default=None)
    )
    """
    This is the unique identifier for the previous chat to filter by.
    """

    page: typing.Optional[float] = pydantic.Field(default=None)
    """
    This is the page number to return. Defaults to 1.
    """

    sort_order: typing_extensions.Annotated[
        typing.Optional[GetChatPaginatedDtoSortOrder], FieldMetadata(alias="sortOrder")
    ] = pydantic.Field(default=None)
    """
    This is the sort order for pagination. Defaults to 'DESC'.
    """

    limit: typing.Optional[float] = pydantic.Field(default=None)
    """
    This is the maximum number of items to return. Defaults to 100.
    """

    created_at_gt: typing_extensions.Annotated[typing.Optional[dt.datetime], FieldMetadata(alias="createdAtGt")] = (
        pydantic.Field(default=None)
    )
    """
    This will return items where the createdAt is greater than the specified value.
    """

    created_at_lt: typing_extensions.Annotated[typing.Optional[dt.datetime], FieldMetadata(alias="createdAtLt")] = (
        pydantic.Field(default=None)
    )
    """
    This will return items where the createdAt is less than the specified value.
    """

    created_at_ge: typing_extensions.Annotated[typing.Optional[dt.datetime], FieldMetadata(alias="createdAtGe")] = (
        pydantic.Field(default=None)
    )
    """
    This will return items where the createdAt is greater than or equal to the specified value.
    """

    created_at_le: typing_extensions.Annotated[typing.Optional[dt.datetime], FieldMetadata(alias="createdAtLe")] = (
        pydantic.Field(default=None)
    )
    """
    This will return items where the createdAt is less than or equal to the specified value.
    """

    updated_at_gt: typing_extensions.Annotated[typing.Optional[dt.datetime], FieldMetadata(alias="updatedAtGt")] = (
        pydantic.Field(default=None)
    )
    """
    This will return items where the updatedAt is greater than the specified value.
    """

    updated_at_lt: typing_extensions.Annotated[typing.Optional[dt.datetime], FieldMetadata(alias="updatedAtLt")] = (
        pydantic.Field(default=None)
    )
    """
    This will return items where the updatedAt is less than the specified value.
    """

    updated_at_ge: typing_extensions.Annotated[typing.Optional[dt.datetime], FieldMetadata(alias="updatedAtGe")] = (
        pydantic.Field(default=None)
    )
    """
    This will return items where the updatedAt is greater than or equal to the specified value.
    """

    updated_at_le: typing_extensions.Annotated[typing.Optional[dt.datetime], FieldMetadata(alias="updatedAtLe")] = (
        pydantic.Field(default=None)
    )
    """
    This will return items where the updatedAt is less than or equal to the specified value.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
