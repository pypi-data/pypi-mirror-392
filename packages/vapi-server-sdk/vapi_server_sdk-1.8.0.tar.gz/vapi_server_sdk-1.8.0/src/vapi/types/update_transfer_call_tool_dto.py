# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, update_forward_refs
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .tool_rejection_plan import ToolRejectionPlan
from .update_transfer_call_tool_dto_destinations_item import UpdateTransferCallToolDtoDestinationsItem
from .update_transfer_call_tool_dto_messages_item import UpdateTransferCallToolDtoMessagesItem


class UpdateTransferCallToolDto(UncheckedBaseModel):
    messages: typing.Optional[typing.List[UpdateTransferCallToolDtoMessagesItem]] = pydantic.Field(default=None)
    """
    These are the messages that will be spoken to the user as the tool is running.
    
    For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
    """

    destinations: typing.Optional[typing.List[UpdateTransferCallToolDtoDestinationsItem]] = pydantic.Field(default=None)
    """
    These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.
    """

    rejection_plan: typing_extensions.Annotated[
        typing.Optional[ToolRejectionPlan], FieldMetadata(alias="rejectionPlan")
    ] = pydantic.Field(default=None)
    """
    This is the plan to reject a tool call based on the conversation state.
    
    // Example 1: Reject endCall if user didn't say goodbye
    ```json
    {
      conditions: [{
        type: 'regex',
        regex: '(?i)\\\\b(bye|goodbye|farewell|see you later|take care)\\\\b',
        target: { position: -1, role: 'user' },
        negate: true  // Reject if pattern does NOT match
      }]
    }
    ```
    
    // Example 2: Reject transfer if user is actually asking a question
    ```json
    {
      conditions: [{
        type: 'regex',
        regex: '\\\\?',
        target: { position: -1, role: 'user' }
      }]
    }
    ```
    
    // Example 3: Reject transfer if user didn't mention transfer recently
    ```json
    {
      conditions: [{
        type: 'liquid',
        liquid: `{% assign recentMessages = messages | last: 5 %}
    {% assign userMessages = recentMessages | where: 'role', 'user' %}
    {% assign mentioned = false %}
    {% for msg in userMessages %}
      {% if msg.content contains 'transfer' or msg.content contains 'connect' or msg.content contains 'speak to' %}
        {% assign mentioned = true %}
        {% break %}
      {% endif %}
    {% endfor %}
    {% if mentioned %}
      false
    {% else %}
      true
    {% endif %}`
      }]
    }
    ```
    
    // Example 4: Reject endCall if the bot is looping and trying to exit
    ```json
    {
      conditions: [{
        type: 'liquid',
        liquid: `{% assign recentMessages = messages | last: 6 %}
    {% assign userMessages = recentMessages | where: 'role', 'user' | reverse %}
    {% if userMessages.size < 3 %}
      false
    {% else %}
      {% assign msg1 = userMessages[0].content | downcase %}
      {% assign msg2 = userMessages[1].content | downcase %}
      {% assign msg3 = userMessages[2].content | downcase %}
      {% comment %} Check for repetitive messages {% endcomment %}
      {% if msg1 == msg2 or msg1 == msg3 or msg2 == msg3 %}
        true
      {% comment %} Check for common loop phrases {% endcomment %}
      {% elsif msg1 contains 'cool thanks' or msg2 contains 'cool thanks' or msg3 contains 'cool thanks' %}
        true
      {% elsif msg1 contains 'okay thanks' or msg2 contains 'okay thanks' or msg3 contains 'okay thanks' %}
        true
      {% elsif msg1 contains 'got it' or msg2 contains 'got it' or msg3 contains 'got it' %}
        true
      {% else %}
        false
      {% endif %}
    {% endif %}`
      }]
    }
    ```
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


from .group_condition import GroupCondition  # noqa: E402, F401, I001

update_forward_refs(UpdateTransferCallToolDto)
