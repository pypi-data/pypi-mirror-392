# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

class Affiliation:
    r"""
    Python wrapper for Author affiliation
    """

    institution: typing.Optional[builtins.str]
    department: typing.Optional[builtins.str]
    address: typing.Optional[builtins.str]
    country: typing.Optional[builtins.str]
    email: typing.Optional[builtins.str]
    def __repr__(self) -> builtins.str: ...

class ArticleSection:
    r"""
    Python wrapper for ArticleSection
    """

    title: typing.Optional[builtins.str]
    content: builtins.str
    section_type: typing.Optional[builtins.str]
    def __repr__(self) -> builtins.str: ...

class Author:
    r"""
    Python wrapper for Author
    """

    last_name: typing.Optional[builtins.str]
    fore_name: typing.Optional[builtins.str]
    first_name: typing.Optional[builtins.str]
    middle_name: typing.Optional[builtins.str]
    initials: typing.Optional[builtins.str]
    suffix: typing.Optional[builtins.str]
    full_name: builtins.str
    orcid: typing.Optional[builtins.str]
    is_corresponding: builtins.bool
    def affiliations(self) -> typing.Any:
        r"""
        Get list of affiliations
        """
    def __repr__(self) -> builtins.str: ...

class Citations:
    r"""
    Python wrapper for Citations
    """

    source_pmids: builtins.list[builtins.int]
    citing_pmids: builtins.list[builtins.int]
    def __repr__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...

class Client:
    r"""
    Combined client with both PubMed and PMC functionality

    This is the main client you'll typically use. It provides access to both
    PubMed metadata searches and PMC full-text retrieval.

    Examples:
        >>> client = Client()
        >>> # Access PubMed client
        >>> articles = client.pubmed.search_and_fetch("covid-19", 10)
        >>> # Access PMC client
        >>> full_text = client.pmc.fetch_full_text("PMC7906746")
        >>> # Search with full text
        >>> results = client.search_with_full_text("covid-19", 5)
    """

    pubmed: PubMedClient
    r"""
    Get PubMed client for metadata operations
    """
    pmc: PmcClient
    r"""
    Get PMC client for full-text operations
    """
    def __new__(cls) -> Client:
        r"""
        Create a new combined client with default configuration
        """
    @staticmethod
    def with_config(config: ClientConfig) -> Client:
        r"""
        Create a new combined client with custom configuration
        """
    def search_with_full_text(
        self, query: builtins.str, limit: builtins.int
    ) -> builtins.list[tuple[PubMedArticle, typing.Optional[PmcFullText]]]:
        r"""
        Search for articles and attempt to fetch full text for each

        This is a convenience method that searches PubMed and attempts to fetch
        PMC full text for each result when available.

        Args:
            query: Search query string
            limit: Maximum number of articles to process

        Returns:
            List of tuples (PubMedArticle, Optional[PmcFullText])
        """
    def get_database_list(self) -> builtins.list[builtins.str]:
        r"""
        Get list of all available NCBI databases
        """
    def get_database_info(self, database: builtins.str) -> DatabaseInfo:
        r"""
        Get detailed information about a specific database
        """
    def get_related_articles(self, pmids: typing.Sequence[builtins.int]) -> RelatedArticles:
        r"""
        Get related articles for given PMIDs
        """
    def get_pmc_links(self, pmids: typing.Sequence[builtins.int]) -> PmcLinks:
        r"""
        Get PMC links for given PMIDs
        """
    def get_citations(self, pmids: typing.Sequence[builtins.int]) -> Citations:
        r"""
        Get citing articles for given PMIDs
        """
    def __repr__(self) -> builtins.str: ...

class ClientConfig:
    r"""
    Python wrapper for ClientConfig

    Configuration for PubMed and PMC clients.

    Examples:
        >>> config = ClientConfig()
        >>> config.with_api_key("your_api_key").with_email("you@example.com")
        >>> client = Client.with_config(config)
    """
    def __new__(cls) -> ClientConfig:
        r"""
        Create a new configuration with default settings
        """
    def with_api_key(self, api_key: builtins.str) -> ClientConfig:
        r"""
        Set the NCBI API key for increased rate limits (10 req/sec instead of 3)
        """
    def with_email(self, email: builtins.str) -> ClientConfig:
        r"""
        Set the email address for identification (recommended by NCBI)
        """
    def with_tool(self, tool: builtins.str) -> ClientConfig:
        r"""
        Set the tool name for identification (default: "pubmed-client-py")
        """
    def with_rate_limit(self, rate_limit: builtins.float) -> ClientConfig:
        r"""
        Set custom rate limit in requests per second
        """
    def with_timeout_seconds(self, timeout_seconds: builtins.int) -> ClientConfig:
        r"""
        Set HTTP request timeout in seconds
        """
    def with_cache(self) -> ClientConfig:
        r"""
        Enable default response caching
        """
    def __repr__(self) -> builtins.str: ...

class DatabaseInfo:
    r"""
    Python wrapper for DatabaseInfo
    """

    name: builtins.str
    menu_name: builtins.str
    description: builtins.str
    build: typing.Optional[builtins.str]
    count: typing.Optional[builtins.int]
    last_update: typing.Optional[builtins.str]
    def __repr__(self) -> builtins.str: ...

class Figure:
    r"""
    Python wrapper for Figure
    """

    id: builtins.str
    label: typing.Optional[builtins.str]
    caption: builtins.str
    alt_text: typing.Optional[builtins.str]
    fig_type: typing.Optional[builtins.str]
    file_path: typing.Optional[builtins.str]
    file_name: typing.Optional[builtins.str]
    def __repr__(self) -> builtins.str: ...

class ExtractedFigure:
    r"""
    Python wrapper for ExtractedFigure

    Represents a figure that has been extracted from a PMC tar.gz archive,
    combining XML metadata with actual file information.
    """

    figure: Figure
    r"""Figure metadata from XML (caption, label, etc.)"""
    extracted_file_path: builtins.str
    r"""Actual file path where the figure was extracted"""
    file_size: typing.Optional[builtins.int]
    r"""File size in bytes"""
    dimensions: typing.Optional[tuple[builtins.int, builtins.int]]
    r"""Image dimensions as (width, height) tuple if available"""
    def __repr__(self) -> builtins.str: ...

class PmcAffiliation:
    r"""
    Python wrapper for PMC Affiliation
    """

    id: typing.Optional[builtins.str]
    institution: builtins.str
    department: typing.Optional[builtins.str]
    address: typing.Optional[builtins.str]
    country: typing.Optional[builtins.str]
    def __repr__(self) -> builtins.str: ...

class PmcAuthor:
    r"""
    Python wrapper for PMC Author
    """

    given_names: typing.Optional[builtins.str]
    surname: typing.Optional[builtins.str]
    full_name: builtins.str
    orcid: typing.Optional[builtins.str]
    email: typing.Optional[builtins.str]
    is_corresponding: builtins.bool
    def affiliations(self) -> typing.Any:
        r"""
        Get list of affiliations
        """
    def __repr__(self) -> builtins.str: ...

class PmcClient:
    r"""
    PMC client for fetching full-text articles

    Examples:
        >>> client = PmcClient()
        >>> full_text = client.fetch_full_text("PMC7906746")
        >>> pmcid = client.check_pmc_availability("31978945")
    """
    def __new__(cls) -> PmcClient:
        r"""
        Create a new PMC client with default configuration
        """
    @staticmethod
    def with_config(config: ClientConfig) -> PmcClient:
        r"""
        Create a new PMC client with custom configuration
        """
    def fetch_full_text(self, pmcid: builtins.str) -> PmcFullText:
        r"""
        Fetch full text article from PMC

        Args:
            pmcid: PMC ID (e.g., "PMC7906746")

        Returns:
            PmcFullText object containing structured article content
        """
    def check_pmc_availability(self, pmid: builtins.str) -> typing.Optional[builtins.str]:
        r"""
        Check if PMC full text is available for a PMID

        Args:
            pmid: PubMed ID as a string

        Returns:
            PMC ID if available, None otherwise
        """
    def download_and_extract_tar(
        self, pmcid: builtins.str, output_dir: builtins.str
    ) -> builtins.list[builtins.str]:
        r"""
        Download and extract PMC tar.gz archive

        Downloads the tar.gz file for the specified PMC ID and extracts all files
        to the output directory.

        Args:
            pmcid: PMC ID (e.g., "PMC7906746" or "7906746")
            output_dir: Directory path where files should be extracted

        Returns:
            List of extracted file paths

        Example:
            >>> client = PmcClient()
            >>> files = client.download_and_extract_tar("PMC7906746", "./output")
            >>> for file in files:
            ...     print(file)
        """
    def extract_figures_with_captions(
        self, pmcid: builtins.str, output_dir: builtins.str
    ) -> builtins.list[ExtractedFigure]:
        r"""
        Extract figures with captions from PMC article

        Downloads the tar.gz file for the specified PMC ID, extracts all files,
        and matches figures with their captions from the XML metadata.

        Args:
            pmcid: PMC ID (e.g., "PMC7906746" or "7906746")
            output_dir: Directory path where files should be extracted

        Returns:
            List of ExtractedFigure objects containing metadata and file information

        Example:
            >>> client = PmcClient()
            >>> figures = client.extract_figures_with_captions("PMC7906746", "./output")
            >>> for fig in figures:
            ...     print(f"{fig.figure.id}: {fig.extracted_file_path}")
            ...     print(f"  Caption: {fig.figure.caption}")
            ...     print(f"  Size: {fig.file_size} bytes")
            ...     print(f"  Dimensions: {fig.dimensions}")
        """
    def __repr__(self) -> builtins.str: ...

class PmcFullText:
    r"""
    Python wrapper for PmcFullText
    """

    pmcid: builtins.str
    pmid: typing.Optional[builtins.str]
    title: builtins.str
    doi: typing.Optional[builtins.str]
    def authors(self) -> typing.Any:
        r"""
        Get list of authors
        """
    def sections(self) -> typing.Any:
        r"""
        Get list of sections
        """
    def figures(self) -> typing.Any:
        r"""
        Get list of all figures from all sections
        """
    def tables(self) -> typing.Any:
        r"""
        Get list of all tables from all sections
        """
    def references(self) -> typing.Any:
        r"""
        Get list of references
        """
    def to_markdown(self) -> builtins.str:
        r"""
        Convert the article to Markdown format

        Returns:
            A Markdown-formatted string representation of the article

        Example:
            >>> full_text = client.pmc.fetch_full_text("PMC7906746")
            >>> markdown = full_text.to_markdown()
            >>> print(markdown)
        """
    def __repr__(self) -> builtins.str: ...

class PmcLinks:
    r"""
    Python wrapper for PmcLinks
    """

    source_pmids: builtins.list[builtins.int]
    pmc_ids: builtins.list[builtins.str]
    def __repr__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...

class PubMedArticle:
    r"""
    Python wrapper for PubMedArticle
    """

    pmid: builtins.str
    title: builtins.str
    journal: builtins.str
    pub_date: builtins.str
    doi: typing.Optional[builtins.str]
    pmc_id: typing.Optional[builtins.str]
    abstract_text: typing.Optional[builtins.str]
    author_count: builtins.int
    def authors(self) -> typing.Any:
        r"""
        Get list of authors
        """
    def article_types(self) -> typing.Any:
        r"""
        Get article types
        """
    def keywords(self) -> typing.Any:
        r"""
        Get keywords
        """
    def __repr__(self) -> builtins.str: ...

class PubMedClient:
    r"""
    PubMed client for searching and fetching article metadata

    Examples:
        >>> client = PubMedClient()
        >>> articles = client.search_and_fetch("covid-19", 10)
        >>> article = client.fetch_article("31978945")
    """
    def __new__(cls) -> PubMedClient:
        r"""
        Create a new PubMed client with default configuration
        """
    @staticmethod
    def with_config(config: ClientConfig) -> PubMedClient:
        r"""
        Create a new PubMed client with custom configuration
        """
    def search_articles(
        self, query: builtins.str | SearchQuery, limit: builtins.int
    ) -> builtins.list[builtins.str]:
        r"""
        Search for articles and return PMIDs only

        This method returns only the list of PMIDs matching the query,
        which is faster than fetching full article metadata.

        Args:
            query: Search query (either a string or SearchQuery object)
            limit: Maximum number of PMIDs to return (ignored if query is SearchQuery)

        Returns:
            List of PMIDs as strings

        Examples:
            >>> client = PubMedClient()
            >>> # Using string query
            >>> pmids = client.search_articles("covid-19", 100)
            >>> pmids = client.search_articles("cancer[ti] AND therapy[tiab]", 50)
            >>> # Using SearchQuery object
            >>> query = SearchQuery().query("covid-19").limit(100)
            >>> pmids = client.search_articles(query, 0)  # limit parameter ignored
        """
    def search_and_fetch(
        self, query: builtins.str | SearchQuery, limit: builtins.int
    ) -> builtins.list[PubMedArticle]:
        r"""
        Search for articles and fetch their metadata

        Args:
            query: Search query (either a string or SearchQuery object)
            limit: Maximum number of articles to return (ignored if query is SearchQuery)

        Returns:
            List of PubMedArticle objects

        Examples:
            >>> client = PubMedClient()
            >>> # Using string query
            >>> articles = client.search_and_fetch("covid-19", 10)
            >>> # Using SearchQuery object
            >>> query = SearchQuery().query("cancer").published_after(2020).limit(50)
            >>> articles = client.search_and_fetch(query, 0)  # limit parameter ignored
        """
    def fetch_article(self, pmid: builtins.str) -> PubMedArticle:
        r"""
        Fetch a single article by PMID

        Args:
            pmid: PubMed ID as a string

        Returns:
            PubMedArticle object
        """
    def get_database_list(self) -> builtins.list[builtins.str]:
        r"""
        Get list of all available NCBI databases

        Returns:
            List of database names
        """
    def get_database_info(self, database: builtins.str) -> DatabaseInfo:
        r"""
        Get detailed information about a specific database

        Args:
            database: Database name (e.g., "pubmed", "pmc")

        Returns:
            DatabaseInfo object
        """
    def get_related_articles(self, pmids: typing.Sequence[builtins.int]) -> RelatedArticles:
        r"""
        Get related articles for given PMIDs

        Args:
            pmids: List of PubMed IDs

        Returns:
            RelatedArticles object
        """
    def get_pmc_links(self, pmids: typing.Sequence[builtins.int]) -> PmcLinks:
        r"""
        Get PMC links for given PMIDs (full-text availability)

        Args:
            pmids: List of PubMed IDs

        Returns:
            PmcLinks object containing available PMC IDs
        """
    def get_citations(self, pmids: typing.Sequence[builtins.int]) -> Citations:
        r"""
        Get citing articles for given PMIDs

        Returns articles that cite the specified PMIDs from the PubMed database only.

        Important: Citation counts from this method may be LOWER than Google Scholar
        or scite.ai because this only includes peer-reviewed articles in PubMed.
        Other sources include preprints, books, and conference proceedings.

        Example: PMID 31978945 shows ~14,000 citations in PubMed vs ~23,000 in scite.ai.
        This is expected - this method provides PubMed-specific citation data.

        Args:
            pmids: List of PubMed IDs

        Returns:
            Citations object containing citing article PMIDs
        """
    def __repr__(self) -> builtins.str: ...

class Reference:
    r"""
    Python wrapper for Reference
    """

    id: builtins.str
    title: typing.Optional[builtins.str]
    journal: typing.Optional[builtins.str]
    year: typing.Optional[builtins.str]
    pmid: typing.Optional[builtins.str]
    doi: typing.Optional[builtins.str]
    def __repr__(self) -> builtins.str: ...

class RelatedArticles:
    r"""
    Python wrapper for RelatedArticles
    """

    source_pmids: builtins.list[builtins.int]
    related_pmids: builtins.list[builtins.int]
    link_type: builtins.str
    def __repr__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...

class SearchQuery:
    r"""
    Python wrapper for SearchQuery

    Builder for constructing PubMed search queries programmatically.

    Examples:
        >>> query = SearchQuery().query("covid-19").limit(10)
        >>> query_string = query.build()
        >>> print(query_string)
        covid-19
    """
    def __new__(cls) -> SearchQuery:
        r"""
        Create a new empty search query builder

        Returns:
            SearchQuery: New query builder instance

        Example:
            >>> query = SearchQuery()
        """
    def query(self, term: typing.Optional[builtins.str] = None) -> SearchQuery:
        r"""
        Add a search term to the query

        Terms are accumulated (not replaced) and will be space-separated in the final query.
        None and empty strings (after trimming) are silently filtered out.

        Args:
            term: Search term string (None or empty strings are filtered)

        Returns:
            SearchQuery: Self for method chaining

        Example:
            >>> query = SearchQuery().query("covid-19").query("treatment")
            >>> query.build()
            'covid-19 treatment'
        """
    def terms(
        self, terms: typing.Optional[typing.Sequence[typing.Optional[builtins.str]]] = None
    ) -> SearchQuery:
        r"""
        Add multiple search terms at once

        Each term is processed like query(). None items and empty strings are filtered out.

        Args:
            terms: List of search term strings

        Returns:
            SearchQuery: Self for method chaining

        Example:
            >>> query = SearchQuery().terms(["covid-19", "vaccine", "efficacy"])
            >>> query.build()
            'covid-19 vaccine efficacy'
        """
    def limit(self, limit: typing.Optional[builtins.int] = None) -> SearchQuery:
        r"""
        Set the maximum number of results to return

        Validates that limit is >0 and â‰¤10,000. None is treated as "use default" (20).

        Args:
            limit: Maximum number of results (None = use default of 20)

        Returns:
            SearchQuery: Self for method chaining

        Raises:
            ValueError: If limit â‰¤ 0 or limit > 10,000

        Example:
            >>> query = SearchQuery().query("cancer").limit(50)
        """
    def build(self) -> builtins.str:
        r"""
        Build the final PubMed query string

        Terms are joined with space separators (PubMed's default OR logic).

        Returns:
            str: Query string for PubMed E-utilities API

        Raises:
            ValueError: If no search terms have been added

        Example:
            >>> query = SearchQuery().query("covid-19").query("treatment")
            >>> query.build()
            'covid-19 treatment'
        """
    def get_limit(self) -> builtins.int:
        r"""
        Get the limit for this query

        Returns the configured limit or the default of 20 if not set.

        Returns:
            int: Maximum number of results (default: 20)

        Example:
            >>> query = SearchQuery().query("cancer").limit(100)
            >>> query.get_limit()
            100
            >>> query2 = SearchQuery().query("diabetes")
            >>> query2.get_limit()
            20
        """
    def __repr__(self) -> builtins.str:
        r"""
        String representation for debugging
        """
    def published_in_year(self, year: builtins.int) -> SearchQuery:
        r"""
        Filter to articles published in a specific year

        Args:
            year: Year to filter by (must be between 1800 and 3000)

        Returns:
            SearchQuery: Self for method chaining

        Raises:
            ValueError: If year is outside the valid range (1800-3000)

        Example:
            >>> query = SearchQuery().query("covid-19").published_in_year(2024)
            >>> query.build()
            'covid-19 AND 2024[pdat]'
        """
    def published_between(
        self, start_year: builtins.int, end_year: typing.Optional[builtins.int] = None
    ) -> SearchQuery:
        r"""
        Filter by publication date range

        Filters articles published between start_year and end_year (inclusive).
        If end_year is None, filters from start_year onwards (up to year 3000).

        Args:
            start_year: Start year (inclusive, must be 1800-3000)
            end_year: End year (inclusive, optional, must be 1800-3000 if provided)

        Returns:
            SearchQuery: Self for method chaining

        Raises:
            ValueError: If years are outside valid range or start_year > end_year

        Example:
            >>> # Filter to 2020-2024
            >>> query = SearchQuery().query("cancer").published_between(2020, 2024)
            >>> query.build()
            'cancer AND 2020:2024[pdat]'

            >>> # Filter from 2020 onwards
            >>> query = SearchQuery().query("treatment").published_between(2020, None)
            >>> query.build()
            'treatment AND 2020:3000[pdat]'
        """
    def published_after(self, year: builtins.int) -> SearchQuery:
        r"""
        Filter to articles published after a specific year

        Equivalent to published_between(year, None).

        Args:
            year: Year after which articles were published (must be 1800-3000)

        Returns:
            SearchQuery: Self for method chaining

        Raises:
            ValueError: If year is outside the valid range (1800-3000)

        Example:
            >>> query = SearchQuery().query("crispr").published_after(2020)
            >>> query.build()
            'crispr AND 2020:3000[pdat]'
        """
    def published_before(self, year: builtins.int) -> SearchQuery:
        r"""
        Filter to articles published before a specific year

        Filters articles from 1900 up to and including the specified year.

        Args:
            year: Year before which articles were published (must be 1800-3000)

        Returns:
            SearchQuery: Self for method chaining

        Raises:
            ValueError: If year is outside the valid range (1800-3000)

        Example:
            >>> query = SearchQuery().query("genome").published_before(2020)
            >>> query.build()
            'genome AND 1900:2020[pdat]'
        """
    def article_type(self, type_name: builtins.str) -> SearchQuery:
        r"""
        Filter by a single article type

        Args:
            type_name: Article type name (case-insensitive)
                Supported types: "Clinical Trial", "Review", "Systematic Review",
                "Meta-Analysis", "Case Reports", "Randomized Controlled Trial" (or "RCT"),
                "Observational Study"

        Returns:
            SearchQuery: Self for method chaining

        Raises:
            ValueError: If article type is not recognized

        Example:
            >>> query = SearchQuery().query("cancer").article_type("Clinical Trial")
            >>> query.build()
            'cancer AND Clinical Trial[pt]'
        """
    def article_types(self, types: typing.Sequence[builtins.str]) -> SearchQuery:
        r"""
        Filter by multiple article types (OR logic)

        When multiple types are provided, they are combined with OR logic.
        Empty list is silently ignored (no filter added).

        Args:
            types: List of article type names (case-insensitive)

        Returns:
            SearchQuery: Self for method chaining

        Raises:
            ValueError: If any article type is not recognized

        Example:
            >>> query = SearchQuery().query("treatment").article_types(["RCT", "Meta-Analysis"])
            >>> query.build()
            'treatment AND (Randomized Controlled Trial[pt] OR Meta-Analysis[pt])'
        """
    def free_full_text_only(self) -> SearchQuery:
        r"""
        Filter to articles with free full text (open access)

        This includes articles that are freely available from PubMed Central
        and other open access sources.

        Returns:
            SearchQuery: Self for method chaining

        Example:
            >>> query = SearchQuery().query("cancer").free_full_text_only()
            >>> query.build()
            'cancer AND free full text[sb]'
        """
    def full_text_only(self) -> SearchQuery:
        r"""
        Filter to articles with full text links

        This includes both free full text and subscription-based full text articles.
        Use free_full_text_only() if you only want open access articles.

        Returns:
            SearchQuery: Self for method chaining

        Example:
            >>> query = SearchQuery().query("diabetes").full_text_only()
            >>> query.build()
            'diabetes AND full text[sb]'
        """
    def pmc_only(self) -> SearchQuery:
        r"""
        Filter to articles with PMC full text

        This filters to articles that have full text available in PubMed Central (PMC).

        Returns:
            SearchQuery: Self for method chaining

        Example:
            >>> query = SearchQuery().query("genomics").pmc_only()
            >>> query.build()
            'genomics AND pmc[sb]'
        """
    def and_(self, other: SearchQuery) -> SearchQuery:
        r"""
        Combine this query with another using AND logic

        Combines two queries by wrapping each in parentheses and joining with AND.
        If either query is empty, returns the non-empty query.
        The result uses the higher limit of the two queries.

        Args:
            other: Another SearchQuery to combine with

        Returns:
            SearchQuery: New query with combined logic

        Example:
            >>> q1 = SearchQuery().query("covid-19")
            >>> q2 = SearchQuery().query("vaccine")
            >>> combined = q1.and_(q2)
            >>> combined.build()
            '(covid-19) AND (vaccine)'

            >>> # Complex chaining
            >>> result = SearchQuery().query("cancer") \
            ...     .and_(SearchQuery().query("treatment")) \
            ...     .and_(SearchQuery().query("2024[pdat]"))
            >>> result.build()
            '((cancer) AND (treatment)) AND (2024[pdat])'
        """
    def or_(self, other: SearchQuery) -> SearchQuery:
        r"""
        Combine this query with another using OR logic

        Combines two queries by wrapping each in parentheses and joining with OR.
        If either query is empty, returns the non-empty query.
        The result uses the higher limit of the two queries.

        Args:
            other: Another SearchQuery to combine with

        Returns:
            SearchQuery: New query with combined logic

        Example:
            >>> q1 = SearchQuery().query("diabetes")
            >>> q2 = SearchQuery().query("hypertension")
            >>> combined = q1.or_(q2)
            >>> combined.build()
            '(diabetes) OR (hypertension)'

            >>> # Find articles about either condition
            >>> result = SearchQuery().query("cancer") \
            ...     .or_(SearchQuery().query("tumor")) \
            ...     .or_(SearchQuery().query("oncology"))
            >>> result.build()
            '((cancer) OR (tumor)) OR (oncology)'
        """
    def negate(self) -> SearchQuery:
        r"""
        Negate this query using NOT logic

        Wraps the current query with NOT operator.
        This is typically used in combination with other queries to exclude results.
        Returns an empty query if the current query is empty.

        Returns:
            SearchQuery: New query with NOT logic

        Example:
            >>> query = SearchQuery().query("cancer").negate()
            >>> query.build()
            'NOT (cancer)'

            >>> # More practical: exclude from search results
            >>> base = SearchQuery().query("treatment")
            >>> excluded = SearchQuery().query("animal studies").negate()
            >>> # (Note: use exclude() method for this pattern)
        """
    def exclude(self, excluded: SearchQuery) -> SearchQuery:
        r"""
        Exclude articles matching the given query

        Excludes results from this query that match the excluded query.
        This is the recommended way to filter out unwanted results.
        If either query is empty, returns the base query unchanged.

        Args:
            excluded: SearchQuery representing articles to exclude

        Returns:
            SearchQuery: New query with exclusion logic

        Example:
            >>> base = SearchQuery().query("cancer treatment")
            >>> exclude = SearchQuery().query("animal studies")
            >>> filtered = base.exclude(exclude)
            >>> filtered.build()
            '(cancer treatment) NOT (animal studies)'

            >>> # Exclude multiple types of studies
            >>> human_only = SearchQuery().query("therapy") \
            ...     .exclude(SearchQuery().query("animal studies")) \
            ...     .exclude(SearchQuery().query("in vitro"))
        """
    def group(self) -> SearchQuery:
        r"""
        Add parentheses around the current query for grouping

        Wraps the query in parentheses to control operator precedence in complex queries.
        Returns an empty query if the current query is empty.

        Returns:
            SearchQuery: New query wrapped in parentheses

        Example:
            >>> query = SearchQuery().query("cancer").or_(SearchQuery().query("tumor")).group()
            >>> query.build()
            '((cancer) OR (tumor))'

            >>> # Controlling precedence
            >>> q1 = SearchQuery().query("a").or_(SearchQuery().query("b")).group()
            >>> q2 = SearchQuery().query("c").or_(SearchQuery().query("d")).group()
            >>> result = q1.and_(q2)
            >>> result.build()
            '(((a) OR (b))) AND (((c) OR (d)))'
        """

class Table:
    r"""
    Python wrapper for Table
    """

    id: builtins.str
    label: typing.Optional[builtins.str]
    caption: builtins.str
    def __repr__(self) -> builtins.str: ...
