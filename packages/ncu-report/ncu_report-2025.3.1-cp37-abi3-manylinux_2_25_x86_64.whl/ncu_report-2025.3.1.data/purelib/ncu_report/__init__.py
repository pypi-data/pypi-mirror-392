# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.


# Copyright (c) 2020-2021, NVIDIA CORPORATION. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#  * Neither the name of NVIDIA CORPORATION nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ncu_report
else:
    import _ncu_report

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_SwigPyIterator

    def value(self):
        return _ncu_report.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ncu_report.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ncu_report.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ncu_report.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ncu_report.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ncu_report.SwigPyIterator_copy(self)

    def next(self):
        return _ncu_report.SwigPyIterator_next(self)

    def __next__(self):
        return _ncu_report.SwigPyIterator___next__(self)

    def previous(self):
        return _ncu_report.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ncu_report.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ncu_report.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ncu_report.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ncu_report.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ncu_report.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ncu_report.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ncu_report.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _ncu_report:
_ncu_report.SwigPyIterator_swigregister(SwigPyIterator)
class map_string_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.map_string_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.map_string_string___nonzero__(self)

    def __bool__(self):
        return _ncu_report.map_string_string___bool__(self)

    def __len__(self):
        return _ncu_report.map_string_string___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _ncu_report.map_string_string___getitem__(self, key)

    def __delitem__(self, key):
        return _ncu_report.map_string_string___delitem__(self, key)

    def has_key(self, key):
        return _ncu_report.map_string_string_has_key(self, key)

    def keys(self):
        return _ncu_report.map_string_string_keys(self)

    def values(self):
        return _ncu_report.map_string_string_values(self)

    def items(self):
        return _ncu_report.map_string_string_items(self)

    def __contains__(self, key):
        return _ncu_report.map_string_string___contains__(self, key)

    def key_iterator(self):
        return _ncu_report.map_string_string_key_iterator(self)

    def value_iterator(self):
        return _ncu_report.map_string_string_value_iterator(self)

    def __setitem__(self, *args):
        return _ncu_report.map_string_string___setitem__(self, *args)

    def asdict(self):
        return _ncu_report.map_string_string_asdict(self)

    def __init__(self, *args):
        _ncu_report.map_string_string_swiginit(self, _ncu_report.new_map_string_string(*args))

    def empty(self):
        return _ncu_report.map_string_string_empty(self)

    def size(self):
        return _ncu_report.map_string_string_size(self)

    def swap(self, v):
        return _ncu_report.map_string_string_swap(self, v)

    def begin(self):
        return _ncu_report.map_string_string_begin(self)

    def end(self):
        return _ncu_report.map_string_string_end(self)

    def rbegin(self):
        return _ncu_report.map_string_string_rbegin(self)

    def rend(self):
        return _ncu_report.map_string_string_rend(self)

    def clear(self):
        return _ncu_report.map_string_string_clear(self)

    def get_allocator(self):
        return _ncu_report.map_string_string_get_allocator(self)

    def count(self, x):
        return _ncu_report.map_string_string_count(self, x)

    def erase(self, *args):
        return _ncu_report.map_string_string_erase(self, *args)

    def find(self, x):
        return _ncu_report.map_string_string_find(self, x)

    def lower_bound(self, x):
        return _ncu_report.map_string_string_lower_bound(self, x)

    def upper_bound(self, x):
        return _ncu_report.map_string_string_upper_bound(self, x)
    __swig_destroy__ = _ncu_report.delete_map_string_string

# Register map_string_string in _ncu_report:
_ncu_report.map_string_string_swigregister(map_string_string)
class set_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.set_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.set_string___nonzero__(self)

    def __bool__(self):
        return _ncu_report.set_string___bool__(self)

    def __len__(self):
        return _ncu_report.set_string___len__(self)

    def append(self, x):
        return _ncu_report.set_string_append(self, x)

    def __contains__(self, x):
        return _ncu_report.set_string___contains__(self, x)

    def __getitem__(self, i):
        return _ncu_report.set_string___getitem__(self, i)

    def add(self, x):
        return _ncu_report.set_string_add(self, x)

    def discard(self, x):
        return _ncu_report.set_string_discard(self, x)

    def __init__(self, *args):
        _ncu_report.set_string_swiginit(self, _ncu_report.new_set_string(*args))

    def empty(self):
        return _ncu_report.set_string_empty(self)

    def size(self):
        return _ncu_report.set_string_size(self)

    def clear(self):
        return _ncu_report.set_string_clear(self)

    def swap(self, v):
        return _ncu_report.set_string_swap(self, v)

    def count(self, x):
        return _ncu_report.set_string_count(self, x)

    def begin(self):
        return _ncu_report.set_string_begin(self)

    def end(self):
        return _ncu_report.set_string_end(self)

    def rbegin(self):
        return _ncu_report.set_string_rbegin(self)

    def rend(self):
        return _ncu_report.set_string_rend(self)

    def erase(self, *args):
        return _ncu_report.set_string_erase(self, *args)

    def find(self, x):
        return _ncu_report.set_string_find(self, x)

    def lower_bound(self, x):
        return _ncu_report.set_string_lower_bound(self, x)

    def upper_bound(self, x):
        return _ncu_report.set_string_upper_bound(self, x)

    def equal_range(self, x):
        return _ncu_report.set_string_equal_range(self, x)

    def insert(self, __x):
        return _ncu_report.set_string_insert(self, __x)
    __swig_destroy__ = _ncu_report.delete_set_string

# Register set_string in _ncu_report:
_ncu_report.set_string_swigregister(set_string)
class set_ull(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.set_ull_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.set_ull___nonzero__(self)

    def __bool__(self):
        return _ncu_report.set_ull___bool__(self)

    def __len__(self):
        return _ncu_report.set_ull___len__(self)

    def append(self, x):
        return _ncu_report.set_ull_append(self, x)

    def __contains__(self, x):
        return _ncu_report.set_ull___contains__(self, x)

    def __getitem__(self, i):
        return _ncu_report.set_ull___getitem__(self, i)

    def add(self, x):
        return _ncu_report.set_ull_add(self, x)

    def discard(self, x):
        return _ncu_report.set_ull_discard(self, x)

    def __init__(self, *args):
        _ncu_report.set_ull_swiginit(self, _ncu_report.new_set_ull(*args))

    def empty(self):
        return _ncu_report.set_ull_empty(self)

    def size(self):
        return _ncu_report.set_ull_size(self)

    def clear(self):
        return _ncu_report.set_ull_clear(self)

    def swap(self, v):
        return _ncu_report.set_ull_swap(self, v)

    def count(self, x):
        return _ncu_report.set_ull_count(self, x)

    def begin(self):
        return _ncu_report.set_ull_begin(self)

    def end(self):
        return _ncu_report.set_ull_end(self)

    def rbegin(self):
        return _ncu_report.set_ull_rbegin(self)

    def rend(self):
        return _ncu_report.set_ull_rend(self)

    def erase(self, *args):
        return _ncu_report.set_ull_erase(self, *args)

    def find(self, x):
        return _ncu_report.set_ull_find(self, x)

    def lower_bound(self, x):
        return _ncu_report.set_ull_lower_bound(self, x)

    def upper_bound(self, x):
        return _ncu_report.set_ull_upper_bound(self, x)

    def equal_range(self, x):
        return _ncu_report.set_ull_equal_range(self, x)

    def insert(self, __x):
        return _ncu_report.set_ull_insert(self, __x)
    __swig_destroy__ = _ncu_report.delete_set_ull

# Register set_ull in _ncu_report:
_ncu_report.set_ull_swigregister(set_ull)
class vector_double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_double___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_double___bool__(self)

    def __len__(self):
        return _ncu_report.vector_double___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_double___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_double___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_double___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_double___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_double___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_double___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_double_pop(self)

    def append(self, x):
        return _ncu_report.vector_double_append(self, x)

    def empty(self):
        return _ncu_report.vector_double_empty(self)

    def size(self):
        return _ncu_report.vector_double_size(self)

    def swap(self, v):
        return _ncu_report.vector_double_swap(self, v)

    def begin(self):
        return _ncu_report.vector_double_begin(self)

    def end(self):
        return _ncu_report.vector_double_end(self)

    def rbegin(self):
        return _ncu_report.vector_double_rbegin(self)

    def rend(self):
        return _ncu_report.vector_double_rend(self)

    def clear(self):
        return _ncu_report.vector_double_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_double_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_double_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_double_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_double_swiginit(self, _ncu_report.new_vector_double(*args))

    def push_back(self, x):
        return _ncu_report.vector_double_push_back(self, x)

    def front(self):
        return _ncu_report.vector_double_front(self)

    def back(self):
        return _ncu_report.vector_double_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_double_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_double_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_double_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_double_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_double_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_double

# Register vector_double in _ncu_report:
_ncu_report.vector_double_swigregister(vector_double)
class vector_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_string___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_string___bool__(self)

    def __len__(self):
        return _ncu_report.vector_string___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_string___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_string___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_string___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_string___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_string___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_string___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_string_pop(self)

    def append(self, x):
        return _ncu_report.vector_string_append(self, x)

    def empty(self):
        return _ncu_report.vector_string_empty(self)

    def size(self):
        return _ncu_report.vector_string_size(self)

    def swap(self, v):
        return _ncu_report.vector_string_swap(self, v)

    def begin(self):
        return _ncu_report.vector_string_begin(self)

    def end(self):
        return _ncu_report.vector_string_end(self)

    def rbegin(self):
        return _ncu_report.vector_string_rbegin(self)

    def rend(self):
        return _ncu_report.vector_string_rend(self)

    def clear(self):
        return _ncu_report.vector_string_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_string_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_string_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_string_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_string_swiginit(self, _ncu_report.new_vector_string(*args))

    def push_back(self, x):
        return _ncu_report.vector_string_push_back(self, x)

    def front(self):
        return _ncu_report.vector_string_front(self)

    def back(self):
        return _ncu_report.vector_string_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_string_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_string_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_string_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_string_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_string_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_string

# Register vector_string in _ncu_report:
_ncu_report.vector_string_swigregister(vector_string)
class vector_ull(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_ull_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_ull___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_ull___bool__(self)

    def __len__(self):
        return _ncu_report.vector_ull___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_ull___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_ull___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_ull___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_ull___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_ull___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_ull___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_ull_pop(self)

    def append(self, x):
        return _ncu_report.vector_ull_append(self, x)

    def empty(self):
        return _ncu_report.vector_ull_empty(self)

    def size(self):
        return _ncu_report.vector_ull_size(self)

    def swap(self, v):
        return _ncu_report.vector_ull_swap(self, v)

    def begin(self):
        return _ncu_report.vector_ull_begin(self)

    def end(self):
        return _ncu_report.vector_ull_end(self)

    def rbegin(self):
        return _ncu_report.vector_ull_rbegin(self)

    def rend(self):
        return _ncu_report.vector_ull_rend(self)

    def clear(self):
        return _ncu_report.vector_ull_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_ull_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_ull_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_ull_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_ull_swiginit(self, _ncu_report.new_vector_ull(*args))

    def push_back(self, x):
        return _ncu_report.vector_ull_push_back(self, x)

    def front(self):
        return _ncu_report.vector_ull_front(self)

    def back(self):
        return _ncu_report.vector_ull_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_ull_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_ull_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_ull_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_ull_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_ull_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_ull

# Register vector_ull in _ncu_report:
_ncu_report.vector_ull_swigregister(vector_ull)
class vector_source_marker(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_source_marker_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_source_marker___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_source_marker___bool__(self)

    def __len__(self):
        return _ncu_report.vector_source_marker___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_source_marker___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_source_marker___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_source_marker___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_source_marker___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_source_marker___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_source_marker___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_source_marker_pop(self)

    def append(self, x):
        return _ncu_report.vector_source_marker_append(self, x)

    def empty(self):
        return _ncu_report.vector_source_marker_empty(self)

    def size(self):
        return _ncu_report.vector_source_marker_size(self)

    def swap(self, v):
        return _ncu_report.vector_source_marker_swap(self, v)

    def begin(self):
        return _ncu_report.vector_source_marker_begin(self)

    def end(self):
        return _ncu_report.vector_source_marker_end(self)

    def rbegin(self):
        return _ncu_report.vector_source_marker_rbegin(self)

    def rend(self):
        return _ncu_report.vector_source_marker_rend(self)

    def clear(self):
        return _ncu_report.vector_source_marker_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_source_marker_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_source_marker_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_source_marker_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_source_marker_swiginit(self, _ncu_report.new_vector_source_marker(*args))

    def push_back(self, x):
        return _ncu_report.vector_source_marker_push_back(self, x)

    def front(self):
        return _ncu_report.vector_source_marker_front(self)

    def back(self):
        return _ncu_report.vector_source_marker_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_source_marker_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_source_marker_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_source_marker_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_source_marker_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_source_marker_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_source_marker

# Register vector_source_marker in _ncu_report:
_ncu_report.vector_source_marker_swigregister(vector_source_marker)
class vector_longlong(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_longlong_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_longlong___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_longlong___bool__(self)

    def __len__(self):
        return _ncu_report.vector_longlong___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_longlong___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_longlong___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_longlong___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_longlong___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_longlong___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_longlong___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_longlong_pop(self)

    def append(self, x):
        return _ncu_report.vector_longlong_append(self, x)

    def empty(self):
        return _ncu_report.vector_longlong_empty(self)

    def size(self):
        return _ncu_report.vector_longlong_size(self)

    def swap(self, v):
        return _ncu_report.vector_longlong_swap(self, v)

    def begin(self):
        return _ncu_report.vector_longlong_begin(self)

    def end(self):
        return _ncu_report.vector_longlong_end(self)

    def rbegin(self):
        return _ncu_report.vector_longlong_rbegin(self)

    def rend(self):
        return _ncu_report.vector_longlong_rend(self)

    def clear(self):
        return _ncu_report.vector_longlong_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_longlong_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_longlong_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_longlong_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_longlong_swiginit(self, _ncu_report.new_vector_longlong(*args))

    def push_back(self, x):
        return _ncu_report.vector_longlong_push_back(self, x)

    def front(self):
        return _ncu_report.vector_longlong_front(self)

    def back(self):
        return _ncu_report.vector_longlong_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_longlong_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_longlong_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_longlong_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_longlong_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_longlong_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_longlong

# Register vector_longlong in _ncu_report:
_ncu_report.vector_longlong_swigregister(vector_longlong)
class vector_iruleresult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_iruleresult_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_iruleresult___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_iruleresult___bool__(self)

    def __len__(self):
        return _ncu_report.vector_iruleresult___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_iruleresult___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_iruleresult___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_iruleresult___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_iruleresult___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_iruleresult___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_iruleresult___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_iruleresult_pop(self)

    def append(self, x):
        return _ncu_report.vector_iruleresult_append(self, x)

    def empty(self):
        return _ncu_report.vector_iruleresult_empty(self)

    def size(self):
        return _ncu_report.vector_iruleresult_size(self)

    def swap(self, v):
        return _ncu_report.vector_iruleresult_swap(self, v)

    def begin(self):
        return _ncu_report.vector_iruleresult_begin(self)

    def end(self):
        return _ncu_report.vector_iruleresult_end(self)

    def rbegin(self):
        return _ncu_report.vector_iruleresult_rbegin(self)

    def rend(self):
        return _ncu_report.vector_iruleresult_rend(self)

    def clear(self):
        return _ncu_report.vector_iruleresult_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_iruleresult_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_iruleresult_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_iruleresult_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_iruleresult_swiginit(self, _ncu_report.new_vector_iruleresult(*args))

    def push_back(self, x):
        return _ncu_report.vector_iruleresult_push_back(self, x)

    def front(self):
        return _ncu_report.vector_iruleresult_front(self)

    def back(self):
        return _ncu_report.vector_iruleresult_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_iruleresult_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_iruleresult_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_iruleresult_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_iruleresult_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_iruleresult_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_iruleresult

# Register vector_iruleresult in _ncu_report:
_ncu_report.vector_iruleresult_swigregister(vector_iruleresult)
class vector_focus_metric(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_focus_metric_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_focus_metric___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_focus_metric___bool__(self)

    def __len__(self):
        return _ncu_report.vector_focus_metric___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_focus_metric___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_focus_metric___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_focus_metric___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_focus_metric___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_focus_metric___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_focus_metric___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_focus_metric_pop(self)

    def append(self, x):
        return _ncu_report.vector_focus_metric_append(self, x)

    def empty(self):
        return _ncu_report.vector_focus_metric_empty(self)

    def size(self):
        return _ncu_report.vector_focus_metric_size(self)

    def swap(self, v):
        return _ncu_report.vector_focus_metric_swap(self, v)

    def begin(self):
        return _ncu_report.vector_focus_metric_begin(self)

    def end(self):
        return _ncu_report.vector_focus_metric_end(self)

    def rbegin(self):
        return _ncu_report.vector_focus_metric_rbegin(self)

    def rend(self):
        return _ncu_report.vector_focus_metric_rend(self)

    def clear(self):
        return _ncu_report.vector_focus_metric_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_focus_metric_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_focus_metric_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_focus_metric_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_focus_metric_swiginit(self, _ncu_report.new_vector_focus_metric(*args))

    def push_back(self, x):
        return _ncu_report.vector_focus_metric_push_back(self, x)

    def front(self):
        return _ncu_report.vector_focus_metric_front(self)

    def back(self):
        return _ncu_report.vector_focus_metric_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_focus_metric_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_focus_metric_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_focus_metric_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_focus_metric_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_focus_metric_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_focus_metric

# Register vector_focus_metric in _ncu_report:
_ncu_report.vector_focus_metric_swigregister(vector_focus_metric)
class vector_rule_result_table_columns(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_rule_result_table_columns_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_rule_result_table_columns___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_rule_result_table_columns___bool__(self)

    def __len__(self):
        return _ncu_report.vector_rule_result_table_columns___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_rule_result_table_columns___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_rule_result_table_columns___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_rule_result_table_columns___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_rule_result_table_columns___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_rule_result_table_columns___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_rule_result_table_columns___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_rule_result_table_columns_pop(self)

    def append(self, x):
        return _ncu_report.vector_rule_result_table_columns_append(self, x)

    def empty(self):
        return _ncu_report.vector_rule_result_table_columns_empty(self)

    def size(self):
        return _ncu_report.vector_rule_result_table_columns_size(self)

    def swap(self, v):
        return _ncu_report.vector_rule_result_table_columns_swap(self, v)

    def begin(self):
        return _ncu_report.vector_rule_result_table_columns_begin(self)

    def end(self):
        return _ncu_report.vector_rule_result_table_columns_end(self)

    def rbegin(self):
        return _ncu_report.vector_rule_result_table_columns_rbegin(self)

    def rend(self):
        return _ncu_report.vector_rule_result_table_columns_rend(self)

    def clear(self):
        return _ncu_report.vector_rule_result_table_columns_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_rule_result_table_columns_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_rule_result_table_columns_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_rule_result_table_columns_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_rule_result_table_columns_swiginit(self, _ncu_report.new_vector_rule_result_table_columns(*args))

    def push_back(self, x):
        return _ncu_report.vector_rule_result_table_columns_push_back(self, x)

    def front(self):
        return _ncu_report.vector_rule_result_table_columns_front(self)

    def back(self):
        return _ncu_report.vector_rule_result_table_columns_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_rule_result_table_columns_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_rule_result_table_columns_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_rule_result_table_columns_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_rule_result_table_columns_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_rule_result_table_columns_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_rule_result_table_columns

# Register vector_rule_result_table_columns in _ncu_report:
_ncu_report.vector_rule_result_table_columns_swigregister(vector_rule_result_table_columns)
class vector_rule_result_table(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_rule_result_table_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_rule_result_table___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_rule_result_table___bool__(self)

    def __len__(self):
        return _ncu_report.vector_rule_result_table___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_rule_result_table___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_rule_result_table___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_rule_result_table___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_rule_result_table___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_rule_result_table___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_rule_result_table___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_rule_result_table_pop(self)

    def append(self, x):
        return _ncu_report.vector_rule_result_table_append(self, x)

    def empty(self):
        return _ncu_report.vector_rule_result_table_empty(self)

    def size(self):
        return _ncu_report.vector_rule_result_table_size(self)

    def swap(self, v):
        return _ncu_report.vector_rule_result_table_swap(self, v)

    def begin(self):
        return _ncu_report.vector_rule_result_table_begin(self)

    def end(self):
        return _ncu_report.vector_rule_result_table_end(self)

    def rbegin(self):
        return _ncu_report.vector_rule_result_table_rbegin(self)

    def rend(self):
        return _ncu_report.vector_rule_result_table_rend(self)

    def clear(self):
        return _ncu_report.vector_rule_result_table_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_rule_result_table_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_rule_result_table_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_rule_result_table_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_rule_result_table_swiginit(self, _ncu_report.new_vector_rule_result_table(*args))

    def push_back(self, x):
        return _ncu_report.vector_rule_result_table_push_back(self, x)

    def front(self):
        return _ncu_report.vector_rule_result_table_front(self)

    def back(self):
        return _ncu_report.vector_rule_result_table_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_rule_result_table_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_rule_result_table_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_rule_result_table_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_rule_result_table_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_rule_result_table_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_rule_result_table

# Register vector_rule_result_table in _ncu_report:
_ncu_report.vector_rule_result_table_swigregister(vector_rule_result_table)
class vector_imetric(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _ncu_report.vector_imetric_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _ncu_report.vector_imetric___nonzero__(self)

    def __bool__(self):
        return _ncu_report.vector_imetric___bool__(self)

    def __len__(self):
        return _ncu_report.vector_imetric___len__(self)

    def __getslice__(self, i, j):
        return _ncu_report.vector_imetric___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _ncu_report.vector_imetric___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _ncu_report.vector_imetric___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _ncu_report.vector_imetric___delitem__(self, *args)

    def __getitem__(self, *args):
        return _ncu_report.vector_imetric___getitem__(self, *args)

    def __setitem__(self, *args):
        return _ncu_report.vector_imetric___setitem__(self, *args)

    def pop(self):
        return _ncu_report.vector_imetric_pop(self)

    def append(self, x):
        return _ncu_report.vector_imetric_append(self, x)

    def empty(self):
        return _ncu_report.vector_imetric_empty(self)

    def size(self):
        return _ncu_report.vector_imetric_size(self)

    def swap(self, v):
        return _ncu_report.vector_imetric_swap(self, v)

    def begin(self):
        return _ncu_report.vector_imetric_begin(self)

    def end(self):
        return _ncu_report.vector_imetric_end(self)

    def rbegin(self):
        return _ncu_report.vector_imetric_rbegin(self)

    def rend(self):
        return _ncu_report.vector_imetric_rend(self)

    def clear(self):
        return _ncu_report.vector_imetric_clear(self)

    def get_allocator(self):
        return _ncu_report.vector_imetric_get_allocator(self)

    def pop_back(self):
        return _ncu_report.vector_imetric_pop_back(self)

    def erase(self, *args):
        return _ncu_report.vector_imetric_erase(self, *args)

    def __init__(self, *args):
        _ncu_report.vector_imetric_swiginit(self, _ncu_report.new_vector_imetric(*args))

    def push_back(self, x):
        return _ncu_report.vector_imetric_push_back(self, x)

    def front(self):
        return _ncu_report.vector_imetric_front(self)

    def back(self):
        return _ncu_report.vector_imetric_back(self)

    def assign(self, n, x):
        return _ncu_report.vector_imetric_assign(self, n, x)

    def resize(self, *args):
        return _ncu_report.vector_imetric_resize(self, *args)

    def insert(self, *args):
        return _ncu_report.vector_imetric_insert(self, *args)

    def reserve(self, n):
        return _ncu_report.vector_imetric_reserve(self, n)

    def capacity(self):
        return _ncu_report.vector_imetric_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_imetric

# Register vector_imetric in _ncu_report:
_ncu_report.vector_imetric_swigregister(vector_imetric)

def load_report(file_name, library_dir):
    return _ncu_report.load_report(file_name, library_dir)
import platform
from pathlib import Path


def __get_library_dir_and_load(load_func):
    ncu_os_from_python = {
        'Linux': 'linux',
        'Windows': 'windows',
        'Darwin': 'osx',
    }

    ncu_os_to_nvperf_host_filename = {
        'linux': "libnvperf_host.so",
        'osx': "libnvperf_host.dylib",
        'windows': "nvperf_host.dll",
    }

    ncu_arch_from_python = {
        'x86_64': 'x64',
        'AMD64': 'x64',
        'aarch64': 'a64',
        'ARM64': 'a64',
    }

    def __get_library_dir():
# Try and use the 'nvperf_host' library in the same folder as this file.
# If not found, assume the 'nvperf_host' library is located at
# '../' (for OSX) or
# '../../target/<var>/' (or all other OSes)
# relative to the 'ncu_report' module.

        os = ncu_os_from_python[platform.system()]
        if os == 'osx':
            library_path_not_found_error = FileNotFoundError(
                "Could not deduce NVIDIA Nsight Compute library directory. "
                "Is 'ncu_report.py' located in 'Contents/MacOS/python' relative "
                "to your installation directory?"
            )
        else:
            library_path_not_found_error = FileNotFoundError(
                "Could not deduce NVIDIA Nsight Compute library directory. "
                "Is 'ncu_report.py' located in 'extras/python' relative "
                "to your installation directory?"
            )

# Get the directory in which the imported module 'ncu_report' resides
        module_dir = Path(__file__).parent

# Check if the lib is in the same dir as the module.
        nvperf_host_path = ncu_os_to_nvperf_host_filename.get(os)
        if nvperf_host_path is not None:
            if (module_dir / nvperf_host_path).is_file():
                return str(module_dir)

        if os == 'osx':
            if len(module_dir.parents) < 1:
                raise library_path_not_found_error
            host_or_target_dir = module_dir.parents[0]
        else:
            if len(module_dir.parents) < 2:
                raise library_path_not_found_error
            host_or_target_dir = module_dir.parents[1].joinpath("target")

        if not host_or_target_dir.is_dir():
            raise library_path_not_found_error

        if os == 'osx':
            return str(host_or_target_dir)

# Filter any directories starting with 'target' as NSYS places their target
# files for local activities in the host directory
        var_dirs = [sub_dir for sub_dir in host_or_target_dir.iterdir() \
                    if sub_dir.is_dir() and not sub_dir.stem.startswith("target")]

# assume there is one and only one '<var>/' directory for the current
# operating system and architecture
        arch = ncu_arch_from_python[platform.machine()]
        for var_dir in var_dirs:
            var_name = var_dir.stem
            if (os in var_name) and (arch in var_name):
                library_dir = str(var_dir)
                break

        if not library_dir:
            raise FileNotFoundError("Could not find any build variant for your system.")

        return library_dir

    def __convert_Path_to_str(file_name):
        if isinstance(file_name, Path):
            file_name = str(file_name)
        return file_name

    def __raise_if_file_does_not_exist(file_name):
        if not Path(file_name).exists():
            raise FileNotFoundError(
                "Could not load report file: {} does not exist.".format(file_name)
            )

    def load_report(file_name):
        """Load an NVIDIA Nsight Compute report file into an :class:`IContext`
        object.

        Args:
            file_name (:class:`str` | :class:`pathlib.Path`): The relative or absolute path to the
                ``.ncu-rep`` report file.

        Returns:
            :class:`IContext`: An :class:`IContext` object representing the
            loaded report file.

        Raises:
            :exc:`FileNotFoundError`: Either if ``file_name`` does not exist or
                if the NVIDIA Nsight Compute library directory cannot be found.
        """
        file_name = __convert_Path_to_str(file_name)
        __raise_if_file_does_not_exist(file_name)
        library_dir = __get_library_dir()
        return load_func(file_name=file_name, library_dir=library_dir)

    return load_report


load_report = __get_library_dir_and_load(load_report)

FocusSeverity_DEFAULT = _ncu_report.FocusSeverity_DEFAULT
FocusSeverity_LOW = _ncu_report.FocusSeverity_LOW
FocusSeverity_HIGH = _ncu_report.FocusSeverity_HIGH
SpeedupType_UNKNOWN = _ncu_report.SpeedupType_UNKNOWN
SpeedupType_LOCAL = _ncu_report.SpeedupType_LOCAL
SpeedupType_GLOBAL = _ncu_report.SpeedupType_GLOBAL
class RuleResultFocusMetric(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ncu_report.RuleResultFocusMetric_name_get, _ncu_report.RuleResultFocusMetric_name_set)
    value = property(_ncu_report.RuleResultFocusMetric_value_get, _ncu_report.RuleResultFocusMetric_value_set)
    severity = property(_ncu_report.RuleResultFocusMetric_severity_get, _ncu_report.RuleResultFocusMetric_severity_set)
    info = property(_ncu_report.RuleResultFocusMetric_info_get, _ncu_report.RuleResultFocusMetric_info_set)

    def __init__(self):
        _ncu_report.RuleResultFocusMetric_swiginit(self, _ncu_report.new_RuleResultFocusMetric())
    __swig_destroy__ = _ncu_report.delete_RuleResultFocusMetric

# Register RuleResultFocusMetric in _ncu_report:
_ncu_report.RuleResultFocusMetric_swigregister(RuleResultFocusMetric)
class RuleResultSpeedup(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_ncu_report.RuleResultSpeedup_type_get, _ncu_report.RuleResultSpeedup_type_set)
    speedup = property(_ncu_report.RuleResultSpeedup_speedup_get, _ncu_report.RuleResultSpeedup_speedup_set)

    def __init__(self):
        _ncu_report.RuleResultSpeedup_swiginit(self, _ncu_report.new_RuleResultSpeedup())
    __swig_destroy__ = _ncu_report.delete_RuleResultSpeedup

# Register RuleResultSpeedup in _ncu_report:
_ncu_report.RuleResultSpeedup_swigregister(RuleResultSpeedup)
class RuleResultTableColumn(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    header = property(_ncu_report.RuleResultTableColumn_header_get, _ncu_report.RuleResultTableColumn_header_set)
    string_values = property(_ncu_report.RuleResultTableColumn_string_values_get, _ncu_report.RuleResultTableColumn_string_values_set)
    double_values = property(_ncu_report.RuleResultTableColumn_double_values_get, _ncu_report.RuleResultTableColumn_double_values_set)
    int_values = property(_ncu_report.RuleResultTableColumn_int_values_get, _ncu_report.RuleResultTableColumn_int_values_set)

    def __init__(self):
        _ncu_report.RuleResultTableColumn_swiginit(self, _ncu_report.new_RuleResultTableColumn())
    __swig_destroy__ = _ncu_report.delete_RuleResultTableColumn

# Register RuleResultTableColumn in _ncu_report:
_ncu_report.RuleResultTableColumn_swigregister(RuleResultTableColumn)
class RuleResultTable(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    title = property(_ncu_report.RuleResultTable_title_get, _ncu_report.RuleResultTable_title_set)
    description = property(_ncu_report.RuleResultTable_description_get, _ncu_report.RuleResultTable_description_set)
    columns = property(_ncu_report.RuleResultTable_columns_get, _ncu_report.RuleResultTable_columns_set)

    def __init__(self):
        _ncu_report.RuleResultTable_swiginit(self, _ncu_report.new_RuleResultTable())
    __swig_destroy__ = _ncu_report.delete_RuleResultTable

# Register RuleResultTable in _ncu_report:
_ncu_report.RuleResultTable_swigregister(RuleResultTable)
TableElementKind_INVALID = _ncu_report.TableElementKind_INVALID
TableElementKind_DOUBLE = _ncu_report.TableElementKind_DOUBLE
TableElementKind_INT = _ncu_report.TableElementKind_INT
TableElementKind_STRING = _ncu_report.TableElementKind_STRING
TableElementKind_CUSTOM = _ncu_report.TableElementKind_CUSTOM
class TableSortInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    column = property(_ncu_report.TableSortInfo_column_get, _ncu_report.TableSortInfo_column_set)
    is_ascending = property(_ncu_report.TableSortInfo_is_ascending_get, _ncu_report.TableSortInfo_is_ascending_set)

    def __init__(self):
        _ncu_report.TableSortInfo_swiginit(self, _ncu_report.new_TableSortInfo())
    __swig_destroy__ = _ncu_report.delete_TableSortInfo

# Register TableSortInfo in _ncu_report:
_ncu_report.TableSortInfo_swigregister(TableSortInfo)
class TableStyle(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_bold = property(_ncu_report.TableStyle_is_bold_get, _ncu_report.TableStyle_is_bold_set)
    is_italic = property(_ncu_report.TableStyle_is_italic_get, _ncu_report.TableStyle_is_italic_set)

    def __init__(self):
        _ncu_report.TableStyle_swiginit(self, _ncu_report.new_TableStyle())
    __swig_destroy__ = _ncu_report.delete_TableStyle

# Register TableStyle in _ncu_report:
_ncu_report.TableStyle_swigregister(TableStyle)
class TableColumnConfig(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tooltip = property(_ncu_report.TableColumnConfig_tooltip_get, _ncu_report.TableColumnConfig_tooltip_set)
    relative_width = property(_ncu_report.TableColumnConfig_relative_width_get, _ncu_report.TableColumnConfig_relative_width_set)
    header_style = property(_ncu_report.TableColumnConfig_header_style_get, _ncu_report.TableColumnConfig_header_style_set)
    data_style = property(_ncu_report.TableColumnConfig_data_style_get, _ncu_report.TableColumnConfig_data_style_set)

    def __init__(self):
        _ncu_report.TableColumnConfig_swiginit(self, _ncu_report.new_TableColumnConfig())
    __swig_destroy__ = _ncu_report.delete_TableColumnConfig

# Register TableColumnConfig in _ncu_report:
_ncu_report.TableColumnConfig_swigregister(TableColumnConfig)
class TableConfig(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    title = property(_ncu_report.TableConfig_title_get, _ncu_report.TableConfig_title_set)
    description = property(_ncu_report.TableConfig_description_get, _ncu_report.TableConfig_description_set)
    use_sorting = property(_ncu_report.TableConfig_use_sorting_get, _ncu_report.TableConfig_use_sorting_set)
    sort_by = property(_ncu_report.TableConfig_sort_by_get, _ncu_report.TableConfig_sort_by_set)
    use_styling = property(_ncu_report.TableConfig_use_styling_get, _ncu_report.TableConfig_use_styling_set)
    style = property(_ncu_report.TableConfig_style_get, _ncu_report.TableConfig_style_set)

    def __init__(self):
        _ncu_report.TableConfig_swiginit(self, _ncu_report.new_TableConfig())
    __swig_destroy__ = _ncu_report.delete_TableConfig

# Register TableConfig in _ncu_report:
_ncu_report.TableConfig_swigregister(TableConfig)
class TableColumn(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ncu_report.TableColumn_name_get, _ncu_report.TableColumn_name_set)
    kind = property(_ncu_report.TableColumn_kind_get, _ncu_report.TableColumn_kind_set)
    double_values = property(_ncu_report.TableColumn_double_values_get, _ncu_report.TableColumn_double_values_set)
    int_values = property(_ncu_report.TableColumn_int_values_get, _ncu_report.TableColumn_int_values_set)
    string_values = property(_ncu_report.TableColumn_string_values_get, _ncu_report.TableColumn_string_values_set)
    has_column_config = property(_ncu_report.TableColumn_has_column_config_get, _ncu_report.TableColumn_has_column_config_set)
    column_config = property(_ncu_report.TableColumn_column_config_get, _ncu_report.TableColumn_column_config_set)

    def size(self):
        return _ncu_report.TableColumn_size(self)

    def __init__(self):
        _ncu_report.TableColumn_swiginit(self, _ncu_report.new_TableColumn())
    __swig_destroy__ = _ncu_report.delete_TableColumn

# Register TableColumn in _ncu_report:
_ncu_report.TableColumn_swigregister(TableColumn)
class TableData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    columns = property(_ncu_report.TableData_columns_get, _ncu_report.TableData_columns_set)
    has_config = property(_ncu_report.TableData_has_config_get, _ncu_report.TableData_has_config_set)
    config = property(_ncu_report.TableData_config_get, _ncu_report.TableData_config_set)

    def __init__(self):
        _ncu_report.TableData_swiginit(self, _ncu_report.new_TableData())
    __swig_destroy__ = _ncu_report.delete_TableData

# Register TableData in _ncu_report:
_ncu_report.TableData_swigregister(TableData)
RuleKind_DEFAULT = _ncu_report.RuleKind_DEFAULT
RuleKind_GUIDED = _ncu_report.RuleKind_GUIDED
MarkerKind_SASS = _ncu_report.MarkerKind_SASS
MarkerKind_SOURCE = _ncu_report.MarkerKind_SOURCE
MarkerKind_NONE = _ncu_report.MarkerKind_NONE
MsgType_NONE = _ncu_report.MsgType_NONE
MsgType_OK = _ncu_report.MsgType_OK
MsgType_OPTIMIZATION = _ncu_report.MsgType_OPTIMIZATION
MsgType_WARNING = _ncu_report.MsgType_WARNING
MsgType_ERR = _ncu_report.MsgType_ERR
class RuleResultMessage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    title = property(_ncu_report.RuleResultMessage_title_get, _ncu_report.RuleResultMessage_title_set)
    message = property(_ncu_report.RuleResultMessage_message_get, _ncu_report.RuleResultMessage_message_set)
    type = property(_ncu_report.RuleResultMessage_type_get, _ncu_report.RuleResultMessage_type_set)

    def __init__(self):
        _ncu_report.RuleResultMessage_swiginit(self, _ncu_report.new_RuleResultMessage())
    __swig_destroy__ = _ncu_report.delete_RuleResultMessage

# Register RuleResultMessage in _ncu_report:
_ncu_report.RuleResultMessage_swigregister(RuleResultMessage)
class ISourceInfo(object):
    r"""

    Represents the source correlation information for a specific function
    address within an action.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_ISourceInfo

    def file_name(self):
        r"""

        Get the file name, as embedded in the correlation information.

        Returns:
            :class:`str`: The file name.

        """
        return _ncu_report.ISourceInfo_file_name(self)

    def line(self):
        r"""

        Get the line number within the file.

        Returns:
            :class:`int`: The line number.

        """
        return _ncu_report.ISourceInfo_line(self)

# Register ISourceInfo in _ncu_report:
_ncu_report.ISourceInfo_swigregister(ISourceInfo)
class SourceMarker(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rule_identifier = property(_ncu_report.SourceMarker_rule_identifier_get, _ncu_report.SourceMarker_rule_identifier_set)
    section_identifier = property(_ncu_report.SourceMarker_section_identifier_get, _ncu_report.SourceMarker_section_identifier_set)
    kind = property(_ncu_report.SourceMarker_kind_get, _ncu_report.SourceMarker_kind_set)
    message_type = property(_ncu_report.SourceMarker_message_type_get, _ncu_report.SourceMarker_message_type_set)
    message = property(_ncu_report.SourceMarker_message_get, _ncu_report.SourceMarker_message_set)
    source_location = property(_ncu_report.SourceMarker_source_location_get, _ncu_report.SourceMarker_source_location_set)
    source_address = property(_ncu_report.SourceMarker_source_address_get, _ncu_report.SourceMarker_source_address_set)

    def __init__(self):
        _ncu_report.SourceMarker_swiginit(self, _ncu_report.new_SourceMarker())
    __swig_destroy__ = _ncu_report.delete_SourceMarker

# Register SourceMarker in _ncu_report:
_ncu_report.SourceMarker_swigregister(SourceMarker)
class IRuleResult(object):
    r"""

    The :class:`IRuleResult` represents rule results.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IRuleResult

    def rule_identifier(self):
        r"""

        Get the rule identifier.

        Returns:
            :class:`str`: The rule identifier.

        """
        return _ncu_report.IRuleResult_rule_identifier(self)

    def name(self):
        r"""

        Get the rule name.

        Returns:
            :class:`str`: The rule name.

        """
        return _ncu_report.IRuleResult_name(self)

    def section_identifier(self):
        r"""

        Get the section identifier.

        Returns:
            :class:`str`: The section identifier.

        """
        return _ncu_report.IRuleResult_section_identifier(self)

    def has_rule_message(self):
        r"""

        Check if the rule has a message.

        Returns:
            :class:`bool`: :data:`True` if rule message present, :data:`False` otherwise.

        """
        return _ncu_report.IRuleResult_has_rule_message(self)

    def rule_message(self):
        r"""

        Get the rule message.

        Returns:
            :class:`dict`: A dictionary with the following key-value pairs:
                - 'title' : (:class:`str`) The rule message title.
                - 'message' : (:class:`str`) The rule message.

                    The message may contain substrings with the following special link formats:
                        - @url:<hypertext>:<external link>@ - To add a external link for a hypertext.
                        - @sass:<address>:<hypertext>@ - To add a link to the hypertext to open the SASS address line on the Source page.
                        - @source:<file name>:<line number>:<hypertext>@ - To add a link to the hypertext to open the source file at the specified line number on the Source page.
                        - @section:<section identifier>:<hypertext>@ - To add a link to the hypertext to jump to the respective section.

                - 'type' : (:class:`MsgType`) The message type.

        """
        val = _ncu_report.IRuleResult_rule_message(self)

        return {
            "title": val.title,
            "message": val.message,
            "type": val.type,
        }


        return val


    def focus_metrics(self):
        r"""

        Get all the focus metrics details.

        Returns:
            :class:`list` of :class:`dict`: A list of focus metrics details. Each focus metric dictionary contains the following key-value pairs:
                - 'name' : (:class:`str`) The name of the focus metric.
                - 'value' : (:class:`float`) The value of the focus metric.
                - 'severity' : (:class:`FocusSeverity`) The severity of the focus metric.
                - 'info' : (:class:`str`) The information about the focus metric.

        """
        val = _ncu_report.IRuleResult_focus_metrics(self)

        return [
            {
                "name": focus_metric.name,
                "value": focus_metric.value,
                "severity": focus_metric.severity,
                "info": focus_metric.info,
            }
            for focus_metric in val
        ]


        return val


    def has_speedup_estimation(self):
        r"""

        Check if the rule has speedup estimation.

        Returns:
            :class:`bool`: :data:`True` if the rule has speedup estimation, :data:`False` otherwise.

        """
        return _ncu_report.IRuleResult_has_speedup_estimation(self)

    def speedup_estimation(self):
        r"""

        Get the speedup estimation.

        Returns:
            :class:`dict` : A dictionary with the following key-value pairs
                - 'type' : (:class:`SpeedupType`) The speedup type.
                - 'speedup' : (:class:`float`) The estimated speedup.

        """
        val = _ncu_report.IRuleResult_speedup_estimation(self)

        return {
            "type": val.type,
            "speedup": val.speedup,
        }


        return val


    def result_tables(self):
        r"""

        Get all the result tables.

        Returns:
            :class:`list` of :class:`dict`: A list of result tables. Each result table dictionary contains the following key-value pairs:
                - 'title' : (:class:`str`) The title of the result table.
                - 'description' : (:class:`str`) The description of the result table.
                - 'headers' : (:class:`list` of :class:`str`) The column headers of the result table.
                - 'data' : (:class:`list` of :class:`list` [:class:`int` | :class:`float` | :class:`str` | :data:`Any` ]) The table data in row-major format. Each column have elements of the same type.

                    :class:str values may contain substrings with the following special link formats:
                        - @url:<hypertext>:<external link>@ - To add a external link for a hypertext.
                        - @sass:<address>:<hypertext>@ - To add a link to the hypertext to open the SASS address line on the Source page.
                        - @source:<file name>:<line number>:<hypertext>@ - To add a link to the hypertext to open the source file at the specified line number on the Source page.
                        - @section:<section identifier>:<hypertext>@ - To add a link to the hypertext to jump to the respective section.

        """
        val = _ncu_report.IRuleResult_result_tables(self)

        return [
            {
                "title": result_table.title,
                "description": result_table.description,
                "headers": [column.header for column in result_table.columns],
                "data": [
                    list(column.string_values) if column.string_values else
                    list(column.double_values) if column.double_values else
                    list(column.int_values) if column.int_values else []
                    for column in result_table.columns
                ]
            } for result_table in val
        ]


        return val


    def __str__(self):
        """Get a human-readable name of the rule result.

        Returns:
            :class:`str`: The name of the :class:`IRuleResult` object
            represents.
        """
        return self.name()


# Register IRuleResult in _ncu_report:
_ncu_report.IRuleResult_swigregister(IRuleResult)
class IMetric(object):
    r"""

    Represents a single, named metric. An :class:`IMetric` can carry one value
    or multiple ones if it is an instanced metric.

    Attributes:
        MetricType_OTHER (:class:`int`): Metric type for metrics that do not fit
            in any other category.
        MetricType_COUNTER (:class:`int`): Metric type for counter metrics.
        MetricType_RATIO (:class:`int`): Metric type for ratio metrics.
        MetricType_THROUGHPUT (:class:`int`): Metric type for throughput
            metrics.

        MetricSubtype_NONE (:class:`int`): Metric subtype for metrics that do
            not have a subtype.
        MetricSubtype_PEAK_SUSTAINED (:class:`int`): Metric subtype for peak
            sustained metrics.
        MetricSubtype_PEAK_SUSTAINED_ACTIVE (:class:`int`): Metric subtype for
            peak sustained active metrics.
        MetricSubtype_PEAK_SUSTAINED_ACTIVE_PER_SECOND (:class:`int`): Metric
            subtype for peak sustained active per-second metrics.
        MetricSubtype_PEAK_SUSTAINED_ELAPSED (:class:`int`): Metric subtype for
            peak sustained elapsed metrics.
        MetricSubtype_PEAK_SUSTAINED_ELAPSED_PER_SECOND (:class:`int`): Metric
            subtype for peak sustained elapsed per-second metrics.
        MetricSubtype_PER_CYCLE_ACTIVE (:class:`int`): Metric subtype for
            per-cycle active metrics.
        MetricSubtype_PER_CYCLE_ELAPSED (:class:`int`): Metric subtype for
            per-cycle elapsed metrics.
        MetricSubtype_PER_SECOND (:class:`int`): Metric subtype for per-second
            metrics.
        MetricSubtype_PCT_OF_PEAK_SUSTAINED_ACTIVE (:class:`int`): Metric
            subtype for percentage of peak sustained active metrics.
        MetricSubtype_PCT_OF_PEAK_SUSTAINED_ELAPSED (:class:`int`): Metric
            subtype for percentage of peak sustained elapsed metrics.
        MetricSubtype_MAX_RATE (:class:`int`): Metric subtype for max rate
            metrics.
        MetricSubtype_PCT (:class:`int`): Metric subtype for percentage metrics.
        MetricSubtype_RATIO (:class:`int`): Metric subtype for ratio metrics.

        RollupOperation_NONE (:class:`int`): No rollup operation.
        RollupOperation_AVG (:class:`int`): Average rollup operation.
        RollupOperation_MAX (:class:`int`): Maximum rollup operation.
        RollupOperation_MIN (:class:`int`): Minimum rollup operation.
        RollupOperation_SUM (:class:`int`): Sum rollup operation.

        ValueKind_UNKNOWN (:class:`int`): Unknown value kind.
        ValueKind_ANY (:class:`int`): Undefined value kind.
        ValueKind_STRING (:class:`int`): String value kind.
        ValueKind_FLOAT (:class:`int`): Float value kind.
        ValueKind_DOUBLE (:class:`int`): Double value kind.
        ValueKind_UINT32 (:class:`int`): Unsigned 32-bit integer value kind.
        ValueKind_UINT64 (:class:`int`): Unsigned 64-bit integer value kind.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ValueKind_UNKNOWN = _ncu_report.IMetric_ValueKind_UNKNOWN
    ValueKind_ANY = _ncu_report.IMetric_ValueKind_ANY
    ValueKind_STRING = _ncu_report.IMetric_ValueKind_STRING
    ValueKind_FLOAT = _ncu_report.IMetric_ValueKind_FLOAT
    ValueKind_DOUBLE = _ncu_report.IMetric_ValueKind_DOUBLE
    ValueKind_UINT32 = _ncu_report.IMetric_ValueKind_UINT32
    ValueKind_UINT64 = _ncu_report.IMetric_ValueKind_UINT64
    MetricType_OTHER = _ncu_report.IMetric_MetricType_OTHER
    MetricType_COUNTER = _ncu_report.IMetric_MetricType_COUNTER
    MetricType_RATIO = _ncu_report.IMetric_MetricType_RATIO
    MetricType_THROUGHPUT = _ncu_report.IMetric_MetricType_THROUGHPUT
    MetricSubtype_NONE = _ncu_report.IMetric_MetricSubtype_NONE
    MetricSubtype_PEAK_SUSTAINED = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED
    MetricSubtype_PEAK_SUSTAINED_ACTIVE = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_ACTIVE
    MetricSubtype_PEAK_SUSTAINED_ACTIVE_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_ACTIVE_PER_SECOND
    MetricSubtype_PEAK_SUSTAINED_ELAPSED = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_ELAPSED
    MetricSubtype_PEAK_SUSTAINED_ELAPSED_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_ELAPSED_PER_SECOND
    MetricSubtype_PEAK_SUSTAINED_FRAME = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_FRAME
    MetricSubtype_PEAK_SUSTAINED_FRAME_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_FRAME_PER_SECOND
    MetricSubtype_PEAK_SUSTAINED_REGION = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_REGION
    MetricSubtype_PEAK_SUSTAINED_REGION_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_REGION_PER_SECOND
    MetricSubtype_PER_CYCLE_ACTIVE = _ncu_report.IMetric_MetricSubtype_PER_CYCLE_ACTIVE
    MetricSubtype_PER_CYCLE_ELAPSED = _ncu_report.IMetric_MetricSubtype_PER_CYCLE_ELAPSED
    MetricSubtype_PER_CYCLE_IN_FRAME = _ncu_report.IMetric_MetricSubtype_PER_CYCLE_IN_FRAME
    MetricSubtype_PER_CYCLE_IN_REGION = _ncu_report.IMetric_MetricSubtype_PER_CYCLE_IN_REGION
    MetricSubtype_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PER_SECOND
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_ACTIVE = _ncu_report.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_ACTIVE
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_ELAPSED = _ncu_report.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_ELAPSED
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_FRAME = _ncu_report.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_FRAME
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_REGION = _ncu_report.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_REGION
    MetricSubtype_MAX_RATE = _ncu_report.IMetric_MetricSubtype_MAX_RATE
    MetricSubtype_PCT = _ncu_report.IMetric_MetricSubtype_PCT
    MetricSubtype_RATIO = _ncu_report.IMetric_MetricSubtype_RATIO
    RollupOperation_NONE = _ncu_report.IMetric_RollupOperation_NONE
    RollupOperation_AVG = _ncu_report.IMetric_RollupOperation_AVG
    RollupOperation_MAX = _ncu_report.IMetric_RollupOperation_MAX
    RollupOperation_MIN = _ncu_report.IMetric_RollupOperation_MIN
    RollupOperation_SUM = _ncu_report.IMetric_RollupOperation_SUM
    __swig_destroy__ = _ncu_report.delete_IMetric

    def name(self):
        r"""

        Get the metric name.

        Returns:
            :class:`str`: The metric name.

        """
        return _ncu_report.IMetric_name(self)

    def metric_type(self):
        r"""

        Get the metric type.

        Returns:
            :class:`int`: The metric type.

        """
        return _ncu_report.IMetric_metric_type(self)

    def metric_subtype(self):
        r"""

        Get the metric subtype.

        Returns:
            :class:`int`: The metric subtype.

        """
        val = _ncu_report.IMetric_metric_subtype(self)

        if val == self.MetricSubtype_NONE:
            return None


        return val


    def rollup_operation(self):
        r"""

        Get the type of rollup operation for this metric.

        Returns:
            :class:`int`: The rollup operation type.

        """
        val = _ncu_report.IMetric_rollup_operation(self)

        if val == self.RollupOperation_NONE:
            return None


        return val


    def unit(self):
        r"""

        Get the metric unit.

        Returns:
            :class:`str`: The metric unit.

        """
        return _ncu_report.IMetric_unit(self)

    def description(self):
        r"""

        Get the metric description.

        Returns:
            :class:`str`: The description of the metric.

        """
        return _ncu_report.IMetric_description(self)

    def kind(self, *args):
        r"""

        Get the metric or metric instance value kind.

        Args:
            instance (:class:`int`, optional): If provided, the index of the
                instance metric to get the value kind for.

        Returns:
            :class:`int`: The metric or metric instance value kind.

        """
        return _ncu_report.IMetric_kind(self, *args)

    def has_value(self, *args):
        r"""

        Check if the metric or metric instance has a value.

        Args:
            instance (:class:`int`, optional): If provided, the index of the
                instance metric to check.

        Returns:
            :class:`bool`: :data:`True` if the metric or metric instance has a
            value, :data:`False`` otherwise.

        """
        return _ncu_report.IMetric_has_value(self, *args)

    def as_double(self, *args):
        r"""

        Get the metric value or metric instance value as a :class:`float`.

        Args:
            instance (:class:`int`, optional): If provided, the index of the
                instance value to retrieve instead a metric value.

        Returns:
            :class:`float`: The metric value or metric instance value requested. If
            the value cannot be casted to a :class:`float`, this function will
            return ``0.``.

        """
        return _ncu_report.IMetric_as_double(self, *args)

    def as_uint64(self, *args):
        r"""

        Get the metric value or metric instance value as an :class:`int`.

        Args:
            instance (:class:`int`, optional): If provided, the index of the
                instance value to retrieve instead a metric value.

        Returns:
            :class:`int`: The metric value or metric instance value requested. If
            the value cannot be casted to a :class:`int`, this function will
            return ``0``.

        """
        return _ncu_report.IMetric_as_uint64(self, *args)

    def as_string(self, *args):
        r"""

        Get the metric value or metric instance value as a :class:`str`.

        Args:
            instance (:class:`int`, optional): If provided, the index of the
                instance value to retrieve instead a metric value.

        Returns:
            :class:`str` | :data:`None`: The metric value or metric instance value
            requested. If the value cannot be casted to a :class:`str`, this
            function will return :data:`None`.

        """
        return _ncu_report.IMetric_as_string(self, *args)

    def num_instances(self):
        r"""

        Get the number of instance values for this metric.

        Not all metrics have instance values. If a metric has instance values, it
        may also have :meth:`IMetric.correlation_ids` matching these instance
        values.

        Returns:
            :class:`int`: The number of instances for this metric.

        """
        return _ncu_report.IMetric_num_instances(self)

    def has_correlation_ids(self):
        r"""

        Check if the metric has correlation IDs.

        Returns:
            :class:`bool`: :data:`True` if the metric has correlation IDs matching
            its instance values, :data:`False` otherwise.

        """
        return _ncu_report.IMetric_has_correlation_ids(self)

    def correlation_ids(self):
        r"""

        Get a metric object for this metric's instance value's correlation IDs.

        Returns a new :class:`IMetric` representing the correlation IDs for the
        metric's instance values. Use :meth:`IMetric.has_correlation_ids` to check
        if this metric has correlation IDs for its instance values. Correlation IDs
        are used to associate instance values with the instance their value
        represents. In the returned new metric object, the correlation IDs are that
        object's instance values.

        If the metric does not have any correlation IDs, this function will return
        :data:`None`.

        Returns:
            :class:`IMetric` | :data:`None`: The new :class:`IMetric` object
            representing the correlation IDs for this metric's instance values or
            :data:`None` if the metric has no correlation IDs.

        """
        return _ncu_report.IMetric_correlation_ids(self)

    def __str__(self):
        """Get a human-readable representation of this :class:`IMetric`.

        Returns:
            :class:`str`: The name of the :class:`IMetric`.
        """
        return self.name()


    def value(self, idx=None):
        """Get the value of this :class:`IMetric`.

        This is a convenience function that will wrap the logic of invoking the
        correct ``IMetric.as_*`` method based on the value kind of this
        :class:`IMetric`.

        Args:
            idx (:class:`int`, optional): The index of the value to get.

        Returns:
            :class:`str` | :class:`int` | :class:`float` | :data:`None`: The
            value of this :class:`IMetric` as :class:`str`, :class:`int` or
            :class:`float`. If no value is available, this will return
            :data:`None`.
        """
        kind_to_value_func = {
            IMetric.ValueKind_ANY: lambda *args: None,
            IMetric.ValueKind_DOUBLE: IMetric.as_double,
            IMetric.ValueKind_FLOAT: IMetric.as_double,
            IMetric.ValueKind_STRING: IMetric.as_string,
            IMetric.ValueKind_UINT32: IMetric.as_uint64,
            IMetric.ValueKind_UINT64: IMetric.as_uint64,
            IMetric.ValueKind_UNKNOWN: lambda *args: None,
        }

        args = tuple() if idx is None else (idx,)
        return kind_to_value_func[self.kind(*args)](self, *args)


# Register IMetric in _ncu_report:
_ncu_report.IMetric_swigregister(IMetric)
class INvtxRange(object):
    r"""

    Represents a single NVTX Push/Pop or Start/End range.

    Attributes:
        PayloadType_PAYLOAD_UNKNOWN (:class:`int`): Payload type for ranges of unknown type.
        PayloadType_PAYLOAD_INT32 (:class:`int`): Payload type for ranges of INT32 type.
        PayloadType_PAYLOAD_INT64 (:class:`int`): Payload type for ranges of INT64 type.
        PayloadType_PAYLOAD_UINT32 (:class:`int`): Payload type for ranges of UINT32 type.
        PayloadType_PAYLOAD_UINT64 (:class:`int`): Payload type for ranges of UINT64 type.
        PayloadType_PAYLOAD_FLOAT (:class:`int`): Payload type for ranges of float type.
        PayloadType_PAYLOAD_DOUBLE (:class:`int`): Payload type for ranges of double type .
        PayloadType_PAYLOAD_JSON (:class:`int`): Payload type for ranges of JSON type.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    PayloadType_PAYLOAD_UNKNOWN = _ncu_report.INvtxRange_PayloadType_PAYLOAD_UNKNOWN
    PayloadType_PAYLOAD_UINT64 = _ncu_report.INvtxRange_PayloadType_PAYLOAD_UINT64
    PayloadType_PAYLOAD_INT64 = _ncu_report.INvtxRange_PayloadType_PAYLOAD_INT64
    PayloadType_PAYLOAD_DOUBLE = _ncu_report.INvtxRange_PayloadType_PAYLOAD_DOUBLE
    PayloadType_PAYLOAD_UINT32 = _ncu_report.INvtxRange_PayloadType_PAYLOAD_UINT32
    PayloadType_PAYLOAD_INT32 = _ncu_report.INvtxRange_PayloadType_PAYLOAD_INT32
    PayloadType_PAYLOAD_FLOAT = _ncu_report.INvtxRange_PayloadType_PAYLOAD_FLOAT
    PayloadType_PAYLOAD_JSON = _ncu_report.INvtxRange_PayloadType_PAYLOAD_JSON
    __swig_destroy__ = _ncu_report.delete_INvtxRange

    def name(self):
        r"""

        Get the range's name.

        Returns:
            :class:`str`: The range's name.

        """
        return _ncu_report.INvtxRange_name(self)

    def has_attributes(self):
        r"""

        Check if range has event attributes.

        Returns:
            :class:`bool`: :data:`True` if the range has event attributes,
            :data:`False` otherwise.

        """
        return _ncu_report.INvtxRange_has_attributes(self)

    def category(self):
        r"""

        Get the category attribute value.

        Returns:
            :class:`int`: The category attribute value. If
            :meth:`INvtxRange.has_attributes` returns :data:`False`, this will
            return ``0``.

        """
        return _ncu_report.INvtxRange_category(self)

    def color(self):
        r"""

        Get the color attribute value.

        Returns:
            :class:`int`: The color attribute value. If
            :meth:`INvtxRange.has_attributes` returns :data:`False`, this will
            return ``0``.

        """
        return _ncu_report.INvtxRange_color(self)

    def payload_type(self):
        r"""

        Get the payload type as an :class:`int`.

        Returns:
            :class:`int`: The payload type.

        """
        return _ncu_report.INvtxRange_payload_type(self)

    def payload_as_uint64(self):
        r"""

        Get the payload attribute value as an :class:`int`.

        Returns:
            :class:`int`: The payload attribute's value as a :class:`int`. If
            the value cannot be casted to a :class:`int`, this function will
            return ``0``.

        """
        return _ncu_report.INvtxRange_payload_as_uint64(self)

    def payload_as_double(self):
        r"""

        Get the payload attribute value as a :class:`float`.

        Returns:
            :class:`float`: The payload attribute's value as a :class:`float`. If
            the value cannot be casted to a :class:`float`, this function will
            return ``0.``.

        """
        return _ncu_report.INvtxRange_payload_as_double(self)

    def payload_as_string(self):
        r"""

        Get the payload attribute value as a :class:`str`.

        Returns:
            :class:`str`: The payload attribute's value as a :class:`str`. If
            the value cannot be casted to a :class:`str`, this function will
            return the empty string.

        """
        return _ncu_report.INvtxRange_payload_as_string(self)

    def message(self):
        r"""

        Get the message attribute value.

        Returns:
            :class:`str`: The message attribute value. If
            :meth:`INvtxRange.has_attributes` returns :data:`False`, this will
            return the empty string.

        """
        return _ncu_report.INvtxRange_message(self)

# Register INvtxRange in _ncu_report:
_ncu_report.INvtxRange_swigregister(INvtxRange)
class INvtxDomainInfo(object):
    r"""

    Represents a single NVTX domain of the NVTX state, including all ranges
    associated with this domain.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_INvtxDomainInfo

    def name(self):
        r"""

        Get a human-readable representation of this :class:`INvtxDomainInfo`.

        Returns:
            :class:`str`: The name of the :class:`INvtxDomainInfo`.

        """
        return _ncu_report.INvtxDomainInfo_name(self)

    def push_pop_ranges(self):
        r"""

        Get a sorted list of push/pop range names.

        Get the sorted list of stacked push/pop range names in this domain,
        associated with the current :class:`INvtxState`.

        Returns:
            :class:`tuple` of :class:`str`: The sorted names of all push/pop ranges.

        """
        return _ncu_report.INvtxDomainInfo_push_pop_ranges(self)

    def push_pop_range(self, idx):
        r"""

        Get a push/pop range object by index.

        The index is identical to the range's order on the call stack.

        Returns:
            :class:`INvtxRange` | :data:`None`: The requested :class:`INvtxRange` or
            :data:`None` if the index is out of range.

        """
        return _ncu_report.INvtxDomainInfo_push_pop_range(self, idx)

    def start_end_ranges(self):
        r"""

        Get a sorted list of start/end range names.

        Get the sorted list of start/end range names in this domain, associated with
        the current :class:`INvtxState`.

        Returns:
            :class:`tuple` of :class:`str`: The sorted names of all start/end ranges.

        """
        return _ncu_report.INvtxDomainInfo_start_end_ranges(self)

    def start_end_range(self, idx):
        r"""

        Get a start/end range object by index.

        Returns:
            :class:`INvtxRange` | :data:`None`: The requested :class:`INvtxRange` or
            :data:`None` if the index is out of range.

        """
        return _ncu_report.INvtxDomainInfo_start_end_range(self, idx)

    def __str__(self):
        """Get a human-readable representation of this :class:`INvtxDomainInfo`.

        Returns:
            :class:`str`: The name of the :class:`INvtxDomainInfo`.

        """
        return self.name()


# Register INvtxDomainInfo in _ncu_report:
_ncu_report.INvtxDomainInfo_swigregister(INvtxDomainInfo)
class INvtxState(object):
    r"""

    Represents the NVTX (Nvidia Tools Extensions) state associated with a single
    :class:`IAction`.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_INvtxState

    def domains(self):
        r"""

        Get the list of domain IDs in this state.

        Returns:
            :class:`tuple` of :class:`int`: The tuple of valid domain IDs.

        """
        return _ncu_report.INvtxState_domains(self)

    def domain_by_id(self, id):
        r"""

        Get a :class:`INvtxDomainInfo` object by ID.

        Use :meth:`INvtxState.domains` to retrieve the list of valid domain IDs.

        Args:
            id (:class:`int`): The ID of the request domain.

        Returns:
            :class:`INvtxDomainInfo` | :data:`None`: The requested
            :class:`INvtxDomainInfo` object.

        """
        return _ncu_report.INvtxState_domain_by_id(self, id)

    def __len__(self):
        """Get the number of :class:`INvtxDomainInfo` objects of this
        :class:`INvtxState`.

        Returns:
            :class:`int`: The number of :class:`INvtxDomainInfo` objects.

        """
        return len(self.domains())


    def __iter__(self):
        """Get an :term:`iterator` over the :class:`INvtxDomainInfo` objects of this
        :class:`INvtxState`.

        Returns:
            :term:`iterator`: An :term:`iterator` over the
            :class:`INvtxDomainInfo` objects.

        """
        return iter(self.domains())


    def __getitem__(self, key):
        """Get an :class:`INvtxDomainInfo` object by ID.

        Args:
            key (:class:`int`): The ID of the :class:`INvtxDomainInfo` object.

        Returns:
            :class:`INvtxDomainInfo`: An :class:`INvtxDomainInfo` object.

        Raises:
            :exc:`TypeError`: If ``key`` is not of type :class:`int`.
            :exc:`KeyError`: If ``key`` is not a valid ID.

        """
        if isinstance(key, int):
            if key not in self.domains():
                raise KeyError("INvtxState invalid ID")
            return self.domain_by_id(key)
        raise TypeError(
            "INvtxState IDs must be integers, not {}".format(
                type(key).__name__
            )
        )


# Register INvtxState in _ncu_report:
_ncu_report.INvtxState_swigregister(INvtxState)
class IAction(object):
    r"""

    The :class:`IAction` represents a profile result such as a CUDA kernel in a
    single range or a range itself in range-based profiling, for which zero or
    more metrics were collected.

    Attributes:
        NameBase_DEMANGLED (:class:`int`): Name base for demangled names.
        NameBase_FUNCTION (:class:`int`): Name base for function signature
            names.
        NameBase_MANGLED (:class:`int`): Name base for mangled names.

        WorkloadType_CMDLIST (:class:`int`): Workload type for CBL command
            lists.
        WorkloadType_GRAPH (:class:`int`): Workload type for CUDA graphs.
        WorkloadType_KERNEL (:class:`int`): Workload type for CUDA kernels or
            CUDA graph kernel nodes.
        WorkloadType_RANGE (:class:`int`): Workload type for result ranges.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    NameBase_FUNCTION = _ncu_report.IAction_NameBase_FUNCTION
    NameBase_DEMANGLED = _ncu_report.IAction_NameBase_DEMANGLED
    NameBase_MANGLED = _ncu_report.IAction_NameBase_MANGLED
    WorkloadType_KERNEL = _ncu_report.IAction_WorkloadType_KERNEL
    WorkloadType_RANGE = _ncu_report.IAction_WorkloadType_RANGE
    WorkloadType_CMDLIST = _ncu_report.IAction_WorkloadType_CMDLIST
    WorkloadType_GRAPH = _ncu_report.IAction_WorkloadType_GRAPH
    __swig_destroy__ = _ncu_report.delete_IAction

    def name(self, *args):
        r"""

        Get the name of the result the :class:`IAction` object represents.

        Args:
            name_base (:class:`int`, optional): The desired name base. Defaults to
                :data:`NameBase_FUNCTION`.

        Returns:
            :class:`str`: The name of the result (potentially in a specific name base).

        """
        return _ncu_report.IAction_name(self, *args)

    def workload_type(self):
        r"""

        Get the workload type of the action.

        Returns:
            :class:`int`: The workload type.

        """
        return _ncu_report.IAction_workload_type(self)

    def metric_by_name(self, metric_name):
        r"""

        Get a single :class:`IMetric` by name.

        Args:
            metric_name (:class:`str`): The name of the :class:`IMetric` to retrieve.

        Returns:
            :class:`IMetric` | :data:`None`: The :class:`IMetric` object or
            :data:`None` if no such metric exists.

        """
        return _ncu_report.IAction_metric_by_name(self, metric_name)

    def metric_names(self):
        r"""

        Get the names of all metrics of this :class:`IAction`.

        Returns:
            :class:`tuple` of :class:`str`: The names of all metrics.

        """
        return _ncu_report.IAction_metric_names(self)

    def add_integer_metric(self, value_name, value_kind, value):
        return _ncu_report.IAction_add_integer_metric(self, value_name, value_kind, value)

    def add_double_metric(self, value_name, value_kind, value):
        return _ncu_report.IAction_add_double_metric(self, value_name, value_kind, value)

    def add_string_metric(self, value_name, value_kind, value):
        return _ncu_report.IAction_add_string_metric(self, value_name, value_kind, value)

    def add_metric(self, value_name):
        return _ncu_report.IAction_add_metric(self, value_name)

    def source_info(self, address):
        r"""

        Get the source info for a function address within this action.

        Addresses are commonly obtained as correlation IDs of source-correlated
        metrics.

        Args:
            address (:class:`int`): The address to get source info for.

        Returns:
            :class:`ISourceInfo` | :data:`None`: The :class:`ISourceInfo` associated
            to the given address. If no source info is available, :data:`None` is
            returned.

        """
        return _ncu_report.IAction_source_info(self, address)

    def source_files(self):
        r"""

        Get the source files associated with this action along with their content.

        If content is not available for a file (e.g. because it hadn't been imported
        into the report), the file name will map to an empty string.

        Returns:
            :class:`dict` of :class:`str` to :class:`str`: A dictionary mapping
            source files to their content.

        """
        return _ncu_report.IAction_source_files(self)

    def sass_by_pc(self, address):
        r"""

        Get the SASS associated with an address.

        Args:
            address (:class:`int`): The address to get SASS for.

        Returns:
            :class:`str`: The SASS associated with the given address. If no SASS is
            available, the empty string will be returned.

        """
        return _ncu_report.IAction_sass_by_pc(self, address)

    def nvtx_state(self):
        r"""

        Get the NVTX state associated with this action.

        Returns:
            :class:`INvtxState` | :data:`None`: The associated :class:`INvtxState`
            or :data:`None` if no state is associated.

        """
        return _ncu_report.IAction_nvtx_state(self)

    def ptx_by_pc(self, address):
        r"""

        Get the PTX associated with an address.

        Args:
            address (:class:`int`): The address to get PTX for.

        Returns:
            :class:`str`: The PTX associated with the given address. If no PTX is
            available, the empty string will be returned.

        """
        return _ncu_report.IAction_ptx_by_pc(self, address)

    def source_markers(self):
        r"""

        Get all the source markers associated with this action.

        Returns:
            :class:`tuple` of :class:`dict`:
            A tuple of source data dictionaries. Each source data :class:`dict` contains the following key-value pairs:
                - 'rule_identifier' : (:class:`str`) The rule identifier.
                - 'section_identifier' : (:class:`str`) The section identifier.
                - 'kind' : (:class:`int`) :class:`MarkerKind` attribute.
                - 'message_type' : (:class:`int`) :class:`MsgType` attribute.
                - 'message' : (:class:`str`) The source marker message.
                - 'source_location' : (:class:`dict`) with the following key-value pairs:
                    - 'file_name' : (:class:`str`) The file name.
                    - 'line' : (:class:`int`) The line number.
                - 'source_address' : (:class:`int`) Source instruction address. Key available only for kind :attr:`MarkerKind.SASS`.

        """
        val = _ncu_report.IAction_source_markers(self)

        return [
            {
                "rule_identifier": source_marker.rule_identifier,
                "section_identifier": source_marker.section_identifier,
                "kind": source_marker.kind,
                "message_type": source_marker.message_type,
                "message": source_marker.message,
                **({"source_location": {
                    "file_name": source_marker.source_location.file_name(),
                    "line": source_marker.source_location.line()
                }} if source_marker.kind == MarkerKind_SOURCE else {}),
                **({"source_address": source_marker.source_address} if source_marker.kind == MarkerKind_SASS else {}),
            }
            for source_marker in val
        ]


        return val


    def rule_results(self):
        r"""

        Get the tuple of all rules associated with this action.

        Returns:
            :class:`tuple` of :class:`IRuleResult`: A tuple of rule results.

        """
        return _ncu_report.IAction_rule_results(self)

    def __str__(self):
        """Get a human-readable representation of this :class:`IAction`.

        Returns:
            :class:`str`: The name of the kernel the :class:`IAction` object
            represents.
        """
        return self.name()


    def __len__(self):
        """Get the number of :class:`IMetric` objects of this :class:`IAction`.

        Returns:
            :class:`int`: The number of :class:`IMetric` objects.
        """
        return len(self.metric_names())


    def __iter__(self):
        """Get an :term:`iterator` over the metric names of this
        :class:`IAction`.

        Returns:
            :term:`iterator` of :class:`str`: An :term:`iterator` over the
            metric names.
        """
        return iter(self.metric_names())


    def __getitem__(self, key):
        """Get an :class:`IMetric` object contained in this :class:`IAction` by
        its name.

        Args:
            key (:class:`str`): The name of the :class:`IMetric` object to
                retrieve.

        Returns:
            :class:`IMetric`: An :class:`IMetric` object.

        Raises:
            :exc:`TypeError`: If ``key`` is not of type :class:`str`.
            :exc:`KeyError`: If ``key`` is not the name of any :class:`IMetric`
                object.
        """
        if not isinstance(key, str):
            raise TypeError(
                "IAction metric keys must be strings, not {}".format(type(key).__name__)
            )

        metric = self.metric_by_name(key)

        if metric is None:
            raise KeyError("no metric named '{}'".format(key))

        return metric


    def rule_results_as_dicts(self):
        """Get the list of all rules data associated with this action.

        Returns:
            :class:`list` of :class:`dict`: A list of rule data dictionaries. Each rule data dictionary contains the following key-value pairs:
                - 'rule_identifier' : (:class:`str`) The rule identifier.
                - 'name' : (:class:`str`) The rule name.
                - 'section_identifier' : (:class:`str`) The section identifier.
                - 'rule_message' : (:class:`dict`) with the following key-value pairs:
                    - 'title' : (:class:`str`) The title of rule message.
                    - 'message' : (:class:`str`) The message.
                    - 'type' : (:class:`MsgType`) The message type.
                - 'focus_metrics' : (:class:`list` of :class:`dict`) : A list of focus metrics. Each focus metric dictionary contains the following key-value pairs:
                    - 'name' : (:class:`str`) The name of the focus metric.
                    - 'value' : (:class:`float`) The value of the focus metric.
                    - 'severity' : (:class:`FocusSeverity`) The severity of the focus metric.
                    - 'info' : (:class:`str`) The information about the focus metric.
                - 'speedup_estimation' : (:class:`dict`) with the following key-value pairs:
                    - 'type' : (:class:`SpeedupType`) The speedup type.
                    - 'speedup' : (:class:`float`) The speedup value.
                - 'result_tables' : (:class:`dict`) with the following key-value pairs:
                    - 'title' : (:class:`str`) The title of the result table.
                    - 'description' : (:class:`str`) The description of the result table.
                    - 'headers' : (:class:`list` of :class:`str`) The column headers of the result table.
                    - 'data' : (:class:`list` of :class:`list` [:class:`int` | :class:`float` | :class:`str` | :data:`Any` ]) The table data in row-major format. Each column have elements of the same type.

                    :class:`str` values support below link formats:
                        - @url:<hypertext>:<external link>@ - To add a external link for a hypertext.
                        - @sass:<address>:<hypertext>@ - To add a link to the hypertext to open the SASS address line on the Source page.
                        - @source:<file name>:<line number>:<hypertext>@ - To add a link to the hypertext to open the source file at the specified line number on the Source page.
                        - @section:<section identifier>:<hypertext>@ - To add a link to the hypertext to jump to the respective section.
        """
        return [
            {
                "rule_identifier": rule_result.rule_identifier(),
                "name": rule_result.name(),
                "section_identifier": rule_result.section_identifier(),
                "rule_message": rule_result.rule_message(),
                **({"focus_metrics": focus_metrics} if len(focus_metrics) else {}),
                **({"speedup_estimation": rule_result.speedup_estimation()} if rule_result.has_speedup_estimation() else {}),
                **({"result_tables": result_tables} if len(result_tables) else {}),
            }
            for rule_result in self.rule_results()
            for focus_metrics in [rule_result.focus_metrics()]
            for result_tables in [rule_result.result_tables()]
        ]


# Register IAction in _ncu_report:
_ncu_report.IAction_swigregister(IAction)
class IRange(object):
    r"""

    Represents a serial, ordered stream of execution, such as a CUDA stream. It
    holds one or more actions that were logically executing in this range.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IRange

    def num_actions(self):
        r"""

        Get the number of :class:`IAction` objects in this :class:`IRange`.

        Returns:
            :class:`int`: The number of class:`IAction` objects.

        """
        return _ncu_report.IRange_num_actions(self)

    def action_by_idx(self, idx):
        r"""

        Get an :class:`IAction` objects by index.

        Args:
            key (:class:`int`): The index to retrieve.

        Returns:
            :class:`IAction` | :data:`None`: An :class:`IAction` object or
            :data:`None` if the index is out of range.

        """
        return _ncu_report.IRange_action_by_idx(self, idx)

    def actions_by_nvtx(self, includes, excludes):
        r"""

        Get a set of indices to IAction objects by their NVTX state. The state is
        defined using a series of *includes* and *excludes*.

        Args:
            includes (:term:`iterable` of :class:`str`): The NVTX states the result
                should be part of.
            excludes (:term:`iterable` of :class:`str`): The NVTX states the result
                should not be part of.

        Returns:
            :class:`tuple` of :class:`int`: A :class:`tuple` of indices to
            :class:`IAction` matching the desired NVTX state.

        """
        return _ncu_report.IRange_actions_by_nvtx(self, includes, excludes)

    def __len__(self):
        """Get the number of :class:`IAction` objects in this :class:`IRange`.

        Returns:
            :class:`int`: The number of class:`IAction` objects.
        """
        return self.num_actions()


    def __getitem__(self, key):
        """Get one or more :class:`IAction` objects by index or by
        :class:`slice`.

        Args:
            key (:class:`int` | :class:`slice`): The index or :class:`slice` to
                retrieve.

        Returns:
            :class:`IAction` | :class:`tuple` of :class:`IAction`: An
            :class:`IAction` object or a :class:`tuple` of :class:`IAction` objects.

        Raises:
            :exc:`TypeError`: If ``key`` is not of type :obj:`int` or
                :obj:`slice`.
            :exc:`IndexError`: If ``key`` is out of range for the
                :class:`IRange`.
        """
        _len = len(self)
        if isinstance(key, int):
            if key < -_len or key >= _len:
                raise IndexError("IRange index out of range")
            if key < 0:
                key += _len
            return self.action_by_idx(key)
        if isinstance(key, slice):
            return tuple(self[i] for i in range(*key.indices(_len)))
        raise TypeError(
            "IRange indices must be integers or slices, not {}".format(
                type(key).__name__
            )
        )


    def __iter__(self):
        """Get an :term:`iterator` over the :class:`IAction` objects of this
        class:`IRange`.

        Returns:
            :term:`iterator` of :class:`IAction`: An :term:`iterator` over the
            :class:`IAction` objects.
        """
        return (self[i] for i in range(len(self)))


# Register IRange in _ncu_report:
_ncu_report.IRange_swigregister(IRange)
class IFrontend(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Severity_SEVERITY_DEFAULT = _ncu_report.IFrontend_Severity_SEVERITY_DEFAULT
    Severity_SEVERITY_LOW = _ncu_report.IFrontend_Severity_SEVERITY_LOW
    Severity_SEVERITY_HIGH = _ncu_report.IFrontend_Severity_SEVERITY_HIGH
    SpeedupType_LOCAL = _ncu_report.IFrontend_SpeedupType_LOCAL
    SpeedupType_GLOBAL = _ncu_report.IFrontend_SpeedupType_GLOBAL
    __swig_destroy__ = _ncu_report.delete_IFrontend

    def message(self, *args):
        return _ncu_report.IFrontend_message(self, *args)

    def _generate_table(self, message_id, table):
        return _ncu_report.IFrontend__generate_table(self, message_id, table)

    def send_dict_to_children(self, dict):
        return _ncu_report.IFrontend_send_dict_to_children(self, dict)

    def receive_dict_from_parent(self, parent_id):
        return _ncu_report.IFrontend_receive_dict_from_parent(self, parent_id)

    def speedup(self, message_id, type, estimated_speedup):
        return _ncu_report.IFrontend_speedup(self, message_id, type, estimated_speedup)

    def focus_metric(self, message_id, metric_name, metric_value, severity, info):
        return _ncu_report.IFrontend_focus_metric(self, message_id, metric_name, metric_value, severity, info)

    def source_marker(self, *args):
        return _ncu_report.IFrontend_source_marker(self, *args)

    def load_chart_from_file(self, filename):
        return _ncu_report.IFrontend_load_chart_from_file(self, filename)

    def __init__(self):
        if self.__class__ == IFrontend:
            _self = None
        else:
            _self = self
        _ncu_report.IFrontend_swiginit(self, _ncu_report.new_IFrontend(_self, ))
    def __disown__(self):
        self.this.disown()
        _ncu_report.disown_IFrontend(self)
        return weakref.proxy(self)

# Register IFrontend in _ncu_report:
_ncu_report.IFrontend_swigregister(IFrontend)
class IBaseContext(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IBaseContext

    def handle_exception(self, msg):
        return _ncu_report.IBaseContext_handle_exception(self, msg)

    def get_version(self):
        return _ncu_report.IBaseContext_get_version(self)

# Register IBaseContext in _ncu_report:
_ncu_report.IBaseContext_swigregister(IBaseContext)
class IMessageVault(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IMessageVault

    def Put(self, ruleId, message):
        return _ncu_report.IMessageVault_Put(self, ruleId, message)

    def Get(self, ruleId):
        return _ncu_report.IMessageVault_Get(self, ruleId)

    def __init__(self):
        if self.__class__ == IMessageVault:
            _self = None
        else:
            _self = self
        _ncu_report.IMessageVault_swiginit(self, _ncu_report.new_IMessageVault(_self, ))
    def __disown__(self):
        self.this.disown()
        _ncu_report.disown_IMessageVault(self)
        return weakref.proxy(self)

# Register IMessageVault in _ncu_report:
_ncu_report.IMessageVault_swigregister(IMessageVault)
class IController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IController

    def propose_rule(self, rule):
        return _ncu_report.IController_propose_rule(self, rule)

    def get_message_vault(self):
        return _ncu_report.IController_get_message_vault(self)

    def __init__(self):
        if self.__class__ == IController:
            _self = None
        else:
            _self = self
        _ncu_report.IController_swiginit(self, _ncu_report.new_IController(_self, ))
    def __disown__(self):
        self.this.disown()
        _ncu_report.disown_IController(self)
        return weakref.proxy(self)

# Register IController in _ncu_report:
_ncu_report.IController_swigregister(IController)
class IEvaluator(IBaseContext):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IEvaluator

    def require_metric(self, metric):
        return _ncu_report.IEvaluator_require_metric(self, metric)

    def require_rule(self, rule):
        return _ncu_report.IEvaluator_require_rule(self, rule)

    def __init__(self):
        if self.__class__ == IEvaluator:
            _self = None
        else:
            _self = self
        _ncu_report.IEvaluator_swiginit(self, _ncu_report.new_IEvaluator(_self, ))
    def __disown__(self):
        self.this.disown()
        _ncu_report.disown_IEvaluator(self)
        return weakref.proxy(self)

# Register IEvaluator in _ncu_report:
_ncu_report.IEvaluator_swigregister(IEvaluator)
class IContext(IBaseContext):
    r"""

    The :class:`IContext` class is the top-level object representing an open
    report.

    It can be created by calling the :func:`load_report` function.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IContext

    def controller(self):
        return _ncu_report.IContext_controller(self)

    def frontend(self):
        return _ncu_report.IContext_frontend(self)

    def num_ranges(self):
        r"""

        Get the number of :class:`IRange` objects in this :class:`IContext`.

        Returns:
            :class:`int`: The number of :class:`IRange` objects.

        """
        return _ncu_report.IContext_num_ranges(self)

    def range_by_idx(self, idx):
        r"""

        Get an :class:`IRange` object by index.

        Args:
            key (:class:`int`): The index to retrieve.

        Returns:
            :class:`IRange` | :data:`None`: An :class:`IRange` object or
            :data:`None` if the index is out of range.

        """
        return _ncu_report.IContext_range_by_idx(self, idx)

    def __len__(self):
        """Get the number of :class:`IRange` objects in this :class:`IContext`.

        Returns:
            :class:`int`: The number of :class:`IRange` objects.
        """
        return self.num_ranges()

    def __getitem__(self, key):
        """Get one or more :class:`IRange` objects by index or by slice.

        Args:
            key (:class:`int` | :class:`slice`): The index or slice to retrieve.

        Returns:
        :class:`IRange` | :class:`tuple` of :class:`IRange`: An :class:`IRange`
        object or a :class:`tuple` of :class:`IRange` objects.

        Raises:
            :exc:`TypeError`: If ``key`` is not of type :class:`int` or
                :class:`slice`.
            :exc:`IndexError`: If ``key`` is out of range for the
                :class:`IContext`.
        """
        _len = len(self)
        if isinstance(key, int):
            if key < -_len or key >= _len:
                raise IndexError("IContext index out of range")
            if key < 0:
                key += _len
            return self.range_by_idx(key)
        if isinstance(key, slice):
            return tuple(self[i] for i in range(*key.indices(_len)))
        raise TypeError(
            "IContext indices must be integers or slices, not {}".format(
                type(key).__name__
            )
        )


    def __iter__(self):
        """Get an :term:`iterator` over the :class:`IRange` objects of this
        :class:`IContext`.

        Returns:
            :term:`iterator` of :class:`IRange`: An :term:`iterator` over the
            :class:`IRange` objects.
        """
        return (self[i] for i in range(len(self)))


# Register IContext in _ncu_report:
_ncu_report.IContext_swigregister(IContext)


import enum

class MarkerKind(enum.IntEnum):
    """
    Enum representing the kind of a source marker.

    Attributes:
        SASS: The marker will be associated with a SASS instruction.
        SOURCE: The marker will be associated with a Source line.
        NONE: No specific kind of marker.
    """
    SASS = MarkerKind_SASS
    SOURCE = MarkerKind_SOURCE
    NONE = MarkerKind_NONE


class MsgType(enum.IntEnum):
    """
    Enum representing the type of the message.

    Attributes:
        NONE: No specific type for this message.
        OK: The message is informative.
        OPTIMIZATION: The message represents a suggestion for performance optimization.
        WARNING: The message represents a warning or fixable issue.
        ERROR: The message represents an error, potentially in executing the rule.
    """
    NONE = MsgType_NONE
    OK = MsgType_OK
    OPTIMIZATION = MsgType_OPTIMIZATION
    WARNING = MsgType_WARNING
    ERROR = MsgType_ERR




class FocusSeverity(enum.IntEnum):
    """
    Enum representing the severity of a focus metric.

    Attributes:
        DEFAULT: Default severity.
        LOW: Low severity.
        HIGH: High severity.
    """
    DEFAULT = FocusSeverity_DEFAULT
    LOW = FocusSeverity_LOW
    HIGH = FocusSeverity_HIGH


class SpeedupType(enum.IntEnum):
    """
    Enum representing the type of speedup estimation.

    Attributes:
        UNKNOWN: Unknown speedup type.
        LOCAL: Value represents increase in hardware efficiency in isolated context.
        GLOBAL: Value represents decrease in overall kernel runtime.
    """
    UNKNOWN = SpeedupType_UNKNOWN
    LOCAL = SpeedupType_LOCAL
    GLOBAL = SpeedupType_GLOBAL



