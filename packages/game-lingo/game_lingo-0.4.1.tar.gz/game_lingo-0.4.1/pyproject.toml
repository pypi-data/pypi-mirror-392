[tool.poetry]
name = "game-lingo"
version = "0.4.1"
description = "Multi-language video game description translator with smart API orchestration"
authors = ["Sermodi <sermodsoftware@gmail.com>"]
readme = "README.md"
license = "MIT"
homepage = "https://github.com/Sermodi/game-lingo"
repository = "https://github.com/Sermodi/game-lingo"
keywords = ["games", "translation", "steam", "rawg", "deepl", "videogames", "api", "multilingual", "i18n", "localization"]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Topic :: Games/Entertainment",
    "Operating System :: OS Independent",
]
packages = [{include = "game_lingo"}]

[tool.poetry.scripts]
game-lingo = "game_lingo.cli:main"

[tool.poetry.dependencies]
python = "^3.9"
requests = "^2.31.0"
pydantic = "^2.5.0"
python-decouple = "^3.8"
tenacity = "^8.2.3"
aiohttp = "^3.9.0"
asyncio = "^3.4.3"
tomli = { version = "^2.0.0", python = "<3.11" }

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-asyncio = "^0.21.0"
pytest-cov = "^4.1.0"
black = "^23.0.0"
ruff = "^0.1.0"
bandit = "^1.7.5"
mypy = "^1.7.0"
types-requests = "^2.31.0"
pre-commit = "^3.5.0"
isort = "^5.13.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 88
target-version = ['py39']

[tool.ruff]
line-length = 88
target-version = "py39"

[tool.ruff.lint]
select = ["E", "F", "W", "C90", "I", "N", "UP", "YTT", "S", "BLE", "FBT", "B", "A", "COM", "C4", "DTZ", "T10", "EM", "EXE", "FA", "ISC", "ICN", "G", "INP", "PIE", "T20", "PYI", "PT", "Q", "RSE", "RET", "SLF", "SLOT", "SIM", "TID", "TCH", "INT", "ARG", "PTH", "TD", "FIX", "ERA", "PD", "PGH", "PL", "TRY", "FLY", "NPY", "AIR", "PERF", "FURB", "LOG", "RUF"]
ignore = [
    "T201",    # print statements (intencional en CLI)
    "G004",    # f-strings en logging (preferencia de legibilidad)
    "TID252",  # imports relativos (estructura del paquete)
    "EM101",   # strings literales en excepciones (OK para mensajes simples)
    "EM102",   # f-strings en excepciones (OK para contexto dinámico)
    "TRY003",  # mensajes largos en excepciones (preferencia de claridad)
    "TRY300",  # try-consider-else (preferencia de estructura)
    "TRY301",  # raise-within-try (a veces necesario)
    "TRY400",  # error-instead-of-exception (logging.error es más claro a veces)
    "S110",    # try-except-pass (usado intencionalmente en algunos casos)
    "PLR2004", # magic values (algunos son obvios en contexto)
    "PLR0913", # too-many-arguments (Pydantic models necesitan muchos)
    "B904",    # raise-without-from (no siempre necesario el contexto)
    "B007",    # unused-loop-variable (a veces solo necesitamos iterar)
    "E501",    # line-too-long (algunas líneas son difíciles de acortar)
    "UP035",   # deprecated-import (typing.Dict vs dict - no urgente)
    "UP006",   # non-pep585-annotation (Dict vs dict - no urgente)
    "UP",
    "FBT001",  # boolean-positional-arg (común en APIs y Pydantic)
    "FBT002",  # boolean-default-arg (común en APIs y Pydantic)
    "FBT003",  # boolean-positional-value (común en llamadas)
    "C901",    # complex-structure (algunas funciones necesitan complejidad)
    "RUF013",  # implicit-optional (PEP 484, pero funciona)
    "F841",    # unused-variable (a veces para claridad)
    "PYI056",  # __all__.extend (funciona bien)
    "BLE001",  # blind-except (a veces necesario para robustez)
    "ERA001",  # commented-out-code (código comentado para referencia)
    "N805",    # invalid-first-argument-name (cls en validators de Pydantic)
    "PLC0415", # import-outside-top-level (imports condicionales OK)
    "RUF012",  # mutable-class-default (Pydantic Field maneja esto)
    "PERF203", # try-except-in-loop (a veces necesario)
    "PTH123",  # builtin-open (open() es más claro que Path.open())
    "RET504",  # unnecessary-assign (a veces mejora legibilidad)
    "ARG002",  # unused-method-argument (interfaces/protocolos)
    "DTZ007",  # datetime-without-timezone (no siempre necesario)
    "PLR0911", # too-many-return-statements (complejidad necesaria)
    "PLR0912", # too-many-branches (complejidad necesaria)
    "PLR0915", # too-many-statements (complejidad necesaria)
    "S605",    # start-process-with-shell (necesario para chcp en Windows)
    "S607",    # start-process-with-partial-path (os.system es seguro aquí)
    "SIM105",  # suppressible-exception (contextlib.suppress no siempre mejor)
    "SIM108",  # if-else-block-instead-of-if-exp (legibilidad)
    "FA100",   # future-rewritable-type-annotation (no urgente)
    "PYI034",  # non-self-return-type (validators de Pydantic)
    "RUF001",  # ambiguous-unicode-character (caracteres españoles OK)
    "PERF401", # manual-list-comprehension (legibilidad)
    "UP007",   # non-pep484-annotation (Dict vs dict - no urgente)
    "S101",    # use-assert (no urgente)
    "N802",    # invalid-first-argument-name (cls en validators de Pydantic)
    "TRY200",  # try-except-in-loop (a veces necesario)
    "PT012",   # asyncio-mode (no urgente)
    "RET503",  # unnecessary-assign (a veces mejora legibilidad)
]

[tool.ruff.lint.per-file-ignores]
"game_lingo/cli.py" = ["T201"]
"tests/**/*.py" = ["PLR0913", "PLR0915", "S101", "SLF001", "E402", "B017", "PT011", "F821", "SIM117"]
"**/__init__.py" = ["F401"]

[tool.mypy]
python_version = "3.9"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true
# Excluir archivos no críticos para el type checking estricto
exclude = '(?x).*(tests/.*_manual\.py|test_.*_manual\.py|test_.*\.py|example_usage\.py|game_lingo[/\\]cli\.py)$'
# Plugins para Pydantic
plugins = ["pydantic.mypy"]

[tool.pydantic-mypy]
init_forbid_extra = true
init_typed = true
warn_required_dynamic_aliases = true

# Configuración por módulo
[[tool.mypy.overrides]]
module = "game_lingo.models.*"
# Pydantic genera constructores dinámicamente, ignorar algunos errores
disable_error_code = ["call-arg", "misc"]

[[tool.mypy.overrides]]
module = "tests.*"
# Tests pueden ser menos estrictos
disallow_untyped_defs = false
disallow_incomplete_defs = false

[[tool.mypy.overrides]]
module = "game_lingo.apis.rawg_api"
disallow_untyped_decorators = false

[[tool.mypy.overrides]]
module = "game_lingo.apis.steam_api"
ignore_missing_imports = true
disallow_untyped_decorators = false
disable_error_code = ["no-any-return"]

[[tool.mypy.overrides]]
module = "aiohttp"
ignore_missing_imports = true

[[tool.mypy.overrides]]
module = "tenacity"
ignore_missing_imports = true

[[tool.mypy.overrides]]
module = "tomli"
# Ignorar import faltante de tomli cuando se ejecuta con python_version 3.9
ignore_missing_imports = true

[[tool.mypy.overrides]]
module = "decouple"
ignore_missing_imports = true

[[tool.mypy.overrides]]
module = "game_lingo.apis.*"
ignore_missing_imports = true
disallow_untyped_defs = false
check_untyped_defs = false
warn_return_any = false
warn_no_return = false
no_implicit_optional = false
disable_error_code = ["no-any-return", "misc", "arg-type", "assignment", "unreachable"]

[[tool.mypy.overrides]]
module = "game_lingo.cli"
ignore_errors = true

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = "-v --cov=game_lingo --cov-report=term-missing --cov-report=html"
asyncio_mode = "auto"
markers = [
    'integration: mark test as integration test (deselect with "-m not integration")'
]

[tool.coverage.run]
source = ["game_lingo"]
omit = ["*/tests/*", "*/test_*"]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "if self.debug:",
    "if settings.DEBUG",
    "raise AssertionError",
    "raise NotImplementedError",
    "if 0:",
    "if __name__ == .__main__.:",
    "class .*\\bProtocol\\):",
    "@(abc\\.)?abstractmethod",
]
