model:
  simulation_name: "config_climate_and_season_dependent_non_autoregressive"
  time_granularity: "M"
  simulation_length: 200
  features:
    - name: "rainfall"
      function: |
        def get_rainfall(region, i):
          if (i % 20 == 0):
            return 4
          return 0
    - name: "mean_temperature"
      function: |
        def get_temperature(i):
          if (i% 20 == 0):
            return 4
          return 0
    - name: "white_noise"
      function: |
        def get_white_noise():
          return 0
    - name: "disease_cases"
      function: |
        def get_disease_cases(i, rainfall, mean_temperature):
          population = 100
          poisson_rate = 0
          for covariate, lag in zip([rainfall, mean_temperature], [3, 3]):
            poisson_rate += np.roll(covariate, lag)[i] #d maybe since your focus is mainly on the DSL, Martin, can you demonstrate that it is possible to reproduce exactly (using some seed) all the possible simulations that can be made using the other codebase described above can be made using your DSL? From a user perspective, I can state that ideally I would like that I do not have to write individual specifications for each simulation and that it is somehow configurable what combinations of simulations I need to generate. 
          
          disease_cases = np.int32((1 / (1 + np.exp(-poisson_rate))) * population)
          disease_cases = np.random.poisson(disease_cases)
          
          return min(disease_cases, population)
  regions:
    - name: "Finnmark"
      region_id: 1
      rain_season: []
      neighbour: []
simulations:
  - simulation_name: "config_climate_and_season_dependent_autoregressive"
    features:
      - name: "white_noise"
        function: |
          def get_white_noise(i, white_noise, rainfall, mean_temperature):
            from sklearn.preprocessing import StandardScaler
            wn = np.random.normal(0, 0.2)  # Generate a single noise value

            # Apply lag and standardization
            for covariate, lag in zip([rainfall, mean_temperature], [3, 3]):
              lagged_covariate = np.roll(covariate, lag)
              scaler = StandardScaler()
              scaled_data = scaler.fit_transform(lagged_covariate[1:].reshape(-1, 1))
              wn += scaled_data.flatten() * 0.5
            return wn[-1]
      - name: "disease_cases"
        function: |
          def get_disease_cases(i, rainfall, mean_temperature, disease_cases, white_noise):
            population = 100
            disease_cases = np.cumsum(white_noise)
            disease_cases_previous = disease_cases[i - 1] if i > 0 else 0
            disease_cases = np.insert(disease_cases, 0, 0) - 0.5
            disease_cases = np.int32((1 / (1 + np.exp(-disease_cases))) * population)

            return disease_cases[-1]

evaluators:
  - evaluation_technique: "holdout"
    test_size: 0.2
    model: "models/minimalist_example_lag"
  - evaluation_technique: "holdout"
    test_size: 0.2
    model: "models/minimalist_multiregion"
