"""
Preview generator for SpecQL Interactive CLI

Generates live preview from SpecQL YAML with error recovery
and pattern detection.
"""

from dataclasses import dataclass
from typing import Optional, List, Dict, Any
from io import StringIO


@dataclass
class PreviewResult:
    """Result of preview generation"""
    success: bool
    output: str
    error: Optional[str] = None
    detected_patterns: Optional[List[Dict[str, Any]]] = None


class PreviewGenerator:
    """
    Generate live preview from SpecQL YAML

    Features:
    - Incremental parsing (handles partial/invalid YAML)
    - Error recovery
    - Pattern detection
    - Multiple output modes
    """

    def __init__(self):
        # We'll import these when needed to avoid circular imports
        self._parser = None
        self._schema_generator = None
        self._action_generator = None

    def generate_preview(
        self,
        yaml_text: str,
        mode: str = "schema"
    ) -> PreviewResult:
        """
        Generate preview from YAML text

        Args:
            yaml_text: SpecQL YAML content
            mode: 'schema', 'actions', or 'fraiseql'

        Returns:
            PreviewResult with generated output or error
        """
        try:
            # Parse YAML (with error recovery)
            entity = self._parse_yaml_safe(yaml_text)

            if entity is None:
                return PreviewResult(
                    success=False,
                    output="",
                    error="Invalid YAML syntax - please check formatting"
                )

            # Detect patterns
            patterns = self._detect_patterns(entity)

            # Generate preview based on mode
            if mode == "schema":
                output = self._generate_schema_preview(entity)
            elif mode == "actions":
                output = self._generate_actions_preview(entity)
            elif mode == "fraiseql":
                output = self._generate_fraiseql_preview(entity)
            else:
                output = "Unknown preview mode"

            return PreviewResult(
                success=True,
                output=output,
                detected_patterns=patterns
            )

        except Exception as e:
            return PreviewResult(
                success=False,
                output="",
                error=f"Error: {str(e)}"
            )

    def _parse_yaml_safe(self, yaml_text: str) -> Optional[Any]:
        """
        Parse YAML with error recovery

        Attempts to parse even partial/invalid YAML
        """
        try:
            # Parse to EntityDefinition object
            if self._parser is None:
                from src.core.specql_parser import SpecQLParser
                self._parser = SpecQLParser()

            entity = self._parser.parse(yaml_text)
            return entity

        except Exception:
            # Try to recover partial YAML
            # (simplified - real implementation would be more sophisticated)

            # Extract entity name at least
            lines = yaml_text.split('\n')
            entity_name = None

            for line in lines:
                if line.strip().startswith('entity:'):
                    entity_name = line.split(':', 1)[1].strip()
                    break

            if entity_name:
                # Return minimal entity
                from src.core.ast_models import EntityDefinition
                return EntityDefinition(
                    name=entity_name,
                    schema="public"
                )

            return None

    def _generate_schema_preview(self, entity) -> str:
        """Generate PostgreSQL DDL preview"""
        try:
            # Simple preview DDL generation
            lines = []
            lines.append("-- Table Definition")
            lines.append(f"CREATE TABLE {entity.schema}.tb_{entity.name.lower()} (")

            # Primary key
            lines.append(f"    pk_{entity.name.lower()} INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,")
            lines.append("    id UUID DEFAULT gen_random_uuid() NOT NULL,")

            # Fields
            for field_name, field_def in list(entity.fields.items())[:3]:  # Limit for preview
                field_type = self._map_field_type_to_sql(field_def)
                lines.append(f"    {field_name} {field_type},")

            # Remove last comma from last field and close table
            if lines and lines[-1].endswith(','):
                lines[-1] = lines[-1][:-1]  # Remove comma

            lines.append(");")
            lines.append("")

            # Add some basic indexes
            lines.append("-- Indexes")
            lines.append(f"CREATE INDEX idx_{entity.name.lower()}_id ON {entity.schema}.tb_{entity.name.lower()}(id);")

            return "\n".join(lines)
        except Exception as e:
            return f"-- Error generating schema: {e}"

    def _map_field_type_to_sql(self, field_def) -> str:
        """Map field definition to SQL type"""
        # Simple mapping for preview
        type_mapping = {
            'text': 'TEXT',
            'integer': 'INTEGER',
            'boolean': 'BOOLEAN',
            'date': 'DATE',
            'timestamp': 'TIMESTAMPTZ',
            'uuid': 'UUID',
            'json': 'JSONB',
        }

        field_type = getattr(field_def, 'type_name', 'text')
        return type_mapping.get(field_type, 'TEXT')

    def _generate_actions_preview(self, entity) -> str:
        """Generate PL/pgSQL functions preview"""
        if not entity.actions:
            return "-- No actions defined"

        try:
            output = StringIO()

            for action in entity.actions[:3]:  # Limit to first 3 for preview
                output.write(f"-- Action: {action.name}\n")

                # Generate function (simplified)
                output.write(f"CREATE OR REPLACE FUNCTION {action.name}(")
                output.write("/* parameters */")
                output.write(")\n")
                output.write("RETURNS void\n")
                output.write("LANGUAGE plpgsql\n")
                output.write("AS $$\n")
                output.write("BEGIN\n")

                for step in action.steps[:2]:  # Limit steps for preview
                    output.write(f"  -- {step}\n")

                output.write("END;\n")
                output.write("$$;\n\n")

            if len(entity.actions) > 3:
                output.write(f"-- ... and {len(entity.actions) - 3} more actions\n")

            return output.getvalue()
        except Exception as e:
            return f"-- Error generating actions: {e}"

    def _generate_fraiseql_preview(self, entity) -> str:
        """Generate FraiseQL metadata preview"""
        try:
            output = StringIO()

            output.write("-- FraiseQL Annotations\n\n")

            # Table comment
            output.write(f"COMMENT ON TABLE {getattr(entity, 'schema', 'public')}.tb_{entity.entity_name.lower()} IS E'@fraiseql\n")
            output.write("type: entity\n")
            output.write(f"graphql_name: {entity.entity_name}\n")
            output.write("';\n\n")

            # Field comments
            if hasattr(entity, 'fields'):
                for field in entity.fields[:5]:  # Limit for preview
                    output.write(f"COMMENT ON COLUMN {getattr(entity, 'schema', 'public')}.tb_{entity.entity_name.lower()}.{field.name} IS E'@fraiseql\n")
                    output.write(f"graphql_type: {self._map_to_graphql_type(getattr(field, 'type', 'text'))}\n")
                    output.write("';\n")

            return output.getvalue()
        except Exception as e:
            return f"-- Error generating FraiseQL: {e}"

    def _detect_patterns(self, entity) -> List[Dict[str, Any]]:
        """Detect patterns in entity"""
        patterns = []

        if not hasattr(entity, 'fields') or not entity.fields:
            return patterns

        # EntityDefinition has fields as dict[str, FieldDefinition]
        field_names = set(entity.fields.keys())

        # Audit trail
        audit_fields = {'created_at', 'updated_at', 'created_by', 'updated_by'}
        if audit_fields <= field_names:
            patterns.append({
                'name': 'audit_trail',
                'confidence': 1.0,
                'description': 'Full audit trail with timestamps and user tracking'
            })

        # Soft delete
        if 'deleted_at' in field_names:
            patterns.append({
                'name': 'soft_delete',
                'confidence': 1.0,
                'description': 'Soft delete pattern for safe record removal'
            })

        # State machine
        if 'status' in field_names or 'state' in field_names:
            patterns.append({
                'name': 'state_machine',
                'confidence': 0.8,
                'description': 'State machine pattern detected'
            })

        # Multi-tenant
        if 'tenant_id' in field_names:
            patterns.append({
                'name': 'multi_tenant',
                'confidence': 1.0,
                'description': 'Multi-tenant architecture'
            })

        return patterns

    def _map_to_graphql_type(self, specql_type: str) -> str:
        """Map SpecQL type to GraphQL type"""
        mapping = {
            'text': 'String',
            'integer': 'Int',
            'float': 'Float',
            'boolean': 'Boolean',
            'date': 'Date',
            'timestamp': 'DateTime',
            'uuid': 'UUID',
        }
        return mapping.get(specql_type, 'String')