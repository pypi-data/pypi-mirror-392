#include <errno.h>
#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>

#include "libcharm.h"

namespace LC = LibCharm;
using namespace LC;

#define MAX_ERROR_MESSAGE 1024

// initialize non-const statics
int Globals::verbosity =
	getenv("WNDCHRM_VERBOSITY") ? atoi (getenv("WNDCHRM_VERBOSITY")) : 2;
bool Globals::forking_executor =
	getenv("WNDCHRM_FORKING_EXECUTOR") ? atoi (getenv("WNDCHRM_FORKING_EXECUTOR")) != 0: false;
bool Globals::forking_gabor =
	getenv("WNDCHRM_FORKING_GABOR") ? atoi (getenv("WNDCHRM_FORKING_GABOR")) != 0: false;
bool Globals::forking_haralick =
	getenv("WNDCHRM_FORKING_HARALICK") ? atoi (getenv("WNDCHRM_FORKING_HARALICK")) != 0: false;

std::vector<std::string> LC::Errors::messages;

int &LC::verbosity         = LC::Globals::verbosity;
bool& LC::forking_executor = LC::Globals::forking_executor;
bool& LC::forking_haralick = LC::Globals::forking_haralick;
bool& LC::forking_gabor    = LC::Globals::forking_gabor;

decltype(LC::Errors::catError)&    LC::catError    = LC::Errors::catError;
decltype(LC::Errors::catErrorStr)& LC::catErrorStr = LC::Errors::catErrorStr;
decltype(LC::Errors::showError)&   LC::showError   = LC::Errors::showError;
decltype(LC::Errors::getErrorStr)& LC::getErrorStr = LC::Errors::getErrorStr;
decltype(LC::Errors::resetError)&  LC::resetError  = LC::Errors::resetError;


void Errors::catErrno () {
	char error_buffer[MAX_ERROR_MESSAGE];

	if (errno != 0) {
	// Append any system error string
		strerror_r(errno, error_buffer, MAX_ERROR_MESSAGE);

		if (strlen(error_buffer) && ! messages.empty()) {
			messages.back().append(": ");
			messages.back().append(error_buffer);
		}
		errno = 0;
	}
}
/*
   Accumulates errors and warnings to be shown later
   N.B.: Variadic - use like printf
*/
void Errors::catError (const char *fmt, ...) {
	va_list ap;
	char error_buffer[MAX_ERROR_MESSAGE];
	std::string err_str;

	// process the printf-style parameters
	va_start (ap, fmt);
	va_end (ap);

	err_str = error_buffer;
	catErrorStr(error_buffer);

	catErrno();
}

void Errors::catErrorStr (const std::string &error) {
const std::string WHITESPACE = " \n\r\t\f\v";
	size_t end = error.find_last_not_of(WHITESPACE);
	if (end != std::string::npos) messages.push_back(error.substr(0, end + 1));
	else messages.push_back(error);
}


/*
   displays an error message and optionally stops the program
   If stopping, shows the accumulated error_message generated by catErrorStr()
   N.B.: variadic.  First parameter is the stop flag, followed by parameters same as printf
*/
int Errors::showError(int stop, const char *fmt, ...) {
va_list ap;
size_t err_lngth;
char error_buffer[MAX_ERROR_MESSAGE];
std::string err_str;

// add the printf-style parameters to error_message
	if (fmt && *fmt) {
		va_start (ap, fmt);
		err_lngth = vsnprintf (error_buffer,MAX_ERROR_MESSAGE, fmt, ap);
		va_end (ap);
		if (err_lngth) catErrorStr (error_buffer);
	}


// Append any system error string
	catErrno();

	if (! messages.empty()) {
		for (const auto &piece : messages) std::cerr << piece + "\n";
	}

	if (stop && ! messages.empty()) {
		std::cerr << "Fatal error - terminating.\n";
	} else if (stop) {
		exit(0);
	}

	return(0);
}


const char* Errors::translateError( ERROR_CODE return_val )
{
	switch( return_val )
	{
		case WC_UNINITIALIZED:
			return "return value is unused.";
		case WC_NO_ERROR:
			return "";
		case WC_IPP_NULL:
			return "intermediate pixel_plane saved in MatrixMap is null.";
		case WC_MM_FAIL_RECURSIVE_CALL:
			return "call to MatrixMap::obtain_transform() failed in recursion.";
		case WC_TRANSFORM_FAIL:
			return "transform algorithm failed to produce an output pixel plane";
		case WC_EMPTY:
			return "nothing in container.";
		//case WC_TRANSFORM_NOT_IN_PHONEBOOK:
		//	return "transform requested was not registered at compile time.";
		case WC_NOT_IMPLEMENTED:
			return "requested functionality not implemented.";
		case WC_INPUT_IMAGEMATRIX_NULL:
			return "pixelplane passed to transform was corrupted.";
	}
	return "";
}

const std::string Errors::getErrorStr () {
	std::string err_str;
	for (const auto &piece : messages) err_str += piece + "\n";
	return (err_str);
}

void Errors::resetError () {
	messages.clear();
}