"""
Common utilities for this package.

@date: 30.06.2025
@author: Baptiste Pestourie
"""

from __future__ import annotations

import importlib
import logging
import os
import shutil
import sys
import sysconfig
import tempfile
from contextlib import contextmanager
from dataclasses import dataclass
from enum import Enum, auto
from pathlib import Path
from types import ModuleType
from typing import Generator, Literal, NewType, assert_never, cast, overload

from setuptools._distutils.extension import Extension

_logger = logging.getLogger(__name__)


# --- Errors ---
class SmeltError(Exception):
    """
    Base exception class for Smelt errors
    """


class SmeltMissingModule(SmeltError): ...


def get_extension_suffix(target_triple: str) -> str:
    """
    Generate the C extension module filename.

    Parameters
    ----------
    target_triple: str
        The target triple, e.g., 'aarch64-linux-gnu'.

    Returns
    -------
    str
        The extension filename, e.g., '.cpython-312-aarch64-linux-gnu.so'
    """
    major = sys.version_info.major
    minor = sys.version_info.minor
    return f".cpython-{major}{minor}-{target_triple}.so"


@contextmanager
def import_shadowed_module(path: str) -> Generator[ModuleType, None, None]:
    """
    Allows importting a .py module shadowed by its .so counterpart
    (typically generated by mypy).
    .so python modules (generally, compiled C extensions) have higher priority on import
    over .py modules. This is is done so that module can provide optional C extensions
    with a pure Python implementation as fallback (e.g., if the interpreter is not CPython,
    or if the C extension cannot be compiled for the target platform)

    This function temporarily REMOVES the .so and proceeds to import the shadowed.
    It is a context manager and will restore the removed .so on exit,
    unless a new version has been built in the meantime (e.g., if the import
    was required as part of a recompile process)
    """
    with tempfile.TemporaryDirectory() as tmp:
        try:
            mod = importlib.import_module(path)
        except ImportError as exc:
            msg = f"Failed to import {path} while trying to mypycify"
            raise SmeltMissingModule(msg) from exc
        mod_path = mod.__file__
        assert mod_path is not None, f"Cannot module to mypycify: {path}"
        if mod_path.endswith((".py", ".pyc")):
            yield mod
        else:
            backup_path = os.path.join(tmp, os.path.basename(mod_path))
            shutil.copy(mod_path, backup_path)
            _logger.debug("Removing %s...", mod_path)
            os.remove(mod_path)
            os.sync()

            try:
                # using reload as otherwise importlib will use the cache
                # and re-import the now deleted .so
                mod = importlib.reload(mod)
                assert mod.__file__ is not None and not (mod.__file__.endswith(".so"))
                yield mod
            except ImportError as exc:
                msg = f"Failed to import {path} while trying to mypycify"
                raise SmeltMissingModule(msg) from exc


ImportPath = NewType("ImportPath", str)
FsPath = NewType("FsPath", str)


class ModpathType(Enum):
    """
    How locations of modules are passed:

    `IMPORT` means the module path is given as it would be used
    in a import statement.
    `FS` means the module is passed as a relative path.
    """

    IMPORT = auto()
    FS = auto()


def get_modpath_type(path: str) -> ModpathType:
    """
    Detects whether the passed type of the given `path`.
    """
    # TODO: stricter checks
    if path.endswith(".py") or path.endswith(".pyx"):
        return ModpathType.FS
    return ModpathType.IMPORT


@overload
def toggle_mod_path(path: str, to_type: Literal[ModpathType.IMPORT]) -> ImportPath: ...


@overload
def toggle_mod_path(path: str, to_type: Literal[ModpathType.FS]) -> FsPath: ...


def toggle_mod_path(path: str, to_type: ModpathType) -> ImportPath | FsPath:
    """
    Changes the path to a module between 'import' style paths
    (a.b.c) and filesystem type (a/b/b).
    """
    if get_modpath_type(path) == to_type:
        return cast(ImportPath | FsPath, path)

    match to_type:
        case ModpathType.IMPORT:
            *parents, modfile = path.split("/")
            modfile = Path(modfile).stem
            return cast(ImportPath, ".".join([*parents, modfile]))

        case ModpathType.FS:
            return cast(FsPath, path.replace(".", "/") + ".py")

        case _ as unreachable:
            assert_never(unreachable)


def locate_module(
    mod_path: str,
    strategy: ModpathType = ModpathType.IMPORT,
    package_root: Path = Path("."),
) -> str:
    """
    Returns the full path to module at `mod_path`.
    If `mod_path` is passed a relative filepath, returns the absolute path.
    If it is passed as an import path ('.' seperated), tries importing and
    locates from the import"""
    match strategy:
        case ModpathType.IMPORT:
            return locate_module_by_import_path(toggle_mod_path(mod_path, strategy))

        case ModpathType.FS:
            return find_module_in_layout(
                toggle_mod_path(mod_path, strategy), package_root=package_root
            )

        case _ as unreachable:
            assert_never(unreachable)


def locate_module_by_import_path(mod_import_path: ImportPath) -> str:
    """
    Given a module import path as package.submodule.module,
    returns the location of on the filesystem of the imported module.
    """
    try:
        module = importlib.import_module(mod_import_path)
    except ImportError as exc:
        msg = f"Failed to import module: {mod_import_path}"
        raise SmeltMissingModule(msg) from exc
    assert module.__file__ is not None, f"Failed to locate module: {mod_import_path}"
    return module.__file__


def find_module_in_layout(mod_path: FsPath, package_root: str | None = None) -> str:
    """
    Given a module path on the filesystem,
    tries resolving that location within the package layout.
    """
    root = Path(package_root) if package_root else Path.cwd()
    src_location = root / "src"
    if src_location.exists():
        mod_potential_location = src_location / mod_path
        if mod_potential_location.exists():
            return str(mod_potential_location)

    mod_potential_location = root / mod_path
    if mod_potential_location.exists():
        return str(mod_potential_location)

    raise FileNotFoundError(f"Failed to locate {mod_path}")


@dataclass
class GenericExtension:
    """
    A wrapper on top of setuptools Extensions used by smelt.
    Used to provide metadata on how to manage these get_extension_suffixns in the install
    process, which is agnostic from the utility producing the extension in the first place.

    `import_path` keeps track of where the module should be placed in the final artifact.
    `src_path` keeps track of the original source files.
    `runtime` is optional and can be used to contain runtime utility module that's can
    be shared across modules (mypyc / Probably Nuitka in the future).
    """

    import_path: str
    src_path: str
    name: str
    dest_folder: Path
    extension: Extension
    runtime: Extension | None = None

    def get_dest_path(self, target_triple: str | None = None) -> Path:
        """
        Returns
        -------
        Path
            Full path for the final compiled .so file.
        """
        suffix = (
            sysconfig.get_config_var("EXT_SUFFIX")
            if target_triple is None
            else get_extension_suffix(target_triple)
        )
        ext_so_name = f"{self.name}{suffix}"
        return self.dest_folder / ext_so_name

    def get_runtime_dest_path(self, target_triple: str | None = None) -> Path:
        """
        Returns
        -------
        Path
            Full path for the final runtime .so file.
        """
        suffix = (
            sysconfig.get_config_var("EXT_SUFFIX")
            if target_triple is None
            else get_extension_suffix(target_triple)
        )
        ext_so_name = f"{self.name}__mypyc{suffix}"
        return self.dest_folder / ext_so_name
