"""
Auxiliary Nodes Interface for Business Flow Diagrams.

This module provides a common interface for adding auxiliary nodes (analysis, profiling, etc.)
to business flow diagrams. This enables consistent handling of various types of observational
or analytical nodes that attach to the main data flow.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


@dataclass
class AuxiliaryNodeDefinition:
    """
    Definition of an auxiliary node to be added to the diagram.

    Attributes:
        node_id: Unique identifier for the node in the diagram (e.g., "DA_1000", "DP_2000")
        label: Display label for the node (supports Mermaid formatting)
        parent_operation_id: LineageID of the operation this node observes/analyzes
        node_type: Type identifier for styling (e.g., "distribution_analysis", "describe_profile")
        shape: Mermaid shape syntax (e.g., "[...]", "{{...}}", "((...))")
        metadata: Additional metadata about the node
    """
    node_id: str
    label: str
    parent_operation_id: Optional[str]
    node_type: str
    shape: str = "rectangle"  # Default shape
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

    def get_mermaid_node_definition(self) -> str:
        """
        Generate the Mermaid node definition string.

        Returns:
            Mermaid syntax for the node (e.g., 'DA_1000["label"]')
        """
        shape_map = {
            "rectangle": ('[', ']'),
            "rounded": ('(', ')'),
            "stadium": ('([', '])'),
            "subroutine": ('[[', ']]'),
            "cylindrical": ('[(', ')]'),
            "circle": ('((', '))'),
            "asymmetric": ('>', ']'),
            "rhombus": ('{', '}'),
            "hexagon": ('{{', '}}'),
            "parallelogram": ('[/', '/]'),
            "trapezoid": ('[\\', '/]')
        }

        open_bracket, close_bracket = shape_map.get(self.shape, ('[', ']'))
        return f"    {self.node_id}{open_bracket}\"{self.label}\"{close_bracket}"

    def get_mermaid_edge(self, parent_mermaid_id: str, edge_style: str = "dotted") -> str:
        """
        Generate the Mermaid edge connecting parent to this node.

        Args:
            parent_mermaid_id: The Mermaid node ID of the parent operation
            edge_style: Style of edge ("dotted", "solid", "thick")

        Returns:
            Mermaid syntax for the edge
        """
        edge_map = {
            "dotted": "-.->",
            "solid": "-->",
            "thick": "==>"
        }
        arrow = edge_map.get(edge_style, "-.->")
        return f"    {parent_mermaid_id} {arrow} {self.node_id}"


class AuxiliaryNodeProvider(ABC):
    """
    Abstract base class for providers that generate auxiliary nodes.

    Implementations should:
    1. Check if they have data to contribute (e.g., from tracker)
    2. Generate AuxiliaryNodeDefinition objects for each node
    3. Return them for inclusion in the diagram
    """

    @abstractmethod
    def get_node_type(self) -> str:
        """
        Get the type identifier for this provider's nodes.

        Returns:
            Type string used for CSS class naming (e.g., "distribution_analysis")
        """
        pass

    @abstractmethod
    def get_nodes(self, tracker, lineage_to_mermaid: Dict[str, str]) -> List[AuxiliaryNodeDefinition]:
        """
        Generate auxiliary nodes from tracker data.

        Args:
            tracker: Global lineage tracker containing captured data
            lineage_to_mermaid: Mapping from lineage IDs to Mermaid node IDs

        Returns:
            List of auxiliary node definitions to add to the diagram
        """
        pass

    @abstractmethod
    def get_node_id_prefix(self) -> str:
        """
        Get the prefix for node IDs generated by this provider.

        Returns:
            Prefix string (e.g., "DA" for distribution analysis, "DP" for describe profile)
        """
        pass

    @abstractmethod
    def get_starting_node_counter(self) -> int:
        """
        Get the starting counter value for node IDs.

        This helps avoid ID conflicts between different providers.

        Returns:
            Starting counter value (e.g., 1000 for DA, 2000 for DP)
        """
        pass


class AuxiliaryNodeManager:
    """
    Manager for collecting and rendering auxiliary nodes from multiple providers.
    """

    def __init__(self):
        self.providers: List[AuxiliaryNodeProvider] = []

    def register_provider(self, provider: AuxiliaryNodeProvider):
        """Register an auxiliary node provider."""
        self.providers.append(provider)
        logger.debug(f"Registered auxiliary node provider: {provider.get_node_type()}")

    def add_auxiliary_nodes_to_diagram(
        self,
        diagram: str,
        tracker,
        lineage_to_mermaid: Dict[str, str]
    ) -> str:
        """
        Add all auxiliary nodes from registered providers to the diagram.

        Args:
            diagram: Original Mermaid diagram
            tracker: Global lineage tracker
            lineage_to_mermaid: Mapping from lineage IDs to Mermaid node IDs

        Returns:
            Enhanced diagram with auxiliary nodes
        """
        if not self.providers:
            return diagram

        lines = diagram.split('\n')

        # Find insertion point (before classDef/class statements)
        insert_index = len(lines)
        for i, line in enumerate(lines):
            if 'classDef' in line or 'class ' in line:
                insert_index = i
                break

        # Collect all auxiliary nodes from all providers
        all_nodes: List[AuxiliaryNodeDefinition] = []
        for provider in self.providers:
            try:
                nodes = provider.get_nodes(tracker, lineage_to_mermaid)
                all_nodes.extend(nodes)
                logger.debug(f"Provider {provider.get_node_type()} contributed {len(nodes)} nodes")
            except Exception as e:
                logger.error(f"Error getting nodes from provider {provider.get_node_type()}: {e}")

        if not all_nodes:
            return diagram

        # Build enhanced diagram
        enhanced_lines = []

        # Copy lines up to insertion point
        for i in range(insert_index):
            enhanced_lines.append(lines[i])

        # Group nodes by type for organized output
        nodes_by_type: Dict[str, List[AuxiliaryNodeDefinition]] = {}
        for node in all_nodes:
            if node.node_type not in nodes_by_type:
                nodes_by_type[node.node_type] = []
            nodes_by_type[node.node_type].append(node)

        # Add nodes grouped by type
        for node_type, nodes in nodes_by_type.items():
            enhanced_lines.append("")
            enhanced_lines.append(f" %% {node_type.replace('_', ' ').title()} Nodes")

            for node in nodes:
                # Add node definition
                enhanced_lines.append(node.get_mermaid_node_definition())

                # Add edge if parent exists
                if node.parent_operation_id and node.parent_operation_id in lineage_to_mermaid:
                    parent_mermaid_id = lineage_to_mermaid[node.parent_operation_id]
                    enhanced_lines.append(node.get_mermaid_edge(parent_mermaid_id))

        enhanced_lines.append("")

        # Copy remaining lines (class definitions, etc.)
        for i in range(insert_index, len(lines)):
            enhanced_lines.append(lines[i])

        # Add class assignments for auxiliary nodes
        last_class_index = -1
        for i in range(len(enhanced_lines) - 1, -1, -1):
            if enhanced_lines[i].strip().startswith('class '):
                last_class_index = i
                break

        if last_class_index != -1:
            # Add class assignments grouped by type
            for node_type, nodes in nodes_by_type.items():
                class_name = f"{node_type}Op"
                for node in nodes:
                    enhanced_lines.insert(last_class_index + 1, f" class {node.node_id} {class_name}")

        return '\n'.join(enhanced_lines)
