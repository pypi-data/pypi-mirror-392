# src/auto_pytest_generator/addon.py

import json
from pathlib import Path
import re
from mitmproxy import http, ctx
from jinja2 import Environment, FileSystemLoader
from urllib.parse import urlparse
from pprint import pformat

class PytestGenerator:
    def __init__(self, url_prefix: str, response_mode: str = "json"):
        self.url_prefix = url_prefix
        self.response_mode = response_mode  # "json" or "text"
        self.processed_urls = set()
        self.seen_prefixes = {}  # map base_key -> base_url
        self.auth_tokens = {}    # map base_key -> "Bearer ..."

        # 初始化Jinja2环境
        template_dir = Path(__file__).parent / "templates"
        self.jinja_env = Environment(loader=FileSystemLoader(template_dir))
        
        # 创建输出目录
        self.output_dir = Path("generated_tests")
        self.output_dir.mkdir(exist_ok=True)
        (self.output_dir / "__init__.py").touch() # 让它成为一个Python包

        # 将用户传入的 url_prefix 的 base 提前加入 seen_prefixes，这样启动时 config 就包含用户想录制的前缀
        try:
            parsed = urlparse(self.url_prefix)
            netloc = parsed.netloc
            if netloc:
                base_url = f"{parsed.scheme}://{netloc}"
                base_key = self._safe_key_from_netloc(netloc)
                # 仅在当前实例的 seen_prefixes 中添加（写入时会与已有 config 合并）
                if base_key not in self.seen_prefixes:
                    self.seen_prefixes[base_key] = base_url
                    # 写入（合并）配置文件，确保多个 generator 不会互相覆盖
                    self._write_config()
        except Exception:
            # 忽略无法解析的 user-provided prefix
            pass

    def _safe_key_from_netloc(self, netloc: str) -> str:
        # 将 host:port 转成合法的变量/键名，如 116.204.99.110:8058 -> host_116_204_99_110_8058
        key = re.sub(r'[^0-9a-zA-Z]', '_', netloc)
        return f"host_{key}"

    def _load_existing_config(self) -> dict:
        """
        读取已存在的 generated_tests/config.py 中的 BASE_URLS 和 AUTH_TOKENS（如果存在），
        返回 dict: {"BASE_URLS": {...}, "AUTH_TOKENS": {...}}
        """
        cfg_path = self.output_dir / "config.py"
        if not cfg_path.exists():
            return {"BASE_URLS": {}, "AUTH_TOKENS": {}}
        try:
            src = cfg_path.read_text(encoding="utf-8")
            namespace = {}
            # 只执行文件内容以获取 BASE_URLS / AUTH_TOKENS（config 是自动生成的简单赋值文件）
            exec(src, namespace)
            base = namespace.get("BASE_URLS", {}) or {}
            auth = namespace.get("AUTH_TOKENS", {}) or {}
            if isinstance(base, dict) and isinstance(auth, dict):
                return {"BASE_URLS": base, "AUTH_TOKENS": auth}
        except Exception:
            pass
        return {"BASE_URLS": {}, "AUTH_TOKENS": {}}

    def _write_config(self):
        """
        每次更新 seen_prefixes 或 auth_tokens 时重写 generated_tests/config.py，
        但先读取已有 config 并合并，保留已有键的值（避免被后来的 generator 覆盖）。
        """
        cfg_path = self.output_dir / "config.py"

        # 读取已有并合并（已有优先，避免覆盖用户手工修改或先前生成的值）
        existing = self._load_existing_config()
        existing_base = existing.get("BASE_URLS", {}) or {}
        existing_auth = existing.get("AUTH_TOKENS", {}) or {}

        merged_base = dict(existing_base)  # existing takes precedence
        for k, v in self.seen_prefixes.items():
            if k not in merged_base:
                merged_base[k] = v

        merged_auth = dict(existing_auth)
        for k, v in self.auth_tokens.items():
            if k not in merged_auth:
                merged_auth[k] = v

        lines = [
            "# Auto-generated by smoke-test-recorder. Edit values to switch environments.\n",
            "BASE_URLS = {\n",
        ]
        for k, v in merged_base.items():
            lines.append(f'    "{k}": "{v}",\n')
        lines.append("}\n\n")

        lines.append("# Optional per-base Authorization tokens (Bearer). Edit or leave empty to fetch dynamically.\n")
        lines.append("AUTH_TOKENS = {\n")
        for k, v in merged_auth.items():
            lines.append(f'    "{k}": "{v}",\n')
        lines.append("}\n")

        # 写入文件
        try:
            with open(cfg_path, "w", encoding="utf-8") as f:
                f.writelines(lines)
            ctx.log.info(f"更新 config: {cfg_path}")
        except Exception as e:
            ctx.log.error(f"无法写入 config: {e}")

    def response(self, flow: http.HTTPFlow) -> None:
        """
        当服务器响应被接收时触发
        """
        req = flow.request
        res = flow.response

        # 1. 过滤不关心的流量
        if not req.pretty_url.startswith(self.url_prefix):
            return
        if req.method.upper() != 'GET': # 初期只处理GET请求
            return
        # 避免重复生成
        if req.pretty_url in self.processed_urls:
            return
            
        ctx.log.info(f"捕获到目标API: {req.method} {req.pretty_url}")
        self.processed_urls.add(req.pretty_url)

        # 解析 URL，拆分 base 和 path+query
        parsed = urlparse(req.pretty_url)
        base_url = f"{parsed.scheme}://{parsed.netloc}"
        # 新增：去掉 scheme 的 host:port，用于填充 Host header（直接来自 config/recorded base）
        base_netloc = parsed.netloc

        path_query = parsed.path or ""
        if parsed.query:
            path_query += "?" + parsed.query

        base_key = self._safe_key_from_netloc(parsed.netloc)
        # 记录并写入 config（合并写入，已有键不会被覆盖）
        if base_key not in self.seen_prefixes:
            self.seen_prefixes[base_key] = base_url
            # don't overwrite existing BASE_URL entries
            self._write_config()

        # 提取 Authorization: Bearer ... 并写入 auth_tokens（首次遇到写入，已有值不覆盖）
        auth_header = req.headers.get("Authorization") or req.headers.get("authorization") or ""
        if auth_header and auth_header.lower().startswith("bearer "):
            if base_key not in self.auth_tokens:
                self.auth_tokens[base_key] = auth_header
                self._write_config()

        # 2. 准备模板需要的数据
        response_data = ""
        is_json = False
        response_data_py = ""
        response_data_text = ""

        if self.response_mode == "json":
            # 尝试把响应解析为 JSON 并以 Python literal 输出（便于在测试文件中以 dict 断言）
            try:
                obj = res.json()
                # 使用 pformat 生成可读的 Python 字面量（dict/list/...）
                response_data_py = pformat(obj, width=120, sort_dicts=False)
                is_json = True
            except Exception:
                # 回退到文本
                try:
                    response_data_text = res.get_text(strict=False)
                except Exception:
                    response_data_text = ""
                is_json = False
        else:
            # text 模式：始终把响应当作文本处理
            try:
                response_data_text = res.get_text(strict=False)
            except Exception:
                response_data_text = ""
            is_json = False

        # 传入模板：如果是 json 模式且成功解析，会提供 response_data_py；否则提供 response_data_text
        context = {
            "method": req.method.lower(),
            "base_key": base_key,
            "base_netloc": base_netloc,
            "path_query": path_query,
            "headers": dict(req.headers),
            "response_status": res.status_code,
            "is_json_response": is_json,
            "response_data_py": response_data_py,
            "response_data_text": response_data_text,
        }

        # 3. 生成文件名和函数名
        test_filename, test_func_name = self._generate_names_from_url(req.pretty_url)
        context["test_func_name"] = test_func_name
        
        # 4. 渲染并保存文件
        template = self.jinja_env.get_template("pytest_template.jinja2")
        rendered_code = template.render(context)
        
        file_path = self.output_dir / test_filename
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(rendered_code)
        ctx.log.info(f"成功生成测试用例: {file_path}")

    def _generate_names_from_url(self, url: str) -> (str, str):
        """根据URL生成合法的文件名和函数名"""
        path = url.replace(self.url_prefix, "").split('?')[0]
        # 移除非法字符
        safe_path = re.sub(r'[^a-zA-Z0-9_]', '_', path).strip('_')
        
        filename = f"test_{safe_path}.py"
        func_name = f"test_{safe_path}"
        
        return filename, func_name

