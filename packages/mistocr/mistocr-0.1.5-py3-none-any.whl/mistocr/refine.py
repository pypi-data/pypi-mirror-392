"""Postprocess markdown files by fixing heading hierarchy and describint images"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_refine.ipynb.

# %% auto 0
__all__ = ['prompt_fix_hdgs', 'get_hdgs', 'add_pg_hdgs', 'read_pgs_pg', 'fmt_hdgs_idx', 'HeadingCorrections', 'fix_hdg_hierarchy',
           'mk_fixes_lut', 'apply_hdg_fixes', 'fix_md_hdgs']

# %% ../nbs/01_refine.ipynb 3
from fastcore.all import *
from .core import read_pgs
from re import sub, findall, MULTILINE
from pydantic import BaseModel
from lisette.core import completion
import os
import json

# %% ../nbs/01_refine.ipynb 8
def get_hdgs(
    md:str # Markdown file string
    ):
    "Return the markdown headings"
    # Sanitize removing '#' in python snippet if any
    md = sub(r'```[\s\S]*?```', '', md)
    return L(findall(r'^#{1,6} .+$', md, MULTILINE))



# %% ../nbs/01_refine.ipynb 9
def add_pg_hdgs(md, n):
    "Add page number to all headings in markdown"
    md = sub(r'```[\s\S]*?```', '', md)
    def repl(m): return m.group(0) + f' ... page {n}'
    return sub(r'^#{1,6} .+$', repl, md, flags=MULTILINE)

# %% ../nbs/01_refine.ipynb 11
def read_pgs_pg(path):
    "Read all pages of a markdown file and add page numbers to all headings"
    pgs = read_pgs(path, join=False)
    return L([add_pg_hdgs(pg, n) for n, pg in enumerate(pgs, 1)]).concat()

# %% ../nbs/01_refine.ipynb 15
def fmt_hdgs_idx(
    hdgs: list[str] # List of markdown headings
    ) -> str: # Formatted string with index
    "Format the headings with index"
    return '\n'.join(f"{i}. {h}" for i, h in enumerate(hdgs))


# %% ../nbs/01_refine.ipynb 18
class HeadingCorrections(BaseModel):
    corrections: dict[int, str]  # index → corrected heading

# %% ../nbs/01_refine.ipynb 20
prompt_fix_hdgs = """Fix markdown heading hierarchy errors while preserving the document's intended structure.

INPUT FORMAT: Each heading is prefixed with its index number (e.g., "0. # Title ... page 1")

RULES - Apply these fixes in order:

1. **Single H1 rule**: Documents must have exactly ONE # heading (typically the document title at the top)
   - If index 0 is already #, then all subsequent headings (index 1+) must be ## or deeper
   - If no H1 exists, the first major heading should be #, and all others ## or deeper
   - NO exceptions: appendices, references, and all sections are ## or deeper after the title

2. **Infer depth from numbering patterns**: If headings contain section numbers, deeper nesting means deeper heading level
   - Parent section (e.g., "1", "2", "A") should be shallower than child (e.g., "1.1", "2.a", "A.1")
   - Child section should be one # deeper than parent
   - Works with any numbering: "1/1.1/1.1.1", "A/A.1/A.1.a", "I/I.A/I.A.1", etc.

3. **Level jumps**: Headings can only increase by one # at a time when moving deeper
   - Wrong: ## Section → ##### Subsection
   - Fixed: ## Section → ### Subsection

4. **Decreasing levels is OK**: Moving back up the hierarchy (### to ##) is valid for new sections

OUTPUT: Return a Python dictionary mapping index to corrected heading (without the index prefix).
IMPORTANT: Preserve the " ... page N" suffix in all corrected headings.
Only include entries that need changes.

Headings to analyze:
{headings_list}
"""


# %% ../nbs/01_refine.ipynb 21
def fix_hdg_hierarchy(
    hdgs: list[str], # List of markdown headings
    prompt: str=prompt_fix_hdgs, # Prompt to use
    model: str='claude-sonnet-4-5', # Model to use
    api_key: str=os.getenv('ANTHROPIC_API_KEY') # API key
    ) -> dict[int, str]: # Dictionary of index → corrected heading
    "Fix the heading hierarchy"
    r = completion(
        model=model, 
        messages=[{"role": "user", "content": prompt_fix_hdgs.format(headings_list=fmt_hdgs_idx(hdgs))}], 
        response_format=HeadingCorrections, 
        api_key=api_key
        )
    return json.loads(r.choices[0].message.content)['corrections']

# %% ../nbs/01_refine.ipynb 24
def mk_fixes_lut(
    hdgs: list[str], # List of markdown headings
    model: str='claude-sonnet-4-5', # Model to use
    api_key: str=os.getenv('ANTHROPIC_API_KEY') # API key
    ) -> dict[str, str]: # Dictionary of old → new heading
    "Make a lookup table of fixes"
    fixes = fix_hdg_hierarchy(hdgs, model=model, api_key=api_key)
    return {hdgs[int(k)]:v for k,v in fixes.items()}

# %% ../nbs/01_refine.ipynb 27
def apply_hdg_fixes(
    p:str, # Page to fix
    lut_fixes: dict[str, str], # Lookup table of fixes
    ) -> str: # Page with fixes applied
    "Apply the fixes to the page"
    for old in get_hdgs(p): p = p.replace(old, lut_fixes.get(old, old))
    return p

# %% ../nbs/01_refine.ipynb 30
def fix_md_hdgs(
    src:str, # Source directory with markdown pages
    model:str='claude-sonnet-4-5', # Model
    dst:str=None, # Destination directory (None=overwrite)
):
    "Fix heading hierarchy in markdown document"
    src_path,dst_path = Path(src),Path(dst) if dst else Path(src)
    if dst_path != src_path: dst_path.mkdir(parents=True, exist_ok=True)
    pgs_with_pg = read_pgs_pg(src_path)
    lut = mk_fixes_lut(L([get_hdgs(pg) for pg in pgs_with_pg]).concat(), model)
    for i,p in enumerate(pgs_with_pg, 1):
        (dst_path/f'page_{i}.md').write_text(apply_hdg_fixes(p, lut))
