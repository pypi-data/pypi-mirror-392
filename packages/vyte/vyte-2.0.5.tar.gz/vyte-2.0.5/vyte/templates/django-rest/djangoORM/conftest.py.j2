"""
Pytest configuration and fixtures for Django REST Framework
Generated by presto v2.0
"""
import pytest
from django.contrib.auth import get_user_model
from django.core.management import call_command
from rest_framework.test import APIClient
from rest_framework_simplejwt.tokens import RefreshToken
from {{ name | snake_case }}.models import Item


# Configure Django settings for pytest
pytest_plugins = ['pytest_django']


@pytest.fixture(scope='session')
def django_db_setup(django_db_setup, django_db_blocker):
    """
    Set up test database for the entire test session
    """
    with django_db_blocker.unblock():
        # Run migrations
        call_command('migrate', '--noinput')
        # Load any fixtures if needed
        # call_command('loaddata', 'test_data.json')


@pytest.fixture
def api_client():
    """Provide DRF test client"""
    return APIClient()


@pytest.fixture
def client():
    """Alias for api_client"""
    return APIClient()


{% if auth_enabled -%}
@pytest.fixture
def user_model():
    """Get the user model"""
    return get_user_model()


@pytest.fixture
def test_user(db, user_model):
    """Create test user for authentication"""
    user = user_model.objects.create_user(
        email='testuser@example.com',
        password='TestPassword123!',
        is_active=True,
        is_staff=False
    )
    # Store plain password for login tests
    user.plain_password = 'TestPassword123!'
    return user


@pytest.fixture
def admin_user(db, user_model):
    """Create admin user for admin tests"""
    user = user_model.objects.create_superuser(
        email='admin@example.com',
        password='AdminPassword123!',
        is_active=True
    )
    user.plain_password = 'AdminPassword123!'
    return user


@pytest.fixture
def another_user(db, user_model):
    """Another user for permission tests"""
    user = user_model.objects.create_user(
        email='otheruser@example.com',
        password='OtherPass123!',
        is_active=True
    )
    user.plain_password = 'OtherPass123!'
    return user


@pytest.fixture
def inactive_user(db, user_model):
    """Inactive user for authentication tests"""
    user = user_model.objects.create_user(
        email='inactive@example.com',
        password='InactivePass123!',
        is_active=False
    )
    user.plain_password = 'InactivePass123!'
    return user


@pytest.fixture
def get_tokens_for_user():
    """Helper to generate JWT tokens for any user"""
    def _get_tokens(user):
        refresh = RefreshToken.for_user(user)
        return {
            'refresh': str(refresh),
            'access': str(refresh.access_token),
        }
    return _get_tokens


@pytest.fixture
def authenticated_client(api_client, test_user, get_tokens_for_user):
    """API client authenticated with test_user"""
    tokens = get_tokens_for_user(test_user)
    api_client.credentials(HTTP_AUTHORIZATION=f'Bearer {tokens["access"]}')
    return api_client


@pytest.fixture
def admin_client(api_client, admin_user, get_tokens_for_user):
    """API client authenticated as admin"""
    tokens = get_tokens_for_user(admin_user)
    api_client.credentials(HTTP_AUTHORIZATION=f'Bearer {tokens["access"]}')
    return api_client


@pytest.fixture
def auth_headers(test_user, get_tokens_for_user):
    """JWT auth headers for manual requests"""
    tokens = get_tokens_for_user(test_user)
    return {
        'HTTP_AUTHORIZATION': f'Bearer {tokens["access"]}',
        'content_type': 'application/json'
    }


@pytest.fixture
def bearer_token(test_user, get_tokens_for_user):
    """Get bearer token for test_user"""
    tokens = get_tokens_for_user(test_user)
    return tokens['access']
{% endif %}


# Database fixtures
@pytest.fixture
def db_with_data(db):
    """Database with test data loaded"""
    try:
        # Create sample items
        Item.objects.create(
            name='Test Item 1',
            description='Description 1'
        )
        Item.objects.create(
            name='Test Item 2',
            description='Description 2'
        )
    except ImportError:
        pass  # Models not yet created

    return db


@pytest.fixture
def sample_item(db):
    """Create a sample item"""
    try:
        return Item.objects.create(
            name='Sample Item',
            description='Sample Description'
        )
    except ImportError:
        return None


{% if auth_enabled -%}
@pytest.fixture
def user_item(db, test_user):
    """Create an item owned by test_user"""
    try:
        return Item.objects.create(
            name='User Item',
            description='Owned by test user',
            owner=test_user
        )
    except (ImportError, TypeError):
        return None
{% endif %}


# Utility fixtures
@pytest.fixture
def mock_now(monkeypatch):
    """Mock datetime.now() for time-dependent tests"""
    from datetime import datetime
    fake_now = datetime(2024, 1, 1, 12, 0, 0)

    class MockDatetime:
        @classmethod
        def now(cls, tz=None):
            return fake_now

    monkeypatch.setattr('django.utils.timezone.now', lambda: fake_now)
    return fake_now


@pytest.fixture(autouse=True)
def media_root(settings, tmp_path):
    """Use temporary directory for media files in tests"""
    settings.MEDIA_ROOT = tmp_path / 'media'
    settings.MEDIA_ROOT.mkdir(exist_ok=True)
    return settings.MEDIA_ROOT


@pytest.fixture(autouse=True)
def email_backend(settings):
    """Use in-memory email backend for tests"""
    settings.EMAIL_BACKEND = 'django.core.mail.backends.locmem.EmailBackend'


# Pytest configuration
def pytest_configure(config):
    """Configure pytest"""
    config.addinivalue_line(
        "markers", "slow: marks tests as slow (deselect with '-m \"not slow\"')"
    )
    config.addinivalue_line(
        "markers", "integration: marks tests as integration tests"
    )
    config.addinivalue_line(
        "markers", "unit: marks tests as unit tests"
    )
