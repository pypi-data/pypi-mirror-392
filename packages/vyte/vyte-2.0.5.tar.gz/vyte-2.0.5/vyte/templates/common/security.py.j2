"""
Security utilities and middleware
Generated by presto v2.0
"""
{% if framework == 'Flask-Restx' -%}
from functools import wraps
from flask import request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
import jwt
from datetime import datetime, timedelta
{% elif framework == 'FastAPI' -%}
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
{% elif framework == 'Django-Rest' -%}
from django.contrib.auth.hashers import make_password, check_password
from datetime import datetime, timedelta
{% endif -%}
import secrets
import re


class PasswordValidator:
    """Validate and hash passwords"""

    MIN_LENGTH = 8

    @staticmethod
    def validate(password: str) -> tuple[bool, list[str]]:
        """Validate password strength"""
        errors = []

        if len(password) < PasswordValidator.MIN_LENGTH:
            errors.append(f"Password must be at least {PasswordValidator.MIN_LENGTH} characters")

        if not re.search(r"[A-Z]", password):
            errors.append("Password must contain at least one uppercase letter")

        if not re.search(r"[a-z]", password):
            errors.append("Password must contain at least one lowercase letter")

        if not re.search(r"\d", password):
            errors.append("Password must contain at least one digit")

        if not re.search(r'[!@#$%^&*()\-_=+\[\]{}|;,.<>?/~`\\]', password):
            errors.append("Password must contain at least one special character")

        return len(errors) == 0, errors
{% if framework == 'Flask-Restx' %}

    @staticmethod
    def hash_password(password: str) -> str:
        """Hash password using werkzeug"""
        return generate_password_hash(password, method='pbkdf2:sha256')

    @staticmethod
    def verify_password(password: str, password_hash: str) -> bool:
        """Verify password against hash"""
        return check_password_hash(password_hash, password)
{% elif framework == 'FastAPI' %}

    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

    @staticmethod
    def hash_password(password: str) -> str:
        """Hash password"""
        return PasswordValidator.pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """Verify password"""
        return PasswordValidator.pwd_context.verify(plain_password, hashed_password)
{% elif framework == 'Django-Rest' %}

    @staticmethod
    def hash_password(password: str) -> str:
        """Hash password using Django"""
        return make_password(password)

    @staticmethod
    def verify_password(password: str, password_hash: str) -> bool:
        """Verify password against hash"""
        return check_password(password, password_hash)
{% endif %}


class InputSanitizer:
    """Sanitize user input"""

    @staticmethod
    def sanitize_email(email: str) -> str:
        """Validate and sanitize email"""
        email = email.strip()

        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

        if not re.match(email_pattern, email):
            raise ValueError("Invalid email format")

        return email.lower()

    @staticmethod
    def sanitize_username(username: str) -> str:
        """Validate and sanitize username"""
        username = username.strip()

        if len(username) < 3:
            raise ValueError("Username must be at least 3 characters")

        if not re.match(r'^[a-zA-Z0-9_-]+$', username):
            raise ValueError("Username can only contain letters, numbers, hyphens and underscores")

        return username

{% if framework == 'FastAPI' %}

security = HTTPBearer()


def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """Get current user from JWT token"""
    token = credentials.credentials

    try:
        # Decode JWT
        payload = jwt.decode(token, "SECRET_KEY", algorithms=["HS256"])
        return payload
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
{% endif -%}
