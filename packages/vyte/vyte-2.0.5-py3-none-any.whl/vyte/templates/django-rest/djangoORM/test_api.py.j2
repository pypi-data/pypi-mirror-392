"""
Advanced API endpoint tests for Django REST Framework
Generated by presto v2.0
"""
import pytest
from django.urls import reverse
from rest_framework import status
from {{ name | snake_case }}.models import User, Item


# ============================================================================
# HEALTH CHECK TESTS
# ============================================================================

@pytest.mark.django_db
class TestHealthCheck:
    """Test API health and availability"""

    @pytest.mark.unit
    def test_root_endpoint(self, api_client):
        """Test root endpoint returns OK status"""
        response = api_client.get('/')
        assert response.status_code == status.HTTP_200_OK
        response_data = response.json()
        assert "status" in response_data
        assert response_data["status"] == "ok"

    @pytest.mark.unit
    def test_api_root(self, api_client):
        """Test API root returns available endpoints"""
        response = api_client.get('/api/')
        assert response.status_code == status.HTTP_200_OK


{% if auth_enabled -%}
# ============================================================================
# AUTHENTICATION TESTS
# ============================================================================

@pytest.mark.django_db
class TestAuthentication:
    """Test JWT authentication flows"""

    @pytest.mark.unit
    def test_login_success(self, api_client, test_user):
        """Test successful login with valid credentials"""
        url = reverse('token_obtain_pair')
        data = {
            'email': test_user.email,
            'password': test_user.plain_password
        }
        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert 'access' in data
        assert 'refresh' in data
        assert isinstance(data['access'], str)
        assert isinstance(data['refresh'], str)

    @pytest.mark.unit
    def test_login_fail_wrong_password(self, api_client, test_user):
        """Test login fails with incorrect password"""
        url = reverse('token_obtain_pair')
        data = {
            'email': test_user.email,
            'password': 'WrongPassword123!'
        }
        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    @pytest.mark.unit
    def test_login_fail_invalid_email(self, api_client):
        """Test login fails with non-existent email"""
        url = reverse('token_obtain_pair')
        data = {
            'email': 'nonexistent@example.com',
            'password': 'SomePassword123!'
        }
        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    @pytest.mark.unit
    def test_login_inactive_user(self, api_client, inactive_user):
        """Test login fails for inactive users"""
        url = reverse('token_obtain_pair')
        data = {
            'email': inactive_user.email,
            'password': inactive_user.plain_password
        }
        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    @pytest.mark.unit
    def test_token_refresh(self, api_client, test_user, get_tokens_for_user):
        """Test token refresh with valid refresh token"""
        tokens = get_tokens_for_user(test_user)
        url = reverse('token_refresh')
        data = {'refresh': tokens['refresh']}

        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_200_OK
        assert 'access' in response.json()

    @pytest.mark.unit
    def test_protected_endpoint_without_token(self, api_client):
        """Test protected endpoint rejects unauthenticated requests"""
        url = reverse('user-list')
        response = api_client.get(url)

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    @pytest.mark.unit
    def test_protected_endpoint_with_token(self, authenticated_client):
        """Test protected endpoint accepts authenticated requests"""
        url = reverse('user-list')
        response = authenticated_client.get(url)

        assert response.status_code == status.HTTP_200_OK


# ============================================================================
# USER REGISTRATION TESTS
# ============================================================================

@pytest.mark.django_db
class TestUserRegistration:
    """Test user registration endpoint"""

    @pytest.mark.unit
    def test_register_success(self, api_client):
        """Test successful user registration"""
        url = reverse('user-register')
        data = {
            'email': 'newuser@example.com',
            'password': 'SecurePass123!',
            'password_confirm': 'SecurePass123!',
            'first_name': 'New',
            'last_name': 'User'
        }
        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_201_CREATED
        assert 'email' in response.json()
        assert response.json()['email'] == data['email']

        # Verify user exists in database
        assert User.objects.filter(email=data['email']).exists()

    @pytest.mark.unit
    def test_register_duplicate_email(self, api_client, test_user):
        """Test registration fails with duplicate email"""
        url = reverse('user-register')
        data = {
            'email': test_user.email,
            'password': 'AnotherPass123!',
            'password_confirm': 'AnotherPass123!'
        }
        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert 'email' in response.json()

    @pytest.mark.unit
    def test_register_password_mismatch(self, api_client):
        """Test registration fails when passwords don't match"""
        url = reverse('user-register')
        data = {
            'email': 'newuser@example.com',
            'password': 'SecurePass123!',
            'password_confirm': 'DifferentPass123!'
        }
        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_400_BAD_REQUEST

    @pytest.mark.unit
    def test_register_weak_password(self, api_client):
        """Test registration fails with weak password"""
        url = reverse('user-register')
        data = {
            'email': 'newuser@example.com',
            'password': '123',
            'password_confirm': '123'
        }
        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert 'password' in response.json()

    @pytest.mark.unit
    def test_register_invalid_email(self, api_client):
        """Test registration fails with invalid email format"""
        url = reverse('user-register')
        data = {
            'email': 'not-an-email',
            'password': 'SecurePass123!',
            'password_confirm': 'SecurePass123!'
        }
        response = api_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_400_BAD_REQUEST


{% endif -%}
# ============================================================================
# USER ENDPOINTS TESTS
# ============================================================================

@pytest.mark.django_db
class TestUserEndpoints:
    """Test user CRUD operations"""

    @pytest.mark.unit
    def test_list_users(self, {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}):
        """Test listing users"""
        url = reverse('user-list')
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.get(url)

        assert response.status_code == status.HTTP_200_OK
        assert isinstance(response.json(){% if auth_enabled %}['results']{% endif %}, list)

    @pytest.mark.unit
    def test_retrieve_user(self, {% if auth_enabled %}authenticated_client, test_user{% else %}api_client{% endif %}, db):
        """Test retrieving a single user"""

{%- if auth_enabled %}

        user = test_user

{%- else %}
        # Create a sample user for non-auth mode
        user = User.objects.create(
            email='sample@example.com',
            full_name='Sample User'
        )
{%- endif %}

        url = reverse('user-detail', kwargs={'pk': user.pk})
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.get(url)

        assert response.status_code == status.HTTP_200_OK
        assert response.json()['email'] == user.email

    @pytest.mark.unit
    def test_retrieve_nonexistent_user(self, {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}):
        """Test retrieving non-existent user returns 404"""
        url = reverse('user-detail', kwargs={'pk': 99999})
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.get(url)

        assert response.status_code == status.HTTP_404_NOT_FOUND


{%- if auth_enabled %}

    @pytest.mark.unit
    def test_update_own_profile(self, authenticated_client, test_user):
        """Test user can update their own profile"""
        url = reverse('user-detail', kwargs={'pk': test_user.pk})
        data = {
            'first_name': 'Updated',
            'last_name': 'Name'
        }
        response = authenticated_client.patch(url, data, format='json')

        assert response.status_code == status.HTTP_200_OK
        test_user.refresh_from_db()
        assert test_user.first_name == data['first_name']

    @pytest.mark.integration
    def test_cannot_update_other_user(self, authenticated_client, another_user):
        """Test user cannot update another user's profile"""
        url = reverse('user-detail', kwargs={'pk': another_user.pk})
        data = {'first_name': 'Hacker'}
        response = authenticated_client.patch(url, data, format='json')

        # Can be 403 (forbidden) or 404 (not found, because user can't see other users)
        assert response.status_code in [status.HTTP_403_FORBIDDEN, status.HTTP_404_NOT_FOUND]

    @pytest.mark.integration
    def test_admin_can_update_any_user(self, admin_client, test_user):
        """Test admin can update any user"""
        url = reverse('user-detail', kwargs={'pk': test_user.pk})
        data = {'first_name': 'AdminUpdate'}
        response = admin_client.patch(url, data, format='json')

        assert response.status_code == status.HTTP_200_OK

    @pytest.mark.integration
    def test_delete_user_cascade_items(self, authenticated_client, test_user):
        """Test deleting user cascades to their items"""
        # Create item owned by user
        item = Item.objects.create(
            title='User Item',
            description='Test',
            owner=test_user
        )
        item_id = item.id

        url = reverse('user-detail', kwargs={'pk': test_user.pk})
        response = authenticated_client.delete(url)

        assert response.status_code == status.HTTP_204_NO_CONTENT
        assert not User.objects.filter(pk=test_user.pk).exists()
        assert not Item.objects.filter(pk=item_id).exists()

    @pytest.mark.unit
    def test_change_password(self, authenticated_client, test_user):
        """Test password change endpoint"""
        url = reverse('user-change-password')
        data = {
            'old_password': test_user.plain_password,
            'new_password': 'NewSecurePass123!',
            'new_password_confirm': 'NewSecurePass123!'
        }
        response = authenticated_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_200_OK

        # Verify password was changed
        test_user.refresh_from_db()
        assert test_user.check_password('NewSecurePass123!')

    @pytest.mark.unit
    def test_change_password_wrong_old(self, authenticated_client):
        """Test password change fails with wrong old password"""
        url = reverse('user-change-password')
        data = {
            'old_password': 'WrongOldPass!',
            'new_password': 'NewSecurePass123!',
            'new_password_confirm': 'NewSecurePass123!'
        }
        response = authenticated_client.post(url, data, format='json')

        assert response.status_code == status.HTTP_400_BAD_REQUEST
{% endif -%}


# ============================================================================
# ITEM ENDPOINTS TESTS
# ============================================================================

@pytest.mark.django_db
class TestItemEndpoints:
    """Test item CRUD operations"""

    @pytest.mark.unit
    def test_create_item(self, {% if auth_enabled %}authenticated_client, test_user{% else %}api_client{% endif %}):
        """Test creating a new item"""
        url = reverse('item-list')
        data = {
            'title': 'New Item',
            'description': 'Test description',
{%- if not auth_enabled %}
            'quantity': 10,
            'price': '19.99'
{%- endif %}
        }
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.post(url, data, format='json')

        assert response.status_code == status.HTTP_201_CREATED
        assert response.json()['title'] == data['title']
        assert Item.objects.filter(title=data['title']).exists()

    @pytest.mark.unit
    def test_create_item_invalid_data(self, {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}):
        """Test creating item with invalid data fails"""
        url = reverse('item-list')
        data = {'title': ''}  # Empty title
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.post(url, data, format='json')

        assert response.status_code == status.HTTP_400_BAD_REQUEST

    @pytest.mark.unit
    def test_list_items(self, {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}):
        """Test listing items"""
        url = reverse('item-list')
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.get(url)

        assert response.status_code == status.HTTP_200_OK
        assert 'results' in response.json()

    @pytest.mark.unit
    def test_retrieve_item(self, {% if auth_enabled %}authenticated_client, test_user{% else %}api_client{% endif %}, db):
        """Test retrieving a single item"""
        # Create item for test
        item = Item.objects.create(
            title='Test Item',
            description='Test Description',
{%- if auth_enabled %}
            owner=test_user
{%- else %}
            quantity=5,
            price=10.99
{%- endif %}
        )
        url = reverse('item-detail', kwargs={'pk': item.pk})
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.get(url)

        assert response.status_code == status.HTTP_200_OK
        assert response.json()['title'] == item.title

    @pytest.mark.unit
    def test_update_item(self, {% if auth_enabled %}authenticated_client, test_user{% else %}api_client{% endif %}, db):
        """Test updating an item"""
        # Create item for test
        item = Item.objects.create(
            title='Original Title',
            description='Original Description',
{%- if auth_enabled %}
            owner=test_user
{%- else %}
            quantity=5,
            price=10.99
{%- endif %}
        )
        url = reverse('item-detail', kwargs={'pk': item.pk})
        data = {'title': 'Updated Title'}
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.patch(url, data, format='json')

        assert response.status_code == status.HTTP_200_OK
        item.refresh_from_db()
        assert item.title == data['title']


{%- if auth_enabled %}

    @pytest.mark.integration
    def test_cannot_update_other_user_item(self, authenticated_client, another_user):
        """Test user cannot update another user's item"""
        item = Item.objects.create(
            title='Other User Item',
            owner=another_user
        )
        url = reverse('item-detail', kwargs={'pk': item.pk})
        data = {'title': 'Hacked'}
        response = authenticated_client.patch(url, data, format='json')

        # Can be 403 (forbidden) or 404 (not found, because user can't see other's items)
        assert response.status_code in [status.HTTP_403_FORBIDDEN, status.HTTP_404_NOT_FOUND]
{%- endif %}

    @pytest.mark.unit
    def test_delete_item(self, {% if auth_enabled %}authenticated_client, test_user{% else %}api_client{% endif %}, db):
        """Test deleting an item"""
        # Create item for test
        item = Item.objects.create(
            title='Item to Delete',
{%- if auth_enabled %}
            owner=test_user
{%- else %}
            quantity=5,
            price=10.99
{%- endif %}
        )
        item_id = item.pk
        url = reverse('item-detail', kwargs={'pk': item_id})
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.delete(url)

        assert response.status_code == status.HTTP_204_NO_CONTENT
        assert not Item.objects.filter(pk=item_id).exists()

    @pytest.mark.integration
    def test_pagination(self, {% if auth_enabled %}authenticated_client, test_user{% else %}api_client{% endif %}):
        """Test item list pagination"""
        # Create 25 items
        items = []
        for i in range(25):
            items.append(Item(
                title=f'Item {i}',
                description=f'Description {i}',
{%- if auth_enabled %}
                owner=test_user
{%- else %}
                quantity=i,
                price=i * 1.5
{%- endif %}
            ))
        Item.objects.bulk_create(items)

        url = reverse('item-list')
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.get(url)

        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert 'count' in data
        assert 'next' in data
        assert 'previous' in data
        assert 'results' in data
        assert data['count'] >= 25
        assert len(data['results']) == 10  # Default page size

    @pytest.mark.integration
    def test_search_items(self, {% if auth_enabled %}authenticated_client, test_user{% else %}api_client{% endif %}):
        """Test searching items by title"""
        Item.objects.create(
            title='Searchable Item',
{%- if auth_enabled %}
            owner=test_user
{%- else %}
            quantity=5,
            price=10.0
{%- endif %}
        )

        url = reverse('item-list') + '?search=Searchable'
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.get(url)

        assert response.status_code == status.HTTP_200_OK
        results = response.json()['results']
        assert len(results) > 0
        assert 'Searchable' in results[0]['title']

    @pytest.mark.integration
    def test_ordering_items(self, {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}):
        """Test ordering items"""
        url = reverse('item-list') + '?ordering=-created_at'
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.get(url)

        assert response.status_code == status.HTTP_200_OK


# ============================================================================
# EDGE CASES & ERROR HANDLING
# ============================================================================

@pytest.mark.django_db
class TestEdgeCases:
    """Test edge cases and error handling"""

    @pytest.mark.unit
    def test_invalid_json(self, {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}):
        """Test API handles invalid JSON gracefully"""
        url = reverse('item-list')
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.post(
            url,
            data='invalid json{',
            content_type='application/json'
        )
        assert response.status_code == status.HTTP_400_BAD_REQUEST

    @pytest.mark.unit
    def test_method_not_allowed(self, {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}):
        """Test method not allowed returns 405"""
        url = '/'  # Root endpoint typically only allows GET
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.post(url, {})
        assert response.status_code == status.HTTP_405_METHOD_NOT_ALLOWED

    @pytest.mark.unit
    def test_not_found(self, {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}):
        """Test 404 for non-existent endpoint"""
        response = {% if auth_enabled %}authenticated_client{% else %}api_client{% endif %}.get('/api/nonexistent/')
        assert response.status_code == status.HTTP_404_NOT_FOUND
