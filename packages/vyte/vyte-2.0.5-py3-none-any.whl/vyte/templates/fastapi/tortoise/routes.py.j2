{% if auth_enabled %}
"""
API routes for FastAPI + TortoiseORM (auth enabled)
Generated by vyte v2.0
"""
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from datetime import datetime, timedelta, timezone
from typing import List

from src.models.models import User, Item
from src.schemas.schemas import (
    UserResponse,
    UserCreate,
    Token,
    TokenData,
    ItemResponse,
    ItemCreate,
    ItemUpdate
)
from src.config.config import settings

router = APIRouter()

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")


# JWT Helper Functions
def create_access_token(data: dict, expires_delta: timedelta = None) -> str:
    """Create JWT access token"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.JWT_ACCESS_TOKEN_EXPIRES)

    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM)
    return encoded_jwt


async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    """Get current authenticated user"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user = await User.filter(username=username).first()

    if user is None:
        raise credentials_exception

    return user


async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    """Get current active user"""
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


# ============================================
# Authentication Routes
# ============================================

@router.post("/auth/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED, tags=["Authentication"])
async def register(user_data: UserCreate):
    """
    Register a new user

    - **username**: unique username (3-50 characters)
    - **email**: valid email address
    - **password**: secure password (min 8 characters)
    """
    # Check if username exists
    if await User.filter(username=user_data.username).exists():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already registered"
        )

    # Check if email exists
    if await User.filter(email=user_data.email).exists():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    # Create user with helper method
    user = await User.create_user(
        username=user_data.username,
        email=user_data.email,
        password=user_data.password
    )

    return user


@router.post("/auth/login", response_model=Token, tags=["Authentication"])
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """
    Login with username and password

    Returns JWT access token for authentication
    """
    user = await User.filter(username=form_data.username).first()

    if not user or not user.verify_password(form_data.password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )

    # Create access token with username
    access_token = create_access_token(data={"sub": user.username})

    return {"access_token": access_token, "token_type": "bearer"}


@router.get("/auth/me", response_model=UserResponse, tags=["Authentication"])
async def get_me(current_user: User = Depends(get_current_active_user)):
    """
    Get current authenticated user information

    Requires valid JWT token in Authorization header
    """
    return current_user


@router.get("/users", response_model=List[UserResponse], tags=["Users"])
async def list_users(
    skip: int = 0,
    limit: int = 100,
    current_user: User = Depends(get_current_active_user)
):
    """
    Get list of all users (requires authentication)

    - **skip**: number of records to skip (pagination)
    - **limit**: maximum number of records to return
    """
    users = await User.all().offset(skip).limit(limit)
    return users


@router.get("/users/{user_id}", response_model=UserResponse, tags=["Users"])
async def get_user(
    user_id: int,
    current_user: User = Depends(get_current_active_user)
):
    """Get specific user by ID (requires authentication)"""
    user = await User.filter(id=user_id).first()

    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    return user


# ============================================
# Item Routes (Protected)
# ============================================

@router.post("/items", response_model=ItemResponse, status_code=status.HTTP_201_CREATED, tags=["Items"])
async def create_item(
    item_data: ItemCreate,
    current_user: User = Depends(get_current_active_user)
):
    """
    Create a new item (requires authentication)

    The authenticated user becomes the owner of the item

    """
    item = await Item.create(
        title=item_data.title,
        description=item_data.description,
        owner=current_user
    )

    return item


@router.get("/items", response_model=List[ItemResponse], tags=["Items"])
async def list_items(
    skip: int = 0,
    limit: int = 100,
    current_user: User = Depends(get_current_active_user)
):
    """
    Get list of items owned by current user (requires authentication)

    - **skip**: number of records to skip (pagination)
    - **limit**: maximum number of records to return
    """
    items = await Item.filter(owner=current_user).offset(skip).limit(limit)
    return items


@router.get("/items/{item_id}", response_model=ItemResponse, tags=["Items"])
async def get_item(
    item_id: int,
    current_user: User = Depends(get_current_active_user)
):
    """Get specific item by ID (requires authentication)"""
    item = await Item.filter(id=item_id).first()

    if not item:
        raise HTTPException(status_code=404, detail="Item not found")

    # Check ownership
    if item.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to access this item")

    return item


@router.put("/items/{item_id}", response_model=ItemResponse, tags=["Items"])
async def update_item(
    item_id: int,
    item_data: ItemUpdate,
    current_user: User = Depends(get_current_active_user)
):
    """Update an item (requires authentication and ownership)"""
    item = await Item.filter(id=item_id).first()

    if not item:
        raise HTTPException(status_code=404, detail="Item not found")

    # Check ownership
    if item.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to modify this item")

    # Update fields
    if item_data.title is not None:
        item.title = item_data.title
    if item_data.description is not None:
        item.description = item_data.description

    await item.save()

    return item


@router.delete("/items/{item_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Items"])
async def delete_item(
    item_id: int,
    current_user: User = Depends(get_current_active_user)
):
    """Delete an item (requires authentication and ownership)"""
    item = await Item.filter(id=item_id).first()

    if not item:
        raise HTTPException(status_code=404, detail="Item not found")

    # Check ownership
    if item.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to delete this item")

    await item.delete()

    return None
{% else %}
"""
API routes for FastAPI + TortoiseORM (no auth)
Generated by vyte v2.0
"""
from fastapi import APIRouter, HTTPException, status
from typing import List

from src.models.models import Item
from src.schemas.schemas import ItemResponse, ItemCreate, ItemUpdate
from src.config.config import settings

router = APIRouter()


@router.post("/items", response_model=ItemResponse, status_code=status.HTTP_201_CREATED, tags=["Items"])
async def create_item(item_data: ItemCreate):
    """Create a new item"""
    item = await Item.create(
        title=item_data.title,
        description=item_data.description
    )
    return item


@router.get("/items", response_model=List[ItemResponse], tags=["Items"])
async def list_items(skip: int = 0, limit: int = 100):
    """Get list of items"""
    items = await Item.all().offset(skip).limit(limit)
    return items


@router.get("/items/{item_id}", response_model=ItemResponse, tags=["Items"])
async def get_item(item_id: int):
    item = await Item.filter(id=item_id).first()
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    return item


@router.put("/items/{item_id}", response_model=ItemResponse, tags=["Items"])
async def update_item(item_id: int, item_data: ItemUpdate):
    item = await Item.filter(id=item_id).first()
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    if item_data.title is not None:
        item.title = item_data.title
    if item_data.description is not None:
        item.description = item_data.description
    await item.save()
    return item


@router.delete("/items/{item_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Items"])
async def delete_item(item_id: int):
    item = await Item.filter(id=item_id).first()
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    await item.delete()
    return None
{% endif %}
