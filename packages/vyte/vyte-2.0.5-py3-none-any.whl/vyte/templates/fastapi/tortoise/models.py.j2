"""
Database models for FastAPI + TortoiseORM
Generated by vyte v2.0
"""
from tortoise import fields
from tortoise.models import Model
{% if auth_enabled -%}
import bcrypt
import hashlib
{% endif %}
"""
Database models for FastAPI + TortoiseORM
Generated by vyte v2.0
"""
from tortoise import fields
from tortoise.models import Model
{% if auth_enabled %}
import bcrypt
import hashlib
{% endif %}



{% if auth_enabled %}
class User(Model):
    """User model"""

    id = fields.IntField(pk=True)
    username = fields.CharField(max_length=50, unique=True, index=True)
    email = fields.CharField(max_length=100, unique=True, index=True)
    hashed_password = fields.CharField(max_length=255)
    is_active = fields.BooleanField(default=True)
    created_at = fields.DatetimeField(auto_now_add=True)
    updated_at = fields.DatetimeField(auto_now=True)

    # Relationships
    items: fields.ReverseRelation["Item"]

    class Meta:
        table = "users"

    @classmethod
    async def create_user(cls, username: str, email: str, password: str, **kwargs) -> "User":
        """
        Create a new user with hashed password

        Args:
            username: Username
            email: Email address
            password: Plain text password (will be hashed)
            **kwargs: Additional fields

        Returns:
            User instance
        """
        user = cls(
            username=username,
            email=email,
            hashed_password="",  # Temporary
            **kwargs
        )
        user.set_password(password)
        await user.save()
        return user

    def set_password(self, password: str) -> None:
        """
        Hash and set password using bcrypt with SHA256 pre-hash
        Pre-hash with SHA256 to avoid bcrypt's 72-byte limit
        """
        # Pre-hash the password with SHA256
        password_hash = hashlib.sha256(password.encode('utf-8')).digest()

        # Hash with bcrypt
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password_hash, salt)

        # Store as string
        self.hashed_password = hashed.decode('utf-8')

    def verify_password(self, password: str) -> bool:
        """
        Verify password against hash
        Pre-hash with SHA256 first, then verify with bcrypt
        """
        if not self.hashed_password:
            return False

        # Pre-hash the password with SHA256
        password_hash = hashlib.sha256(password.encode('utf-8')).digest()

        # Verify with bcrypt
        return bcrypt.checkpw(password_hash, self.hashed_password.encode('utf-8'))

    def __str__(self) -> str:
        return f"User(id={self.id}, username='{self.username}')"

    def __repr__(self) -> str:
        return f"User(id={self.id}, username='{self.username}')"

    def to_dict(self) -> dict:
        """Convert model to dictionary"""
        return {
            "id": self.id,
            "username": self.username,
            "email": self.email,
            "is_active": self.is_active,
        }



{% endif %}
class Item(Model):
    """Item model"""

    id = fields.IntField(pk=True)
    title = fields.CharField(max_length=100)
    description = fields.TextField(null=True)
    created_at = fields.DatetimeField(auto_now_add=True)
    updated_at = fields.DatetimeField(auto_now=True)

{% if auth_enabled %}
    # Foreign key to User
    owner = fields.ForeignKeyField(
        "models.User",
        related_name="items",
        on_delete=fields.CASCADE
    )
{% endif %}

    class Meta:
        table = "items"

    def __str__(self) -> str:
        return f"Item(id={self.id}, title='{self.title}')"

    def __repr__(self) -> str:
        return f"Item(id={self.id}, title='{self.title}')"

    def to_dict(self) -> dict:
        """Convert model to dictionary"""
        return {
            "id": self.id,
            "title": self.title,
            "description": self.description,
{% if auth_enabled %}
            "owner": self.owner_id,
{% endif %}
        }
