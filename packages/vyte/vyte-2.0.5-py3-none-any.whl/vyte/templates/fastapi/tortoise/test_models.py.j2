"""
Model tests for FastAPI + TortoiseORM
Generated by vyteo v2.0
"""
import pytest
"""
Model tests for FastAPI + TortoiseORM
Generated by vyte v2.0
"""
import pytest
from tortoise.exceptions import IntegrityError
{% if auth_enabled %}
from src.models.models import User, Item
{% else %}
from src.models.models import Item
{% endif %}


{% if auth_enabled %}
class TestUserModel:
    """Test User model"""

    async def test_create_user(self):
        """Test creating a user"""
        user = await User.create_user(
            username="testuser",
            email="test@example.com",
            password="testpassword123"
        )

        # The ID is set during save
        assert user.id is not None
        assert user.username == "testuser"
        assert user.email == "test@example.com"
        assert user.is_active is True

    async def test_user_password_hashing(self):
        """Test password hashing"""
        user = await User.create_user(
            username="testuser",
            email="test@example.com",
            password="securepassword123"
        )

        # Password should be hashed
        assert user.hashed_password != "securepassword123"
        assert len(user.hashed_password) > 0

        # Should be able to verify correct password
        assert user.verify_password("securepassword123") is True

        # Should fail with wrong password
        assert user.verify_password("wrongpassword") is False

    async def test_user_unique_username(self):
        """Test that username must be unique"""
        await User.create_user(
            username="uniqueuser",
            email="user1@example.com",
            password="password123"
        )

        # Trying to create another user with same username should fail
        with pytest.raises((IntegrityError, Exception)) as exc_info:
            await User.create_user(
                username="uniqueuser",
                email="user2@example.com",
                password="password123"
            )

        # Verify it's the right kind of error
        assert "unique" in str(exc_info.value).lower() or "duplicate" in str(exc_info.value).lower()

    async def test_user_unique_email(self):
        """Test that email must be unique"""
        await User.create_user(
            username="user1",
            email="unique@example.com",
            password="password123"
        )

        # Trying to create another user with same email should fail
        with pytest.raises((IntegrityError, Exception)) as exc_info:
            await User.create_user(
                username="user2",
                email="unique@example.com",
                password="password123"
            )

        # Verify it's the right kind of error
        assert "unique" in str(exc_info.value).lower() or "duplicate" in str(exc_info.value).lower()

    async def test_user_to_dict(self):
        """Test user to_dict method"""
        user = await User.create_user(
            username="testuser",
            email="test@example.com",
            password="password123"
        )

        user_dict = user.to_dict()

        assert isinstance(user_dict, dict)
        assert user_dict["username"] == "testuser"
        assert user_dict["email"] == "test@example.com"
        assert "id" in user_dict
        assert "hashed_password" not in user_dict  # Should not expose password

    async def test_user_repr(self):
        """Test user string representation"""
        user = await User.create_user(
            username="testuser",
            email="test@example.com",
            password="password123"
        )

        # After create_user, the ID should be set
        assert user.id is not None

        # Get string representation
        str_repr = str(user)
        repr_str = repr(user)

        # Check that they contain the username
        assert "testuser" in str_repr
        assert "testuser" in repr_str


{% endif %}
class TestItemModel:
    """Test Item model"""

{% if auth_enabled %}
    async def test_create_item(self, test_user: dict):
        """Test creating an item"""
        user = await User.filter(id=test_user["id"]).first()

        item = await Item.create(
            title="Test Item",
            description="Test description",
            owner=user
        )

        assert item.id is not None
        assert item.title == "Test Item"
        assert item.description == "Test description"
        assert item.owner_id == test_user["id"]

    async def test_item_without_description(self, test_user: dict):
        """Test creating item without description (should be optional)"""
        user = await User.filter(id=test_user["id"]).first()

        item = await Item.create(
            title="Item No Description",
            owner=user
        )

        assert item.id is not None
        assert item.title == "Item No Description"
        assert item.description is None

    async def test_item_owner_relationship(self, test_user: dict):
        """Test item-owner relationship"""
        user = await User.filter(id=test_user["id"]).first()

        item = await Item.create(
            title="Test Item",
            description="Test description",
            owner=user
        )

        # Fetch owner
        await item.fetch_related('owner')

        assert item.owner is not None
        assert item.owner.id == test_user["id"]
        assert item.owner.username == test_user["username"]

    async def test_item_to_dict(self, test_user: dict):
        """Test item to_dict method"""
        user = await User.filter(id=test_user["id"]).first()

        item = await Item.create(
            title="Test Item",
            description="Test description",
            owner=user
        )

        item_dict = item.to_dict()

        assert isinstance(item_dict, dict)
        assert item_dict["title"] == "Test Item"
        assert item_dict["description"] == "Test description"
        assert "id" in item_dict
        assert "owner_id" in item_dict

    async def test_item_repr(self, test_user: dict):
        """Test item string representation"""
        user = await User.filter(id=test_user["id"]).first()

        item = await Item.create(
            title="Test Item",
            description="Test description",
            owner=user
        )

        # Get string representation
        str_repr = str(item)
        repr_str = repr(item)

        # Check that they contain the title
        assert "Test Item" in str_repr
        assert "Test Item" in repr_str

    async def test_cascade_delete(self):
        """Test that deleting user deletes associated items"""
        # Create and save user first
        user = User(
            username="deleteuser",
            email="delete@example.com",
            hashed_password=""
        )
        user.set_password("password123")
        await user.save()

        # Create item for user
        item = await Item.create(
            title="Item to be deleted",
            description="Will be deleted with user",
            owner=user
        )

        item_id = item.id

        # Delete user
        await user.delete()

        # Item should also be deleted (cascade)
        deleted_item = await Item.filter(id=item_id).first()
        assert deleted_item is None
{% else %}
    async def test_create_item(self):
        """Test creating an item"""
        item = await Item.create(
            title="Test Item",
            description="Test description"
        )

        assert item.id is not None
        assert item.title == "Test Item"
        assert item.description == "Test description"

    async def test_item_without_description(self):
        """Test creating item without description (should be optional)"""
        item = await Item.create(
            title="Item No Description"
        )

        assert item.id is not None
        assert item.title == "Item No Description"
        assert item.description is None

    async def test_item_to_dict(self):
        """Test item to_dict method"""
        item = await Item.create(
            title="Test Item",
            description="Test description"
        )

        item_dict = item.to_dict()

        assert isinstance(item_dict, dict)
        assert item_dict["title"] == "Test Item"
        assert item_dict["description"] == "Test description"
        assert "id" in item_dict

    async def test_item_repr(self):
        """Test item string representation"""
        item = await Item.create(
            title="Test Item",
            description="Test description"
        )

        # Get string representation
        str_repr = str(item)
        repr_str = repr(item)

        # Check that they contain the title
        assert "Test Item" in str_repr
        assert "Test Item" in repr_str
{% endif %}


class TestModelValidation:
    """Test model validation"""

{% if auth_enabled %}
    async def test_user_empty_username(self):
        """Test that empty username is not allowed"""
        # TortoiseORM doesn't validate empty strings by default
        # This would need custom validators
        user = await User.create_user(
            username="u",
            email="test@example.com",
            password="password123"
        )
        assert user.username == "u"

    async def test_user_empty_email(self):
        """Test that empty email is not allowed"""
        user = await User.create_user(
            username="testuser",
            email="e@e.com",
            password="password123"
        )
        assert len(user.email) > 0

    async def test_item_empty_title(self, test_user: dict):
        """Test that empty title is not allowed"""
        user = await User.filter(id=test_user["id"]).first()

        item = await Item.create(
            title="t",
            owner=user
        )
        assert len(item.title) > 0
{% else %}
    async def test_item_empty_title(self):
        """Test that empty title is not allowed"""
        item = await Item.create(
            title="t"
        )
        assert len(item.title) > 0
{% endif %}
