from _typeshed import Incomplete
from ray.autoscaler.command_runner import CommandRunnerInterface as CommandRunnerInterface
from ray.autoscaler.node_provider import NodeProvider
from typing import Any
from yellowdog_client.common import SearchClient as SearchClient
from yellowdog_client.model import Node as Node, WorkerPool as WorkerPool, WorkerPoolSummary as WorkerPoolSummary
from yellowdog_client.platform_client import PlatformClient
from yellowdog_ray.utils.utils import get_public_ip_from_node as get_public_ip_from_node

YD_API_URL_VAR: str
YD_DEFAULT_API_URL: str
YD_API_KEY_ID_VAR: str
YD_API_KEY_SECRET_VAR: str
PROP_CLUSTER_NAMESPACE: str
PROP_RAY_HEAD_NODE_TASK_SCRIPT: str
PROP_RAY_WORKER_NODE_TASK_SCRIPT: str
PROP_CLUSTER_TAG: str
PROP_CLUSTER_LIFETIME_HOURS: str
PROP_BUILD_TIMEOUT_MINUTES: str
PROP_FILES_TO_UPLOAD: str
PROP_TAG_SERVER_PORT: str
PROP_CRT: str
PROP_IMAGES_ID: str
PROP_USERDATA: str
PROP_EXTRA_USERDATA: str
PROP_CAPTURE_TASKOUTPUT: str
PROP_METRICS_ENABLED: str
TAG_PUBLIC_IP: str
TAG_PRIVATE_IP: str
TAG_TERMINATED: str
VAL_TRUE: str
TASK_TYPE: str
HEAD_NODE_TASK_POLLING_INTERVAL: Incomplete
BUILD_TIMEOUT_DEFAULT_MINUTES: float
CLUSTER_LIFETIME_DEFAULT_HOURS: float
TAG_SERVER_PORT_DEFAULT: int
LOCALHOST: str
PROP_SSH_USER: str
PROP_SSH_PRIVATE_KEY: str
SCRIPT_FILE_PREFIX: str
HEAD_NODE_NAME: str
RAY_HEAD_IP_ENV_VAR: str
PROP_PROVIDER: str
PROP_AVAILABLE_NODE_TYPES: str
PROP_AUTH: str
HEAD_NODE_TASK_NAME: Incomplete
WORKER_NODES_TASK_GROUP_NAME: str
WORKER_NODE_TASK_NAME: str
EXECUTION_CONTEXT_USERNAME: str
IDLE_NODE_YD_SHUTDOWN: Incomplete
MAX_NODES_IN_WORKER_POOL: int
LOG: Incomplete

class RayDogNodeProvider(NodeProvider):
    @staticmethod
    def bootstrap_config(cluster_config: dict[str, Any]) -> dict[str, Any]: ...
    head_node_public_ip: Incomplete
    head_node_private_ip: Incomplete
    def __init__(self, provider_config: dict[str, Any], cluster_name: str) -> None: ...
    def non_terminated_nodes(self, tag_filters: dict[str, str]) -> list[str]: ...
    def is_running(self, node_id: str) -> bool: ...
    def is_terminated(self, node_id: str) -> bool: ...
    def node_tags(self, node_id: str) -> dict[str, str]: ...
    def set_node_tags(self, node_id: str, tags: dict) -> None: ...
    def external_ip(self, node_id: str) -> str: ...
    def internal_ip(self, node_id: str) -> str: ...
    def create_node(self, node_config: dict[str, Any], tags: dict[str, str], count: int) -> dict[str, Any] | None: ...
    def create_node_with_resources_and_labels(self, node_config: dict[str, Any], tags: dict[str, str], count: int, resources: dict[str, float], labels: dict[str, str]) -> dict[str, Any] | None: ...
    def terminate_node(self, node_id: str) -> None: ...
    def terminate_nodes(self, node_ids: list[str]) -> None: ...
    def prepare_for_head_node(self, cluster_config: dict[str, Any]) -> dict[str, Any]: ...
    def __del__(self) -> None: ...

class TagStore:
    def __init__(self, cluster_name: str) -> None: ...
    def find_matches(self, longlist: list[str] | None, tag_name: str, tag_value: str) -> list[str]: ...
    def update_tags(self, node_id: str, new_tags: dict[str, str]) -> None: ...
    def get_all_tags(self, node_id: str) -> dict[str, str]: ...
    def get_tag(self, node_id: str, tag_name: str) -> str | None: ...
    def connect(self, remote_server: str | None, port: int, auth_config: dict[str, str] = None) -> None: ...
    def close(self) -> None: ...
    def refresh(self) -> None: ...

class AutoRayDog:
    yd_client: PlatformClient
    head_node_task_id: str | None
    head_node_public_ip: str | None
    head_node_private_ip: str | None
    def __init__(self, provider_config: dict[str, Any], cluster_name: str, tag_store: TagStore) -> None: ...
    def has_worker_pool(self, flavour: str) -> bool: ...
    def create_worker_pool(self, flavour: str, node_type: str, node_config: dict[str, Any], count: int, userdata: str, metrics_enabled: bool = False) -> None: ...
    def find_raydog_cluster(self) -> bool: ...
    def get_ip_addresses(self, node_id: str) -> tuple[str, str]: ...
    def shut_down(self) -> None: ...
    def create_head_node_task(self, flavour: str, ray_start_script: str, capture_taskoutput: bool = False) -> str: ...
    def create_worker_node_tasks(self, flavour: str, ray_start_script: str, count: int, capture_taskoutput: bool = False) -> list[str]: ...
