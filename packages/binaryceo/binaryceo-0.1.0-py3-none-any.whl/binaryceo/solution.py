"""
Solution representation for Binary CEO algorithm.

This module defines the CelestialBody class, which represents a single
solution (search agent) in the Binary CEO algorithm.
"""

from typing import Optional

import numpy as np


class CelestialBody:
    """
    Represents a celestial body (solution) in the Binary CEO algorithm.

    This class is a data container for a single search agent. It holds
    the agent's state, which includes its binary solution, its
    continuous-space position, and its fitness.

    Attributes:
        position (np.ndarray):
            The binary solution vector [0, 1, ...]. This is the
            vector that is evaluated by the fitness function.

        continuous_position (np.ndarray):
            The continuous vector [2.2, -1.8, ...] that represents
            the "true" position in the search space. This vector
            is updated by the physics forces.

        fitness (float):
            The quality score of the binary `position` (lower is better).

        proposed_binary_position (Optional[np.ndarray]):
            A temporary holding spot for a *new* binary position
            generated by Module 4. Module 5 will evaluate this
            and decide whether to make it the new `position`.
    """

    def __init__(
        self,
        position: np.ndarray,
        continuous_position: np.ndarray,  # No longer optional
        fitness: float,  # No longer optional
    ):
        """
        Initialize a celestial body.

        Args:
            position: Binary vector representing the solution.
            continuous_position: Continuous vector for position updates.
            fitness: Fitness score of the initial position.
        """
        self.position = position.copy()
        self.continuous_position = continuous_position.copy()
        self.fitness = fitness

        # This will be set by Module 4 (Position Update)
        self.proposed_binary_position: Optional[np.ndarray] = None

    def copy(self) -> "CelestialBody":
        """
        Create a deep copy of this celestial body.
        This is critical for tracking the global_best_body.

        Returns:
            New CelestialBody instance with copied attributes.
        """
        # Create a new body with the core (immutable) attributes
        new_body = CelestialBody(
            position=self.position.copy(),
            continuous_position=self.continuous_position.copy(),
            fitness=self.fitness,
        )

        # Manually copy over any mutable "state" attributes
        new_body.proposed_binary_position = (
            self.proposed_binary_position.copy()
            if self.proposed_binary_position is not None
            else None
        )
        return new_body

    def __repr__(self) -> str:
        """String representation of the celestial body."""
        n_selected = np.sum(self.position)

        fitness_str = f"{self.fitness:.6f}" if self.fitness is not None else "N/A"

        return (
            f"CelestialBody(features={n_selected}/{len(self.position)}, "
            f"fitness={fitness_str})"
        )

    def __lt__(self, other: "CelestialBody") -> bool:
        """
        Allows sorting bodies by fitness (less than).
        Needed for Module 3 (Partitioning) to find leaders.
        """
        if self.fitness is None or other.fitness is None:
            return False  # Or handle as per your logic
        return self.fitness < other.fitness

    def __eq__(self, other: object) -> bool:
        """
        Allows comparing bodies.
        Needed for Module 3 to find leaders in sets.
        """
        if not isinstance(other, CelestialBody):
            return False
        # Two bodies are equal if their state is identical
        return self.fitness == other.fitness and np.array_equal(
            self.position, other.position
        )

    def __hash__(self) -> int:
        """
        Allows CelestialBody objects to be used as keys in dictionaries.
        This is *required* for Module 3 (Partitioning).
        """
        # Hash the fitness and the immutable bytes of the position
        return hash((self.fitness, self.position.tobytes()))
