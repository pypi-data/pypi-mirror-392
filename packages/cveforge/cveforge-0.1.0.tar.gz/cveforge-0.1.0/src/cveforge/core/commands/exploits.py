from collections.abc import Callable
from typing import Any, Self, TypedDict
from cveforge.core.context import Context
from cveforge.utils.args import ForgeParser

class ParserDict(TypedDict):
    parser: type[ForgeParser]|None
    callable: Callable[..., Any]

class ExploitParser(ForgeParser):
    _parsers: dict[str, ParserDict] = {}
    _singleton_parser_inst: Self|None = None

    # def __new__(cls, *args: Any, **kwargs: Any) -> Self:
    #     if not cls._singleton_parser_inst:
    #         cls._singleton_parser_inst = super().__new__(cls)
    #     return cls._singleton_parser_inst

    def __init__(self, *args: Any, **kwargs: Any):
        kwargs.update({"prog": "exploit"})
        super().__init__(*args, **kwargs)

    @classmethod
    def instance(cls):
        return cls._singleton_parser_inst

    @classmethod
    def register_exploit(cls, name: str, parser: type[ForgeParser]|None, callable: Callable[..., Any]) -> None:
        cls._parsers[name] = {
            "parser": parser,
            "callable": callable
        }

    @classmethod
    def get_exploit_parser(cls, name: str):
        return cls._parsers.get(name, {}).get("parser")
    
    @classmethod
    def run_exploit(cls, name: str, context: Context, option: str, **kwargs: Any):
        exploit = cls._parsers.get(name)
        if not exploit:
            raise ValueError("No exploit registered with the given name")

        if option == "run":
            exploit_callable = exploit.get("callable")
            return exploit_callable(context, **kwargs)
        elif option == "search":
            return cls.search_exploit(name)
    @classmethod
    def search_exploit(cls, name: str, ):
        return "no implemented yet"

    def setUp(self) -> None:
        subparsers = self.add_subparsers(dest="option", required=True) # this allows tcve_exploit to extend the options available
        # handle search
        search_parser = subparsers.add_parser("search", prog=f"{self.prog} search", add_help=True, help="Search for useful information in our DB, for OSINT please use the OSINT command instead")
        search_options = search_parser.add_subparsers(dest="option")
        malware_parser = search_options.add_parser("malware", help="Search for a malware payload in its binary form, either from The Zoo repository or from here, useful for when we need a way to either persist or escalate privilege on a given computer [WARNING: THE USE OF MALWARE ON UNAUTHORIZED TARGETS IS ILLEGAL]")
        malware_parser.add_argument(dest="search_term", help="Term to search for", nargs="+")
        exploit_parser = search_options.add_parser("exploit", help="Search for an exploit in its binary form, either from The Zoo repository or from here, useful for when we need a way to either persist or escalate privilege on a given computer [WARNING: THE USE OF MALWARE ON UNAUTHORIZED TARGETS IS ILLEGAL]")
        exploit_parser.add_argument(dest="search_term", help="Term to search for", nargs="+")

        # handle run
        run_parser = subparsers.add_parser("run", prog=f"{self.prog} run", add_help=True, help="Run an exploit on a target. [WARNING: The use of this command on unauthorized targets is considered ILLEGAL, WE ARE NOT RESPONSIBLE FOR THE MISUSE OF THIS TOOL]")
        run_command_parser = run_parser.add_subparsers(dest='command')
        # handle scan
        scan_parser = subparsers.add_parser("scan", prog=f"{self.prog} scan", add_help=True, help="Scan a target for known vulnerabilities")
        scan_parser.add_argument("uri")
        # handle patch
        patch_parser = subparsers.add_parser("patch", prog=f"{self.prog} patch", add_help=True, help="Patch a vulnerability on the given URI, an URI is required to handle different connection protocols like SSH and so on")
        patch_parser.add_argument("uri")

        for parser_name in self._parsers:
            parser_value = self._parsers[parser_name]
            argument_parser = parser_value.get("parser")
            option_parser = run_command_parser.add_parser(
                name=parser_name,
                prog=f"{self.prog} run"
            )
            if argument_parser:
                parser = argument_parser()
                parser.setUp()
                # option_parser._actions = parser._actions # Hack a Tom :-) this should have a more human like way of doing it xD but let's just have a party for this one
                
                option_parser.__dict__.update(**parser.__dict__)