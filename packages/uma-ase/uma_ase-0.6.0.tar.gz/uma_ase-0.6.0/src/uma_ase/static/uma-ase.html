<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>uma-ase Web Interface</title>
<style>
  :root {
    color-scheme: light dark;
  }
  body {
    font-family: "Segoe UI", Roboto, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f5f5f5;
    color: #222;
  }
  header {
    background: linear-gradient(120deg, #004d7a, #008793);
    color: #fff;
    padding: 1.5rem 2rem;
    display: flex;
    align-items: center;
    gap: 1.5rem;
    flex-wrap: wrap;
  }
  .brand {
    display: flex;
    align-items: center;
    flex-shrink: 0;
  }
  .brand img {
    width: 140px;
    height: auto;
    display: block;
  }
  .header-copy {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }
  .header-copy h1 {
    margin: 0;
  }
  .header-copy p {
    margin: 0;
    max-width: 600px;
  }
  main {
    padding: 2rem;
  }
  .layout-grid {
    display: grid;
    gap: 1.5rem;
    grid-template-columns: minmax(0, 1fr);
    align-items: start;
  }
  @media (min-width: 1024px) {
    .layout-grid {
      grid-template-columns: 40% 60%;
    }
    .input-section {
      grid-column: 1;
    }
    .actions-results {
      grid-column: 2;
      display: grid;
      row-gap: 5px;
    }
  }
  section {
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
    padding: 1.5rem;
  }
  .form-grid {
    display: grid;
    gap: 0.75rem;
  }
  @media (min-width: 768px) {
    .form-grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
      column-gap: 1.5rem;
    }
    .form-grid .full-width {
      grid-column: 1 / -1;
    }
  }
  .thermo-grid {
    display: grid;
    gap: 0.75rem;
  }
  @media (min-width: 768px) {
    .thermo-grid {
      grid-template-columns: 1fr;
    }
  }
  .actions-row {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-top: 0.5rem;
  }
  .actions-row button {
    margin-top: 0;
  }
  .summary-block {
    background: #0f172a;
    color: #e2e8f0;
    border-radius: 6px;
    padding: 0.75rem;
    font-family: "Fira Code", "Courier New", monospace;
    white-space: pre-wrap;
    overflow-x: auto;
    margin: 0;
    min-height: 120px;
    max-height: 200px;
    overflow-y: auto;
  }
  .actions-results {
    display: grid;
    row-gap: 5px;
  }
  #structure-summary h3 {
    margin-bottom: 0.35rem;
    margin-top: 0;
  }
  .group-title {
    display: block;
    font-weight: 600;
    margin-bottom: 0.5rem;
  }
  .is-disabled {
    opacity: 0.45;
  }
  h2 {
    margin-top: 0;
    font-size: 1.25rem;
    color: #004d7a;
  }
  label {
    display: block;
    margin-top: 0.75rem;
    font-weight: 600;
  }
  input[type="file"],
  select,
  input[type="number"],
  input[type="text"] {
    width: 80%;
    padding: 0.3rem 0.65rem;
    margin-top: 0.2rem;
    border-radius: 6px;
    border: 1px solid #cbd5e1;
    font-size: 0.95rem;
    min-height: 28px;
  }
  .file-indicator {
    display: block;
    font-size: 0.85rem;
    color: #475569;
    margin-top: 0.3rem;
    word-break: break-word;
  }
  .help-hint {
    font-size: 0.8rem;
    color: #64748b;
    margin-top: 0.25rem;
  }
  .viewer-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
  }
  .viewer-upload-label {
    font-weight: 600;
    color: #0f172a;
  }
  .viewer-controls input[type="file"] {
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    padding: 0.4rem;
  }
  .viewer-panel,
  .analyze-panel {
    border: 1px solid #cbd5e1;
    border-radius: 12px;
    padding: 1rem;
    background: #ffffff;
    box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
  }
  .analyze-panel {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }
  .analyze-group .btn-inline {
    width: auto;
    align-self: flex-start;
  }
  .analyze-block + .analyze-block {
    border-top: 1px solid #e2e8f0;
    padding-top: 1.25rem;
  }
  .analyze-block h3 {
    margin-top: 0;
    margin-bottom: 0.5rem;
  }
  .analyze-preview {
    margin-top: 1rem;
    max-height: 260px;
    overflow-y: auto;
  }
  .multi-result-row {
    padding: 0.5rem 0;
    border-bottom: 1px solid rgba(148, 163, 184, 0.3);
    font-size: 0.9rem;
  }
  .multi-result-row:last-child {
    border-bottom: none;
  }
  .multi-result-row pre {
    margin: 0;
    white-space: pre-wrap;
    font-family: "Fira Code", "Courier New", monospace;
    font-size: inherit;
    color: inherit;
  }
  .multi-result-actions {
    margin-top: 0.35rem;
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }
  .panel-actions {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.75rem;
  }
  .pdf-frame {
    width: 100%;
    min-height: 520px;
    border: 1px solid #cbd5e1;
    border-radius: 12px;
    margin-top: 1rem;
  }
  .tabs {
    display: inline-flex;
    border-radius: 999px;
    background: #e2e8f0;
    padding: 0.25rem;
    margin-bottom: 1.5rem;
    gap: 0.35rem;
  }
  .tab-button {
    background: transparent;
    border: none;
    border-radius: 999px;
    padding: 0.5rem 1.5rem;
    font-size: 0.95rem;
    cursor: pointer;
    color: #334155;
    transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
  }
  .tab-button.active {
    background: #fff;
    color: #008793;
    box-shadow: 0 4px 12px rgba(15, 23, 42, 0.12);
  }
  .tab-button:not(.active):hover {
    color: #0f172a;
  }
  .tab-content {
    display: none;
  }
  .tab-content.active {
    display: block;
  }
  .visualize-grid {
    display: grid;
    gap: 1.5rem;
    grid-template-columns: minmax(0, 1fr);
    align-items: start;
  }
  @media (min-width: 1024px) {
    .visualize-grid {
      grid-template-columns: 40% 60%;
    }
  }
  .viewer-section iframe {
    width: 100%;
    min-height: 520px;
    border: 1px solid #cbd5e1;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(15, 23, 42, 0.1);
    background: #fff;
  }
  .geoopt-extra {
    display: grid;
    gap: 0.75rem;
  }
  @media (min-width: 768px) {
    .geoopt-extra {
      grid-template-columns: repeat(2, minmax(0, 1fr));
      column-gap: 1.5rem;
    }
  }
  .checkbox-group {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
    margin-top: 0.75rem;
  }
  .checkbox-group label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0;
    font-weight: 500;
  }
  .folder-input-wrapper {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }
  .folder-selected-label {
    flex: 1;
    min-height: 34px;
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    padding: 0.35rem 0.75rem;
    background: #f8fafc;
    color: #0f172a;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    position: relative;
    overflow: hidden;
    cursor: pointer;
    gap: 0.5rem;
  }
  .folder-selected-label span {
    flex: 1;
    pointer-events: none;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .folder-selected-label input[type="file"] {
    position: absolute;
    inset: 0;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
  }
  button {
    background: #008793;
    color: #fff;
    border: none;
    border-radius: 25px;
    padding: 0.75rem 1.75rem;
    font-size: 1rem;
    cursor: pointer;
    margin-top: 1rem;
    transition: transform 0.1s ease, box-shadow 0.1s ease;
  }
  button:hover {
    transform: translateY(-1px);
    box-shadow: 0 8px 20px rgba(0, 135, 147, 0.22);
  }
  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
  }
  button.secondary {
    background: #0f172a;
    margin-top: 0.75rem;
    padding: 0.6rem 1.25rem;
    font-size: 0.9rem;
  }
  #results {
    white-space: pre-wrap;
    font-family: "Fira Code", "Courier New", monospace;
    background: #0f172a;
    color: #e2e8f0;
    padding: 1rem;
    border-radius: 8px;
    min-height: 200px;
    line-height: 1.2rem;
    max-height: calc(25 * 1.2rem);
    overflow-y: auto;
  }
  #multi-results {
    white-space: pre-wrap;
    font-family: "Fira Code", "Courier New", monospace;
    background: #0f172a;
    color: #e2e8f0;
    padding: 1rem;
    border-radius: 8px;
    min-height: 200px;
    line-height: 1.2rem;
    max-height: calc(25 * 1.2rem);
    overflow-y: auto;
  }
  #multi-results a {
    color: #f97316;
    font-weight: 500;
    text-decoration: underline;
  }
  #multi-results a:hover,
  #multi-results a:focus {
    color: #fb923c;
  }
  #status {
    margin-top: 0.5rem;
    font-size: 0.9rem;
    color: #444;
  }
  .status-text {
    margin-top: 0.5rem;
    font-size: 0.9rem;
    color: #444;
  }
  .status-text.error {
    color: #b91c1c;
  }
  footer {
    text-align: center;
    padding: 1.5rem;
    font-size: 0.85rem;
    color: #666;
  }
</style>
</head>
<body>
<header>
  <div class="brand">
    <img src="assets/logo.svg" alt="uma-ase logo" />
  </div>
  <div class="header-copy">
    <h1>uma-ase</h1>
    <p>Run single or multiple jobs implementing the UMA MLFF and ASE methods</p>
    <p>Optimize geometries, calculate frequencies, visualize, analyze, ...</p>
</div>
</header>

<main>
  <div class="tabs">
    <button type="button" class="tab-button active" data-tab="actions-tab">Single Run</button>
    <button type="button" class="tab-button" data-tab="multi-tab">Multi Run</button>
    <button type="button" class="tab-button" data-tab="visualize-tab">Visualize</button>
    <button type="button" class="tab-button" data-tab="analyze-tab">Analyze</button>
  </div>

  <div id="actions-tab" class="tab-content active">
    <div class="layout-grid">
      <section class="input-section">
        <h2>Input Details</h2>
        <div class="form-grid">
          <div>
            <label for="input-geometry">Select Input file</label>
            <input type="file" id="input-geometry" accept=".xyz,.pdb,.mol,.cif,.sdf,.gjf,.traj" />
          </div>
          <div>
            <label for="charge">Charge</label>
            <input type="number" id="charge" value="0" step="1" />
          </div>
          <div></div>
          <div>
            <label for="spin">Spin Multiplicity</label>
            <input type="number" id="spin" value="1" min="1" step="1" />
          </div>
          <div>
            <label for="mlff-checkpoint">MLFF Checkpoint</label>
            <input type="text" id="mlff-checkpoint" value="uma-s-1p1" placeholder="Enter checkpoint identifier" />
          </div>
          <div>
            <label for="mlff-task">MLFF Task</label>
            <input type="text" id="mlff-task" value="omol" placeholder="Enter UMA task name" />
          </div>
          <div>
            <label>Run Type</label>
            <div id="run-type-group" class="checkbox-group">
              <label><input type="checkbox" value="sp" checked /> Single Point</label>
              <label><input type="checkbox" value="geoopt" /> GeoOpt</label>
              <label><input type="checkbox" value="freqs" /> Frequencies</label>
            </div>
          </div>
          <div></div>
          <div id="optimizer-group">
            <div class="thermo-grid">
              <div>
                <label for="optimizer">Optimizer</label>
                <select id="optimizer">
                  <option value="LBFGS">LBFGS (default)</option>
                  <option value="BFGS">BFGS</option>
                  <option value="BFGS_LINESEARCH">BFGS Line Search</option>
                  <option value="FIRE">FIRE</option>
                  <option value="MDMIN">MDMin</option>
                </select>
              </div>
            </div>
            <div id="geoopt-extra" class="geoopt-extra">
              <div>
                <label for="geoopt-grad">Force (eV/Å)</label>
                <input type="number" id="geoopt-grad" value="0.01" step="0.001" min="0" />
              </div>
              <div>
                <label for="geoopt-iter">Max GeoOpt Iter</label>
                <input type="number" id="geoopt-iter" value="250" min="1" step="1" />
              </div>
            </div>
          </div>
          <div id="freqs-group">
            <p class="group-title">Vib Analysis Settings</p>
            <div class="thermo-grid">
              <div>
                <label for="temperature">Temperature (K)</label>
                <input type="number" id="temperature" value="298.15" step="0.01" />
              </div>
              <div>
                <label for="pressure">Pressure (Pa)</label>
                <input type="number" id="pressure" value="101325" step="1" />
              </div>
            </div>
          </div>
          <div class="full-width" id="structure-summary">
            <h3>Summary</h3>
            <pre id="summary-message" class="summary-block">No structure loaded.</pre>
          </div>
        </div>
      </section>
      <div class="actions-results">
        <section class="actions-section">
          <h2>Calculate</h2>
          <div class="actions-grid">
            <button id="run-btn">Run uma-ase</button>
            <div id="status" class="status-text"></div>
            <div class="download-buttons">
              <button id="download-log" class="secondary" disabled>Download Log</button>
              <button id="download-traj" class="secondary" disabled>Download Trajectory</button>
              <button id="download-opt" class="secondary" disabled>Download Optimized XYZ</button>
            </div>
          </div>
        </section>
        <section class="results-section">
          <h2>Results</h2>
          <div id="results">Select an input file and run a job to see results here.</div>
        </section>
      </div>
    </div>
  </div>

  <div id="multi-tab" class="tab-content">
    <div class="layout-grid">
      <section class="input-section">
        <h2>Input Details</h2>
        <div class="form-grid">
          <div class="full-width">
            <label for="multi-folder-input">Select a Folder</label>
            <div class="folder-input-wrapper">
              <label id="multi-folder-name" class="folder-selected-label">
                <span id="multi-folder-label-text">No folder selected</span>
                <input type="file" id="multi-folder-input" webkitdirectory directory multiple />
              </label>
              <button id="multi-folder-reset" class="secondary" type="button">Reset</button>
            </div>
          </div>
          <div>
            <label for="multi-mlff-checkpoint">MLFF Checkpoint</label>
            <input type="text" id="multi-mlff-checkpoint" value="uma-s-1p1" placeholder="Enter checkpoint identifier" />
          </div>
          <div>
            <label for="multi-mlff-task">MLFF Task</label>
            <input type="text" id="multi-mlff-task" value="omol" placeholder="Enter UMA task name" />
          </div>
          <div class="full-width">
            <label>Run Type</label>
            <div id="multi-run-type-group" class="checkbox-group">
              <label><input type="checkbox" value="sp" checked /> Single Point</label>
              <label><input type="checkbox" value="geoopt" /> GeoOpt</label>
              <label><input type="checkbox" value="freqs" /> Frequencies</label>
            </div>
          </div>
          <div id="multi-optimizer-group" class="full-width">
            <div class="thermo-grid">
              <div>
                <label for="multi-optimizer">Optimizer</label>
                <select id="multi-optimizer">
                  <option value="LBFGS">LBFGS (default)</option>
                  <option value="BFGS">BFGS</option>
                  <option value="BFGS_LINESEARCH">BFGS Line Search</option>
                  <option value="FIRE">FIRE</option>
                  <option value="MDMIN">MDMin</option>
                </select>
              </div>
              <div class="thermo-grid">
                <div>
                  <label for="multi-geoopt-grad">Force (eV/Å)</label>
                  <input type="number" id="multi-geoopt-grad" value="0.01" step="0.001" min="0" />
                </div>
                <div>
                  <label for="multi-geoopt-iter">Max Iter</label>
                  <input type="number" id="multi-geoopt-iter" value="250" min="1" step="1" />
                </div>
              </div>
            </div>
          </div>
          <div id="multi-freqs-group" class="full-width">
            <p class="group-title">Vib Analysis Settings</p>
            <div class="thermo-grid">
              <div>
                <label for="multi-temperature">Temperature (K)</label>
                <input type="number" id="multi-temperature" value="298.15" step="0.01" />
              </div>
              <div>
                <label for="multi-pressure">Pressure (Pa)</label>
                <input type="number" id="multi-pressure" value="101325" step="1" />
              </div>
            </div>
          </div>
          <div class="full-width">
            <h3>Summary</h3>
            <pre id="multi-summary-message" class="summary-block">No folder selected.</pre>
          </div>
        </div>
      </section>
      <div class="actions-results">
        <section class="actions-section">
          <h2>Calculate</h2>
          <div class="actions-grid">
            <div class="panel-actions">
              <button id="multi-run-btn" class="btn-inline primary">Run uma-ase</button>
              <button id="multi-download-files" class="secondary" disabled>Download Files</button>
            </div>
            <div id="multi-status" class="status-text"></div>
          </div>
        </section>
        <section class="results-section">
          <h2>Results</h2>
          <div id="multi-results"></div>
        </section>
      </div>
    </div>
  </div>

  <div id="visualize-tab" class="tab-content">
    <div class="visualize-grid">
      <section class="input-section">
        <h2>Input Details</h2>
        <div class="form-grid">
          <div class="full-width">
            <label>Input file</label>
            <span id="viz-file-name" class="file-indicator">No file selected</span>
          </div>
          <div>
            <label for="viz-charge">Charge</label>
            <input type="number" id="viz-charge" value="0" step="1" />
          </div>
          <div></div>
          <div>
            <label for="viz-spin">Spin Multiplicity</label>
            <input type="number" id="viz-spin" value="1" min="1" step="1" />
          </div>
          <div class="full-width">
            <h3>Summary</h3>
            <pre id="viz-summary-message" class="summary-block">No structure loaded.</pre>
          </div>
        </div>
      </section>
      <section class="viewer-section">
        <div class="viewer-controls">
          <input id="viewer-file-input" type="file" accept=".xyz,.pdb,.mol,.cif,.sdf,.gjf,.traj" />
        </div>
        <div class="viewer-panel">
          <div id="jsmol-applet"></div>
        </div>
      </section>
    </div>
  </div>

  <div id="analyze-tab" class="tab-content">
    <section class="viewer-section">
      <h2>Analyze</h2>
      <div class="analyze-panel analyze-group">
        <div class="analyze-panel">
          <label class="viewer-upload-label" for="analyze-folder-input">Select a folder</label>
          <input id="analyze-folder-input" type="file" webkitdirectory directory multiple />
        </div>
        <div class="analyze-panel">
          <h4>RMSD Report</h4>
          <p>Reads uma-ase .log files (Formula, RMSD, uma model, optimizer) and generates a bar plot and a table of RMSDs by formula.</p>
          <div class="panel-actions">
            <button id="analyze-run-btn" class="primary btn-inline">Run RMSD Report</button>
            <div class="download-buttons analyze-downloads">
              <button id="analyze-download-pdf" class="secondary" disabled>Download PDF</button>
              <button id="analyze-download-latex" class="secondary" disabled>Download LaTeX</button>
              <button id="analyze-download-docx" class="secondary" disabled>Download DOCX</button>
            </div>
          </div>
          <div id="analyze-status" class="status-text"></div>
          <iframe id="analyze-pdf-frame" class="pdf-frame" hidden title="Analysis PDF"></iframe>
        </div>
        <div class="analyze-panel">
          <h4>XYZ Pair Analysis</h4>
          <p>Matches *.xyz files with their *geoopt-OPT* counterparts and detailed geometry analysis. Python script provided by A. Solé-Daura.</p>
          <div class="panel-actions">
            <button id="driver-run-btn" class="primary btn-inline">Run XYZ Pair Analysis</button>
            <div class="download-buttons analyze-downloads">
              <button id="driver-download-txt" class="secondary" disabled>Download TXT</button>
              <button id="driver-download-pdf" class="secondary" disabled>Download PDF</button>
              <button id="driver-download-latex" class="secondary" disabled>Download LaTeX</button>
              <button id="driver-download-docx" class="secondary" disabled>Download DOCX</button>
            </div>
          </div>
          <div id="driver-status" class="status-text"></div>
          <pre id="driver-preview" class="summary-block analyze-preview" hidden></pre>
        </div>
      </div>
    </section>
  </div>
</main>

<footer>
  &copy; 2025 uma-ase workflows. Use responsibly. Backend service required to execute calculations.
</footer>

<script src="/assets/jsmol/jquery/jquery-1.11.0.js"></script>
<script src="/assets/jsmol/JSmol.min.js"></script>
<script>
  const resultsEl = document.getElementById("results");
  const statusEl = document.getElementById("status");
  const fileInput = document.getElementById("input-geometry");
  const downloadBtn = document.getElementById("download-log");
  const trajBtn = document.getElementById("download-traj");
  const optBtn = document.getElementById("download-opt");
  const checkpointInput = document.getElementById("mlff-checkpoint");
  const taskInput = document.getElementById("mlff-task");
  const chargeInput = document.getElementById("charge");
  const spinInput = document.getElementById("spin");
  const vizChargeInput = document.getElementById("viz-charge");
  const vizSpinInput = document.getElementById("viz-spin");
  const viewerFileInput = document.getElementById("viewer-file-input");
  const jsmolContainer = document.getElementById("jsmol-applet");
  const viewerStatusText = document.getElementById("viewer-status");
  const viewerFileLabel = document.getElementById("viewer-file-label");
  const viewerLoadedLabel = document.getElementById("viewer-loaded-name");
  const gradInput = document.getElementById("geoopt-grad");
  const iterInput = document.getElementById("geoopt-iter");
  const optimizerSelect = document.getElementById("optimizer");
  const temperatureInput = document.getElementById("temperature");
  const pressureInput = document.getElementById("pressure");
  const summaryMessage = document.getElementById("summary-message");
  const vizSummaryMessage = document.getElementById("viz-summary-message");
  const geooptExtras = document.getElementById("geoopt-extra");
  const fileIndicatorPrimary = document.getElementById("input-file-name");
  const fileIndicatorViz = document.getElementById("viz-file-name");
  const analyzeSelectionLabel = document.getElementById("analyze-selection-label");
  const analyzeFolderInput = document.getElementById("analyze-folder-input");
  const analyzeRunBtn = document.getElementById("analyze-run-btn");
  const analyzeStatus = document.getElementById("analyze-status");
  const analyzePdfFrame = document.getElementById("analyze-pdf-frame");
  const analyzeDownloadPdfBtn = document.getElementById("analyze-download-pdf");
  const analyzeDownloadLatexBtn = document.getElementById("analyze-download-latex");
  const analyzeDownloadDocxBtn = document.getElementById("analyze-download-docx");
  let multiFolderInput = document.getElementById("multi-folder-input");
  const multiFolderLabel = document.getElementById("multi-folder-name");
  const multiFolderLabelText = document.getElementById("multi-folder-label-text");
  const multiSummaryMessage = document.getElementById("multi-summary-message");
  const multiRunBtn = document.getElementById("multi-run-btn");
  const multiFolderResetBtn = document.getElementById("multi-folder-reset");
  const multiStatusEl = document.getElementById("multi-status");
  const multiResultsEl = document.getElementById("multi-results");
  const multiDownloadFilesBtn = document.getElementById("multi-download-files");
  const multiCheckpointInput = document.getElementById("multi-mlff-checkpoint");
  const multiTaskInput = document.getElementById("multi-mlff-task");
  const multiRunTypeGroup = document.getElementById("multi-run-type-group");
  const multiRunTypeCheckboxes = multiRunTypeGroup
    ? Array.from(multiRunTypeGroup.querySelectorAll("input[type=checkbox]"))
    : [];
  const multiOptimizerGroup = document.getElementById("multi-optimizer-group");
  const multiOptimizerSelect = document.getElementById("multi-optimizer");
  const multiGradInput = document.getElementById("multi-geoopt-grad");
  const multiIterInput = document.getElementById("multi-geoopt-iter");
  const multiFreqsGroup = document.getElementById("multi-freqs-group");
  const multiTemperatureInput = document.getElementById("multi-temperature");
  const multiPressureInput = document.getElementById("multi-pressure");
  const multiBundleBtn = null;
  const driverRunBtn = document.getElementById("driver-run-btn");
  const driverStatus = document.getElementById("driver-status");
  const driverDownloadTxtBtn = document.getElementById("driver-download-txt");
  const driverDownloadPdfBtn = document.getElementById("driver-download-pdf");
  const driverDownloadLatexBtn = document.getElementById("driver-download-latex");
  const driverDownloadDocxBtn = document.getElementById("driver-download-docx");
  const driverPreview = document.getElementById("driver-preview");
  const resultsDefaultText = resultsEl.textContent;
  const summaryDefaultText = summaryMessage.textContent;
  const multiSummaryDefaultText = multiSummaryMessage ? multiSummaryMessage.textContent : "No folder selected.";

  const optimizerGroup = document.getElementById("optimizer-group");
  const freqsGroup = document.getElementById("freqs-group");
  const runTypeGroup = document.getElementById("run-type-group");
  const runTypeCheckboxes = Array.from(runTypeGroup.querySelectorAll("input[type=checkbox]"));

  let currentGeometryFile = null;
  let previewRequestId = 0;
  let chargeManuallyEdited = false;
  let viewerReady = false;
  let pendingViewerFile = null;
  let jsmolApplet = null;
  let viewerInitializing = false;
  let analyzeDownloadLinks = { pdf: null, latex: null, docx: null };
  let driverDownloadLinks = { txt: null, pdf: null, latex: null, docx: null };
  let multiEntries = [];
  let multiFolderRoot = null;
  let singleRunExpectGeoopt = false;

  function derivePaths(file) {
    const relPathRaw = file.webkitRelativePath || file.name;
    if (!multiFolderRoot || !relPathRaw) {
      return {
        displayPath: relPathRaw || file.name,
        relativePath: relPathRaw || file.name,
      };
    }
    const prefix = `${multiFolderRoot}/`;
    const normalized = relPathRaw.startsWith(prefix)
      ? relPathRaw.slice(prefix.length) || relPathRaw
      : relPathRaw;
    return {
      displayPath: relPathRaw,
      relativePath: normalized,
    };
  }

  function updateViewerStatus(message, isError = false) {
    if (!viewerStatusText) {
      return;
    }
    viewerStatusText.textContent = message;
    viewerStatusText.classList.toggle("error", isError);
  }

  function updateAnalyzeSelection(files) {
    if (!analyzeSelectionLabel) {
      return;
    }
    if (!files || !files.length) {
      analyzeSelectionLabel.textContent = "No folder selected.";
      return;
    }
    const first = files[0];
    const root = first && first.webkitRelativePath
      ? first.webkitRelativePath.split("/")[0]
      : (first ? first.name : "Folder");
    analyzeSelectionLabel.textContent = `${root} (${files.length} items)`;
  }

  function getAnalyzeFiles() {
    if (analyzeFolderInput && analyzeFolderInput.files && analyzeFolderInput.files.length) {
      return Array.from(analyzeFolderInput.files);
    }
    return [];
  }

  function updateAnalyzeDownloadButtons() {
    if (analyzeDownloadPdfBtn) {
      analyzeDownloadPdfBtn.disabled = !analyzeDownloadLinks.pdf;
    }
    if (analyzeDownloadLatexBtn) {
      analyzeDownloadLatexBtn.disabled = !analyzeDownloadLinks.latex;
    }
    if (analyzeDownloadDocxBtn) {
      analyzeDownloadDocxBtn.disabled = !analyzeDownloadLinks.docx;
    }
  }

  function resetAnalyzeOutputs() {
    analyzeDownloadLinks = { pdf: null, latex: null, docx: null };
    updateAnalyzeDownloadButtons();
    if (analyzePdfFrame) {
      analyzePdfFrame.hidden = true;
      analyzePdfFrame.removeAttribute("src");
    }
  }
  updateAnalyzeDownloadButtons();

  function updateDriverDownloadButtonsState() {
    if (driverDownloadTxtBtn) {
      driverDownloadTxtBtn.disabled = !driverDownloadLinks.txt;
    }
    if (driverDownloadPdfBtn) {
      driverDownloadPdfBtn.disabled = !driverDownloadLinks.pdf;
    }
    if (driverDownloadLatexBtn) {
      driverDownloadLatexBtn.disabled = !driverDownloadLinks.latex;
    }
    if (driverDownloadDocxBtn) {
      driverDownloadDocxBtn.disabled = !driverDownloadLinks.docx;
    }
  }

  function resetDriverOutputs() {
    driverDownloadLinks = { txt: null, pdf: null, latex: null, docx: null };
    updateDriverDownloadButtonsState();
    if (driverPreview) {
      driverPreview.hidden = true;
      driverPreview.textContent = "";
    }
  }
  resetDriverOutputs();

  function updateMultiFolderLabel(folderName, count) {
    if (!multiFolderLabelText) {
      return;
    }
    const suffix = folderName && typeof count === "number" && count >= 0
      ? ` (${count} file${count === 1 ? "" : "s"})`
      : "";
    const text = folderName ? `${folderName}${suffix}` : "No folder selected";
    multiFolderLabelText.textContent = text;
    if (multiFolderLabel) {
      multiFolderLabel.classList.toggle("has-selection", Boolean(folderName));
    }
  }

  function updateMultiSummary(entries, message) {
    if (!multiSummaryMessage) {
      return;
    }
    if (typeof message === "string") {
      multiSummaryMessage.textContent = message;
      return;
    }
    if (!entries || !entries.length) {
      multiSummaryMessage.textContent = multiSummaryDefaultText;
      return;
    }
    const header = `Preparing ${entries.length} file${entries.length === 1 ? "" : "s"}:`;
    const lines = entries.map((entry, index) => {
      const label = entry.displayPath || entry.relativePath || entry.file.name;
      return `${index + 1}. ${label} — charge=${entry.charge} spin=${entry.spin}`;
    });
    multiSummaryMessage.textContent = [header, ...lines].join("\n");
  }

  function appendMultiResult(text, link) {
    if (!multiResultsEl || !text) {
      return;
    }
    const row = document.createElement("div");
    row.className = "multi-result-row";
    const block = document.createElement("pre");
    block.className = "multi-result-text";
    block.textContent = text;
    row.appendChild(block);
    if (link) {
      const actions = document.createElement("div");
      actions.className = "multi-result-actions";
      actions.appendChild(link);
      row.appendChild(actions);
    }
    multiResultsEl.appendChild(row);
    multiResultsEl.scrollTop = multiResultsEl.scrollHeight;
  }

  async function cleanResultsDir() {
    try {
      const response = await fetch("/api/uma-ase/clean", { method: "POST" });
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }
      return true;
    } catch (error) {
      if (multiStatusEl) {
        multiStatusEl.textContent = error && error.message
          ? `Unable to clean workspace: ${error.message}`
          : "Unable to clean workspace.";
      }
      return false;
    }
  }

  function updateViewerFileLabel(file) {
    if (!viewerFileLabel) {
      return;
    }
    viewerFileLabel.textContent = file && file.name ? file.name : "No file selected";
  }

  function clearViewer() {
    if (jsmolApplet && viewerReady) {
      Jmol.script(jsmolApplet, "zap; background white;");
    }
    updateViewerStatus("No structure loaded.");
  }

  function loadStructureContent(name, content) {
    if (!jsmolApplet) {
      return;
    }
    const fileName = name || "geometry.xyz";
    const trimmed = `${content}`.trim();
    if (!trimmed) {
      updateViewerStatus("Empty structure file.", true);
      return;
    }
    const loadScript = [
      'zap;',
      'background white;',
      'load DATA "inline"',
      trimmed,
      'END "inline";',
      'spin off;',
    ].join('\n');
    Jmol.script(jsmolApplet, loadScript);
    updateViewerStatus(`Loaded ${fileName}.`);
    const pseudoFile = { name: fileName };
    updateViewerFileLabel(pseudoFile);
    if (viewerLoadedLabel) {
      viewerLoadedLabel.textContent = fileName;
    }
  }

  function initializeViewer() {
    if (!jsmolContainer || jsmolApplet) {
      viewerInitializing = false;
      return;
    }
    viewerInitializing = true;
    if (typeof window.Jmol === "undefined") {
      updateViewerStatus("3D viewer unavailable (JSmol not loaded).");
      viewerInitializing = false;
      return;
    }
    viewerReady = false;
    updateViewerStatus("Loading viewer...");
    Jmol._isAsync = false;
    Jmol._debugCode = false;
    Jmol._ajaxTestSite = "";
    Jmol._binaryTypes = [];

    Jmol.setDocument(0);
    const info = {
      width: 600,
      height: 400,
      debug: false,
      color: "0xFFFFFF",
      use: "HTML5",
      j2sPath: "/assets/jsmol/j2s",
      script: "background white; set antialiasDisplay true; spin off;",
      readyFunction: () => {
        viewerReady = true;
        updateViewerStatus("Viewer ready. Select a structure to display.");
        if (jsmolApplet) {
          Jmol.script(jsmolApplet, "zap; background white; spin off;");
        }
        if (pendingViewerFile !== null) {
          const pending = pendingViewerFile;
          pendingViewerFile = null;
          dispatchFileToViewer(pending);
        }
        console.log("[uma-ase] viewer ready callback fired");
      },
    };

    const applet = Jmol.getApplet("jsmolApplet", info);
    console.log("[uma-ase] raw applet target", applet);
    console.log("[uma-ase] applet panel", applet ? applet._appletPanel : undefined);
    console.log("[uma-ase] viewerReady flag", viewerReady, "pending file", pendingViewerFile);
    function wrapAppletEventHandlers(target) {
      if (!target || typeof target !== "object") {
        return target;
      }
      const guard = (fnName, panelMethod) => {
        const original = target[fnName];
        if (typeof original !== "function") {
          return;
        }
        target[fnName] = function wrapped(...args) {
          const panel = this._appletPanel;
          if (!panel || typeof panel[panelMethod] !== "function") {
            return null;
          }
          return original.apply(this, args);
        };
      };
      guard("_processEvent", "processMouseEvent");
      guard("_processGesture", "processTwoPointGesture");
      guard("_processKeyEvent", "processKeyEvent");
      return target;
    }
    jsmolApplet = wrapAppletEventHandlers(applet);
    jsmolContainer.innerHTML = Jmol.getAppletHtml(jsmolApplet);
    console.log("[uma-ase] JSmol applet initialised", jsmolApplet);
    viewerInitializing = false;
    const readyCheck = setInterval(() => {
      const panel = jsmolApplet && jsmolApplet._appletPanel;
      if (!panel) {
        return;
      }
      clearInterval(readyCheck);
        if (!viewerReady) {
          viewerReady = true;
          updateViewerStatus("Viewer ready. Select a structure to display.");
          if (jsmolApplet) {
            Jmol.script(jsmolApplet, "zap; background white; spin off;");
          }
          if (pendingViewerFile !== null) {
            const pending = pendingViewerFile;
            pendingViewerFile = null;
            dispatchFileToViewer(pending);
          }
      }
      console.log("[uma-ase] panel detected via poll", panel);
    }, 200);
  }

  function ensureViewerInitialized() {
    if (jsmolApplet || viewerInitializing) {
      return;
    }
    requestAnimationFrame(() => {
      initializeViewer();
    });
  }

  function evaluateRunTypeVisibility() {
    const runTypes = runTypeCheckboxes
      .filter((checkbox) => checkbox.checked)
      .map((checkbox) => checkbox.value);

    const showOptimizer = runTypes.includes("geoopt");
    const showThermo = runTypes.includes("freqs");

    optimizerGroup.classList.toggle("is-disabled", !showOptimizer);
    optimizerSelect.disabled = !showOptimizer;
    gradInput.disabled = !showOptimizer;
    iterInput.disabled = !showOptimizer;
    geooptExtras.classList.toggle("is-disabled", !showOptimizer);

    freqsGroup.classList.toggle("is-disabled", !showThermo);
    Array.from(freqsGroup.querySelectorAll("input")).forEach((input) => {
      input.disabled = !showThermo;
    });
  }

  evaluateRunTypeVisibility();

  runTypeCheckboxes.forEach((checkbox) => {
    checkbox.addEventListener("change", () => {
      evaluateRunTypeVisibility();
      if (currentGeometryFile) {
        requestStructurePreview();
      }
    });
  });

  function evaluateMultiRunTypeVisibility() {
    if (!multiRunTypeCheckboxes.length) {
      return;
    }
    const runTypes = multiRunTypeCheckboxes
      .filter((checkbox) => checkbox.checked)
      .map((checkbox) => checkbox.value);
    const showOptimizer = runTypes.indexOf("geoopt") !== -1;
    const showThermo = runTypes.indexOf("freqs") !== -1;
    if (multiOptimizerGroup) {
      multiOptimizerGroup.classList.toggle("is-disabled", !showOptimizer);
    }
    if (multiOptimizerSelect) {
      multiOptimizerSelect.disabled = !showOptimizer;
    }
    if (multiGradInput) {
      multiGradInput.disabled = !showOptimizer;
    }
    if (multiIterInput) {
      multiIterInput.disabled = !showOptimizer;
    }
    if (multiFreqsGroup) {
      multiFreqsGroup.classList.toggle("is-disabled", !showThermo);
      const freqInputs = multiFreqsGroup.querySelectorAll("input");
      Array.prototype.forEach.call(freqInputs, (input) => {
        input.disabled = !showThermo;
      });
    }
  }

  evaluateMultiRunTypeVisibility();

  multiRunTypeCheckboxes.forEach((checkbox) => {
    checkbox.addEventListener("change", () => {
      evaluateMultiRunTypeVisibility();
    });
  });

  function resetDownloadLink() {
    downloadBtn.disabled = true;
    downloadBtn.removeAttribute("data-href");
    downloadBtn.title = "Log not available yet.";
    if (trajBtn) {
      trajBtn.disabled = true;
      trajBtn.removeAttribute("data-href");
      trajBtn.title = "Trajectory not available.";
    }
    if (optBtn) {
      optBtn.disabled = true;
      optBtn.removeAttribute("data-href");
      optBtn.title = "Optimized geometry not available.";
    }
  }

  resetDownloadLink();
  updateFileIndicators(null);

  function updateSummaryMessages(text) {
    summaryMessage.textContent = text;
    vizSummaryMessage.textContent = text;
  }

  function updateFileIndicators(file) {
    const label = file && file.name ? file.name : "No file selected";
    if (fileIndicatorPrimary) {
      fileIndicatorPrimary.textContent = label;
    }
    if (fileIndicatorViz) {
      fileIndicatorViz.textContent = label;
    }
    if (viewerLoadedLabel) {
      viewerLoadedLabel.textContent = label;
    }
  }

  async function requestStructurePreview(options = {}) {
    const { allowChargeUpdate = false } = options;
    const file = currentGeometryFile;
    if (!file) {
      updateSummaryMessages(summaryDefaultText);
      return;
    }

    const requestId = ++previewRequestId;
    const formData = new FormData();
    formData.append("geometry", file);
    formData.append("charge", chargeInput.value);
    formData.append("spin", spinInput.value);

    try {
      const response = await fetch("/api/uma-ase/preview", {
        method: "POST",
        body: formData,
      });

      const data = await response.json().catch(() => ({}));
      if (requestId !== previewRequestId) {
        return;
      }

      if (!response.ok) {
        throw new Error(data.message || `Server returned ${response.status}`);
      }

      if (typeof data.charge === "number" && (allowChargeUpdate || !chargeManuallyEdited)) {
        chargeInput.value = data.charge;
        vizChargeInput.value = data.charge;
      }
      if (typeof data.spin === "number") {
        spinInput.value = data.spin;
        vizSpinInput.value = data.spin;
      }

      const summaryText = Array.isArray(data.lines) && data.lines.length
        ? data.lines.join("\n")
        : (data.message || summaryDefaultText);

      updateSummaryMessages(summaryText);
    } catch (error) {
      if (requestId !== previewRequestId) {
        return;
      }
      const errorText = `Preview unavailable: ${error.message}`;
      updateSummaryMessages(errorText);
    }
  }

  function parseChargeSpinFromFile(file) {
    return new Promise((resolve) => {
      if (!file) {
        resolve(null);
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const text = typeof reader.result === "string" ? reader.result : "";
          const lines = text.split(/\r?\n/);
          if (lines.length < 2) {
            resolve(null);
            return;
          }
          const tokens = lines[1].trim().split(/\s+/).filter(Boolean);
          let parsedCharge = null;
          let parsedSpin = null;
          tokens.forEach((token, index) => {
            const value = Number(token);
            if (!Number.isInteger(value)) {
              return;
            }
            if (parsedCharge === null) {
              parsedCharge = value;
            } else if (parsedSpin === null) {
              parsedSpin = value;
            }
          });
          resolve({
            charge: parsedCharge,
            spin: parsedSpin,
          });
        } catch (error) {
          console.warn("Unable to parse charge/spin from file", error);
          resolve(null);
        }
      };
      reader.onerror = () => resolve(null);
      reader.readAsText(file.slice(0, 2000));
    });
  }

  function dispatchFileToViewer(file) {
    const visualizeTab = document.getElementById("visualize-tab");
    const visualizeActive = visualizeTab ? visualizeTab.classList.contains("active") : false;
    if (!jsmolApplet && visualizeActive) {
      ensureViewerInitialized();
    }
    if (!viewerReady) {
      pendingViewerFile = file || null;
      if (file) {
        if (visualizeActive) {
          updateViewerStatus(`Loading ${file.name || "structure"}...`);
        } else {
          updateViewerStatus("Open the Visualize tab to view the structure.");
        }
      } else {
        updateViewerStatus("No structure loaded.");
      }
    return;
  }
    if (!file) {
      pendingViewerFile = null;
      clearViewer();
      return;
    }
    updateViewerStatus(`Loading ${file.name || "structure"}...`);
    const reader = new FileReader();
    reader.onload = () => {
      try {
        loadStructureContent(file.name || "geometry.xyz", reader.result);
      } catch (error) {
        updateViewerStatus(`Unable to load structure: ${error.message}`, true);
        console.error("[uma-ase] loadStructureContent failed", error);
      }
    };
    reader.onerror = (event) => {
      console.error("[uma-ase] file reader error", event);
      updateViewerStatus("Unable to read file.", true);
    };
    reader.readAsText(file);
    pendingViewerFile = null;
  }

  function handleFileSelection(file) {
    currentGeometryFile = file;
    chargeManuallyEdited = false;
    if (!file) {
    chargeInput.value = "0";
    spinInput.value = "1";
    vizChargeInput.value = "0";
    vizSpinInput.value = "1";
      updateSummaryMessages(summaryDefaultText);
      resultsEl.textContent = resultsDefaultText;
      updateFileIndicators(null);
      dispatchFileToViewer(null);
      updateViewerFileLabel(null);
      if (fileIndicatorPrimary) {
        fileIndicatorPrimary.textContent = "No file selected";
      }
      if (fileIndicatorViz) {
        fileIndicatorViz.textContent = "No file selected";
      }
      if (viewerFileLabel) {
        viewerFileLabel.textContent = "No file selected";
      }
      return;
    }

    parseChargeSpinFromFile(file).then((parsed) => {
      if (parsed && typeof parsed.charge === "number" && !chargeManuallyEdited) {
        chargeInput.value = String(parsed.charge);
        vizChargeInput.value = String(parsed.charge);
      }
      if (parsed && typeof parsed.spin === "number") {
        spinInput.value = String(parsed.spin);
        vizSpinInput.value = String(parsed.spin);
      }
    }).finally(() => {
      updateFileIndicators(file);
      vizChargeInput.value = chargeInput.value;
      vizSpinInput.value = spinInput.value;
      updateViewerFileLabel(file);
      resultsEl.textContent = `Loaded ${file.name}. Ready to run calculations.`;
      dispatchFileToViewer(file);
      requestStructurePreview({ allowChargeUpdate: true });
    });
  }

  fileInput.addEventListener("change", () => {
    const file = fileInput.files[0] || null;
    handleFileSelection(file);
  });

  if (viewerFileInput) {
    viewerFileInput.addEventListener("change", () => {
      const file = viewerFileInput.files[0] || null;
      handleFileSelection(file);
    });
  }

  if (analyzeFolderInput) {
    analyzeFolderInput.addEventListener("change", () => {
      updateAnalyzeSelection(analyzeFolderInput.files);
    });
  }

  function attachMultiFolderListener() {
    if (multiFolderInput) {
      multiFolderInput.addEventListener("change", handleMultiFolderSelection);
    }
  }

  attachMultiFolderListener();

  if (multiFolderResetBtn) {
    multiFolderResetBtn.addEventListener("click", () => {
      cleanResultsDir();
      if (multiFolderInput) {
        const newInput = multiFolderInput.cloneNode(true);
        newInput.value = "";
        multiFolderInput.parentNode.replaceChild(newInput, multiFolderInput);
        multiFolderInput = newInput;
        attachMultiFolderListener();
      }
      multiEntries = [];
      multiFolderRoot = null;
      updateMultiFolderLabel(null);
      updateMultiSummary(null, "No folder selected.");
      const inputsToClear = [
        multiCheckpointInput,
        multiTaskInput,
        multiGradInput,
        multiIterInput,
        multiTemperatureInput,
        multiPressureInput,
      ];
      inputsToClear.forEach((input) => {
        if (input) {
          if (input.type === "number" || input.type === "text") {
            input.value = input.defaultValue || "";
          }
        }
      });
      multiRunTypeCheckboxes.forEach((checkbox) => {
        checkbox.checked = checkbox.defaultChecked;
      });
      evaluateMultiRunTypeVisibility();
      if (multiResultsEl) {
        multiResultsEl.textContent = "";
      }
      if (multiStatusEl) {
        multiStatusEl.textContent = "No folder selected.";
      }
      if (multiRunBtn) {
        multiRunBtn.disabled = true;
        multiRunBtn.title = "Select a folder first.";
      }
      if (multiDownloadFilesBtn) {
        multiDownloadFilesBtn.disabled = true;
        multiDownloadFilesBtn.removeAttribute("data-href");
        multiDownloadFilesBtn.title = "Run jobs to enable file download.";
      }
    });
  }

  async function handleMultiFolderSelection() {
    if (!multiFolderInput) {
      return;
    }

    const fileList = multiFolderInput.files;
    multiEntries = [];
    if (multiResultsEl) {
      multiResultsEl.textContent = "";
    }
    if (multiDownloadFilesBtn) {
      multiDownloadFilesBtn.disabled = true;
      multiDownloadFilesBtn.removeAttribute("data-href");
      multiDownloadFilesBtn.title = "Run jobs to enable file download.";
    }

    if (!fileList || !fileList.length) {
      multiFolderRoot = null;
      updateMultiFolderLabel(null);
      updateMultiSummary(null, "No folder selected.");
      if (multiStatusEl) {
        multiStatusEl.textContent = "No folder selected.";
      }
      if (multiRunBtn) {
        multiRunBtn.disabled = true;
        multiRunBtn.title = "Select a folder first.";
      }
      return;
    }

    const files = Array.from(fileList);
    const first = files[0];
    const relativePath = first && first.webkitRelativePath ? first.webkitRelativePath : first ? first.name : "";
    const rootCandidate = relativePath && relativePath.indexOf("/") !== -1
      ? relativePath.split("/")[0]
      : relativePath || (first ? first.name : "");
    if (rootCandidate && !/\.xyz$/i.test(rootCandidate)) {
      multiFolderRoot = rootCandidate.replace(/[^A-Za-z0-9_.-]/g, "_") || `multi_run_${Date.now()}`;
    } else {
      multiFolderRoot = `multi_run_${Date.now()}`;
    }
    const xyzFiles = files
      .filter((file) => /\.xyz$/i.test(file.name))
      .filter((file) => {
        const base = file.name.replace(/\.[^/.]+$/, "").toLowerCase();
        return base.indexOf("opt") === -1 && base.indexOf("geoopt") === -1;
      })
      .sort((a, b) => {
        const pathA = a.webkitRelativePath || a.name;
        const pathB = b.webkitRelativePath || b.name;
        return pathA.localeCompare(pathB);
      });

    const folderLabel = rootCandidate || "Folder";
    updateMultiFolderLabel(folderLabel, xyzFiles.length);
    if (!xyzFiles.length) {
      updateMultiSummary(null, "No eligible .xyz files found in the selected folder.");
      if (multiStatusEl) {
        multiStatusEl.textContent = "No .xyz files detected.";
      }
      if (multiRunBtn) {
        multiRunBtn.disabled = true;
        multiRunBtn.title = "Select a folder with .xyz files.";
      }
      return;
    }

    if (multiStatusEl) {
      multiStatusEl.textContent = `Reading ${xyzFiles.length} file(s)...`;
    }
    if (multiRunBtn) {
      multiRunBtn.disabled = true;
      multiRunBtn.title = "Parsing files...";
    }

    multiEntries = xyzFiles.map((file) => {
      const { displayPath, relativePath } = derivePaths(file);
      return {
        file,
        displayPath,
        relativePath,
        charge: 0,
        spin: 1,
      };
    });
    updateMultiSummary(multiEntries);

    const entries = [];
    for (const file of xyzFiles) {
      const parsed = await parseChargeSpinFromFile(file).catch(() => null);
      const { displayPath, relativePath } = derivePaths(file);
      entries.push({
        file,
        displayPath,
        relativePath,
        charge: parsed && typeof parsed.charge === "number" ? parsed.charge : 0,
        spin: parsed && typeof parsed.spin === "number" ? parsed.spin : 1,
      });
      updateMultiSummary(entries);
    }

    multiEntries = entries;
    updateMultiSummary(entries);
    if (multiStatusEl) {
      multiStatusEl.textContent = `Ready to run ${entries.length} job(s).`;
    }
    if (multiRunBtn) {
      multiRunBtn.disabled = false;
      multiRunBtn.title = "";
    }
  }

  if (analyzeRunBtn) {
    analyzeRunBtn.addEventListener("click", async () => {
      const files = getAnalyzeFiles();
      if (!files.length) {
        if (analyzeStatus) {
          analyzeStatus.textContent = "Select at least one log file or folder.";
        }
        return;
      }
      resetAnalyzeOutputs();
      if (analyzeStatus) {
        analyzeStatus.textContent = "Running analysis...";
      }
      analyzeRunBtn.disabled = true;
      const formData = new FormData();
      files.forEach((file) => {
        const relative = file.webkitRelativePath || file.name;
        formData.append("files", file, relative);
      });
      try {
        const response = await fetch("/api/uma-ase/analyze", {
          method: "POST",
          body: formData,
        });
        const contentType = response.headers.get("content-type") || "";
        if (!response.ok) {
          let payload = null;
          if (contentType.includes("application/json")) {
            payload = await response.json().catch(() => null);
          }
          throw new Error((payload && payload.message) || `Analysis failed (${response.status}).`);
        }
        const payload = await response.json().catch(() => null);
        if (!payload || payload.status !== "ok") {
          throw new Error((payload && payload.message) || "Server returned an unexpected response.");
        }
        analyzeDownloadLinks = {
          pdf: payload.pdf_url || null,
          latex: payload.latex_url || null,
          docx: payload.docx_url || null,
        };
        updateAnalyzeDownloadButtons();
        if (analyzeDownloadLinks.pdf && analyzePdfFrame) {
          const pdfUrl = analyzeDownloadLinks.pdf.includes("?")
            ? `${analyzeDownloadLinks.pdf}&ts=${Date.now()}`
            : `${analyzeDownloadLinks.pdf}?ts=${Date.now()}`;
          analyzePdfFrame.hidden = false;
          analyzePdfFrame.src = pdfUrl;
        }
        if (analyzeStatus) {
          analyzeStatus.textContent = analyzeDownloadLinks.pdf
            ? "Analysis complete."
            : "Analysis complete (no PDF generated).";
        }
      } catch (error) {
        if (analyzeStatus) {
          analyzeStatus.textContent = error.message || "Unable to run analysis.";
        }
      } finally {
        analyzeRunBtn.disabled = false;
      }
    });
  }

  if (driverRunBtn) {
    driverRunBtn.addEventListener("click", async () => {
      const files = getAnalyzeFiles();
      if (!files.length) {
        if (driverStatus) {
          driverStatus.textContent = "Select at least one XYZ file or folder.";
        }
        return;
      }
      resetDriverOutputs();
      if (driverStatus) {
        driverStatus.textContent = "Running pair analysis...";
      }
      driverRunBtn.disabled = true;
      const formData = new FormData();
      files.forEach((file) => {
        const relative = file.webkitRelativePath || file.name;
        formData.append("files", file, relative);
      });
      try {
        const response = await fetch("/api/uma-ase/analyze/driver", {
          method: "POST",
          body: formData,
        });
        const payload = await response.json().catch(() => null);
        if (!response.ok || !payload || payload.status !== "ok") {
          throw new Error((payload && payload.message) || `Driver analysis failed (${response.status}).`);
        }
        driverDownloadLinks = {
          txt: payload.results_url || null,
          pdf: payload.pdf_url || null,
          latex: payload.latex_url || null,
          docx: payload.docx_url || null,
        };
        updateDriverDownloadButtonsState();
        if (driverPreview) {
          if (payload.preview) {
            driverPreview.hidden = false;
            driverPreview.textContent = payload.preview;
          } else {
            driverPreview.hidden = true;
            driverPreview.textContent = "";
          }
        }
        if (driverStatus) {
          const pairCount = typeof payload.pairs === "number" ? payload.pairs : null;
          if (pairCount && pairCount > 0) {
            driverStatus.textContent = `Processed ${pairCount} file pairs.`;
          } else {
            driverStatus.textContent = payload.message || "Analysis complete.";
          }
        }
      } catch (error) {
        if (driverStatus) {
          driverStatus.textContent = error && error.message ? error.message : "Unable to run driver analysis.";
        }
      } finally {
        driverRunBtn.disabled = false;
      }
    });
  }


  async function downloadDriverArtifact(type, fallbackLabel) {
    const url = driverDownloadLinks[type];
    if (!url) {
      return;
    }
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Download failed (${response.status})`);
      }
      const blob = await response.blob();
      const filename = url.split("/").pop() || fallbackLabel;
      await saveBlobWithDialog(blob, filename, fallbackLabel);
    } catch (error) {
      if (driverStatus) {
        driverStatus.textContent = error && error.message
          ? `Unable to download ${type.toUpperCase()} result: ${error.message}`
          : `Unable to download ${type.toUpperCase()} result.`;
      }
    }
  }

  if (driverDownloadTxtBtn) {
    driverDownloadTxtBtn.addEventListener("click", () => downloadDriverArtifact("txt", "compiled_rmsd_results.txt"));
  }
  if (driverDownloadPdfBtn) {
    driverDownloadPdfBtn.addEventListener("click", () => downloadDriverArtifact("pdf", "compiled_rmsd_results.pdf"));
  }
  if (driverDownloadLatexBtn) {
    driverDownloadLatexBtn.addEventListener("click", () => downloadDriverArtifact("latex", "compiled_rmsd_results.tex"));
  }
  if (driverDownloadDocxBtn) {
    driverDownloadDocxBtn.addEventListener("click", () => downloadDriverArtifact("docx", "compiled_rmsd_results.docx"));
  }

  if (analyzeDownloadPdfBtn) {
    analyzeDownloadPdfBtn.addEventListener("click", () => downloadAnalyzeArtifact("pdf", "uma-ase_RMSD_report.pdf"));
  }
  if (analyzeDownloadLatexBtn) {
    analyzeDownloadLatexBtn.addEventListener("click", () => downloadAnalyzeArtifact("latex", "uma-ase_RMSD_report.tex"));
  }
  if (analyzeDownloadDocxBtn) {
    analyzeDownloadDocxBtn.addEventListener("click", () => downloadAnalyzeArtifact("docx", "uma-ase_RMSD_report.docx"));
  }

  if (multiRunBtn) {
    multiRunBtn.addEventListener("click", () => {
      runMultiJobs();
    });
  }

  if (multiDownloadFilesBtn) {
    multiDownloadFilesBtn.addEventListener("click", async () => {
      if (!multiFolderRoot) {
        if (multiStatusEl) {
          multiStatusEl.textContent = "Select a folder and run jobs before downloading files.";
        }
        return;
      }
      try {
        const href = multiDownloadFilesBtn.dataset.href
          || `/api/uma-ase/multi/logs/${encodeURIComponent(multiFolderRoot)}?ts=${Date.now()}`;
        const response = await fetch(href);
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}`);
        }
        const blob = await response.blob();
        const filename = multiFolderRoot ? `${multiFolderRoot}_files.zip` : "uma-ase-multi-files.zip";
        await saveBlobWithDialog(blob, filename, "Results bundle");
      } catch (error) {
        if (multiStatusEl) {
          multiStatusEl.textContent = error && error.message
            ? `Unable to download files: ${error.message}`
            : "Unable to download files.";
        }
      }
    });
  }

  [chargeInput, spinInput].forEach((input) => {
    input.addEventListener("input", () => {
      if (input === chargeInput) {
        chargeManuallyEdited = input.value !== "";
        vizChargeInput.value = input.value;
      } else if (input === spinInput) {
        vizSpinInput.value = input.value;
      }
      if (currentGeometryFile) {
        requestStructurePreview();
      }
    });
  });

  if (vizChargeInput) {
    vizChargeInput.addEventListener("input", () => {
      chargeInput.value = vizChargeInput.value;
      chargeManuallyEdited = vizChargeInput.value !== "";
      if (currentGeometryFile) {
        requestStructurePreview();
      }
    });
  }

  if (vizSpinInput) {
    vizSpinInput.addEventListener("input", () => {
      spinInput.value = vizSpinInput.value;
      if (currentGeometryFile) {
        requestStructurePreview();
      }
    });
  }

  const tabButtons = document.querySelectorAll(".tab-button");
  const tabContents = document.querySelectorAll(".tab-content");

  tabButtons.forEach((button) => {
    button.addEventListener("click", () => {
      tabButtons.forEach((btn) => btn.classList.remove("active"));
      tabContents.forEach((content) => content.classList.remove("active"));
      button.classList.add("active");
      const target = document.getElementById(button.dataset.tab);
      if (target) {
        target.classList.add("active");
      }
      if (button.dataset.tab === "visualize-tab") {
        requestAnimationFrame(() => ensureViewerInitialized());
      }
    });
  });

  const initiallyActiveTab = document.querySelector(".tab-button.active");
  if (initiallyActiveTab && initiallyActiveTab.dataset.tab === "visualize-tab") {
    ensureViewerInitialized();
  }

  let pollTimer = null;

  function stopPolling() {
    if (pollTimer !== null) {
      clearInterval(pollTimer);
      pollTimer = null;
    }
  }

  function startJobPolling(jobId) {
    stopPolling();

    const poll = async () => {
      try {
        const response = await fetch(`/api/uma-ase/job/${jobId}`);
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}`);
        }

        const jobData = await response.json();
        const logText = jobData.log || "";
        if (logText) {
          resultsEl.textContent = logText;
          resultsEl.scrollTop = resultsEl.scrollHeight;
        } else if (jobData.status === "completed") {
          resultsEl.textContent = "Job completed. No output generated.";
        }

        if (jobData.status) {
          statusEl.textContent = jobData.status.toUpperCase();
        }

        if (jobData.status === "error" && jobData.message) {
          const combined = (logText ? `${logText}\n` : "") + jobData.message;
          resultsEl.textContent = combined.trim();
        }

        if (jobData.log_download) {
          downloadBtn.dataset.href = jobData.log_download;
          downloadBtn.disabled = false;
          downloadBtn.title = "Download log file";
        } else {
          downloadBtn.disabled = true;
          downloadBtn.removeAttribute("data-href");
          downloadBtn.title = "Log not available yet.";
        }

        if (trajBtn) {
          if (jobData.traj_download) {
            trajBtn.dataset.href = jobData.traj_download;
            trajBtn.disabled = false;
            trajBtn.title = "Download trajectory file";
          } else {
            trajBtn.disabled = true;
            trajBtn.removeAttribute("data-href");
            trajBtn.title = "Trajectory not available.";
          }
        }

        if (optBtn) {
          if (jobData.opt_download) {
            optBtn.dataset.href = jobData.opt_download;
            optBtn.disabled = false;
            optBtn.title = "Download optimized geometry";
          } else {
            optBtn.disabled = true;
            optBtn.removeAttribute("data-href");
            optBtn.title = "Optimized geometry not available.";
          }
        }

        if (jobData.status && jobData.status !== "running") {
          if (singleRunExpectGeoopt && jobData.opt_download) {
            loadOptimizedStructureFromUrl(jobData.opt_download);
          }
          singleRunExpectGeoopt = false;
          stopPolling();
          if (jobData.status === "completed") {
            statusEl.textContent = "COMPLETED";
          } else if (jobData.status === "error") {
            statusEl.textContent = "ERROR";
          }
        }
      } catch (error) {
        stopPolling();
        statusEl.textContent = "Job failed.";
        resultsEl.textContent = `Error: ${error.message}`;
        resetDownloadLink();
      }
    };

    poll();
    pollTimer = setInterval(poll, 1500);
  }

  async function runMultiJobs() {
    if (!multiEntries.length) {
      if (multiStatusEl) {
        multiStatusEl.textContent = "Select a folder with .xyz files first.";
      }
      return;
    }
    const runTypes = multiRunTypeCheckboxes
      .filter((checkbox) => checkbox.checked)
      .map((checkbox) => checkbox.value);
    if (!runTypes.length) {
      if (multiStatusEl) {
        multiStatusEl.textContent = "Select at least one run type.";
      }
      return;
    }
    if (multiRunBtn) {
      multiRunBtn.disabled = true;
    }
    const cleaned = await cleanResultsDir();
    if (!cleaned) {
      if (multiRunBtn) {
        multiRunBtn.disabled = false;
      }
      return;
    }
    if (multiDownloadFilesBtn) {
      multiDownloadFilesBtn.disabled = true;
      multiDownloadFilesBtn.removeAttribute("data-href");
      multiDownloadFilesBtn.title = "Files available after jobs finish.";
    }
    if (multiStatusEl) {
      multiStatusEl.textContent = `Launching ${multiEntries.length} job(s)...`;
    }
    if (!multiFolderRoot) {
      multiFolderRoot = "multi_run";
    }
    for (let index = 0; index < multiEntries.length; index += 1) {
      const entry = multiEntries[index];
      try {
        if (multiStatusEl) {
          const label = entry.displayPath || entry.relativePath || entry.file.name;
          multiStatusEl.textContent = `Submitting job ${index + 1} of ${multiEntries.length}: ${label}`;
        }
        const jobId = await submitMultiJob(entry, runTypes);
        await monitorMultiJob(jobId, entry);
      } catch (error) {
        const label = entry.displayPath || entry.relativePath || entry.file.name;
        appendMultiResult(`[${label}] ERROR: ${error && error.message ? error.message : "Job failed."}`);
      }
    }
    if (multiStatusEl) {
      multiStatusEl.textContent = "Multi-run complete.";
    }
    if (multiRunBtn) {
      multiRunBtn.disabled = false;
    }
    if (multiDownloadFilesBtn && multiFolderRoot) {
      multiDownloadFilesBtn.disabled = false;
      multiDownloadFilesBtn.dataset.href = `/api/uma-ase/multi/logs/${encodeURIComponent(multiFolderRoot)}?ts=${Date.now()}`;
      multiDownloadFilesBtn.title = "Download all job files.";
    }
  }

  async function submitMultiJob(entry, runTypes) {
    const formData = new FormData();
    formData.append("geometry", entry.file, entry.file.name);
    formData.append("charge", String(entry.charge));
    formData.append("spin", String(entry.spin));
    formData.append("run_type", runTypes.join(" "));
    formData.append("grad", multiGradInput && multiGradInput.value ? multiGradInput.value : "0.01");
    formData.append("iter", multiIterInput && multiIterInput.value ? multiIterInput.value : "250");
    const relPath = entry.relativePath || entry.displayPath || entry.file.name;
    formData.append("relative_path", relPath);
    if (multiFolderRoot) {
      formData.append("multi_root", multiFolderRoot);
    }

    if (runTypes.indexOf("geoopt") !== -1 && multiOptimizerSelect) {
      formData.append("optimizer", multiOptimizerSelect.value);
    }
    if (runTypes.indexOf("freqs") !== -1) {
      if (multiTemperatureInput) {
        formData.append("temperature", multiTemperatureInput.value);
      }
      if (multiPressureInput) {
        formData.append("pressure", multiPressureInput.value);
      }
    }

    if (multiCheckpointInput && (multiCheckpointInput.value || "").trim()) {
      formData.append("mlff_checkpoint", multiCheckpointInput.value.trim());
    }
    if (multiTaskInput && (multiTaskInput.value || "").trim()) {
      formData.append("mlff_task", multiTaskInput.value.trim());
    }

    const response = await fetch("/api/uma-ase/run", {
      method: "POST",
      body: formData,
    });
    const data = await response.json().catch(() => ({}));
    if (!response.ok || !data.job_id) {
      throw new Error(data && data.message ? data.message : `Job submission failed (${response.status}).`);
    }
    return data.job_id;
  }

  async function monitorMultiJob(jobId, entry) {
    const label = entry.displayPath || entry.relativePath || entry.file.name;
    while (true) {
      const response = await fetch(`/api/uma-ase/job/${jobId}`);
      if (!response.ok) {
        throw new Error(`Status check failed (${response.status}).`);
      }
      const jobData = await response.json().catch(() => ({}));
      if (jobData && jobData.status && jobData.status !== "running") {
        const statusUpper = jobData.status.toUpperCase();
        const extra = jobData.message ? ` - ${jobData.message}` : "";
        appendMultiResult(`[${label}] ${statusUpper}${extra}`);
        if (jobData.log) {
          appendMultiResult(`[${label}] Log output:\n${jobData.log}`);
        }
        if (jobData.log_download) {
          const link = document.createElement("a");
          link.href = jobData.log_download;
          link.textContent = "Download log";
          link.target = "_blank";
          link.rel = "noopener noreferrer";
          appendMultiResult(`[${label}] Log ready.`, link);
        }
        if (jobData.traj_download) {
          const trajLink = document.createElement("a");
          trajLink.href = jobData.traj_download;
          trajLink.textContent = "Download trajectory";
          trajLink.target = "_blank";
          trajLink.rel = "noopener noreferrer";
          appendMultiResult(`[${label}] Trajectory ready.`, trajLink);
        }
        if (jobData.opt_download) {
          const optLink = document.createElement("a");
          optLink.href = jobData.opt_download;
          optLink.textContent = "Download optimized geometry";
          optLink.target = "_blank";
          optLink.rel = "noopener noreferrer";
          appendMultiResult(`[${label}] Optimized geometry ready.`, optLink);
        }
        break;
      }
      if (multiStatusEl) {
        multiStatusEl.textContent = `[${label}] running...`;
      }
      await new Promise((resolve) => setTimeout(resolve, 1500));
    }
  }

  async function runUmaJob() {
    const file = fileInput.files[0] || currentGeometryFile;

    if (!file) {
      statusEl.textContent = "Please upload a geometry file first.";
      return;
    }

    const runTypes = runTypeCheckboxes
      .filter((checkbox) => checkbox.checked)
      .map((checkbox) => checkbox.value);

    if (runTypes.length === 0) {
      statusEl.textContent = "Select at least one run type.";
      return;
    }

    singleRunExpectGeoopt = runTypes.indexOf("geoopt") !== -1;

    const cleaned = await cleanResultsDir();
    if (!cleaned) {
      singleRunExpectGeoopt = false;
      return;
    }

    const formData = new FormData();
    formData.append("geometry", file);
    formData.append("charge", chargeInput.value);
    formData.append("spin", spinInput.value);
    formData.append("run_type", runTypes.join(" "));
    formData.append("grad", gradInput.value || "0.01");
    formData.append("iter", iterInput.value || "250");

    if (runTypes.includes("geoopt")) {
      formData.append("optimizer", optimizerSelect.value);
    }
    if (runTypes.includes("freqs")) {
      formData.append("temperature", temperatureInput.value);
      formData.append("pressure", pressureInput.value);
    }

    const checkpointValue = (checkpointInput.value || "").trim();
    if (checkpointValue) {
      formData.append("mlff_checkpoint", checkpointValue);
    }

    const taskValue = (taskInput.value || "").trim();
    if (taskValue) {
      formData.append("mlff_task", taskValue);
    }

    statusEl.textContent = "Submitting job...";
    resultsEl.textContent = "";
    resetDownloadLink();
    stopPolling();

    try {
      const response = await fetch("/api/uma-ase/run", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }

      const data = await response.json();
      const jobId = data.job_id;
      if (!jobId) {
        throw new Error(data.message || "Unable to start uma-ase job.");
      }

      statusEl.textContent = "Running...";
      resultsEl.textContent = "Waiting for output...";
      startJobPolling(jobId);
    } catch (error) {
      stopPolling();
      statusEl.textContent = "Job failed.";
      resultsEl.textContent = `Error: ${error.message}\nCheck server logs for more information.`;
      resetDownloadLink();
    }
  }

  async function saveBlobWithDialog(blob, suggestedName, fallbackLabel) {
    if (window.showSaveFilePicker) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName,
          types: [
            {
              description: fallbackLabel,
              accept: { "text/plain": [".log", ".txt", ".traj", ".xyz"] },
            },
          ],
        });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
        return true;
      } catch (error) {
        if (error && error.name === "AbortError") {
          return true;
        }
        console.error("Unable to save using file picker", error);
      }
    }

    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = suggestedName;
    document.body.appendChild(anchor);
    anchor.click();
    document.body.removeChild(anchor);
    URL.revokeObjectURL(url);
    return true;
  }

  downloadBtn.addEventListener("click", async () => {
    const href = downloadBtn.dataset.href;
    if (!href) {
      return;
    }
    try {
      const response = await fetch(href);
      if (!response.ok) {
        throw new Error(`Download failed (${response.status})`);
      }
      const blob = await response.blob();
      const filename = href.split("/").pop() || "uma-ase.log";
      await saveBlobWithDialog(blob, filename, "Log file");
    } catch (error) {
      statusEl.textContent = `Unable to download log: ${error.message}`;
    }
  });

  if (trajBtn) {
    trajBtn.addEventListener("click", async () => {
      const href = trajBtn.dataset.href;
      if (!href) {
        return;
      }
      try {
        const response = await fetch(href);
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}`);
        }
        const blob = await response.blob();
        const filename = href.split("/").pop() || "uma-ase.traj";
        await saveBlobWithDialog(blob, filename, "Trajectory file");
      } catch (error) {
        statusEl.textContent = `Unable to download trajectory: ${error.message}`;
      }
    });
  }

  if (optBtn) {
    optBtn.addEventListener("click", async () => {
      const href = optBtn.dataset.href;
      if (!href) {
        return;
      }
      try {
        const response = await fetch(href);
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}`);
        }
        const blob = await response.blob();
        const filename = href.split("/").pop() || "uma-ase-opt.xyz";
        await saveBlobWithDialog(blob, filename, "Optimized geometry");
      } catch (error) {
        statusEl.textContent = `Unable to download optimized geometry: ${error.message}`;
      }
    });
  }

  async function downloadAnalyzeArtifact(type, fallbackLabel) {
    const url = analyzeDownloadLinks[type];
    if (!url) {
      return;
    }
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Download failed (${response.status})`);
      }
      const blob = await response.blob();
      const filename = url.split("/").pop() || fallbackLabel;
      await saveBlobWithDialog(blob, filename, fallbackLabel);
    } catch (error) {
      if (analyzeStatus) {
        analyzeStatus.textContent = `Unable to download ${type.toUpperCase()}: ${error.message}`;
      }
    }
  }

  async function loadOptimizedStructureFromUrl(url, label = "optimized.xyz") {
    if (!url) {
      return;
    }
    ensureViewerInitialized();
    try {
      const cacheBusted = url.indexOf("?") !== -1 ? `${url}&ts=${Date.now()}` : `${url}?ts=${Date.now()}`;
      const response = await fetch(cacheBusted);
      if (!response.ok) {
        throw new Error(`Viewer download failed (${response.status})`);
      }
      const text = await response.text();
      loadStructureContent(label, text);
      const pseudoFile = { name: label };
      updateFileIndicators(pseudoFile);
      updateViewerFileLabel(pseudoFile);
      if (fileIndicatorViz) {
        fileIndicatorViz.textContent = label;
      }
      if (viewerFileLabel) {
        viewerFileLabel.textContent = label;
      }
      if (viewerLoadedLabel) {
        viewerLoadedLabel.textContent = label;
      }
      updateViewerStatus(`Loaded optimized structure (${label}).`);
    } catch (error) {
      console.error("Unable to load optimized structure", error);
      updateViewerStatus("Optimized structure ready. Open Visualize tab to load manually.", true);
    }
  }

  document.getElementById("run-btn").addEventListener("click", runUmaJob);
</script>
</body>
</html>
