<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>arts.mysql</title>
<base href="/mysql/README.md">
<base target="_blank">
<link rel="icon" href="/site.ico" type="image/x-icon">
<script src="/cdn/markdown_css/light.js"></script>
<link rel="stylesheet" href="/cdn/markdown_css/light.css">
<article class="markdown-body">
<h1>描述</h1>
<p>一个优雅的 mysql ORM ，无须做模型映射。</p>
<p><a href="https://github.com/canbiaoxu/arts/tree/main/arts/mysql">源码</a></p>
<h1>教程</h1>
<p>本文将以简洁的方式向你介绍核心知识，而不会让你被繁琐的术语所淹没。</p>
<h2>安装</h2>
<pre><code class="language-bash">pip install arts
</code></pre>
<h2>导入</h2>
<pre><code class="language-python">import pymysql, aiomysql
from arts.mysql import ORM, mc
</code></pre>
<h2>创建ORM</h2>
<pre><code class="language-python">class ORM_2(ORM):

    def mkconn(self):  # 定义同步连接器
        return pymysql.connect(
            host = 'localhost',
            port = 3306,
            user = 'root',
            password = '123456789'
        )

    async def amkconn(self):  # 定义异步连接器
        return await aiomysql.connect(
            host = 'localhost',
            port = 3306,
            user = 'root',
            password = '123456789'
        )

orm = ORM_2()          # 账户ORM
db = orm['泉州市']      # 库ORM
sheet = db['希望小学']  # 表ORM
</code></pre>
<h2>基础功能 —— 增、查、改、删</h2>
<p>【增、查、改、删】的同步方法名称分别为：insert、select、update、delete 。</p>
<p>对应的异步方法名称为各同步方法名前加 <code>a</code> ，即：ainsert、aselect、aupdate、adelete 。</p>
<h3>示例</h3>
<pre><code class="language-python">row1 = {'姓名': '小一', '年龄': 11, '性别': '男', '视力': 4.5, '签到日期': '2023-01-11'}
row2 = {'姓名': '小二', '年龄': 12, '性别': '男', '视力': 4.6, '签到日期': '2023-01-12'}
row3 = {'姓名': '小三', '年龄': 13, '性别': '女', '视力': 4.7, '签到日期': '2023-01-13'}
row4 = {'姓名': '小四', '年龄': 14, '性别': '女', '视力': 4.8, '签到日期': '2023-01-14'}
row5 = {'姓名': '小五', '年龄': 15, '性别': '男', '视力': 4.9, '签到日期': '2023-01-15'}
row6 = {'姓名': '小六', '年龄': 16, '性别': '女', '视力': 5.0, '签到日期': '2023-01-16'}
</code></pre>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th>同步方式</th>
<th>异步方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">增（1 条）</td>
<td>sheet.insert( row1 )</td>
<td>await sheet.ainsert( row2 )</td>
</tr>
<tr>
<td style="text-align: center;">增（批量）</td>
<td>sheet.insert( row3, row4 )</td>
<td>await sheet.ainsert( row5, row6 )</td>
</tr>
<tr>
<td style="text-align: center;">查</td>
<td>sheet.select( )</td>
<td>await sheet.aselect( )</td>
</tr>
<tr>
<td style="text-align: center;">改</td>
<td>sheet.update( {'年龄': 100} )</td>
<td>await sheet.aupdate( {'年龄': 200} )</td>
</tr>
<tr>
<td style="text-align: center;">删</td>
<td>sheet.delete( )</td>
<td>await sheet.adelete( )</td>
</tr>
</tbody>
</table>
<h3>新增时，查看分配到的主键：</h3>
<pre><code class="language-python">r1 = sheet.insert( row1 )
r2 = await sheet.ainsert( row2 )

r1.lastrowid
r2.lastrowid
</code></pre>
<h2>注：下文中所有示例都同时支持同步方式和异步方式，将同步示例中的 insert、delete、update、select 替换为 ainsert、adelete、aupdate、aselect 即为异步方式，当然，须加上 await 前缀。</h2>
<h2>条件筛选</h2>
<h3>示例一：理解条件筛选的基本范式</h3>
<p>筛选【年龄&gt;13，且视力≧4.6，且性别为女】的数据，并进行查改删：</p>
<p><strong>查询</strong>：<code>sheet[mc.年龄 &gt; 13][mc.视力 &gt;= 4.6][mc.性别 == '女'].select( )</code></p>
<p><strong>修改</strong>：<code>sheet[mc.年龄 &gt; 13][mc.视力 &gt;= 4.6][mc.性别 == '女'].update( {'年级':'初一', '爱好':'画画,跳绳'} )</code></p>
<p><strong>删除</strong>：<code>sheet[mc.年龄 &gt; 13][mc.视力 &gt;= 4.6][mc.性别 == '女'].delete( )</code></p>
<h3>筛选操作清单</h3>
<table>
<thead>
<tr>
<th><strong>代码</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>mc.年龄 &gt; 10</td>
<td>大于</td>
</tr>
<tr>
<td>mc.年龄 &gt;= 10</td>
<td>大于或等于</td>
</tr>
<tr>
<td>mc.年龄 &lt; 10</td>
<td>小于</td>
</tr>
<tr>
<td>mc.年龄 &lt;= 10</td>
<td>小于或等于</td>
</tr>
<tr>
<td>mc.年龄 == 10</td>
<td>等于</td>
</tr>
<tr>
<td>mc.年龄 != 10</td>
<td>不等于</td>
</tr>
<tr>
<td>mc.年级.isin( '初三', '高二' )</td>
<td>若字段值是传入值的成员，则符合</td>
</tr>
<tr>
<td>mc.年龄.notin( 10, 30, 45 )</td>
<td>若字段值不是传入值的成员，则符合</td>
</tr>
<tr>
<td>mc.姓名.re( '小' )</td>
<td>正则匹配</td>
</tr>
<tr>
<td>[mc.年龄 &gt; 3][mc.年龄 &lt; 100]</td>
<td>交集（方式一）</td>
</tr>
<tr>
<td>[ (mc.年龄 &gt; 3) &amp; (mc.年龄 &lt; 100) ]</td>
<td>交集（方式二）</td>
</tr>
<tr>
<td>[(mc.年龄&lt;30)&#124; (mc.年龄&gt;30) &#124; (mc.年龄==30) &#124; (mc.年龄==None)]</td>
<td>并集</td>
</tr>
<tr>
<td>[ (mc.年龄 &gt; 3) - (mc.年龄 &gt; 100) ]</td>
<td>差集</td>
</tr>
<tr>
<td>[ ~(mc.年龄 &gt; 100) ]</td>
<td>补集</td>
</tr>
</tbody>
</table>
<p>注：</p>
<p>1、isin、notin 的传入值都不必是同类型的数据，以 isin 为例：可以这样使用：mc.tag.isin( 3, 3.5, '学生', None )  ，传入值含有 int、float、str、NoneType 等多种类型。</p>
<p>2、成员运算符未传入任何值时的处理方式：</p>
<table>
<thead>
<tr>
<th><strong>代码</strong></th>
<th><strong>处理方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>mc.年级.isin( )</td>
<td>所有数据都 不符合</td>
</tr>
<tr>
<td>mc.年级.notin( )</td>
<td>所有数据都 符合</td>
</tr>
</tbody>
</table>
<p>3、四种集合运算可以相互嵌套，且可以无限嵌套。</p>
<h3>示例二：理解并集、交集、差集的使用</h3>
<p>筛选【年龄&gt;13或视力≧4.6、且姓名含有‘小’、且喜欢足球但不喜欢画画】的数据：</p>
<p><strong>查询</strong>：<code>sheet[(mc.年龄&gt;13) | (mc.视力&gt;=4.6)][mc.姓名.re('小')][mc.爱好.re('足球') - mc.爱好.re('画画')].select( )</code></p>
<p><strong>修改</strong>：<code>sheet[(mc.年龄&gt;13) | (mc.视力&gt;=4.6)][mc.姓名.re('小')][mc.爱好.re('足球') - mc.爱好.re('画画')].update( {'年级':'初三'} )</code></p>
<p><strong>删除</strong>：<code>sheet[(mc.年龄&gt;13) | (mc.视力&gt;=4.6)][mc.姓名.re('小')][mc.爱好.re('足球') - mc.爱好.re('画画')].delete( )</code></p>
<h2>特殊字段名的表示方法</h2>
<p>MySQL 支持各种特殊的字段名，如：数字、符号、emoji 表情，这些字符在 Python 中不是合法变量名，因此使用  mc.1、mc.+  等格式会报错，可用  mc['1']、mc['+']、mc['👈']  这种格式代替。</p>
<h2>切片</h2>
<p>1、切片格式为  [start: stop: step]  ，start 表示从哪条开始，stop 表示到哪条停止，step 表示步长。</p>
<p>2、start 和 stop</p>
<ul>
<li>当为正值时，表示正序第 x 条，例如：1 表示第 1 条、2 表示第 2 条。</li>
<li>当为负值时，表示倒数第 x 条，例如：-1 表示倒数第 1 条、-2 表示倒数第 2 条。</li>
<li>不可为 0 。</li>
</ul>
<p>3、step</p>
<ul>
<li>须为正整数。</li>
<li>当 step ≧ 2  时表示间隔式切片。</li>
<li>当 step = 1 时可省略 <code>: step</code> ，即：[start: stop] 等价于 [start: stop: 1] 。</li>
</ul>
<h3>示例</h3>
<pre><code class="language-python">sheet[过滤器]...[过滤器][:].select()                    # 查询符合条件的全部数据
sheet[过滤器]...[过滤器][:].delete()                    # 删除符合条件的全部数据
sheet[过滤器]...[过滤器][:].update({'年级':'初一'})      # 修改符合条件的全部数据

sheet[过滤器]...[过滤器][1].select()                    # 查询符合条件的第1条
sheet[过滤器]...[过滤器][1].delete()                    # 删除符合条件的第1条
sheet[过滤器]...[过滤器][1].update({'年级':'初一'})      # 修改符合条件的第1条

sheet[过滤器]...[过滤器][3:7].select()                  # 查询符合条件的第3~7条
sheet[过滤器]...[过滤器][3:7].delete()                  # 删除符合条件的第3~7条
sheet[过滤器]...[过滤器][3:7].update({'年级':'初一'})    # 修改符合条件的第3~7条

sheet[过滤器]...[过滤器][3:7:2].select()                # 查询符合条件的第3、5、7条
sheet[过滤器]...[过滤器][3:7:2].delete()                # 删除符合条件的第3、5、7条
sheet[过滤器]...[过滤器][3:7:2].update({'年级':'初一'})  # 修改符合条件的第3、5、7条
</code></pre>
<p>值得注意的地方：  [3: 8: 2]  操作第  3、5、7  条，而  [8: 3: 2]  操作第  8、6、4  条。</p>
<p>更多示例：</p>
<pre><code class="language-python">[:]           # 所有数据
[1:-1]        # 所有数据
[-1:1]        # 所有数据（逆序）
[1:]          # 所有数据
[:1000]       # 第1条 ~ 第1000条
[:-1000]      # 第1条 ~ 倒数第1000条
[100:200]     # 第100条 ~ 第200条
[200:100]     # 第200条 ~ 第100条
[-300:-2]     # 倒数第300条 ~ 倒数第2条
[50:-2]       # 第50条 ~ 倒数第2条
[250:]        # 第250条 ~ 最后1条
[-250:]       # 倒数第250条 ~ 最后1条
[1]           # 第1条
[-1]          # 最后1条
[::3]         # 以3为间距, 间隔操作所有数据
[100:200:4]   # 以4为间距, 间隔操作第100条 ~ 第200条
</code></pre>
<h2>字段提示</h2>
<p>变量 mc 无字段提示功能，输入‘mc.’后，编辑器不会提示可选字段。</p>
<p>为了获得字段提示功能，可自建一个‘mc2’：</p>
<pre><code class="language-python">class mc2(mc):
    姓名 = 年龄 = 签到日期 = 年级 = 爱好 = None

await sheet[mc.姓名 == '小王'][mc2.年龄 &gt; 10].aselect()
</code></pre>
<p>注：</p>
<p>1、mc2 与 mc 用法完全一致，可混用。</p>
<p>2、mc2 设置字段提示后，仅具备提示效果，而不产生任何实际约束。</p>
<h2>排序</h2>
<p>对所有年级为“高一”的数据，优先按年龄降序，其次按姓名升序，排序后返回第 2\~4 条数据：</p>
<pre><code class="language-python">sheet[mc.年级=='高一'].order(年龄=False, 姓名=True)[2:4].select()
</code></pre>
<p>有趣的，以下两行代码的返回结果相同：</p>
<pre><code class="language-python">sheet[mc.年级=='高一'].order(年龄=True)[1:-1].select()

sheet[mc.年级=='高一'].order(年龄=False)[-1:1].select()
</code></pre>
<p>解释：order(年龄=False) 表示按年龄降序，[-1:1] 表示逆序切片，产生了类似‘负负得正’的效果。</p>
<p>注：</p>
<p>1、筛选器、切片器、排序器、限定字段器的位置可任意，位置不影响其效果。当然，它们都应该在 sheet 之后，且在 select/update/delete 之前。</p>
<p>2、可反复排序，select/update/delete 时是根据最后一次指定的顺序提取数据。以下代码最终是按年龄降序后提取数据：</p>
<pre><code class="language-python">sheet.order(年龄=True, 姓名=False).order(年龄=False).select()
</code></pre>
<p>3、若想取消排序，则再次调用 order 方法，但不传入任何值。</p>
<pre><code class="language-python">sheet.order(年龄=True, 姓名=False).order().select()
</code></pre>
<h2>限定字段</h2>
<p>只返回姓名、年龄这两个字段：</p>
<pre><code class="language-python">sheet[mc.年级=='高一']['姓名','年龄'].select()
</code></pre>
<p>注：</p>
<p>1、限定字段只对 select 有作用，对 update/delete 无作用但不会报错。</p>
<p>2、筛选器、切片器、排序器、限定字段器的位置可任意，位置不影响其效果。当然，它们都应该在 sheet 之后，且在 select/update/delete 之前。</p>
<p>3、可反复限定字段，查询时是根据最后一次指定的字段提取数据。以下代码返回结果中只有‘年龄’字段：</p>
<pre><code class="language-python">sheet[mc.年级=='高一']['姓名']['年龄'].select()
</code></pre>
<p>4、若想恢复提取全部字段，则限定字段为 <code>'*'</code> ，<code>'*'</code> 即代表“全部字段”。</p>
<pre><code class="language-python">sheet[mc.年级=='高一']['姓名']['*'].select()
</code></pre>
<h2>统计</h2>
<table>
<thead>
<tr>
<th></th>
<th>同步方式</th>
<th>异步方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>统计库的数量</td>
<td>orm.len( )</td>
<td>await orm.alen( )</td>
</tr>
<tr>
<td>统计表的数量</td>
<td>db.len( )</td>
<td>await db.alen( )</td>
</tr>
<tr>
<td>统计行的数量</td>
<td>sheet.len( )</td>
<td>await sheet.alen( )</td>
</tr>
<tr>
<td>统计符合条件的行的数量</td>
<td>sheet[ mc.age &gt; 8 ].len( )</td>
<td>await sheet[ mc.age &gt; 8 ].alen( )</td>
</tr>
<tr>
<td>获取库名清单</td>
<td>orm.get_db_names( )</td>
<td>await orm.aget_db_names( )</td>
</tr>
<tr>
<td>获取表名清单</td>
<td>db.get_sheet_names( )</td>
<td>await db.aget_sheet_names( )</td>
</tr>
<tr>
<td>获取主键</td>
<td>sheet.get_pk( )</td>
<td>await sheet.aget_pk( )</td>
</tr>
</tbody>
</table>
<h2>迭代所有 库ORM 和 表ORM</h2>
<pre><code class="language-python"># 同步方式迭代
for db in orm:
    for sheet in db:
        print(sheet.sheet_name)

# 异步方式迭代
async for db in orm:
    async for sheet in db:
        print(sheet.sheet_name)
</code></pre>
<h2>执行原生 SQL 语句</h2>
<pre><code class="language-python">data, cursor = sheet.execute('select 姓名 from 希望小学 limit 1')
data  # &gt;&gt;&gt; [{'姓名': '小一'}]

data, cursor = sheet.execute('update 希望小学 set 爱好=&quot;编程&quot; limit 3')
cursor.rowcount  # &gt;&gt;&gt; 3

data, cursor = sheet.execute(&quot;delete from 希望小学 limit 2&quot;)
cursor.rowcount  # &gt;&gt;&gt; 2

data, cursor = sheet.executemany( 'insert into 希望小学(姓名, 年龄) values (%s, %s)', [('小七', 17), ('小八', 18)] )
cursor.lastrowid  # &gt;&gt;&gt; 8
</code></pre>
<h2>按主键修改</h2>
<pre><code class="language-python">data = {
    2: {'姓名':'xiao二', '年龄':20},
    3: {'年级':'三年级'},
    4: {'id':400, '视力':4.0}
}

sheet.update_by_pk(data)
</code></pre>
<h2>用自定义函数修改</h2>
<pre><code class="language-python">def handler(row: dict):
    row['年龄'] += 1  # 年龄统一加1岁
    if row['爱好'] == '打篮球':
        row['身高'] = 180
    elif row['爱好'] == '玩手机':
        row['视力'] = 1.8
    row['姓名'] = row['姓名'].replace('小', 'xiao')

sheet[mc.年龄&gt;11][:].apply(handler)  # 修改符合条件的所有数据
sheet[mc.年龄&gt;11][2:-2].apply(handler)  # 修改符合条件的第2条~倒数第2条
sheet[mc.年龄&gt;11][2].apply(handler)  # 修改符合条件的第2条数据
</code></pre>
<p>注：</p>
<p>1、传递给 apply 方法的函数必须接收且仅接收 1 个参数，参数名可以不是‘row’。</p>
<p>2、可只提取需要的字段以提升性能。比如在上例中，handler 函数只使用到年龄、爱好、姓名这3个字段，可改为 <code>sheet[mc.年龄&gt;11]['年龄', '爱好', '姓名'][:].apply(handler)</code> 以提高性能。</p>
<p>3、ORM 会自动对比修改前与修改后的数据差异，只提交差异部分到数据库。</p>
<h2>调用 MySQL 函数</h2>
<h3>示例一</h3>
<p>在查询、删除、修改的筛选条件中调用 year 函数</p>
<pre><code class="language-python">from arts.mysql import mf

sheet[mf.year('签到日期') == 2023][:].select()
sheet[mf.year('签到日期') == 2029][:].delete()
sheet[mf.year('签到日期') == 2023][:].update({'性别':'女'})
</code></pre>
<h3>示例二</h3>
<p>在修改中作为新值</p>
<pre><code class="language-python">sheet[:].update({'备注': '签到日期'}) # 修改为'签到日期'这个字符串
sheet[:].update({'备注': mc.签到日期}) # 修改为各自的'签到日期'字段的值
sheet[:].update({'备注': mf.year('签到日期')}) # 修改为各自的'签到日期'字段的值经year处理后的值
</code></pre>
<p>使用该语法可调用mysql的任意函数。</p>
<h3>MySQL 函数名提示</h3>
<p>ORM 已添加了（20几个）mysql 常用函数的函数名提示，输入‘mf.’后，编辑器会提示可选函数名。如有需要，可添加更多提示：</p>
<pre><code class="language-python">class mf2(mf):
    reverse = length = lower = upper = None

sheet[mf2.reverse('姓名') == '二小'][:].select()
</code></pre>
<p>注：</p>
<p>1、mf2 与 mf 用法完全一致，可混用。</p>
<p>2、mf2 设置函数名提示后，仅具备提示效果，而不产生任何实际约束。</p>
</article>