{"version":3,"mappings":";kQAAA,yBAUCA,EAEWC,EAAiBC,EAAAC,EAAA,YAEnBC,EAASF,EAAAC,EAAA,mBAEWE,EAAAH,EAAAC,EAAA,kBACXG,EAAAJ,EAAAC,EAAA,sBACdI,EAAsCL,EAAAC,EAAA,mBACvBD,EAAAC,EAAA,gBAKjBK,EAAeC,EAAA,EACdC,EACAC,EACAC,IAAA,IAEAC,EAAA,MACC,SAAuB,CACxBb,qBAAA,4BAAAc,KAAA,8CACAd,EAAQ,sBAAsBe,EAAAP,CAAA,GAC9B,WAAAH,EAAS,EACT,qBAAc,GACf,kBAAE,GACH,gBAAC,aAED,cAAYW,GAAA,CAEZL,EAAYK,KAEX,KAAAC,GAAA,CACAP,EAAAO,EAECC,EAAAN,EAAW,GAEd,EACC,GAED,EAGW,KACTF,GAAA,QAAS,CACR,+CAOEC,EAAA,qBAAAQ,EAGC,SAAAC,EAAAC,EAAuB,CACxBX,MACCA,EACD,UAAAW,EAAA,CAAO,eACN,KACD,mCAGF,CACDjB,EAAA,kBACDkB,EAAA,OACDlB,EAAA,kBAEgB,OAMfmB,IAA+B,EAAEhB,EAAA,EAAAiB,EAAA,EAEjC,GAECd,EAAA,WAAW,EAGX,CAEM,SAAAa,QAGN,OAEDE,EAAAd,EAAyB,OACzBL,EAAO,YACRmB,EAAA,MAAAnB,EAAA,gBAGCA,EAAiB,CAAE,aAClB,OAAoB,gBAEtBA,EAAA,YACCmB,EAAM,OAAAnB,EAAA,IAEPmB,EAAO,iBAAoB,qLAvF1BJ,EAAMpB,EAAA,kCAoCDW,CAAA,GAAAQ,EAAKL,EAAAM,CAAA","names":["BABYLON_VIEWER","value","$.prop","$$props","display_mode","clear_color","camera_position","zoom_speed","canvas","$.mutable_source","viewer","viewerDetails","mounted","onMount","n","$.get","details","promiseViewer","$.set","wireframe","load_model","url","setRenderingMode","update_camera","pan_speed","camera"],"ignoreList":[],"sources":["../../../../js/model3D/shared/Canvas3D.svelte"],"sourcesContent":["<script lang=\"ts\">\n\timport { onMount } from \"svelte\";\n\timport type { FileData } from \"@gradio/client\";\n\timport type { Viewer, ViewerDetails } from \"@babylonjs/viewer\";\n\n\tlet BABYLON_VIEWER: typeof import(\"@babylonjs/viewer\");\n\n\texport let value: FileData;\n\texport let display_mode: \"solid\" | \"point_cloud\" | \"wireframe\";\n\texport let clear_color: [number, number, number, number];\n\texport let camera_position: [number | null, number | null, number | null];\n\texport let zoom_speed: number;\n\texport let pan_speed: number;\n\n\t$: url = value.url;\n\n\tlet canvas: HTMLCanvasElement;\n\tlet viewer: Viewer;\n\tlet viewerDetails: Readonly<ViewerDetails>;\n\tlet mounted = false;\n\n\tonMount(() => {\n\t\tconst initViewer = async (): Promise<void> => {\n\t\t\tBABYLON_VIEWER = await import(\"@babylonjs/viewer\");\n\t\t\tBABYLON_VIEWER.CreateViewerForCanvas(canvas, {\n\t\t\t\tclearColor: clear_color,\n\t\t\t\tuseRightHandedSystem: true,\n\t\t\t\tanimationAutoPlay: true,\n\t\t\t\tcameraAutoOrbit: { enabled: false },\n\t\t\t\tonInitialized: (details: any) => {\n\t\t\t\t\tviewerDetails = details;\n\t\t\t\t}\n\t\t\t}).then((promiseViewer: any) => {\n\t\t\t\tviewer = promiseViewer;\n\t\t\t\tmounted = true;\n\t\t\t});\n\t\t};\n\n\t\tinitViewer();\n\n\t\treturn () => {\n\t\t\tviewer?.dispose();\n\t\t};\n\t});\n\n\t$: mounted && load_model(url);\n\n\tfunction setRenderingMode(pointsCloud: boolean, wireframe: boolean): void {\n\t\tviewerDetails.scene.forcePointsCloud = pointsCloud;\n\t\tviewerDetails.scene.forceWireframe = wireframe;\n\t}\n\n\tfunction load_model(url: string | undefined): void {\n\t\tif (viewer) {\n\t\t\tif (url) {\n\t\t\t\tviewer\n\t\t\t\t\t.loadModel(url, {\n\t\t\t\t\t\tpluginOptions: {\n\t\t\t\t\t\t\tobj: {\n\t\t\t\t\t\t\t\timportVertexColors: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\tif (display_mode === \"point_cloud\") {\n\t\t\t\t\t\t\tsetRenderingMode(true, false);\n\t\t\t\t\t\t} else if (display_mode === \"wireframe\") {\n\t\t\t\t\t\t\tsetRenderingMode(false, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdate_camera(camera_position, zoom_speed, pan_speed);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tviewer.resetModel();\n\t\t\t}\n\t\t}\n\t}\n\n\texport function update_camera(\n\t\tcamera_position: [number | null, number | null, number | null],\n\t\tzoom_speed: number,\n\t\tpan_speed: number\n\t): void {\n\t\tconst camera = viewerDetails.camera;\n\t\tif (camera_position[0] !== null) {\n\t\t\tcamera.alpha = (camera_position[0] * Math.PI) / 180;\n\t\t}\n\t\tif (camera_position[1] !== null) {\n\t\t\tcamera.beta = (camera_position[1] * Math.PI) / 180;\n\t\t}\n\t\tif (camera_position[2] !== null) {\n\t\t\tcamera.radius = camera_position[2];\n\t\t}\n\t\tcamera.lowerRadiusLimit = 0.1;\n\t\tconst updateCameraSensibility = (): void => {\n\t\t\tcamera.wheelPrecision = 250 / (camera.radius * zoom_speed);\n\t\t\tcamera.panningSensibility = (10000 * pan_speed) / camera.radius;\n\t\t};\n\t\tupdateCameraSensibility();\n\t\tcamera.onAfterCheckInputsObservable.add(updateCameraSensibility);\n\t}\n\n\texport function reset_camera_position(): void {\n\t\tif (viewerDetails) {\n\t\t\tviewer.resetCamera();\n\t\t}\n\t}\n</script>\n\n<canvas bind:this={canvas}></canvas>\n"],"file":"Canvas3D-BgbjnOxQ.js"}