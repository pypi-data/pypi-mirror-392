{"version":3,"file":"webAudioStaticSound-BtgQBOZZ.js","sources":["../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/staticSound.js","../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/staticSoundBuffer.js","../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/staticSoundInstance.js","../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/webAudio/webAudioStaticSound.js"],"sourcesContent":["import { AbstractSound } from \"./abstractSound.js\";\n/**\n * Abstract class representing a static sound.\n *\n * A static sound has a sound buffer that is loaded into memory all at once. This allows it to have more capabilities\n * than a streaming sound, such as loop points and playback rate changes, but it also means that the sound must be\n * fully downloaded and decoded before it can be played, which may take a long time for sounds with long durations.\n *\n * To prevent downloading and decoding a sound multiple times, a sound's buffer can be shared with other sounds.\n * See {@link CreateSoundBufferAsync}, {@link StaticSoundBuffer} and {@link StaticSound.buffer} for more information.\n *\n * Static sounds are created by the {@link CreateSoundAsync} function.\n */\nexport class StaticSound extends AbstractSound {\n    constructor(name, engine) {\n        super(name, engine);\n    }\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    get duration() {\n        return this._options.duration;\n    }\n    set duration(value) {\n        this._options.duration = value;\n    }\n    /**\n     * The start of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     */\n    get loopStart() {\n        return this._options.loopStart;\n    }\n    set loopStart(value) {\n        this._options.loopStart = value;\n    }\n    /**\n     * The end of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     */\n    get loopEnd() {\n        return this._options.loopEnd;\n    }\n    set loopEnd(value) {\n        this._options.loopEnd = value;\n    }\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Gets combined with {@link playbackRate} to determine the final pitch.\n     */\n    get pitch() {\n        return this._options.pitch;\n    }\n    set pitch(value) {\n        this._options.pitch = value;\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.pitch = value;\n        }\n    }\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Gets combined with {@link pitch} to determine the final playback rate.\n     */\n    get playbackRate() {\n        return this._options.playbackRate;\n    }\n    set playbackRate(value) {\n        this._options.playbackRate = value;\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.playbackRate = value;\n        }\n    }\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    play(options = {}) {\n        if (this.state === 5 /* SoundState.Paused */) {\n            this.resume();\n            return;\n        }\n        options.duration ?? (options.duration = this.duration);\n        options.loop ?? (options.loop = this.loop);\n        options.loopStart ?? (options.loopStart = this.loopStart);\n        options.loopEnd ?? (options.loopEnd = this.loopEnd);\n        options.startOffset ?? (options.startOffset = this.startOffset);\n        options.volume ?? (options.volume = 1);\n        options.waitTime ?? (options.waitTime = 0);\n        const instance = this._createInstance();\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n        this._stopExcessInstances();\n    }\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     * @param options - The options to use when stopping the sound.\n     */\n    stop(options = {}) {\n        if (options.waitTime && 0 < options.waitTime) {\n            this._setState(0 /* SoundState.Stopping */);\n        }\n        else {\n            this._setState(1 /* SoundState.Stopped */);\n        }\n        if (!this._instances) {\n            return;\n        }\n        for (const instance of Array.from(this._instances)) {\n            instance.stop(options);\n        }\n    }\n}\n//# sourceMappingURL=staticSound.js.map","let StaticSoundBufferId = 1;\n/**\n * Abstract class representing a static sound buffer.\n *\n * A static sound buffer is a fully downloaded and decoded array of audio data that is ready to be played.\n *\n * Static sound buffers can be reused multiple times by different {@link StaticSound} instances.\n *\n * Static sound buffers are created by the {@link CreateSoundBufferAsync} function.\n *\n * @see {@link StaticSound.buffer}\n */\nexport class StaticSoundBuffer {\n    constructor(engine) {\n        /**\n         * The name of the sound buffer.\n         */\n        this.name = `StaticSoundBuffer #${StaticSoundBufferId++}`;\n        this.engine = engine;\n    }\n}\n//# sourceMappingURL=staticSoundBuffer.js.map","import { _AbstractSoundInstance } from \"./abstractSoundInstance.js\";\n/** @internal */\nexport class _StaticSoundInstance extends _AbstractSoundInstance {\n}\n//# sourceMappingURL=staticSoundInstance.js.map","import { StaticSound } from \"../abstractAudio/staticSound.js\";\nimport { StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer.js\";\nimport { _StaticSoundInstance } from \"../abstractAudio/staticSoundInstance.js\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio.js\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio.js\";\nimport { _CleanUrl, _FileExtensionRegex } from \"../audioUtils.js\";\nimport { _WebAudioParameterComponent } from \"./components/webAudioParameterComponent.js\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph.js\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio.js\";\n/** @internal */\nexport class _WebAudioStaticSound extends StaticSound {\n    /** @internal */\n    constructor(name, engine, options) {\n        super(name, engine);\n        this._spatial = null;\n        this._spatialAutoUpdate = true;\n        this._spatialMinUpdateTime = 0;\n        this._stereo = null;\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            duration: options.duration ?? 0,\n            loop: options.loop ?? false,\n            loopEnd: options.loopEnd ?? 0,\n            loopStart: options.loopStart ?? 0,\n            maxInstances: options.maxInstances ?? Infinity,\n            pitch: options.pitch ?? 0,\n            playbackRate: options.playbackRate ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n        this._subGraph = new _WebAudioStaticSound._SubGraph(this);\n    }\n    /** @internal */\n    async _initAsync(source, options) {\n        this._audioContext = this.engine._audioContext;\n        if (source instanceof _WebAudioStaticSoundBuffer) {\n            this._buffer = source;\n        }\n        else if (typeof source === \"string\" || Array.isArray(source) || source instanceof ArrayBuffer || source instanceof AudioBuffer) {\n            this._buffer = (await this.engine.createSoundBufferAsync(source, options));\n        }\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        }\n        else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n        await this._subGraph.initAsync(options);\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n        if (options.autoplay) {\n            this.play();\n        }\n        this.engine._addSound(this);\n    }\n    /** @internal */\n    get buffer() {\n        return this._buffer;\n    }\n    /** @internal */\n    get _inNode() {\n        return this._subGraph._inNode;\n    }\n    /** @internal */\n    get _outNode() {\n        return this._subGraph._outNode;\n    }\n    /** @internal */\n    get spatial() {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n    /** @internal */\n    get stereo() {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n    /** @internal */\n    async cloneAsync(options = null) {\n        const clone = await this.engine.createSoundAsync(this.name, options?.cloneBuffer ? this.buffer.clone() : this.buffer, this._options);\n        clone.outBus = options?.outBus ? options.outBus : this.outBus;\n        return clone;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._spatial?.dispose();\n        this._spatial = null;\n        this._stereo = null;\n        this._subGraph.dispose();\n        this.engine._removeSound(this);\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStaticSound\";\n    }\n    _createInstance() {\n        return new _WebAudioStaticSoundInstance(this, this._options);\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n        return true;\n    }\n    _initSpatialProperty() {\n        if (!this._spatial) {\n            this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);\n        }\n        return this._spatial;\n    }\n}\n_WebAudioStaticSound._SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n    get _downstreamNodes() {\n        return this._owner._downstreamNodes ?? null;\n    }\n    get _upstreamNodes() {\n        return this._owner._upstreamNodes ?? null;\n    }\n};\n/** @internal */\nexport class _WebAudioStaticSoundBuffer extends StaticSoundBuffer {\n    /** @internal */\n    constructor(engine) {\n        super(engine);\n    }\n    async _initAsync(source, options) {\n        if (source instanceof AudioBuffer) {\n            this._audioBuffer = source;\n        }\n        else if (typeof source === \"string\") {\n            await this._initFromUrlAsync(source);\n        }\n        else if (Array.isArray(source)) {\n            await this._initFromUrlsAsync(source, options.skipCodecCheck ?? false);\n        }\n        else if (source instanceof ArrayBuffer) {\n            await this._initFromArrayBufferAsync(source);\n        }\n    }\n    /** @internal */\n    get channelCount() {\n        return this._audioBuffer.numberOfChannels;\n    }\n    /** @internal */\n    get duration() {\n        return this._audioBuffer.duration;\n    }\n    /** @internal */\n    get length() {\n        return this._audioBuffer.length;\n    }\n    /** @internal */\n    get sampleRate() {\n        return this._audioBuffer.sampleRate;\n    }\n    /** @internal */\n    clone(options = null) {\n        const audioBuffer = new AudioBuffer({\n            length: this._audioBuffer.length,\n            numberOfChannels: this._audioBuffer.numberOfChannels,\n            sampleRate: this._audioBuffer.sampleRate,\n        });\n        for (let i = 0; i < this._audioBuffer.numberOfChannels; i++) {\n            audioBuffer.copyToChannel(this._audioBuffer.getChannelData(i), i);\n        }\n        const buffer = new _WebAudioStaticSoundBuffer(this.engine);\n        buffer._audioBuffer = audioBuffer;\n        buffer.name = options?.name ? options.name : this.name;\n        return buffer;\n    }\n    async _initFromArrayBufferAsync(arrayBuffer) {\n        this._audioBuffer = await this.engine._audioContext.decodeAudioData(arrayBuffer);\n    }\n    async _initFromUrlAsync(url) {\n        url = _CleanUrl(url);\n        await this._initFromArrayBufferAsync(await (await fetch(url)).arrayBuffer());\n    }\n    async _initFromUrlsAsync(urls, skipCodecCheck) {\n        for (const url of urls) {\n            if (skipCodecCheck) {\n                // eslint-disable-next-line no-await-in-loop\n                await this._initFromUrlAsync(url);\n            }\n            else {\n                const matches = url.match(_FileExtensionRegex);\n                const format = matches?.at(1);\n                if (format && this.engine.isFormatValid(format)) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        await this._initFromUrlAsync(url);\n                    }\n                    catch {\n                        if (format && 0 < format.length) {\n                            this.engine.flagInvalidFormat(format);\n                        }\n                    }\n                }\n            }\n            if (this._audioBuffer) {\n                break;\n            }\n        }\n    }\n}\n/** @internal */\nclass _WebAudioStaticSoundInstance extends _StaticSoundInstance {\n    constructor(sound, options) {\n        super(sound);\n        this._enginePlayTime = 0;\n        this._enginePauseTime = 0;\n        this._isConnected = false;\n        this._pitch = null;\n        this._playbackRate = null;\n        this._sourceNode = null;\n        this._onEnded = () => {\n            this._enginePlayTime = 0;\n            this.onEndedObservable.notifyObservers(this);\n            this._deinitSourceNode();\n        };\n        this._onEngineStateChanged = () => {\n            if (this.engine.state !== \"running\") {\n                return;\n            }\n            if (this._options.loop && this.state === 2 /* SoundState.Starting */) {\n                this.play();\n            }\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        };\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n        this._initSourceNode();\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._pitch?.dispose();\n        this._playbackRate?.dispose();\n        this._sourceNode = null;\n        this.stop();\n        this._deinitSourceNode();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n    /** @internal */\n    get currentTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        const timeSinceLastStart = this._state === 5 /* SoundState.Paused */ ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n    set currentTime(value) {\n        const restart = this._state === 2 /* SoundState.Starting */ || this._state === 3 /* SoundState.Started */;\n        if (restart) {\n            // Stop source node without sending `onEndedObservable` so instance's `dispose` function is not called.\n            const sourceNode = this._sourceNode;\n            this._deinitSourceNode();\n            sourceNode?.stop();\n            this._state = 1 /* SoundState.Stopped */;\n        }\n        this._options.startOffset = value;\n        if (restart) {\n            this.play();\n        }\n    }\n    get _outNode() {\n        return this._volumeNode;\n    }\n    /** @internal */\n    set pitch(value) {\n        this._pitch?.setTargetValue(value);\n    }\n    /** @internal */\n    set playbackRate(value) {\n        this._playbackRate?.setTargetValue(value);\n    }\n    /** @internal */\n    get startTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        return this._enginePlayTime;\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStaticSoundInstance\";\n    }\n    /** @internal */\n    play(options = {}) {\n        if (this._state === 3 /* SoundState.Started */) {\n            return;\n        }\n        if (options.duration !== undefined) {\n            this._options.duration = options.duration;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        if (options.loopStart !== undefined) {\n            this._options.loopStart = options.loopStart;\n        }\n        if (options.loopEnd !== undefined) {\n            this._options.loopEnd = options.loopEnd;\n        }\n        if (options.startOffset !== undefined) {\n            this._options.startOffset = options.startOffset;\n        }\n        let startOffset = this._options.startOffset;\n        if (this._state === 5 /* SoundState.Paused */) {\n            startOffset += this.currentTime;\n            startOffset %= this._sound.buffer.duration;\n        }\n        this._enginePlayTime = this.engine.currentTime + (options.waitTime ?? 0);\n        this._volumeNode.gain.value = options.volume ?? 1;\n        this._initSourceNode();\n        if (this.engine.state === \"running\") {\n            this._setState(3 /* SoundState.Started */);\n            this._sourceNode?.start(this._enginePlayTime, startOffset, this._options.duration > 0 ? this._options.duration : undefined);\n        }\n        else if (this._options.loop) {\n            this._setState(2 /* SoundState.Starting */);\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n    }\n    /** @internal */\n    pause() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            return;\n        }\n        this._setState(5 /* SoundState.Paused */);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n        this._sourceNode?.stop();\n        this._deinitSourceNode();\n    }\n    /** @internal */\n    resume() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            this.play();\n        }\n    }\n    /** @internal */\n    stop(options = {}) {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return;\n        }\n        const engineStopTime = this.engine.currentTime + (options.waitTime ?? 0);\n        this._sourceNode?.stop(engineStopTime);\n        if (options.waitTime === undefined || options.waitTime <= 0) {\n            this._setState(1 /* SoundState.Stopped */);\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        }\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n            this._isConnected = true;\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n            this._isConnected = false;\n        }\n        return true;\n    }\n    _deinitSourceNode() {\n        if (!this._sourceNode) {\n            return;\n        }\n        if (this._isConnected && !this._disconnect(this._sound)) {\n            throw new Error(\"Disconnect failed\");\n        }\n        this._sourceNode.disconnect(this._volumeNode);\n        this._sourceNode.removeEventListener(\"ended\", this._onEnded);\n        this._sourceNode = null;\n    }\n    _initSourceNode() {\n        if (!this._sourceNode) {\n            this._sourceNode = new AudioBufferSourceNode(this._sound._audioContext, { buffer: this._sound.buffer._audioBuffer });\n            this._sourceNode.addEventListener(\"ended\", this._onEnded, { once: true });\n            this._sourceNode.connect(this._volumeNode);\n            if (!this._connect(this._sound)) {\n                throw new Error(\"Connect failed\");\n            }\n            this._pitch = new _WebAudioParameterComponent(this.engine, this._sourceNode.detune);\n            this._playbackRate = new _WebAudioParameterComponent(this.engine, this._sourceNode.playbackRate);\n        }\n        const node = this._sourceNode;\n        node.detune.value = this._sound.pitch;\n        node.loop = this._options.loop;\n        node.loopEnd = this._options.loopEnd;\n        node.loopStart = this._options.loopStart;\n        node.playbackRate.value = this._sound.playbackRate;\n    }\n}\n//# sourceMappingURL=webAudioStaticSound.js.map"],"names":["StaticSound","AbstractSound","name","engine","value","it","instance","options","StaticSoundBufferId","StaticSoundBuffer","_StaticSoundInstance","_AbstractSoundInstance","_WebAudioStaticSound","source","_WebAudioStaticSoundBuffer","_HasSpatialAudioOptions","_StereoAudio","clone","_WebAudioStaticSoundInstance","node","_SpatialWebAudio","_WebAudioBusAndSoundSubGraph","audioBuffer","i","buffer","arrayBuffer","url","_CleanUrl","urls","skipCodecCheck","format","_FileExtensionRegex","sound","timeSinceLastStart","restart","sourceNode","startOffset","engineStopTime","_WebAudioParameterComponent"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}