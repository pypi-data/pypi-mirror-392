{"version":3,"file":"flowGraphJsonPointerParserBlock-DW3T3HIM.js","sources":["../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/FlowGraph/flowGraphPathConverterComponent.js","../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Transformers/flowGraphJsonPointerParserBlock.js"],"sourcesContent":["import { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger.js\";\nimport { RichTypeFlowGraphInteger } from \"./flowGraphRichTypes.js\";\nconst PathHasTemplatesRegex = new RegExp(/\\/\\{(\\w+)\\}(?=\\/|$)/g);\n/**\n * @experimental\n * A component that converts a path to an object accessor.\n */\nexport class FlowGraphPathConverterComponent {\n    constructor(path, ownerBlock) {\n        this.path = path;\n        this.ownerBlock = ownerBlock;\n        /**\n         * The templated inputs for the provided path.\n         */\n        this.templatedInputs = [];\n        let match = PathHasTemplatesRegex.exec(path);\n        const templateSet = new Set();\n        while (match) {\n            const [, matchGroup] = match;\n            if (templateSet.has(matchGroup)) {\n                throw new Error(\"Duplicate template variable detected.\");\n            }\n            templateSet.add(matchGroup);\n            this.templatedInputs.push(ownerBlock.registerDataInput(matchGroup, RichTypeFlowGraphInteger, new FlowGraphInteger(0)));\n            match = PathHasTemplatesRegex.exec(path);\n        }\n    }\n    /**\n     * Get the accessor for the path.\n     * @param pathConverter the path converter to use to convert the path to an object accessor.\n     * @param context the context to use.\n     * @returns the accessor for the path.\n     * @throws if the value for a templated input is invalid.\n     */\n    getAccessor(pathConverter, context) {\n        let finalPath = this.path;\n        for (const templatedInput of this.templatedInputs) {\n            const valueToReplace = templatedInput.getValue(context).value;\n            if (typeof valueToReplace !== \"number\" || valueToReplace < 0) {\n                throw new Error(\"Invalid value for templated input.\");\n            }\n            finalPath = finalPath.replace(`{${templatedInput.name}}`, valueToReplace.toString());\n        }\n        return pathConverter.convert(finalPath);\n    }\n}\n//# sourceMappingURL=flowGraphPathConverterComponent.js.map","import { FlowGraphPathConverterComponent } from \"../../../flowGraphPathConverterComponent.js\";\nimport { RichTypeAny } from \"../../../flowGraphRichTypes.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Vector3, Vector4 } from \"../../../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../../../Maths/math.color.js\";\nimport { FlowGraphCachedOperationBlock } from \"../flowGraphCachedOperationBlock.js\";\n/**\n * This block will take a JSON pointer and parse it to get the value from the JSON object.\n * The output is an object and a property name.\n * Optionally, the block can also output the value of the property. This is configurable.\n */\nexport class FlowGraphJsonPointerParserBlock extends FlowGraphCachedOperationBlock {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        super(RichTypeAny, config);\n        this.config = config;\n        this.object = this.registerDataOutput(\"object\", RichTypeAny);\n        this.propertyName = this.registerDataOutput(\"propertyName\", RichTypeAny);\n        this.setterFunction = this.registerDataOutput(\"setFunction\", RichTypeAny, this._setPropertyValue.bind(this));\n        this.getterFunction = this.registerDataOutput(\"getFunction\", RichTypeAny, this._getPropertyValue.bind(this));\n        this.generateAnimationsFunction = this.registerDataOutput(\"generateAnimationsFunction\", RichTypeAny, this._getInterpolationAnimationPropertyInfo.bind(this));\n        this.templateComponent = new FlowGraphPathConverterComponent(config.jsonPointer, this);\n    }\n    _doOperation(context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const value = accessorContainer.info.get(accessorContainer.object);\n        const object = accessorContainer.info.getTarget?.(accessorContainer.object);\n        const propertyName = accessorContainer.info.getPropertyName?.[0](accessorContainer.object);\n        if (!object) {\n            throw new Error(\"Object is undefined\");\n        }\n        else {\n            this.object.setValue(object, context);\n            if (propertyName) {\n                this.propertyName.setValue(propertyName, context);\n            }\n        }\n        return value;\n    }\n    _setPropertyValue(_target, _propertyName, value, context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        if (type.startsWith(\"Color\")) {\n            value = ToColor(value, type);\n        }\n        accessorContainer.info.set?.(value, accessorContainer.object);\n    }\n    _getPropertyValue(_target, _propertyName, context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        const value = accessorContainer.info.get(accessorContainer.object);\n        if (type.startsWith(\"Color\")) {\n            return FromColor(value);\n        }\n        return value;\n    }\n    _getInterpolationAnimationPropertyInfo(_target, _propertyName, context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        return (keys, fps, animationType, easingFunction) => {\n            const animations = [];\n            // make sure keys are of the right type (in case of float3 color/vector)\n            const type = accessorContainer.info.type;\n            if (type.startsWith(\"Color\")) {\n                keys = keys.map((key) => {\n                    return {\n                        frame: key.frame,\n                        value: ToColor(key.value, type),\n                    };\n                });\n            }\n            accessorContainer.info.interpolation?.forEach((info, index) => {\n                const name = accessorContainer.info.getPropertyName?.[index](accessorContainer.object) || \"Animation-interpolation-\" + index;\n                // generate the keys based on interpolation info\n                let newKeys = keys;\n                if (animationType !== info.type) {\n                    // convert the keys to the right type\n                    newKeys = keys.map((key) => {\n                        return {\n                            frame: key.frame,\n                            value: info.getValue(undefined, key.value.asArray ? key.value.asArray() : [key.value], 0, 1),\n                        };\n                    });\n                }\n                const animationData = info.buildAnimations(accessorContainer.object, name, 60, newKeys);\n                for (const animation of animationData) {\n                    if (easingFunction) {\n                        animation.babylonAnimation.setEasingFunction(easingFunction);\n                    }\n                    animations.push(animation.babylonAnimation);\n                }\n            });\n            return animations;\n        };\n    }\n    /**\n     * Gets the class name of this block\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FlowGraphJsonPointerParserBlock\" /* FlowGraphBlockNames.JsonPointerParser */;\n    }\n}\nfunction ToColor(value, expectedValue) {\n    if (value.getClassName().startsWith(\"Color\")) {\n        return value;\n    }\n    if (expectedValue === \"Color3\") {\n        return new Color3(value.x, value.y, value.z);\n    }\n    else if (expectedValue === \"Color4\") {\n        return new Color4(value.x, value.y, value.z, value.w);\n    }\n    return value;\n}\nfunction FromColor(value) {\n    if (value instanceof Color3) {\n        return new Vector3(value.r, value.g, value.b);\n    }\n    else if (value instanceof Color4) {\n        return new Vector4(value.r, value.g, value.b, value.a);\n    }\n    throw new Error(\"Invalid color type\");\n}\nRegisterClass(\"FlowGraphJsonPointerParserBlock\" /* FlowGraphBlockNames.JsonPointerParser */, FlowGraphJsonPointerParserBlock);\n//# sourceMappingURL=flowGraphJsonPointerParserBlock.js.map"],"names":["PathHasTemplatesRegex","FlowGraphPathConverterComponent","path","ownerBlock","match","templateSet","matchGroup","RichTypeFlowGraphInteger","FlowGraphInteger","pathConverter","context","finalPath","templatedInput","valueToReplace","FlowGraphJsonPointerParserBlock","FlowGraphCachedOperationBlock","config","RichTypeAny","accessorContainer","value","object","propertyName","_target","_propertyName","type","ToColor","FromColor","keys","fps","animationType","easingFunction","animations","key","info","index","name","newKeys","animationData","animation","expectedValue","Color3","Color4","Vector3","Vector4","RegisterClass"],"mappings":"qTAEA,MAAMA,EAAwB,IAAI,OAAO,sBAAsB,EAKxD,MAAMC,CAAgC,CACzC,YAAYC,EAAMC,EAAY,CAC1B,KAAK,KAAOD,EACZ,KAAK,WAAaC,EAIlB,KAAK,gBAAkB,CAAA,EACvB,IAAIC,EAAQJ,EAAsB,KAAKE,CAAI,EAC3C,MAAMG,EAAc,IAAI,IACxB,KAAOD,GAAO,CACV,KAAM,CAAA,CAAGE,CAAU,EAAIF,EACvB,GAAIC,EAAY,IAAIC,CAAU,EAC1B,MAAM,IAAI,MAAM,uCAAuC,EAE3DD,EAAY,IAAIC,CAAU,EAC1B,KAAK,gBAAgB,KAAKH,EAAW,kBAAkBG,EAAYC,EAA0B,IAAIC,EAAiB,CAAC,CAAC,CAAC,EACrHJ,EAAQJ,EAAsB,KAAKE,CAAI,CAC3C,CACJ,CAQA,YAAYO,EAAeC,EAAS,CAChC,IAAIC,EAAY,KAAK,KACrB,UAAWC,KAAkB,KAAK,gBAAiB,CAC/C,MAAMC,EAAiBD,EAAe,SAASF,CAAO,EAAE,MACxD,GAAI,OAAOG,GAAmB,UAAYA,EAAiB,EACvD,MAAM,IAAI,MAAM,oCAAoC,EAExDF,EAAYA,EAAU,QAAQ,IAAIC,EAAe,IAAI,IAAKC,EAAe,UAAU,CACvF,CACA,OAAOJ,EAAc,QAAQE,CAAS,CAC1C,CACJ,CClCO,MAAMG,UAAwCC,CAA8B,CAC/E,YAIAC,EAAQ,CACJ,MAAMC,EAAaD,CAAM,EACzB,KAAK,OAASA,EACd,KAAK,OAAS,KAAK,mBAAmB,SAAUC,CAAW,EAC3D,KAAK,aAAe,KAAK,mBAAmB,eAAgBA,CAAW,EACvE,KAAK,eAAiB,KAAK,mBAAmB,cAAeA,EAAa,KAAK,kBAAkB,KAAK,IAAI,CAAC,EAC3G,KAAK,eAAiB,KAAK,mBAAmB,cAAeA,EAAa,KAAK,kBAAkB,KAAK,IAAI,CAAC,EAC3G,KAAK,2BAA6B,KAAK,mBAAmB,6BAA8BA,EAAa,KAAK,uCAAuC,KAAK,IAAI,CAAC,EAC3J,KAAK,kBAAoB,IAAIhB,EAAgCe,EAAO,YAAa,IAAI,CACzF,CACA,aAAaN,EAAS,CAClB,MAAMQ,EAAoB,KAAK,kBAAkB,YAAY,KAAK,OAAO,cAAeR,CAAO,EACzFS,EAAQD,EAAkB,KAAK,IAAIA,EAAkB,MAAM,EAC3DE,EAASF,EAAkB,KAAK,YAAYA,EAAkB,MAAM,EACpEG,EAAeH,EAAkB,KAAK,kBAAkB,CAAC,EAAEA,EAAkB,MAAM,EACzF,GAAKE,EAID,KAAK,OAAO,SAASA,EAAQV,CAAO,EAChCW,GACA,KAAK,aAAa,SAASA,EAAcX,CAAO,MALpD,OAAM,IAAI,MAAM,qBAAqB,EAQzC,OAAOS,CACX,CACA,kBAAkBG,EAASC,EAAeJ,EAAOT,EAAS,CACtD,MAAMQ,EAAoB,KAAK,kBAAkB,YAAY,KAAK,OAAO,cAAeR,CAAO,EACzFc,EAAON,EAAkB,KAAK,KAChCM,EAAK,WAAW,OAAO,IACvBL,EAAQM,EAAQN,EAAOK,CAAI,GAE/BN,EAAkB,KAAK,MAAMC,EAAOD,EAAkB,MAAM,CAChE,CACA,kBAAkBI,EAASC,EAAeb,EAAS,CAC/C,MAAMQ,EAAoB,KAAK,kBAAkB,YAAY,KAAK,OAAO,cAAeR,CAAO,EACzFc,EAAON,EAAkB,KAAK,KAC9BC,EAAQD,EAAkB,KAAK,IAAIA,EAAkB,MAAM,EACjE,OAAIM,EAAK,WAAW,OAAO,EAChBE,EAAUP,CAAK,EAEnBA,CACX,CACA,uCAAuCG,EAASC,EAAeb,EAAS,CACpE,MAAMQ,EAAoB,KAAK,kBAAkB,YAAY,KAAK,OAAO,cAAeR,CAAO,EAC/F,MAAO,CAACiB,EAAMC,EAAKC,EAAeC,IAAmB,CACjD,MAAMC,EAAa,CAAA,EAEbP,EAAON,EAAkB,KAAK,KACpC,OAAIM,EAAK,WAAW,OAAO,IACvBG,EAAOA,EAAK,IAAKK,IACN,CACH,MAAOA,EAAI,MACX,MAAOP,EAAQO,EAAI,MAAOR,CAAI,CACtD,EACiB,GAELN,EAAkB,KAAK,eAAe,QAAQ,CAACe,EAAMC,IAAU,CAC3D,MAAMC,EAAOjB,EAAkB,KAAK,kBAAkBgB,CAAK,EAAEhB,EAAkB,MAAM,GAAK,2BAA6BgB,EAEvH,IAAIE,EAAUT,EACVE,IAAkBI,EAAK,OAEvBG,EAAUT,EAAK,IAAKK,IACT,CACH,MAAOA,EAAI,MACX,MAAOC,EAAK,SAAS,OAAWD,EAAI,MAAM,QAAUA,EAAI,MAAM,QAAO,EAAK,CAACA,EAAI,KAAK,EAAG,EAAG,CAAC,CACvH,EACqB,GAEL,MAAMK,EAAgBJ,EAAK,gBAAgBf,EAAkB,OAAQiB,EAAM,GAAIC,CAAO,EACtF,UAAWE,KAAaD,EAChBP,GACAQ,EAAU,iBAAiB,kBAAkBR,CAAc,EAE/DC,EAAW,KAAKO,EAAU,gBAAgB,CAElD,CAAC,EACMP,CACX,CACJ,CAKA,cAAe,CACX,MAAO,iCACX,CACJ,CACA,SAASN,EAAQN,EAAOoB,EAAe,CACnC,OAAIpB,EAAM,aAAY,EAAG,WAAW,OAAO,EAChCA,EAEPoB,IAAkB,SACX,IAAIC,EAAOrB,EAAM,EAAGA,EAAM,EAAGA,EAAM,CAAC,EAEtCoB,IAAkB,SAChB,IAAIE,EAAOtB,EAAM,EAAGA,EAAM,EAAGA,EAAM,EAAGA,EAAM,CAAC,EAEjDA,CACX,CACA,SAASO,EAAUP,EAAO,CACtB,GAAIA,aAAiBqB,EACjB,OAAO,IAAIE,EAAQvB,EAAM,EAAGA,EAAM,EAAGA,EAAM,CAAC,EAE3C,GAAIA,aAAiBsB,EACtB,OAAO,IAAIE,EAAQxB,EAAM,EAAGA,EAAM,EAAGA,EAAM,EAAGA,EAAM,CAAC,EAEzD,MAAM,IAAI,MAAM,oBAAoB,CACxC,CACAyB,EAAc,kCAA+E9B,CAA+B","x_google_ignoreList":[0,1]}