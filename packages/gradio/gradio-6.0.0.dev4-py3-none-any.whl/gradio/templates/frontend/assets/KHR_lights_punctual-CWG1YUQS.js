import{be as y,aP as m,V as n,M as L,aw as w,_ as b,s as A,R as v,bf as P,F as g,aN as C,aO as S}from"./index-CKSmRzt-.js";import{a as T}from"./objectModelMapping-CFlMfOyz.js";import{ArrayItem as _,GLTFLoader as p}from"./glTFLoader-Dm3LessQ.js";import"./index-bhUlIv2p.js";import"./bone-DKMuB1dq.js";import"./skeleton-BfCPY60z.js";import"./rawTexture-DOa77KPU.js";import"./assetContainer-BOrw4ub9.js";w.AddNodeConstructor("Light_Type_0",(l,e)=>()=>new c(l,n.Zero(),e));class c extends y{get shadowAngle(){return this._shadowAngle}set shadowAngle(e){this._shadowAngle=e,this.forceProjectionMatrixCompute()}get direction(){return this._direction}set direction(e){const i=this.needCube();if(this._direction=e,this.needCube()!==i&&this._shadowGenerators){const t=this._shadowGenerators.values();for(let r=t.next();r.done!==!0;r=t.next())r.value.recreateShadowMap()}}constructor(e,i,t){super(e,t),this._shadowAngle=Math.PI/2,this.position=i}getClassName(){return"PointLight"}getTypeID(){return m.LIGHTTYPEID_POINTLIGHT}needCube(){return!this.direction}getShadowDirection(e){if(this.direction)return super.getShadowDirection(e);switch(e){case 0:return new n(1,0,0);case 1:return new n(-1,0,0);case 2:return new n(0,-1,0);case 3:return new n(0,1,0);case 4:return new n(0,0,1);case 5:return new n(0,0,-1)}return n.Zero()}_setDefaultShadowProjectionMatrix(e,i,t){const r=this.getScene().activeCamera,d=this.getDepthMinZ(r),a=this.getDepthMaxZ(r),s=this.getScene().getEngine().useReverseDepthBuffer;L.PerspectiveFovLHToRef(this.shadowAngle,1,s?a:d,s?d:a,e,!0,this._scene.getEngine().isNDCHalfZRange,void 0,s)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(e,i){const t=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x-t.x,this.transformedPosition.y-t.y,this.transformedPosition.z-t.z,0,i):this._uniformBuffer.updateFloat4("vLightData",this.position.x-t.x,this.position.y-t.y,this.position.z-t.z,0,i),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,0,0,i),this}transferToNodeMaterialEffect(e,i){const t=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?e.setFloat3(i,this.transformedPosition.x-t.x,this.transformedPosition.y-t.y,this.transformedPosition.z-t.z):e.setFloat3(i,this.position.x-t.x,this.position.y-t.y,this.position.z-t.z),this}prepareLightSpecificDefines(e,i){e["POINTLIGHT"+i]=!0}}b([A()],c.prototype,"shadowAngle",null);v("BABYLON.PointLight",c);const f="KHR_lights_punctual";class x{constructor(e){this.name=f,this._loader=e,this.enabled=this._loader.isExtensionUsed(f)}dispose(){this._loader=null,delete this._lights}onLoading(){const e=this._loader.gltf.extensions;if(e&&e[this.name]){const i=e[this.name];this._lights=i.lights,_.Assign(this._lights)}}loadNodeAsync(e,i,t){return p.LoadExtensionAsync(e,i,this.name,async(r,d)=>(this._loader._allMaterialsDirtyRequired=!0,await this._loader.loadNodeAsync(e,i,a=>{let s;const o=_.Get(r,this._lights,d.light),u=o.name||a.name;switch(this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer,o.type){case"directional":{const h=new P(u,n.Backward(),this._loader.babylonScene);h.position.setAll(0),s=h;break}case"point":{s=new c(u,n.Zero(),this._loader.babylonScene);break}case"spot":{const h=new T(u,n.Zero(),n.Backward(),0,1,this._loader.babylonScene);h.angle=(o.spot&&o.spot.outerConeAngle||Math.PI/4)*2,h.innerAngle=(o.spot&&o.spot.innerConeAngle||0)*2,s=h;break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${r}: Invalid light type (${o.type})`)}s._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,o._babylonLight=s,s.falloffType=m.FALLOFF_GLTF,s.diffuse=o.color?g.FromArray(o.color):g.White(),s.intensity=o.intensity==null?1:o.intensity,s.range=o.range==null?Number.MAX_VALUE:o.range,s.parent=a,this._loader._babylonLights.push(s),p.AddPointerMetadata(s,r),t(a)})))}}C(f);S(f,!0,l=>new x(l));export{x as KHR_lights};
//# sourceMappingURL=KHR_lights_punctual-CWG1YUQS.js.map
