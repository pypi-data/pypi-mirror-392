{"version":3,"file":"engine.multiRender-DD86bNjV.js","sources":["../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.multiRender.js"],"sourcesContent":["import { InternalTexture } from \"../../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\n\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n    if (onBeforeUnbind) {\n        onBeforeUnbind();\n    }\n    this._endCurrentRenderPass();\n    if (!disableGenerateMipMaps) {\n        this.generateMipMapsMultiFramebuffer(rtWrapper);\n    }\n    this._currentRenderTarget = null;\n    this._mrtAttachments = [];\n    this._cacheRenderPipeline.setMRT([]);\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n};\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers) {\n    let generateMipMaps = false;\n    let generateDepthBuffer = true;\n    let generateStencilBuffer = false;\n    let generateDepthTexture = false;\n    let depthTextureFormat = 15;\n    let textureCount = 1;\n    let samples = 1;\n    const defaultType = 0;\n    const defaultSamplingMode = 3;\n    const defaultUseSRGBBuffer = false;\n    const defaultFormat = 5;\n    const defaultTarget = 3553;\n    let types = [];\n    let samplingModes = [];\n    let useSRGBBuffers = [];\n    let formats = [];\n    let targets = [];\n    let faceIndex = [];\n    let layerIndex = [];\n    let layers = [];\n    let labels = [];\n    let creationFlags = [];\n    let dontCreateTextures = false;\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n    if (options !== undefined) {\n        generateMipMaps = options.generateMipMaps ?? false;\n        generateDepthBuffer = options.generateDepthBuffer ?? true;\n        generateStencilBuffer = options.generateStencilBuffer ?? false;\n        generateDepthTexture = options.generateDepthTexture ?? false;\n        textureCount = options.textureCount ?? 1;\n        depthTextureFormat = options.depthTextureFormat ?? 15;\n        types = options.types || types;\n        samplingModes = options.samplingModes || samplingModes;\n        useSRGBBuffers = options.useSRGBBuffers || useSRGBBuffers;\n        formats = options.formats || formats;\n        targets = options.targetTypes || targets;\n        faceIndex = options.faceIndex || faceIndex;\n        layerIndex = options.layerIndex || layerIndex;\n        layers = options.layerCounts || layers;\n        labels = options.labels || labels;\n        creationFlags = options.creationFlags || creationFlags;\n        samples = options.samples ?? samples;\n        dontCreateTextures = options.dontCreateTextures ?? false;\n    }\n    const width = size.width ?? size;\n    const height = size.height ?? size;\n    const textures = [];\n    const attachments = [];\n    const defaultAttachments = [];\n    rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\n    rtWrapper._attachments = attachments;\n    rtWrapper._defaultAttachments = defaultAttachments;\n    let depthStencilTexture = null;\n    if ((generateDepthBuffer || generateStencilBuffer || generateDepthTexture) && !dontCreateTextures) {\n        if (!generateDepthTexture) {\n            // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\n            // So, we will align with what the WebGL engine does\n            if (generateDepthBuffer && generateStencilBuffer) {\n                depthTextureFormat = 13;\n            }\n            else if (generateDepthBuffer) {\n                depthTextureFormat = 14;\n            }\n            else {\n                depthTextureFormat = 19;\n            }\n        }\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat, rtWrapper.label + \"-DepthStencil\");\n    }\n    const mipmapsCreationOnly = options !== undefined && typeof options === \"object\" && options.createMipMaps && !generateMipMaps;\n    for (let i = 0; i < textureCount; i++) {\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\n        let type = types[i] || defaultType;\n        const format = formats[i] || defaultFormat;\n        const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\n        const target = targets[i] || defaultTarget;\n        const layerCount = layers[i] ?? 1;\n        const creationFlag = creationFlags[i];\n        if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n            // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\n            samplingMode = 1;\n        }\n        else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n            samplingMode = 1;\n        }\n        if (type === 1 && !this._caps.textureFloat) {\n            type = 0;\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n        }\n        attachments.push(i + 1);\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\n        if (target === -1 || dontCreateTextures) {\n            continue;\n        }\n        const texture = new InternalTexture(this, 6 /* InternalTextureSource.MultiRenderTarget */);\n        textures[i] = texture;\n        switch (target) {\n            case 34067:\n                texture.isCube = true;\n                break;\n            case 32879:\n                texture.is3D = true;\n                texture.baseDepth = texture.depth = layerCount;\n                break;\n            case 35866:\n                texture.is2DArray = true;\n                texture.baseDepth = texture.depth = layerCount;\n                break;\n        }\n        texture.baseWidth = width;\n        texture.baseHeight = height;\n        texture.width = width;\n        texture.height = height;\n        texture.isReady = true;\n        texture.samples = 1;\n        texture.generateMipMaps = generateMipMaps;\n        texture.samplingMode = samplingMode;\n        texture.type = type;\n        texture._cachedWrapU = 0;\n        texture._cachedWrapV = 0;\n        texture._useSRGBBuffer = useSRGBBuffer;\n        texture.format = format;\n        texture.label = labels[i] ?? rtWrapper.label + \"-Texture\" + i;\n        this._internalTexturesCache.push(texture);\n        if (mipmapsCreationOnly) {\n            // createGPUTextureForInternalTexture will only create a texture with mipmaps if generateMipMaps is true, as InternalTexture has no createMipMaps property, separate from generateMipMaps.\n            texture.generateMipMaps = true;\n        }\n        this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, creationFlag, true);\n        if (mipmapsCreationOnly) {\n            texture.generateMipMaps = false;\n        }\n    }\n    if (depthStencilTexture) {\n        depthStencilTexture.incrementReferences();\n        textures[textureCount] = depthStencilTexture;\n        this._internalTexturesCache.push(depthStencilTexture);\n    }\n    rtWrapper.setTextures(textures);\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\n    if (!dontCreateTextures) {\n        this.updateMultipleRenderTargetTextureSampleCount(rtWrapper, samples);\n    }\n    else {\n        rtWrapper._samples = samples;\n    }\n    return rtWrapper;\n};\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures.length === 0 || rtWrapper.textures[0].samples === samples) {\n        return samples;\n    }\n    const count = rtWrapper.textures.length;\n    if (count === 0) {\n        return 1;\n    }\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\n    for (let i = 0; i < count; ++i) {\n        const texture = rtWrapper.textures[i];\n        const gpuTextureWrapper = texture._hardwareTexture;\n        gpuTextureWrapper?.releaseMSAATexture(rtWrapper.getBaseArrayLayer(i));\n    }\n    // Note that rtWrapper.textures can't have null textures, lastTextureIsDepthTexture can't be true if rtWrapper._depthStencilTexture is null\n    const lastTextureIsDepthTexture = rtWrapper._depthStencilTexture === rtWrapper.textures[count - 1];\n    for (let i = 0; i < count; ++i) {\n        const texture = rtWrapper.textures[i];\n        this._textureHelper.createMSAATexture(texture, samples, false, rtWrapper.getBaseArrayLayer(i));\n        texture.samples = samples;\n    }\n    // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\n    // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\n    // because rtWrapper._depthStencilTexture is the same texture than the depth texture\n    if (rtWrapper._depthStencilTexture && !lastTextureIsDepthTexture) {\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\n        rtWrapper._depthStencilTexture.samples = samples;\n    }\n    rtWrapper._samples = samples;\n    return samples;\n};\nWebGPUEngine.prototype.generateMipMapsMultiFramebuffer = function (texture) {\n    const rtWrapper = texture;\n    if (!rtWrapper.isMulti) {\n        return;\n    }\n    const attachments = rtWrapper._attachments;\n    const count = attachments.length;\n    for (let i = 0; i < count; i++) {\n        const texture = rtWrapper.textures[i];\n        if (texture.generateMipMaps && !texture.isCube && !texture.is3D) {\n            this._generateMipmaps(texture);\n        }\n    }\n};\nWebGPUEngine.prototype.resolveMultiFramebuffer = function (_texture) {\n    throw new Error(\"resolveMultiFramebuffer is not yet implemented in WebGPU!\");\n};\nWebGPUEngine.prototype.bindAttachments = function (attachments) {\n    if (attachments.length === 0 || !this._currentRenderTarget) {\n        return;\n    }\n    this._mrtAttachments = attachments;\n    if (this._currentRenderPass) {\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\n    }\n    else {\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\n    }\n};\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus, backBufferLayout = false) {\n    const result = [];\n    if (backBufferLayout) {\n        result.push(1);\n    }\n    else {\n        for (let i = 0; i < textureStatus.length; i++) {\n            if (textureStatus[i]) {\n                result.push(i + 1);\n            }\n            else {\n                result.push(0);\n            }\n        }\n    }\n    return result;\n};\nWebGPUEngine.prototype.restoreSingleAttachment = function () {\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\n};\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\n};\n//# sourceMappingURL=engine.multiRender.js.map"],"names":["WebGPUEngine","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","size","options","initializeBuffers","generateMipMaps","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","textureCount","samples","defaultType","defaultSamplingMode","defaultUseSRGBBuffer","defaultFormat","defaultTarget","types","samplingModes","useSRGBBuffers","formats","targets","faceIndex","layerIndex","layers","labels","creationFlags","dontCreateTextures","width","height","textures","attachments","defaultAttachments","depthStencilTexture","mipmapsCreationOnly","i","samplingMode","type","format","useSRGBBuffer","target","layerCount","creationFlag","Logger","texture","InternalTexture","count","lastTextureIsDepthTexture","_texture","textureStatus","backBufferLayout","result"],"mappings":"gcAIAA,EAAa,UAAU,sCAAwC,SAAUC,EAAWC,EAAyB,GAAOC,EAAgB,CAC5HA,GACAA,EAAc,EAElB,KAAK,sBAAqB,EACrBD,GACD,KAAK,gCAAgCD,CAAS,EAElD,KAAK,qBAAuB,KAC5B,KAAK,gBAAkB,CAAA,EACvB,KAAK,qBAAqB,OAAO,EAAE,EACnC,KAAK,qBAAqB,kBAAkB,KAAK,eAAe,CACpE,EACAD,EAAa,UAAU,2BAA6B,SAAUI,EAAMC,EAASC,EAAmB,CAC5F,IAAIC,EAAkB,GAClBC,EAAsB,GACtBC,EAAwB,GACxBC,EAAuB,GACvBC,EAAqB,GACrBC,EAAe,EACfC,EAAU,EACd,MAAMC,EAAc,EACdC,EAAsB,EACtBC,EAAuB,GACvBC,EAAgB,EAChBC,EAAgB,KACtB,IAAIC,EAAQ,CAAA,EACRC,EAAgB,CAAA,EAChBC,EAAiB,CAAA,EACjBC,EAAU,CAAA,EACVC,EAAU,CAAA,EACVC,EAAY,CAAA,EACZC,EAAa,CAAA,EACbC,EAAS,CAAA,EACTC,EAAS,CAAA,EACTC,EAAgB,CAAA,EAChBC,EAAqB,GACzB,MAAM5B,EAAY,KAAK,mCAAmC,GAAM,GAAOG,CAAI,EACvEC,IAAY,SACZE,EAAkBF,EAAQ,iBAAmB,GAC7CG,EAAsBH,EAAQ,qBAAuB,GACrDI,EAAwBJ,EAAQ,uBAAyB,GACzDK,EAAuBL,EAAQ,sBAAwB,GACvDO,EAAeP,EAAQ,cAAgB,EACvCM,EAAqBN,EAAQ,oBAAsB,GACnDc,EAAQd,EAAQ,OAASc,EACzBC,EAAgBf,EAAQ,eAAiBe,EACzCC,EAAiBhB,EAAQ,gBAAkBgB,EAC3CC,EAAUjB,EAAQ,SAAWiB,EAC7BC,EAAUlB,EAAQ,aAAekB,EACjCC,EAAYnB,EAAQ,WAAamB,EACjCC,EAAapB,EAAQ,YAAcoB,EACnCC,EAASrB,EAAQ,aAAeqB,EAChCC,EAAStB,EAAQ,QAAUsB,EAC3BC,EAAgBvB,EAAQ,eAAiBuB,EACzCf,EAAUR,EAAQ,SAAWQ,EAC7BgB,EAAqBxB,EAAQ,oBAAsB,IAEvD,MAAMyB,EAAQ1B,EAAK,OAASA,EACtB2B,EAAS3B,EAAK,QAAUA,EACxB4B,EAAW,CAAA,EACXC,EAAc,CAAA,EACdC,EAAqB,CAAA,EAC3BjC,EAAU,MAAQI,GAAS,OAAS,2BACpCJ,EAAU,qBAAuBO,EACjCP,EAAU,uBAAyBQ,EACnCR,EAAU,aAAegC,EACzBhC,EAAU,oBAAsBiC,EAChC,IAAIC,EAAsB,MACrB3B,GAAuBC,GAAyBC,IAAyB,CAACmB,IACtEnB,IAGGF,GAAuBC,EACvBE,EAAqB,GAEhBH,EACLG,EAAqB,GAGrBA,EAAqB,IAG7BwB,EAAsBlC,EAAU,0BAA0B,EAAG,GAAOQ,EAAuB,EAAGE,EAAoBV,EAAU,MAAQ,eAAe,GAEvJ,MAAMmC,EAAsB/B,IAAY,QAAa,OAAOA,GAAY,UAAYA,EAAQ,eAAiB,CAACE,EAC9G,QAAS8B,EAAI,EAAGA,EAAIzB,EAAcyB,IAAK,CACnC,IAAIC,EAAelB,EAAciB,CAAC,GAAKtB,EACnCwB,EAAOpB,EAAMkB,CAAC,GAAKvB,EACvB,MAAM0B,EAASlB,EAAQe,CAAC,GAAKpB,EACvBwB,GAAiBpB,EAAegB,CAAC,GAAKrB,IAAyB,KAAK,MAAM,mBAC1E0B,EAASnB,EAAQc,CAAC,GAAKnB,EACvByB,EAAajB,EAAOW,CAAC,GAAK,EAC1BO,EAAehB,EAAcS,CAAC,EAepC,IAdIE,IAAS,GAAK,CAAC,KAAK,MAAM,6BAIrBA,IAAS,GAAK,CAAC,KAAK,MAAM,mCAE/BD,EAAe,GAEfC,IAAS,GAAK,CAAC,KAAK,MAAM,eAC1BA,EAAO,EACPM,EAAO,KAAK,0FAA0F,GAE1GZ,EAAY,KAAKI,EAAI,CAAC,EACtBH,EAAmB,KAAK5B,EAAoB+B,EAAI,EAAIA,IAAM,EAAI,EAAI,CAAC,EAC/DK,IAAW,IAAMb,EACjB,SAEJ,MAAMiB,EAAU,IAAIC,EAAgB,KAAM,CAAC,EAE3C,OADAf,EAASK,CAAC,EAAIS,EACNJ,EAAM,CACV,IAAK,OACDI,EAAQ,OAAS,GACjB,MACJ,IAAK,OACDA,EAAQ,KAAO,GACfA,EAAQ,UAAYA,EAAQ,MAAQH,EACpC,MACJ,IAAK,OACDG,EAAQ,UAAY,GACpBA,EAAQ,UAAYA,EAAQ,MAAQH,EACpC,KAChB,CACQG,EAAQ,UAAYhB,EACpBgB,EAAQ,WAAaf,EACrBe,EAAQ,MAAQhB,EAChBgB,EAAQ,OAASf,EACjBe,EAAQ,QAAU,GAClBA,EAAQ,QAAU,EAClBA,EAAQ,gBAAkBvC,EAC1BuC,EAAQ,aAAeR,EACvBQ,EAAQ,KAAOP,EACfO,EAAQ,aAAe,EACvBA,EAAQ,aAAe,EACvBA,EAAQ,eAAiBL,EACzBK,EAAQ,OAASN,EACjBM,EAAQ,MAAQnB,EAAOU,CAAC,GAAKpC,EAAU,MAAQ,WAAaoC,EAC5D,KAAK,uBAAuB,KAAKS,CAAO,EACpCV,IAEAU,EAAQ,gBAAkB,IAE9B,KAAK,eAAe,mCAAmCA,EAAS,OAAW,OAAW,OAAWF,EAAc,EAAI,EAC/GR,IACAU,EAAQ,gBAAkB,GAElC,CACA,OAAIX,IACAA,EAAoB,oBAAmB,EACvCH,EAASpB,CAAY,EAAIuB,EACzB,KAAK,uBAAuB,KAAKA,CAAmB,GAExDlC,EAAU,YAAY+B,CAAQ,EAC9B/B,EAAU,uBAAuBwB,EAAYD,CAAS,EACjDK,EAID5B,EAAU,SAAWY,EAHrB,KAAK,6CAA6CZ,EAAWY,CAAO,EAKjEZ,CACX,EACAD,EAAa,UAAU,6CAA+C,SAAUC,EAAWY,EAAS,CAChG,GAAI,CAACZ,GAAa,CAACA,EAAU,UAAYA,EAAU,SAAS,SAAW,GAAKA,EAAU,SAAS,CAAC,EAAE,UAAYY,EAC1G,OAAOA,EAEX,MAAMmC,EAAQ/C,EAAU,SAAS,OACjC,GAAI+C,IAAU,EACV,MAAO,GAEXnC,EAAU,KAAK,IAAIA,EAAS,KAAK,QAAO,EAAG,cAAc,EACzD,QAASwB,EAAI,EAAGA,EAAIW,EAAO,EAAEX,EACTpC,EAAU,SAASoC,CAAC,EACF,kBACf,mBAAmBpC,EAAU,kBAAkBoC,CAAC,CAAC,EAGxE,MAAMY,EAA4BhD,EAAU,uBAAyBA,EAAU,SAAS+C,EAAQ,CAAC,EACjG,QAASX,EAAI,EAAGA,EAAIW,EAAO,EAAEX,EAAG,CAC5B,MAAMS,EAAU7C,EAAU,SAASoC,CAAC,EACpC,KAAK,eAAe,kBAAkBS,EAASjC,EAAS,GAAOZ,EAAU,kBAAkBoC,CAAC,CAAC,EAC7FS,EAAQ,QAAUjC,CACtB,CAIA,OAAIZ,EAAU,sBAAwB,CAACgD,IACnC,KAAK,eAAe,kBAAkBhD,EAAU,qBAAsBY,CAAO,EAC7EZ,EAAU,qBAAqB,QAAUY,GAE7CZ,EAAU,SAAWY,EACdA,CACX,EACAb,EAAa,UAAU,gCAAkC,SAAU8C,EAAS,CACxE,MAAM7C,EAAY6C,EAClB,GAAI,CAAC7C,EAAU,QACX,OAGJ,MAAM+C,EADc/C,EAAU,aACJ,OAC1B,QAASoC,EAAI,EAAGA,EAAIW,EAAOX,IAAK,CAC5B,MAAMS,EAAU7C,EAAU,SAASoC,CAAC,EAChCS,EAAQ,iBAAmB,CAACA,EAAQ,QAAU,CAACA,EAAQ,MACvD,KAAK,iBAAiBA,CAAO,CAErC,CACJ,EACA9C,EAAa,UAAU,wBAA0B,SAAUkD,EAAU,CACjE,MAAM,IAAI,MAAM,2DAA2D,CAC/E,EACAlD,EAAa,UAAU,gBAAkB,SAAUiC,EAAa,CACxDA,EAAY,SAAW,GAAK,CAAC,KAAK,uBAGtC,KAAK,gBAAkBA,EACnB,KAAK,oBAEL,KAAK,qBAAqB,kBAAkBA,CAAW,EAK/D,EACAjC,EAAa,UAAU,mBAAqB,SAAUmD,EAAeC,EAAmB,GAAO,CAC3F,MAAMC,EAAS,CAAA,EACf,GAAID,EACAC,EAAO,KAAK,CAAC,MAGb,SAAS,EAAI,EAAG,EAAIF,EAAc,OAAQ,IAClCA,EAAc,CAAC,EACfE,EAAO,KAAK,EAAI,CAAC,EAGjBA,EAAO,KAAK,CAAC,EAIzB,OAAOA,CACX,EACArD,EAAa,UAAU,wBAA0B,UAAY,CAE7D,EACAA,EAAa,UAAU,uCAAyC,UAAY,CAE5E","x_google_ignoreList":[0]}