{"version":3,"file":"abstractSoundInstance-B7H0pjSR.js","sources":["../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractSound.js","../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractSoundInstance.js"],"sourcesContent":["import { Observable } from \"../../Misc/observable.js\";\nimport { AbstractSoundSource } from \"./abstractSoundSource.js\";\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport class AbstractSound extends AbstractSoundSource {\n    constructor(name, engine) {\n        super(name, engine, 3 /* AudioNodeType.HAS_INPUTS_AND_OUTPUTS */); // Inputs are for instances.\n        this._newestInstance = null;\n        this._privateInstances = new Set();\n        this._state = 1 /* SoundState.Stopped */;\n        this._instances = this._privateInstances;\n        /**\n         * Observable for when the sound stops playing.\n         */\n        this.onEndedObservable = new Observable();\n        this._onInstanceEnded = (instance) => {\n            if (this._newestInstance === instance) {\n                this._newestInstance = null;\n            }\n            this._privateInstances.delete(instance);\n            if (this._instances.size === 0) {\n                this._state = 1 /* SoundState.Stopped */;\n                this.onEndedObservable.notifyObservers(this);\n            }\n            instance.dispose();\n        };\n    }\n    /**\n     * The number of active instances of the sound that are currently playing.\n     */\n    get activeInstancesCount() {\n        return this._instances.size;\n    }\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    get autoplay() {\n        return this._options.autoplay;\n    }\n    /**\n     * The current playback time of the sound, in seconds.\n     */\n    get currentTime() {\n        const instance = this._getNewestInstance();\n        return instance ? instance.currentTime : 0;\n    }\n    set currentTime(value) {\n        this.startOffset = value;\n        const instance = this._getNewestInstance();\n        if (instance) {\n            instance.currentTime = value;\n        }\n    }\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    get loop() {\n        return this._options.loop;\n    }\n    set loop(value) {\n        this._options.loop = value;\n    }\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    get maxInstances() {\n        return this._options.maxInstances;\n    }\n    set maxInstances(value) {\n        this._options.maxInstances = value;\n    }\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    get startOffset() {\n        return this._options.startOffset;\n    }\n    set startOffset(value) {\n        this._options.startOffset = value;\n    }\n    /**\n     * The state of the sound.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Releases associated resources.\n     */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this._newestInstance = null;\n        this._privateInstances.clear();\n        this.onEndedObservable.clear();\n    }\n    /**\n     * Pauses the sound.\n     */\n    pause() {\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.pause();\n        }\n        this._state = 5 /* SoundState.Paused */;\n    }\n    /**\n     * Resumes the sound.\n     */\n    resume() {\n        if (this._state !== 5 /* SoundState.Paused */) {\n            return;\n        }\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.resume();\n        }\n        this._state = 3 /* SoundState.Started */;\n    }\n    _beforePlay(instance) {\n        if (this.state === 5 /* SoundState.Paused */ && this._instances.size > 0) {\n            this.resume();\n            return;\n        }\n        instance.onEndedObservable.addOnce(this._onInstanceEnded);\n        this._privateInstances.add(instance);\n        this._newestInstance = instance;\n    }\n    _afterPlay(instance) {\n        this._state = instance.state;\n    }\n    _getNewestInstance() {\n        if (this._instances.size === 0) {\n            return null;\n        }\n        if (!this._newestInstance) {\n            const it = this._instances.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                this._newestInstance = next.value;\n            }\n        }\n        return this._newestInstance;\n    }\n    _setState(state) {\n        this._state = state;\n    }\n    _stopExcessInstances() {\n        if (this.maxInstances < Infinity) {\n            const numberOfInstancesToStop = Array.from(this._instances).filter((instance) => instance.state === 3 /* SoundState.Started */).length - this.maxInstances;\n            const it = this._instances.values();\n            for (let i = 0; i < numberOfInstancesToStop; i++) {\n                const instance = it.next().value;\n                instance.stop();\n            }\n        }\n    }\n}\n//# sourceMappingURL=abstractSound.js.map","import { Observable } from \"../../Misc/observable.js\";\nimport { AbstractAudioNode } from \"./abstractAudioNode.js\";\n/** @internal */\nexport class _AbstractSoundInstance extends AbstractAudioNode {\n    constructor(sound) {\n        super(sound.engine, 2 /* AudioNodeType.HAS_OUTPUTS */);\n        this._state = 1 /* SoundState.Stopped */;\n        /** Observable triggered when the sound instance's playback ends */\n        this.onEndedObservable = new Observable();\n        /** Observable triggered if the sound instance encounters an error and can not be played */\n        this.onErrorObservable = new Observable();\n        /** Observable triggered when the sound instance's state changes */\n        this.onStateChangedObservable = new Observable();\n        this._sound = sound;\n    }\n    /** The playback state of the sound instance */\n    get state() {\n        return this._state;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this.onEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n    _setState(value) {\n        if (this._state === value) {\n            return;\n        }\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(this);\n        if (this._state === 1 /* SoundState.Stopped */) {\n            this.onEndedObservable.notifyObservers(this);\n        }\n    }\n}\n//# sourceMappingURL=abstractSoundInstance.js.map"],"names":["AbstractSound","AbstractSoundSource","name","engine","Observable","instance","value","it","next","state","numberOfInstancesToStop","i","_AbstractSoundInstance","AbstractAudioNode","sound"],"mappings":"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","x_google_ignoreList":[0,1]}