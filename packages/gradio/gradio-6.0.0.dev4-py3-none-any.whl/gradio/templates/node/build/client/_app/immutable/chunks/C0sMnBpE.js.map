{"version":3,"file":"C0sMnBpE.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Meshes/Compression/dracoCompressionWorker.js","../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Meshes/Compression/dracoCodec.js","../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Meshes/Compression/dracoDecoder.js","../../../../../../../../node_modules/.pnpm/@babylonjs+loaders@8.36.1_@babylonjs+core@8.36.1_babylonjs-gltf2interface@8.36.1/node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_draco_mesh_compression.js"],"sourcesContent":["/**\n * @internal\n */\nexport function EncodeMesh(module /** EncoderModule */, attributes, indices, options) {\n    const encoderModule = module;\n    let encoder = null;\n    let meshBuilder = null;\n    let mesh = null;\n    let encodedNativeBuffer = null;\n    const attributeIDs = {}; // Babylon kind -> Draco unique id\n    // Double-check that at least a position attribute is provided\n    const positionAttribute = attributes.find((a) => a.dracoName === \"POSITION\");\n    if (!positionAttribute) {\n        throw new Error(\"Position attribute is required for Draco encoding\");\n    }\n    // If no indices are provided, assume mesh is unindexed. Let's generate them, since Draco meshes require them.\n    // TODO: This may be the POINT_CLOUD case, but need to investigate. Should work for now-- just less efficient.\n    if (!indices) {\n        // Assume position attribute is the largest attribute.\n        const positionVerticesCount = positionAttribute.data.length / positionAttribute.size;\n        indices = new (positionVerticesCount > 65535 ? Uint32Array : Uint16Array)(positionVerticesCount);\n        for (let i = 0; i < positionVerticesCount; i++) {\n            indices[i] = i;\n        }\n    }\n    try {\n        encoder = new encoderModule.Encoder();\n        meshBuilder = new encoderModule.MeshBuilder();\n        mesh = new encoderModule.Mesh();\n        // Add the faces\n        meshBuilder.AddFacesToMesh(mesh, indices.length / 3, indices);\n        const addAttributeMap = new Map([\n            [Float32Array, (mb, m, a, c, s, d) => mb.AddFloatAttribute(m, a, c, s, d)],\n            [Uint32Array, (mb, m, a, c, s, d) => mb.AddUInt32Attribute(m, a, c, s, d)],\n            [Uint16Array, (mb, m, a, c, s, d) => mb.AddUInt16Attribute(m, a, c, s, d)],\n            [Uint8Array, (mb, m, a, c, s, d) => mb.AddUInt8Attribute(m, a, c, s, d)],\n            [Int32Array, (mb, m, a, c, s, d) => mb.AddInt32Attribute(m, a, c, s, d)],\n            [Int16Array, (mb, m, a, c, s, d) => mb.AddInt16Attribute(m, a, c, s, d)],\n            [Int8Array, (mb, m, a, c, s, d) => mb.AddInt8Attribute(m, a, c, s, d)],\n        ]);\n        // Add the attributes\n        for (const attribute of attributes) {\n            if (attribute.data instanceof Uint8ClampedArray) {\n                attribute.data = new Uint8Array(attribute.data); // Draco does not support Uint8ClampedArray\n            }\n            const addAttribute = addAttributeMap.get(attribute.data.constructor);\n            const verticesCount = attribute.data.length / attribute.size;\n            attributeIDs[attribute.kind] = addAttribute(meshBuilder, mesh, encoderModule[attribute.dracoName], verticesCount, attribute.size, attribute.data);\n            if (options.quantizationBits && options.quantizationBits[attribute.dracoName]) {\n                encoder.SetAttributeQuantization(encoderModule[attribute.dracoName], options.quantizationBits[attribute.dracoName]);\n            }\n        }\n        // Set the options\n        if (options.method) {\n            encoder.SetEncodingMethod(encoderModule[options.method]);\n        }\n        if (options.encodeSpeed !== undefined && options.decodeSpeed !== undefined) {\n            encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\n        }\n        // Encode to native buffer\n        encodedNativeBuffer = new encoderModule.DracoInt8Array();\n        const encodedLength = encoder.EncodeMeshToDracoBuffer(mesh, encodedNativeBuffer);\n        if (encodedLength <= 0) {\n            throw new Error(\"Draco encoding failed.\");\n        }\n        // Copy the native buffer data to worker heap\n        const encodedData = new Int8Array(encodedLength);\n        for (let i = 0; i < encodedLength; i++) {\n            encodedData[i] = encodedNativeBuffer.GetValue(i);\n        }\n        return { data: encodedData, attributeIds: attributeIDs };\n    }\n    finally {\n        if (mesh) {\n            encoderModule.destroy(mesh);\n        }\n        if (meshBuilder) {\n            encoderModule.destroy(meshBuilder);\n        }\n        if (encoder) {\n            encoderModule.destroy(encoder);\n        }\n        if (encodedNativeBuffer) {\n            encoderModule.destroy(encodedNativeBuffer);\n        }\n    }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\n */\nexport function EncoderWorkerFunction() {\n    let encoderPromise;\n    onmessage = (event) => {\n        const message = event.data;\n        switch (message.id) {\n            case \"init\": {\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\n                if (message.url) {\n                    importScripts(message.url);\n                }\n                const initEncoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\n                encoderPromise = DracoEncoderModule(initEncoderObject);\n                postMessage({ id: \"initDone\" });\n                break;\n            }\n            case \"encodeMesh\": {\n                if (!encoderPromise) {\n                    throw new Error(\"Draco encoder module is not available\");\n                }\n                // eslint-disable-next-line github/no-then\n                encoderPromise.then((encoder) => {\n                    const result = EncodeMesh(encoder, message.attributes, message.indices, message.options);\n                    postMessage({ id: \"encodeMeshDone\", encodedMeshData: result }, result ? [result.data.buffer] : undefined);\n                });\n                break;\n            }\n        }\n    };\n}\n/**\n * @internal\n */\nexport function DecodeMesh(module /** DecoderModule */, data, attributeIDs, onIndicesData, onAttributeData) {\n    const decoderModule = module;\n    let decoder = null;\n    let buffer = null;\n    let geometry = null;\n    try {\n        decoder = new decoderModule.Decoder();\n        buffer = new decoderModule.DecoderBuffer();\n        buffer.Init(data, data.byteLength);\n        let status;\n        const type = decoder.GetEncodedGeometryType(buffer);\n        switch (type) {\n            case decoderModule.TRIANGULAR_MESH: {\n                const mesh = new decoderModule.Mesh();\n                status = decoder.DecodeBufferToMesh(buffer, mesh);\n                if (!status.ok() || mesh.ptr === 0) {\n                    throw new Error(status.error_msg());\n                }\n                const numFaces = mesh.num_faces();\n                const numIndices = numFaces * 3;\n                const byteLength = numIndices * 4;\n                const ptr = decoderModule._malloc(byteLength);\n                try {\n                    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\n                    const indices = new Uint32Array(numIndices);\n                    indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n                    onIndicesData(indices);\n                }\n                finally {\n                    decoderModule._free(ptr);\n                }\n                geometry = mesh;\n                break;\n            }\n            case decoderModule.POINT_CLOUD: {\n                const pointCloud = new decoderModule.PointCloud();\n                status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\n                if (!status.ok() || !pointCloud.ptr) {\n                    throw new Error(status.error_msg());\n                }\n                geometry = pointCloud;\n                break;\n            }\n            default: {\n                throw new Error(`Invalid geometry type ${type}`);\n            }\n        }\n        const numPoints = geometry.num_points();\n        const processAttribute = (decoder, geometry, kind, attribute /** Attribute */) => {\n            const dataType = attribute.data_type();\n            const numComponents = attribute.num_components();\n            const normalized = attribute.normalized();\n            const byteStride = attribute.byte_stride();\n            const byteOffset = attribute.byte_offset();\n            const dataTypeInfo = {\n                [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },\n                [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },\n                [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },\n                [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },\n                [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },\n                [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },\n                [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 },\n            };\n            const info = dataTypeInfo[dataType];\n            if (!info) {\n                throw new Error(`Invalid data type ${dataType}`);\n            }\n            const numValues = numPoints * numComponents;\n            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\n            const ptr = decoderModule._malloc(byteLength);\n            try {\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\n                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\n                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\n            }\n            finally {\n                decoderModule._free(ptr);\n            }\n        };\n        if (attributeIDs) {\n            for (const kind in attributeIDs) {\n                const id = attributeIDs[kind];\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\n                processAttribute(decoder, geometry, kind, attribute);\n            }\n        }\n        else {\n            const dracoAttributeTypes = {\n                position: decoderModule.POSITION,\n                normal: decoderModule.NORMAL,\n                color: decoderModule.COLOR,\n                uv: decoderModule.TEX_COORD,\n            };\n            for (const kind in dracoAttributeTypes) {\n                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\n                if (id !== -1) {\n                    const attribute = decoder.GetAttribute(geometry, id);\n                    processAttribute(decoder, geometry, kind, attribute);\n                }\n            }\n        }\n        return numPoints;\n    }\n    finally {\n        if (geometry) {\n            decoderModule.destroy(geometry);\n        }\n        if (buffer) {\n            decoderModule.destroy(buffer);\n        }\n        if (decoder) {\n            decoderModule.destroy(decoder);\n        }\n    }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\n */\nexport function DecoderWorkerFunction() {\n    let decoderPromise;\n    onmessage = (event) => {\n        const message = event.data;\n        switch (message.id) {\n            case \"init\": {\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\n                if (message.url) {\n                    importScripts(message.url);\n                }\n                const initDecoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\n                decoderPromise = DracoDecoderModule(initDecoderObject);\n                postMessage({ id: \"initDone\" });\n                break;\n            }\n            case \"decodeMesh\": {\n                if (!decoderPromise) {\n                    throw new Error(\"Draco decoder module is not available\");\n                }\n                // eslint-disable-next-line github/no-then\n                decoderPromise.then((decoder) => {\n                    const numPoints = DecodeMesh(decoder, message.dataView, message.attributes, (indices) => {\n                        postMessage({ id: \"indices\", data: indices }, [indices.buffer]);\n                    }, (kind, data, size, offset, stride, normalized) => {\n                        postMessage({ id: \"attribute\", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);\n                    });\n                    postMessage({ id: \"decodeMeshDone\", totalVertices: numPoints });\n                });\n                break;\n            }\n        }\n    };\n}\n// For backwards compatibility\nexport { DecoderWorkerFunction as workerFunction };\n/**\n * Initializes a worker that was created for the draco agent pool\n * @param worker  The worker to initialize\n * @param wasmBinary The wasm binary to load into the worker\n * @param moduleUrl The url to the draco decoder module (optional)\n * @returns A promise that resolves when the worker is initialized\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport async function initializeWebWorker(worker, wasmBinary, moduleUrl) {\n    return await new Promise((resolve, reject) => {\n        const onError = (error) => {\n            worker.removeEventListener(\"error\", onError);\n            worker.removeEventListener(\"message\", onMessage);\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(error);\n        };\n        const onMessage = (event) => {\n            if (event.data.id === \"initDone\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n            }\n        };\n        worker.addEventListener(\"error\", onError);\n        worker.addEventListener(\"message\", onMessage);\n        // Load with either JS-only or WASM version\n        if (!wasmBinary) {\n            worker.postMessage({\n                id: \"init\",\n                url: moduleUrl,\n            });\n        }\n        else {\n            // clone the array buffer to make it transferable\n            const clone = wasmBinary.slice(0);\n            worker.postMessage({\n                id: \"init\",\n                url: moduleUrl,\n                wasmBinary: clone,\n            }, [clone]);\n        }\n        // note: no transfer list as the ArrayBuffer is shared across main thread and pool workers\n    });\n}\n//# sourceMappingURL=dracoCompressionWorker.js.map","import { Tools } from \"../../Misc/tools.js\";\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool.js\";\nimport { initializeWebWorker } from \"./dracoCompressionWorker.js\";\n/**\n * @internal\n */\nexport function _GetDefaultNumWorkers() {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n        return 1;\n    }\n    // Use 50% of the available logical processors but capped at 4.\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n}\n/**\n * @internal\n */\nexport function _IsConfigurationAvailable(config) {\n    return !!((config.wasmUrl && (config.wasmBinary || config.wasmBinaryUrl) && typeof WebAssembly === \"object\") || config.fallbackUrl);\n    // TODO: Account for jsModule\n}\n/**\n * Base class for a Draco codec.\n * @internal\n */\nexport class DracoCodec {\n    /**\n     * Constructor\n     * @param configuration The configuration for the DracoCodec instance.\n     */\n    constructor(configuration) {\n        // check if the codec binary and worker pool was injected\n        // Note - it is expected that the developer checked if WebWorker, WebAssembly and the URL object are available\n        if (configuration.workerPool) {\n            // Set the promise accordingly\n            this._workerPoolPromise = Promise.resolve(configuration.workerPool);\n            return;\n        }\n        // to avoid making big changes to the code here, if wasmBinary is provided use it in the wasmBinaryPromise\n        const wasmBinaryProvided = configuration.wasmBinary;\n        const numberOfWorkers = configuration.numWorkers ?? _GetDefaultNumWorkers();\n        const useWorkers = numberOfWorkers && typeof Worker === \"function\" && typeof URL === \"function\";\n        const urlNeeded = useWorkers || !configuration.jsModule;\n        // code maintained here for back-compat with no changes\n        const codecInfo = configuration.wasmUrl && configuration.wasmBinaryUrl && typeof WebAssembly === \"object\"\n            ? {\n                url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.wasmUrl, true) : \"\",\n                wasmBinaryPromise: wasmBinaryProvided\n                    ? Promise.resolve(wasmBinaryProvided)\n                    : Tools.LoadFileAsync(Tools.GetBabylonScriptURL(configuration.wasmBinaryUrl, true)),\n            }\n            : {\n                url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.fallbackUrl) : \"\",\n                wasmBinaryPromise: Promise.resolve(undefined),\n            };\n        // If using workers, initialize a worker pool with either the wasm or url?\n        if (useWorkers) {\n            // eslint-disable-next-line github/no-then\n            this._workerPoolPromise = codecInfo.wasmBinaryPromise.then((wasmBinary) => {\n                const workerContent = this._getWorkerContent();\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\n                // eslint-disable-next-line @typescript-eslint/promise-function-async\n                return new AutoReleaseWorkerPool(numberOfWorkers, () => {\n                    const worker = new Worker(workerBlobUrl);\n                    return initializeWebWorker(worker, wasmBinary, codecInfo.url);\n                });\n            });\n        }\n        else {\n            // eslint-disable-next-line github/no-then\n            this._modulePromise = codecInfo.wasmBinaryPromise.then(async (wasmBinary) => {\n                if (!this._isModuleAvailable()) {\n                    if (!configuration.jsModule) {\n                        if (!codecInfo.url) {\n                            throw new Error(\"Draco codec module is not available\");\n                        }\n                        await Tools.LoadBabylonScriptAsync(codecInfo.url);\n                    }\n                }\n                return await this._createModuleAsync(wasmBinary, configuration.jsModule);\n            });\n        }\n    }\n    /**\n     * Returns a promise that resolves when ready. Call this manually to ensure the draco codec is ready before use.\n     * @returns a promise that resolves when ready\n     */\n    async whenReadyAsync() {\n        if (this._workerPoolPromise) {\n            await this._workerPoolPromise;\n            return;\n        }\n        if (this._modulePromise) {\n            await this._modulePromise;\n            return;\n        }\n    }\n    /**\n     * Stop all async operations and release resources.\n     */\n    dispose() {\n        if (this._workerPoolPromise) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n            this._workerPoolPromise.then((workerPool) => {\n                workerPool.dispose();\n            });\n        }\n        delete this._workerPoolPromise;\n        delete this._modulePromise;\n    }\n}\n//# sourceMappingURL=dracoCodec.js.map","import { _IsConfigurationAvailable, DracoCodec } from \"./dracoCodec.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Geometry } from \"../geometry.js\";\nimport { VertexBuffer } from \"../buffer.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { DecodeMesh, DecoderWorkerFunction } from \"./dracoCompressionWorker.js\";\n/**\n * @experimental This class is an experimental version of `DracoCompression` and is subject to change.\n *\n * Draco Decoder (https://google.github.io/draco/)\n *\n * This class wraps the Draco decoder module.\n *\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the Babylon.js cdn https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js.\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     DracoDecoder.DefaultConfiguration = {\n *          wasmUrl: \"<url to the WebAssembly library>\",\n *          wasmBinaryUrl: \"<url to the WebAssembly binary>\",\n *          fallbackUrl: \"<url to the fallback JavaScript library>\",\n *     };\n * ```\n *\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\n * Use `DracoDecoder.DefaultAvailable` to determine if the decoder configuration is available for the current context.\n *\n * To decode Draco compressed data, get the default DracoDecoder object and call decodeMeshToGeometryAsync:\n * ```javascript\n *     var geometry = await DracoDecoder.Default.decodeMeshToGeometryAsync(data);\n * ```\n */\nexport class DracoDecoder extends DracoCodec {\n    /**\n     * Returns true if the decoder's `DefaultConfiguration` is available.\n     */\n    static get DefaultAvailable() {\n        return _IsConfigurationAvailable(DracoDecoder.DefaultConfiguration);\n    }\n    /**\n     * Default instance for the DracoDecoder.\n     */\n    static get Default() {\n        DracoDecoder._Default ?? (DracoDecoder._Default = new DracoDecoder());\n        return DracoDecoder._Default;\n    }\n    /**\n     * Reset the default DracoDecoder object to null and disposing the removed default instance.\n     * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,\n     * unless the static worker pool is no longer needed.\n     * @param skipDispose set to true to not dispose the removed default instance\n     */\n    static ResetDefault(skipDispose) {\n        if (DracoDecoder._Default) {\n            if (!skipDispose) {\n                DracoDecoder._Default.dispose();\n            }\n            DracoDecoder._Default = null;\n        }\n    }\n    _isModuleAvailable() {\n        return typeof DracoDecoderModule !== \"undefined\";\n    }\n    async _createModuleAsync(wasmBinary, jsModule /** DracoDecoderModule */) {\n        const module = await (jsModule || DracoDecoderModule)({ wasmBinary });\n        return { module };\n    }\n    _getWorkerContent() {\n        return `${DecodeMesh}(${DecoderWorkerFunction})()`;\n    }\n    /**\n     * Creates a new Draco decoder.\n     * @param configuration Optional override of the configuration for the DracoDecoder. If not provided, defaults to {@link DracoDecoder.DefaultConfiguration}.\n     */\n    constructor(configuration = DracoDecoder.DefaultConfiguration) {\n        super(configuration);\n    }\n    /**\n     * Decode Draco compressed mesh data to mesh data.\n     * @param data The ArrayBuffer or ArrayBufferView of the compressed Draco data\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n     * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization\n     * @returns A promise that resolves with the decoded mesh data\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride) {\n        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\n        const applyGltfNormalizedOverride = (kind, normalized) => {\n            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\n                if (normalized !== gltfNormalizedOverride[kind]) {\n                    Logger.Warn(`Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`);\n                }\n                return gltfNormalizedOverride[kind];\n            }\n            else {\n                return normalized;\n            }\n        };\n        if (this._workerPoolPromise) {\n            // eslint-disable-next-line github/no-then\n            return this._workerPoolPromise.then(async (workerPool) => {\n                return await new Promise((resolve, reject) => {\n                    workerPool.push((worker, onComplete) => {\n                        let resultIndices = null;\n                        const resultAttributes = [];\n                        const onError = (error) => {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                            reject(error);\n                            onComplete();\n                        };\n                        const onMessage = (event) => {\n                            const message = event.data;\n                            switch (message.id) {\n                                case \"indices\": {\n                                    resultIndices = message.data;\n                                    break;\n                                }\n                                case \"attribute\": {\n                                    resultAttributes.push({\n                                        kind: message.kind,\n                                        data: message.data,\n                                        size: message.size,\n                                        byteOffset: message.byteOffset,\n                                        byteStride: message.byteStride,\n                                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized),\n                                    });\n                                    break;\n                                }\n                                case \"decodeMeshDone\": {\n                                    worker.removeEventListener(\"error\", onError);\n                                    worker.removeEventListener(\"message\", onMessage);\n                                    resolve({ indices: resultIndices, attributes: resultAttributes, totalVertices: message.totalVertices });\n                                    onComplete();\n                                    break;\n                                }\n                            }\n                        };\n                        worker.addEventListener(\"error\", onError);\n                        worker.addEventListener(\"message\", onMessage);\n                        const dataViewCopy = dataView.slice();\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\n                    });\n                });\n            });\n        }\n        if (this._modulePromise) {\n            // eslint-disable-next-line github/no-then\n            return this._modulePromise.then((decoder) => {\n                let resultIndices = null;\n                const resultAttributes = [];\n                const numPoints = DecodeMesh(decoder.module, dataView, attributes, (indices) => {\n                    resultIndices = indices;\n                }, (kind, data, size, byteOffset, byteStride, normalized) => {\n                    resultAttributes.push({\n                        kind,\n                        data,\n                        size,\n                        byteOffset,\n                        byteStride,\n                        normalized,\n                    });\n                });\n                return { indices: resultIndices, attributes: resultAttributes, totalVertices: numPoints };\n            });\n        }\n        throw new Error(\"Draco decoder module is not available\");\n    }\n    /**\n     * Decode Draco compressed mesh data to Babylon geometry.\n     * @param name The name to use when creating the geometry\n     * @param scene The scene to use when creating the geometry\n     * @param data The ArrayBuffer or ArrayBufferView of the Draco compressed data\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n     * @returns A promise that resolves with the decoded geometry\n     */\n    async decodeMeshToGeometryAsync(name, scene, data, attributes) {\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);\n        const geometry = new Geometry(name, scene);\n        if (meshData.indices) {\n            geometry.setIndices(meshData.indices);\n        }\n        for (const attribute of meshData.attributes) {\n            geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);\n        }\n        return geometry;\n    }\n    /** @internal */\n    async _decodeMeshToGeometryForGltfAsync(name, scene, data, attributes, gltfNormalizedOverride, boundingInfo) {\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);\n        const geometry = new Geometry(name, scene);\n        if (boundingInfo) {\n            geometry._boundingInfo = boundingInfo;\n            geometry.useBoundingInfoFromGeometry = true;\n        }\n        if (meshData.indices) {\n            geometry.setIndices(meshData.indices);\n        }\n        for (const attribute of meshData.attributes) {\n            geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);\n        }\n        return geometry;\n    }\n}\n/**\n * Default configuration for the DracoDecoder. Defaults to the following:\n * - numWorkers: 50% of the available logical processors, capped to 4. If no logical processors are available, defaults to 1.\n * - wasmUrl: `\"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"`\n * - wasmBinaryUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"`\n * - fallbackUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.js\"`\n */\nDracoDecoder.DefaultConfiguration = {\n    wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,\n    wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,\n    fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`,\n};\nDracoDecoder._Default = null;\n//# sourceMappingURL=dracoDecoder.js.map","/* eslint-disable github/no-then */\nimport { DracoDecoder } from \"@babylonjs/core/Meshes/Compression/dracoDecoder.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { GLTFLoader, ArrayItem, LoadBoundingInfoFromPositionAccessor } from \"../glTFLoader.js\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry.js\";\nconst NAME = \"KHR_draco_mesh_compression\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_draco_mesh_compression {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines whether to use the normalized flag from the glTF accessor instead of the Draco data. Defaults to true.\n         */\n        this.useNormalizedFlagFromAccessor = true;\n        this._loader = loader;\n        this.enabled = DracoDecoder.DefaultAvailable && this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        delete this.dracoDecoder;\n        this._loader = null;\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    _loadVertexDataAsync(context, primitive, babylonMesh) {\n        return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, async (extensionContext, extension) => {\n            if (primitive.mode != undefined) {\n                if (primitive.mode !== 4 /* MeshPrimitiveMode.TRIANGLES */ && primitive.mode !== 5 /* MeshPrimitiveMode.TRIANGLE_STRIP */) {\n                    throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\n                }\n            }\n            const attributes = {};\n            const normalized = {};\n            const loadAttribute = (name, kind) => {\n                const uniqueId = extension.attributes[name];\n                if (uniqueId == undefined) {\n                    return;\n                }\n                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n                    babylonMesh._delayInfo.push(kind);\n                }\n                attributes[kind] = uniqueId;\n                if (this.useNormalizedFlagFromAccessor) {\n                    const accessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes[name]);\n                    if (accessor) {\n                        normalized[kind] = accessor.normalized || false;\n                    }\n                }\n            };\n            loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n            loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n            loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n            loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n            loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n            loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\n            loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\n            loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\n            loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\n            loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n            loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n            loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\n            const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView);\n            if (!bufferView._dracoBabylonGeometry) {\n                bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then(async (data) => {\n                    const dracoDecoder = this.dracoDecoder || DracoDecoder.Default;\n                    const positionAccessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes[\"POSITION\"]);\n                    const babylonBoundingInfo = !this._loader.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton && positionAccessor ? LoadBoundingInfoFromPositionAccessor(positionAccessor) : null;\n                    return await dracoDecoder\n                        ._decodeMeshToGeometryForGltfAsync(babylonMesh.name, this._loader.babylonScene, data, attributes, normalized, babylonBoundingInfo)\n                        .catch((error) => {\n                        throw new Error(`${context}: ${error.message}`);\n                    });\n                });\n            }\n            return await bufferView._dracoBabylonGeometry;\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_draco_mesh_compression(loader));\n//# sourceMappingURL=KHR_draco_mesh_compression.js.map"],"names":["decoder","geometry","data"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}