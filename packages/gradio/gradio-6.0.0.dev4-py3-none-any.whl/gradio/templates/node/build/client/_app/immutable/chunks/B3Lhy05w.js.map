{"version":3,"file":"B3Lhy05w.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Maths/math.vector.functions.js","../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Math/flowGraphVectorMathBlocks.js"],"sourcesContent":["import { Clamp } from \"./math.scalar.functions.js\";\nimport { Quaternion, Vector3 } from \"./math.vector.js\";\n/**\n * Creates a string representation of the IVector2Like\n * @param vector defines the IVector2Like to stringify\n * @param decimalCount defines the number of decimals to use\n * @returns a string with the IVector2Like coordinates.\n */\nexport function Vector2ToFixed(vector, decimalCount) {\n    return `{X: ${vector.x.toFixed(decimalCount)} Y: ${vector.y.toFixed(decimalCount)}}`;\n}\n/**\n * Computes the dot product of two IVector3Like objects.\n * @param a defines the first vector\n * @param b defines the second vector\n * @returns the dot product\n */\nexport function Vector3Dot(a, b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n/**\n * Computes the squared length of the IVector3Like\n * @param vector the vector to measure\n * @returns the squared length of the vector\n */\nexport function Vector3LengthSquared(vector) {\n    return vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;\n}\n/**\n * Computes the length of the IVector3Like\n * @param vector the vector to measure\n * @returns the length of the vector\n */\nexport function Vector3Length(vector) {\n    return Math.sqrt(Vector3LengthSquared(vector));\n}\n/**\n * Computes the squared distance between the IVector3Like objects\n * @param a defines the first vector\n * @param b defines the second vector\n * @returns the squared distance\n */\nexport function Vector3DistanceSquared(a, b) {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    return x * x + y * y + z * z;\n}\n/**\n * Computes the distance between the IVector3Like objects\n * @param a defines the first vector\n * @param b defines the second vector\n * @returns the distance\n */\nexport function Vector3Distance(a, b) {\n    return Math.sqrt(Vector3DistanceSquared(a, b));\n}\n/**\n * Sets the given floats into the result.\n * @param x defines the x coordinate\n * @param y defines the y coordinate\n * @param z defines the z coordinate\n * @param result defines the result vector\n * @returns the result vector\n */\nexport function Vector3FromFloatsToRef(x, y, z, result) {\n    result.x = x;\n    result.y = y;\n    result.z = z;\n    return result;\n}\n/**\n * Stores the scaled values of a vector into the result.\n * @param a defines the source vector\n * @param scale defines the scale factor\n * @param result defines the result vector\n * @returns the scaled vector\n */\nexport function Vector3ScaleToRef(a, scale, result) {\n    result.x = a.x * scale;\n    result.y = a.y * scale;\n    result.z = a.z * scale;\n    return result;\n}\n/**\n * Scales the current vector values in place by a factor.\n * @param vector defines the vector to scale\n * @param scale defines the scale factor\n * @returns the scaled vector\n */\nexport function Vector3ScaleInPlace(vector, scale) {\n    vector.x *= scale;\n    vector.y *= scale;\n    vector.z *= scale;\n    return vector;\n}\n/**\n * Creates a string representation of the IVector3Like\n * @param vector defines the IVector3Like to stringify\n * @param decimalCount defines the number of decimals to use\n * @returns a string with the IVector3Like coordinates.\n */\nexport function Vector3ToFixed(vector, decimalCount) {\n    return `{X: ${vector.x.toFixed(decimalCount)} Y: ${vector.y.toFixed(decimalCount)} Z: ${vector.z.toFixed(decimalCount)}}`;\n}\n/**\n * Computes the dot product of two IVector4Like objects\n * @param a defines the first vector\n * @param b defines the second vector\n * @returns the dot product\n */\nexport function Vector4Dot(a, b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n}\n/**\n * Creates a string representation of the IVector4Like\n * @param vector defines the IVector4Like to stringify\n * @param decimalCount defines the number of decimals to use\n * @returns a string with the IVector4Like coordinates.\n */\nexport function Vector4ToFixed(vector, decimalCount) {\n    return `{X: ${vector.x.toFixed(decimalCount)} Y: ${vector.y.toFixed(decimalCount)} Z: ${vector.z.toFixed(decimalCount)} W: ${vector.w.toFixed(decimalCount)}}`;\n}\n/**\n * Returns the angle in radians between two quaternions\n * @param q1 defines the first quaternion\n * @param q2 defines the second quaternion\n * @returns the angle in radians between the two quaternions\n */\nexport function GetAngleBetweenQuaternions(q1, q2) {\n    return Math.acos(Clamp(Vector4Dot(q1, q2))) * 2;\n}\n/**\n * Creates a quaternion from two direction vectors\n * @param a defines the first direction vector\n * @param b defines the second direction vector\n * @returns the target quaternion\n */\nexport function GetQuaternionFromDirections(a, b) {\n    const result = new Quaternion();\n    GetQuaternionFromDirectionsToRef(a, b, result);\n    return result;\n}\n/**\n * Creates a quaternion from two direction vectors\n * @param a defines the first direction vector\n * @param b defines the second direction vector\n * @param result defines the target quaternion\n * @returns the target quaternion\n */\nexport function GetQuaternionFromDirectionsToRef(a, b, result) {\n    const axis = Vector3.Cross(a, b);\n    const angle = Math.acos(Clamp(Vector3Dot(a, b), -1, 1));\n    Quaternion.RotationAxisToRef(axis, angle, result);\n    return result;\n}\n//# sourceMappingURL=math.vector.functions.js.map","import { FlowGraphBlock } from \"../../../flowGraphBlock.js\";\nimport { RichTypeVector3, RichTypeNumber, RichTypeAny, RichTypeVector2, RichTypeMatrix, getRichTypeByFlowGraphType, RichTypeQuaternion, RichTypeBoolean, } from \"../../../flowGraphRichTypes.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { FlowGraphBinaryOperationBlock } from \"../flowGraphBinaryOperationBlock.js\";\nimport { FlowGraphUnaryOperationBlock } from \"../flowGraphUnaryOperationBlock.js\";\nimport { Quaternion, Vector3, Vector4 } from \"../../../../Maths/math.vector.js\";\nimport { _GetClassNameOf } from \"../../../utils.js\";\nimport { GetAngleBetweenQuaternions, GetQuaternionFromDirections } from \"../../../../Maths/math.vector.functions.js\";\nconst AxisCacheName = \"cachedOperationAxis\";\nconst AngleCacheName = \"cachedOperationAngle\";\nconst CacheExecIdName = \"cachedExecutionId\";\n/**\n * Vector length block.\n */\nexport class FlowGraphLengthBlock extends FlowGraphUnaryOperationBlock {\n    constructor(config) {\n        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLength(a), \"FlowGraphLengthBlock\" /* FlowGraphBlockNames.Length */, config);\n    }\n    _polymorphicLength(a) {\n        const aClassName = _GetClassNameOf(a);\n        switch (aClassName) {\n            case \"Vector2\" /* FlowGraphTypes.Vector2 */:\n            case \"Vector3\" /* FlowGraphTypes.Vector3 */:\n            case \"Vector4\" /* FlowGraphTypes.Vector4 */:\n            case \"Quaternion\" /* FlowGraphTypes.Quaternion */:\n                return a.length();\n            default:\n                throw new Error(`Cannot compute length of value ${a}`);\n        }\n    }\n}\nRegisterClass(\"FlowGraphLengthBlock\" /* FlowGraphBlockNames.Length */, FlowGraphLengthBlock);\n/**\n * Vector normalize block.\n */\nexport class FlowGraphNormalizeBlock extends FlowGraphUnaryOperationBlock {\n    constructor(config) {\n        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicNormalize(a), \"FlowGraphNormalizeBlock\" /* FlowGraphBlockNames.Normalize */, config);\n    }\n    _polymorphicNormalize(a) {\n        const aClassName = _GetClassNameOf(a);\n        let normalized;\n        switch (aClassName) {\n            case \"Vector2\" /* FlowGraphTypes.Vector2 */:\n            case \"Vector3\" /* FlowGraphTypes.Vector3 */:\n            case \"Vector4\" /* FlowGraphTypes.Vector4 */:\n            case \"Quaternion\" /* FlowGraphTypes.Quaternion */:\n                normalized = a.normalizeToNew();\n                if (this.config?.nanOnZeroLength) {\n                    const length = a.length();\n                    if (length === 0) {\n                        normalized.setAll(NaN);\n                    }\n                }\n                return normalized;\n            default:\n                throw new Error(`Cannot normalize value ${a}`);\n        }\n    }\n}\nRegisterClass(\"FlowGraphNormalizeBlock\" /* FlowGraphBlockNames.Normalize */, FlowGraphNormalizeBlock);\n/**\n * Dot product block.\n */\nexport class FlowGraphDotBlock extends FlowGraphBinaryOperationBlock {\n    constructor(config) {\n        super(RichTypeAny, RichTypeAny, RichTypeNumber, (a, b) => this._polymorphicDot(a, b), \"FlowGraphDotBlock\" /* FlowGraphBlockNames.Dot */, config);\n    }\n    _polymorphicDot(a, b) {\n        const className = _GetClassNameOf(a);\n        switch (className) {\n            case \"Vector2\" /* FlowGraphTypes.Vector2 */:\n            case \"Vector3\" /* FlowGraphTypes.Vector3 */:\n            case \"Vector4\" /* FlowGraphTypes.Vector4 */:\n            case \"Quaternion\" /* FlowGraphTypes.Quaternion */:\n                // casting is needed because dot requires both to be the same type\n                return a.dot(b);\n            default:\n                throw new Error(`Cannot get dot product of ${a} and ${b}`);\n        }\n    }\n}\nRegisterClass(\"FlowGraphDotBlock\" /* FlowGraphBlockNames.Dot */, FlowGraphDotBlock);\n/**\n * Cross product block.\n */\nexport class FlowGraphCrossBlock extends FlowGraphBinaryOperationBlock {\n    constructor(config) {\n        super(RichTypeVector3, RichTypeVector3, RichTypeVector3, (a, b) => Vector3.Cross(a, b), \"FlowGraphCrossBlock\" /* FlowGraphBlockNames.Cross */, config);\n    }\n}\nRegisterClass(\"FlowGraphCrossBlock\" /* FlowGraphBlockNames.Cross */, FlowGraphCrossBlock);\n/**\n * 2D rotation block.\n */\nexport class FlowGraphRotate2DBlock extends FlowGraphBinaryOperationBlock {\n    constructor(config) {\n        super(RichTypeVector2, RichTypeNumber, RichTypeVector2, (a, b) => a.rotate(b), \"FlowGraphRotate2DBlock\" /* FlowGraphBlockNames.Rotate2D */, config);\n    }\n}\nRegisterClass(\"FlowGraphRotate2DBlock\" /* FlowGraphBlockNames.Rotate2D */, FlowGraphRotate2DBlock);\n/**\n * 3D rotation block.\n */\nexport class FlowGraphRotate3DBlock extends FlowGraphBinaryOperationBlock {\n    constructor(config) {\n        super(RichTypeVector3, RichTypeQuaternion, RichTypeVector3, (a, b) => a.applyRotationQuaternion(b), \"FlowGraphRotate3DBlock\" /* FlowGraphBlockNames.Rotate3D */, config);\n    }\n}\nRegisterClass(\"FlowGraphRotate3DBlock\" /* FlowGraphBlockNames.Rotate3D */, FlowGraphRotate3DBlock);\nfunction TransformVector(a, b) {\n    const className = _GetClassNameOf(a);\n    switch (className) {\n        case \"Vector2\" /* FlowGraphTypes.Vector2 */:\n            return b.transformVector(a);\n        case \"Vector3\" /* FlowGraphTypes.Vector3 */:\n            return b.transformVector(a);\n        case \"Vector4\" /* FlowGraphTypes.Vector4 */:\n            a = a;\n            // transform the vector 4 with the matrix here. Vector4.TransformCoordinates transforms a 3D coordinate, not Vector4\n            return new Vector4(a.x * b.m[0] + a.y * b.m[1] + a.z * b.m[2] + a.w * b.m[3], a.x * b.m[4] + a.y * b.m[5] + a.z * b.m[6] + a.w * b.m[7], a.x * b.m[8] + a.y * b.m[9] + a.z * b.m[10] + a.w * b.m[11], a.x * b.m[12] + a.y * b.m[13] + a.z * b.m[14] + a.w * b.m[15]);\n        default:\n            throw new Error(`Cannot transform value ${a}`);\n    }\n}\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformBlock extends FlowGraphBinaryOperationBlock {\n    constructor(config) {\n        const vectorType = config?.vectorType || \"Vector3\" /* FlowGraphTypes.Vector3 */;\n        const matrixType = vectorType === \"Vector2\" /* FlowGraphTypes.Vector2 */ ? \"Matrix2D\" /* FlowGraphTypes.Matrix2D */ : vectorType === \"Vector3\" /* FlowGraphTypes.Vector3 */ ? \"Matrix3D\" /* FlowGraphTypes.Matrix3D */ : \"Matrix\" /* FlowGraphTypes.Matrix */;\n        super(getRichTypeByFlowGraphType(vectorType), getRichTypeByFlowGraphType(matrixType), getRichTypeByFlowGraphType(vectorType), TransformVector, \"FlowGraphTransformVectorBlock\" /* FlowGraphBlockNames.TransformVector */, config);\n    }\n}\nRegisterClass(\"FlowGraphTransformVectorBlock\" /* FlowGraphBlockNames.TransformVector */, FlowGraphTransformBlock);\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformCoordinatesBlock extends FlowGraphBinaryOperationBlock {\n    constructor(config) {\n        super(RichTypeVector3, RichTypeMatrix, RichTypeVector3, (a, b) => Vector3.TransformCoordinates(a, b), \"FlowGraphTransformCoordinatesBlock\" /* FlowGraphBlockNames.TransformCoordinates */, config);\n    }\n}\nRegisterClass(\"FlowGraphTransformCoordinatesBlock\" /* FlowGraphBlockNames.TransformCoordinates */, FlowGraphTransformCoordinatesBlock);\n/**\n * Conjugate the quaternion.\n */\nexport class FlowGraphConjugateBlock extends FlowGraphUnaryOperationBlock {\n    constructor(config) {\n        super(RichTypeQuaternion, RichTypeQuaternion, (a) => a.conjugate(), \"FlowGraphConjugateBlock\" /* FlowGraphBlockNames.Conjugate */, config);\n    }\n}\nRegisterClass(\"FlowGraphConjugateBlock\" /* FlowGraphBlockNames.Conjugate */, FlowGraphConjugateBlock);\n/**\n * Get the angle between two quaternions.\n */\nexport class FlowGraphAngleBetweenBlock extends FlowGraphBinaryOperationBlock {\n    constructor(config) {\n        super(RichTypeQuaternion, RichTypeQuaternion, RichTypeNumber, (a, b) => GetAngleBetweenQuaternions(a, b), \"FlowGraphAngleBetweenBlock\" /* FlowGraphBlockNames.AngleBetween */, config);\n    }\n}\nRegisterClass(\"FlowGraphAngleBetweenBlock\" /* FlowGraphBlockNames.AngleBetween */, FlowGraphAngleBetweenBlock);\n/**\n * Get the quaternion from an axis and an angle.\n */\nexport class FlowGraphQuaternionFromAxisAngleBlock extends FlowGraphBinaryOperationBlock {\n    constructor(config) {\n        super(RichTypeVector3, RichTypeNumber, RichTypeQuaternion, (a, b) => Quaternion.RotationAxis(a, b), \"FlowGraphQuaternionFromAxisAngleBlock\" /* FlowGraphBlockNames.QuaternionFromAxisAngle */, config);\n    }\n}\nRegisterClass(\"FlowGraphQuaternionFromAxisAngleBlock\" /* FlowGraphBlockNames.QuaternionFromAxisAngle */, FlowGraphQuaternionFromAxisAngleBlock);\n/**\n * Get the axis and angle from a quaternion.\n */\nexport class FlowGraphAxisAngleFromQuaternionBlock extends FlowGraphBlock {\n    constructor(config) {\n        super(config);\n        this.a = this.registerDataInput(\"a\", RichTypeQuaternion);\n        this.axis = this.registerDataOutput(\"axis\", RichTypeVector3);\n        this.angle = this.registerDataOutput(\"angle\", RichTypeNumber);\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeBoolean);\n    }\n    /** @override */\n    _updateOutputs(context) {\n        const cachedExecutionId = context._getExecutionVariable(this, CacheExecIdName, -1);\n        const cachedAxis = context._getExecutionVariable(this, AxisCacheName, null);\n        const cachedAngle = context._getExecutionVariable(this, AngleCacheName, null);\n        if (cachedAxis !== undefined && cachedAxis !== null && cachedAngle !== undefined && cachedAngle !== null && cachedExecutionId === context.executionId) {\n            this.axis.setValue(cachedAxis, context);\n            this.angle.setValue(cachedAngle, context);\n        }\n        else {\n            try {\n                const { axis, angle } = this.a.getValue(context).toAxisAngle();\n                context._setExecutionVariable(this, AxisCacheName, axis);\n                context._setExecutionVariable(this, AngleCacheName, angle);\n                context._setExecutionVariable(this, CacheExecIdName, context.executionId);\n                this.axis.setValue(axis, context);\n                this.angle.setValue(angle, context);\n                this.isValid.setValue(true, context);\n            }\n            catch (e) {\n                this.isValid.setValue(false, context);\n            }\n        }\n    }\n    /** @override */\n    getClassName() {\n        return \"FlowGraphAxisAngleFromQuaternionBlock\" /* FlowGraphBlockNames.AxisAngleFromQuaternion */;\n    }\n}\nRegisterClass(\"FlowGraphAxisAngleFromQuaternionBlock\" /* FlowGraphBlockNames.AxisAngleFromQuaternion */, FlowGraphAxisAngleFromQuaternionBlock);\n/**\n * Get the quaternion from two direction vectors.\n */\nexport class FlowGraphQuaternionFromDirectionsBlock extends FlowGraphBinaryOperationBlock {\n    constructor(config) {\n        super(RichTypeVector3, RichTypeVector3, RichTypeQuaternion, (a, b) => GetQuaternionFromDirections(a, b), \"FlowGraphQuaternionFromDirectionsBlock\" /* FlowGraphBlockNames.QuaternionFromDirections */, config);\n    }\n}\n//# sourceMappingURL=flowGraphVectorMathBlocks.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0,1]}