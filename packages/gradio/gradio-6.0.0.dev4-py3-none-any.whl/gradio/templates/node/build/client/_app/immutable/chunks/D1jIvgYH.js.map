{"version":3,"file":"D1jIvgYH.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js","../../../../../../../../node_modules/.pnpm/@babylonjs+loaders@8.36.1_@babylonjs+core@8.36.1_babylonjs-gltf2interface@8.36.1/node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_lights_image_based.js"],"sourcesContent":["import { SerializationHelper } from \"../../Misc/decorators.serialization.js\";\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools.js\";\nimport { CubeTexture } from \"./cubeTexture.js\";\n\n/**\n * Raw cube texture where the raw buffers are passed in\n */\nexport class RawCubeTexture extends CubeTexture {\n    /**\n     * Creates a cube texture where the raw buffers are passed in.\n     * @param scene defines the scene the texture is attached to\n     * @param data defines the array of data to use to create each face\n     * @param size defines the size of the textures\n     * @param format defines the format of the data\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\n     * @param generateMipMaps  defines if the engine should generate the mip levels\n     * @param invertY defines if data must be stored with Y axis inverted\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\n     * @param compression defines the compression used (null by default)\n     */\n    constructor(scene, data, size, format = 5, type = 0, generateMipMaps = false, invertY = false, samplingMode = 3, compression = null) {\n        super(\"\", scene);\n        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\n    }\n    /**\n     * Updates the raw cube texture.\n     * @param data defines the data to store\n     * @param format defines the data format\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\n     * @param invertY defines if data must be stored with Y axis inverted\n     * @param compression defines the compression used (null by default)\n     */\n    update(data, format, type, invertY, compression = null) {\n        this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);\n    }\n    /**\n     * Updates a raw cube texture with RGBD encoded data.\n     * @param data defines the array of data [mipmap][face] to use to create each face\n     * @param sphericalPolynomial defines the spherical polynomial for irradiance\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n     * @returns a promise that resolves when the operation is complete\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    updateRGBDAsync(data, sphericalPolynomial = null, lodScale = 0.8, lodOffset = 0) {\n        // eslint-disable-next-line github/no-then\n        return UpdateRGBDAsyncEnvTools(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(() => { });\n    }\n    /**\n     * Clones the raw cube texture.\n     * @returns a new cube texture\n     */\n    clone() {\n        return SerializationHelper.Clone(() => {\n            const scene = this.getScene();\n            const internalTexture = this._texture;\n            const texture = new RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n            if (internalTexture.source === 13 /* InternalTextureSource.CubeRawRGBD */) {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);\n            }\n            return texture;\n        }, this);\n    }\n}\n//# sourceMappingURL=rawCubeTexture.js.map","import { SphericalHarmonics, SphericalPolynomial } from \"@babylonjs/core/Maths/sphericalPolynomial.js\";\nimport { Quaternion, Matrix } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { RawCubeTexture } from \"@babylonjs/core/Materials/Textures/rawCubeTexture.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry.js\";\nconst NAME = \"EXT_lights_image_based\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_image_based/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_lights_image_based {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        delete this._lights;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._lights = extension.lights;\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadSceneAsync(context, scene) {\n        return GLTFLoader.LoadExtensionAsync(context, scene, this.name, async (extensionContext, extension) => {\n            this._loader._allMaterialsDirtyRequired = true;\n            const promises = new Array();\n            promises.push(this._loader.loadSceneAsync(context, scene));\n            this._loader.logOpen(`${extensionContext}`);\n            const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);\n            promises.push(\n            // eslint-disable-next-line github/no-then\n            this._loadLightAsync(`/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {\n                this._loader.babylonScene.environmentTexture = texture;\n            }));\n            this._loader.logClose();\n            // eslint-disable-next-line github/no-then\n            return await Promise.all(promises).then(() => { });\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _loadLightAsync(context, light) {\n        if (!light._loaded) {\n            const promises = new Array();\n            this._loader.logOpen(`${context}`);\n            const imageData = new Array(light.specularImages.length);\n            for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\n                const faces = light.specularImages[mipmap];\n                imageData[mipmap] = new Array(faces.length);\n                for (let face = 0; face < faces.length; face++) {\n                    const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;\n                    this._loader.logOpen(`${specularImageContext}`);\n                    const index = faces[face];\n                    const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);\n                    promises.push(\n                    // eslint-disable-next-line github/no-then\n                    this._loader.loadImageAsync(`/images/${index}`, image).then((data) => {\n                        imageData[mipmap][face] = data;\n                    }));\n                    this._loader.logClose();\n                }\n            }\n            this._loader.logClose();\n            // eslint-disable-next-line github/no-then\n            light._loaded = Promise.all(promises).then(async () => {\n                const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);\n                babylonTexture.name = light.name || \"environment\";\n                light._babylonTexture = babylonTexture;\n                if (light.intensity != undefined) {\n                    babylonTexture.level = light.intensity;\n                }\n                if (light.rotation) {\n                    let rotation = Quaternion.FromArray(light.rotation);\n                    // Invert the rotation so that positive rotation is counter-clockwise.\n                    if (!this._loader.babylonScene.useRightHandedSystem) {\n                        rotation = Quaternion.Inverse(rotation);\n                    }\n                    Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\n                }\n                if (!light.irradianceCoefficients) {\n                    throw new Error(`${context}: Irradiance coefficients are missing`);\n                }\n                const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\n                sphericalHarmonics.scaleInPlace(light.intensity);\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\n                const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n                // Compute the lod generation scale to fit exactly to the number of levels available.\n                const lodGenerationScale = (imageData.length - 1) / Math.log2(light.specularImageSize);\n                return await babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);\n            });\n        }\n        // eslint-disable-next-line github/no-then\n        return light._loaded.then(() => {\n            return light._babylonTexture;\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new EXT_lights_image_based(loader));\n//# sourceMappingURL=EXT_lights_image_based.js.map"],"names":["UpdateRGBDAsyncEnvTools"],"mappings":"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","x_google_ignoreList":[0,1]}