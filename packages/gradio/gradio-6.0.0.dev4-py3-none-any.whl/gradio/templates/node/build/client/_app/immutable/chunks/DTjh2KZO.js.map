{"version":3,"file":"DTjh2KZO.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Misc/timer.js","../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSetDelayBlock.js"],"sourcesContent":["import { Observable } from \"../Misc/observable.js\";\n/**\n * The current state of the timer\n */\nexport var TimerState;\n(function (TimerState) {\n    /**\n     * Timer initialized, not yet started\n     */\n    TimerState[TimerState[\"INIT\"] = 0] = \"INIT\";\n    /**\n     * Timer started and counting\n     */\n    TimerState[TimerState[\"STARTED\"] = 1] = \"STARTED\";\n    /**\n     * Timer ended (whether aborted or time reached)\n     */\n    TimerState[TimerState[\"ENDED\"] = 2] = \"ENDED\";\n})(TimerState || (TimerState = {}));\n/**\n * A simple version of the timer. Will take options and start the timer immediately after calling it\n *\n * @param options options with which to initialize this timer\n * @returns an observer that can be used to stop the timer\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function setAndStartTimer(options) {\n    let timer = 0;\n    const startTime = Date.now();\n    options.observableParameters = options.observableParameters ?? {};\n    const observer = options.contextObservable.add((payload) => {\n        const now = Date.now();\n        timer = now - startTime;\n        const data = {\n            startTime,\n            currentTime: now,\n            deltaTime: timer,\n            completeRate: timer / options.timeout,\n            payload,\n        };\n        options.onTick && options.onTick(data);\n        if (options.breakCondition && options.breakCondition()) {\n            options.contextObservable.remove(observer);\n            options.onAborted && options.onAborted(data);\n        }\n        if (timer >= options.timeout) {\n            options.contextObservable.remove(observer);\n            options.onEnded && options.onEnded(data);\n        }\n    }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);\n    return observer;\n}\n/**\n * An advanced implementation of a timer class\n */\nexport class AdvancedTimer {\n    /**\n     * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\n     * @param options construction options for this advanced timer\n     */\n    constructor(options) {\n        /**\n         * Will notify each time the timer calculates the remaining time\n         */\n        this.onEachCountObservable = new Observable();\n        /**\n         * Will trigger when the timer was aborted due to the break condition\n         */\n        this.onTimerAbortedObservable = new Observable();\n        /**\n         * Will trigger when the timer ended successfully\n         */\n        this.onTimerEndedObservable = new Observable();\n        /**\n         * Will trigger when the timer state has changed\n         */\n        this.onStateChangedObservable = new Observable();\n        this._observer = null;\n        this._breakOnNextTick = false;\n        this._tick = (payload) => {\n            const now = Date.now();\n            this._timer = now - this._startTime;\n            const data = {\n                startTime: this._startTime,\n                currentTime: now,\n                deltaTime: this._timer,\n                completeRate: this._timer / this._timeToEnd,\n                payload,\n            };\n            const shouldBreak = this._breakOnNextTick || this._breakCondition(data);\n            if (shouldBreak || this._timer >= this._timeToEnd) {\n                this._stop(data, shouldBreak);\n            }\n            else {\n                this.onEachCountObservable.notifyObservers(data);\n            }\n        };\n        this._setState(0 /* TimerState.INIT */);\n        this._contextObservable = options.contextObservable;\n        this._observableParameters = options.observableParameters ?? {};\n        this._breakCondition = options.breakCondition ?? (() => false);\n        this._timeToEnd = options.timeout;\n        if (options.onEnded) {\n            this.onTimerEndedObservable.add(options.onEnded);\n        }\n        if (options.onTick) {\n            this.onEachCountObservable.add(options.onTick);\n        }\n        if (options.onAborted) {\n            this.onTimerAbortedObservable.add(options.onAborted);\n        }\n    }\n    /**\n     * set a breaking condition for this timer. Default is to never break during count\n     * @param predicate the new break condition. Returns true to break, false otherwise\n     */\n    set breakCondition(predicate) {\n        this._breakCondition = predicate;\n    }\n    /**\n     * Reset ALL associated observables in this advanced timer\n     */\n    clearObservables() {\n        this.onEachCountObservable.clear();\n        this.onTimerAbortedObservable.clear();\n        this.onTimerEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n    /**\n     * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\n     *\n     * @param timeToEnd how much time to measure until timer ended\n     */\n    start(timeToEnd = this._timeToEnd) {\n        if (this._state === 1 /* TimerState.STARTED */) {\n            throw new Error(\"Timer already started. Please stop it before starting again\");\n        }\n        this._timeToEnd = timeToEnd;\n        this._startTime = Date.now();\n        this._timer = 0;\n        this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\n        this._setState(1 /* TimerState.STARTED */);\n    }\n    /**\n     * Will force a stop on the next tick.\n     */\n    stop() {\n        if (this._state !== 1 /* TimerState.STARTED */) {\n            return;\n        }\n        this._breakOnNextTick = true;\n    }\n    /**\n     * Dispose this timer, clearing all resources\n     */\n    dispose() {\n        if (this._observer) {\n            this._contextObservable.remove(this._observer);\n        }\n        this.clearObservables();\n    }\n    _setState(newState) {\n        this._state = newState;\n        this.onStateChangedObservable.notifyObservers(this._state);\n    }\n    _stop(data, aborted = false) {\n        this._contextObservable.remove(this._observer);\n        this._setState(2 /* TimerState.ENDED */);\n        if (aborted) {\n            this.onTimerAbortedObservable.notifyObservers(data);\n        }\n        else {\n            this.onTimerEndedObservable.notifyObservers(data);\n        }\n    }\n}\n//# sourceMappingURL=timer.js.map","import { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock.js\";\nimport { RichTypeFlowGraphInteger, RichTypeNumber } from \"../../../flowGraphRichTypes.js\";\nimport { AdvancedTimer } from \"../../../../Misc/timer.js\";\nimport { Logger } from \"../../../../Misc/logger.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { FlowGraphInteger } from \"../../../CustomTypes/flowGraphInteger.js\";\n/**\n * Block that sets a delay in seconds before activating the output signal.\n */\nexport class FlowGraphSetDelayBlock extends FlowGraphAsyncExecutionBlock {\n    constructor(config) {\n        super(config);\n        this.cancel = this._registerSignalInput(\"cancel\");\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\n        this.lastDelayIndex = this.registerDataOutput(\"lastDelayIndex\", RichTypeFlowGraphInteger, new FlowGraphInteger(-1));\n    }\n    _preparePendingTasks(context) {\n        const duration = this.duration.getValue(context);\n        if (duration < 0 || isNaN(duration) || !isFinite(duration)) {\n            return this._reportError(context, \"Invalid duration in SetDelay block\");\n        }\n        // active delays are global to the context\n        const activeDelays = context._getGlobalContextVariable(\"activeDelays\", 0);\n        if (activeDelays >= FlowGraphSetDelayBlock.MaxParallelDelayCount) {\n            return this._reportError(context, \"Max parallel delays reached\");\n        }\n        // get the last global delay index\n        const lastDelayIndex = context._getGlobalContextVariable(\"lastDelayIndex\", -1);\n        // these are block-specific and not global\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        const scene = context.configuration.scene;\n        const timer = new AdvancedTimer({\n            timeout: duration * 1000, // duration is in seconds\n            contextObservable: scene.onBeforeRenderObservable,\n            onEnded: () => this._onEnded(timer, context),\n        });\n        timer.start();\n        const newIndex = lastDelayIndex + 1;\n        this.lastDelayIndex.setValue(new FlowGraphInteger(newIndex), context);\n        context._setGlobalContextVariable(\"lastDelayIndex\", newIndex);\n        timers[newIndex] = timer;\n        context._setExecutionVariable(this, \"pendingDelays\", timers);\n        this._updateGlobalTimers(context);\n    }\n    _cancelPendingTasks(context) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        for (const timer of timers) {\n            timer?.dispose();\n        }\n        context._deleteExecutionVariable(this, \"pendingDelays\");\n        this.lastDelayIndex.setValue(new FlowGraphInteger(-1), context);\n        this._updateGlobalTimers(context);\n    }\n    _execute(context, callingSignal) {\n        if (callingSignal === this.cancel) {\n            this._cancelPendingTasks(context);\n            return;\n        }\n        else {\n            this._preparePendingTasks(context);\n            this.out._activateSignal(context);\n        }\n    }\n    getClassName() {\n        return \"FlowGraphSetDelayBlock\" /* FlowGraphBlockNames.SetDelay */;\n    }\n    _onEnded(timer, context) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        const index = timers.indexOf(timer);\n        if (index !== -1) {\n            timers.splice(index, 1);\n        }\n        else {\n            Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n        }\n        context._removePendingBlock(this);\n        this.done._activateSignal(context);\n        this._updateGlobalTimers(context);\n    }\n    _updateGlobalTimers(context) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        const globalTimers = context._getGlobalContextVariable(\"pendingDelays\", []);\n        // there should NEVER be the same index in the global and local timers, unless they are equal\n        for (let i = 0; i < timers.length; i++) {\n            if (!timers[i]) {\n                continue;\n            }\n            const timer = timers[i];\n            if (globalTimers[i] && globalTimers[i] !== timer) {\n                Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n            }\n            else {\n                globalTimers[i] = timer;\n            }\n        }\n        context._setGlobalContextVariable(\"pendingDelays\", globalTimers);\n    }\n}\n/**\n * The maximum number of parallel delays that can be set per node.\n */\nFlowGraphSetDelayBlock.MaxParallelDelayCount = 100;\nRegisterClass(\"FlowGraphSetDelayBlock\" /* FlowGraphBlockNames.SetDelay */, FlowGraphSetDelayBlock);\n//# sourceMappingURL=flowGraphSetDelayBlock.js.map"],"names":["TimerState"],"mappings":";;;AAIO,IAAI;AAAA,CACV,SAAUA,aAAY;AAInB,EAAAA,YAAWA,YAAW,MAAM,IAAI,CAAC,IAAI;AAIrC,EAAAA,YAAWA,YAAW,SAAS,IAAI,CAAC,IAAI;AAIxC,EAAAA,YAAWA,YAAW,OAAO,IAAI,CAAC,IAAI;AAC1C,GAAG,eAAe,aAAa,CAAA,EAAG;AAqC3B,MAAM,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA,EAKvB,YAAY,SAAS;AAIjB,SAAK,wBAAwB,IAAI,WAAU;AAI3C,SAAK,2BAA2B,IAAI,WAAU;AAI9C,SAAK,yBAAyB,IAAI,WAAU;AAI5C,SAAK,2BAA2B,IAAI,WAAU;AAC9C,SAAK,YAAY;AACjB,SAAK,mBAAmB;AACxB,SAAK,QAAQ,CAAC,YAAY;AACtB,YAAM,MAAM,KAAK,IAAG;AACpB,WAAK,SAAS,MAAM,KAAK;AACzB,YAAM,OAAO;AAAA,QACT,WAAW,KAAK;AAAA,QAChB,aAAa;AAAA,QACb,WAAW,KAAK;AAAA,QAChB,cAAc,KAAK,SAAS,KAAK;AAAA,QACjC;AAAA,MAChB;AACY,YAAM,cAAc,KAAK,oBAAoB,KAAK,gBAAgB,IAAI;AACtE,UAAI,eAAe,KAAK,UAAU,KAAK,YAAY;AAC/C,aAAK,MAAM,MAAM,WAAW;AAAA,MAChC,OACK;AACD,aAAK,sBAAsB,gBAAgB,IAAI;AAAA,MACnD;AAAA,IACJ;AACA,SAAK;AAAA,MAAU;AAAA;AAAA,IAAC;AAChB,SAAK,qBAAqB,QAAQ;AAClC,SAAK,wBAAwB,QAAQ,wBAAwB,CAAA;AAC7D,SAAK,kBAAkB,QAAQ,mBAAmB,MAAM;AACxD,SAAK,aAAa,QAAQ;AAC1B,QAAI,QAAQ,SAAS;AACjB,WAAK,uBAAuB,IAAI,QAAQ,OAAO;AAAA,IACnD;AACA,QAAI,QAAQ,QAAQ;AAChB,WAAK,sBAAsB,IAAI,QAAQ,MAAM;AAAA,IACjD;AACA,QAAI,QAAQ,WAAW;AACnB,WAAK,yBAAyB,IAAI,QAAQ,SAAS;AAAA,IACvD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,eAAe,WAAW;AAC1B,SAAK,kBAAkB;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB;AACf,SAAK,sBAAsB,MAAK;AAChC,SAAK,yBAAyB,MAAK;AACnC,SAAK,uBAAuB,MAAK;AACjC,SAAK,yBAAyB,MAAK;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,YAAY,KAAK,YAAY;AAC/B,QAAI,KAAK,WAAW,GAA4B;AAC5C,YAAM,IAAI,MAAM,6DAA6D;AAAA,IACjF;AACA,SAAK,aAAa;AAClB,SAAK,aAAa,KAAK,IAAG;AAC1B,SAAK,SAAS;AACd,SAAK,YAAY,KAAK,mBAAmB,IAAI,KAAK,OAAO,KAAK,sBAAsB,MAAM,KAAK,sBAAsB,aAAa,KAAK,sBAAsB,KAAK;AAClK,SAAK;AAAA,MAAU;AAAA;AAAA,IAAC;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO;AACH,QAAI,KAAK,WAAW,GAA4B;AAC5C;AAAA,IACJ;AACA,SAAK,mBAAmB;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACN,QAAI,KAAK,WAAW;AAChB,WAAK,mBAAmB,OAAO,KAAK,SAAS;AAAA,IACjD;AACA,SAAK,iBAAgB;AAAA,EACzB;AAAA,EACA,UAAU,UAAU;AAChB,SAAK,SAAS;AACd,SAAK,yBAAyB,gBAAgB,KAAK,MAAM;AAAA,EAC7D;AAAA,EACA,MAAM,MAAM,UAAU,OAAO;AACzB,SAAK,mBAAmB,OAAO,KAAK,SAAS;AAC7C,SAAK;AAAA,MAAU;AAAA;AAAA,IAAC;AAChB,QAAI,SAAS;AACT,WAAK,yBAAyB,gBAAgB,IAAI;AAAA,IACtD,OACK;AACD,WAAK,uBAAuB,gBAAgB,IAAI;AAAA,IACpD;AAAA,EACJ;AACJ;ACtKO,MAAM,+BAA+B,6BAA6B;AAAA,EACrE,YAAY,QAAQ;AAChB,UAAM,MAAM;AACZ,SAAK,SAAS,KAAK,qBAAqB,QAAQ;AAChD,SAAK,WAAW,KAAK,kBAAkB,YAAY,cAAc;AACjE,SAAK,iBAAiB,KAAK,mBAAmB,kBAAkB,0BAA0B,IAAI,iBAAiB,EAAE,CAAC;AAAA,EACtH;AAAA,EACA,qBAAqB,SAAS;AAC1B,UAAM,WAAW,KAAK,SAAS,SAAS,OAAO;AAC/C,QAAI,WAAW,KAAK,MAAM,QAAQ,KAAK,CAAC,SAAS,QAAQ,GAAG;AACxD,aAAO,KAAK,aAAa,SAAS,oCAAoC;AAAA,IAC1E;AAEA,UAAM,eAAe,QAAQ,0BAA0B,gBAAgB,CAAC;AACxE,QAAI,gBAAgB,uBAAuB,uBAAuB;AAC9D,aAAO,KAAK,aAAa,SAAS,6BAA6B;AAAA,IACnE;AAEA,UAAM,iBAAiB,QAAQ,0BAA0B,kBAAkB,EAAE;AAE7E,UAAM,SAAS,QAAQ,sBAAsB,MAAM,iBAAiB,CAAA,CAAE;AACtE,UAAM,QAAQ,QAAQ,cAAc;AACpC,UAAM,QAAQ,IAAI,cAAc;AAAA,MAC5B,SAAS,WAAW;AAAA;AAAA,MACpB,mBAAmB,MAAM;AAAA,MACzB,SAAS,MAAM,KAAK,SAAS,OAAO,OAAO;AAAA,IACvD,CAAS;AACD,UAAM,MAAK;AACX,UAAM,WAAW,iBAAiB;AAClC,SAAK,eAAe,SAAS,IAAI,iBAAiB,QAAQ,GAAG,OAAO;AACpE,YAAQ,0BAA0B,kBAAkB,QAAQ;AAC5D,WAAO,QAAQ,IAAI;AACnB,YAAQ,sBAAsB,MAAM,iBAAiB,MAAM;AAC3D,SAAK,oBAAoB,OAAO;AAAA,EACpC;AAAA,EACA,oBAAoB,SAAS;AACzB,UAAM,SAAS,QAAQ,sBAAsB,MAAM,iBAAiB,CAAA,CAAE;AACtE,eAAW,SAAS,QAAQ;AACxB,aAAO,QAAO;AAAA,IAClB;AACA,YAAQ,yBAAyB,MAAM,eAAe;AACtD,SAAK,eAAe,SAAS,IAAI,iBAAiB,EAAE,GAAG,OAAO;AAC9D,SAAK,oBAAoB,OAAO;AAAA,EACpC;AAAA,EACA,SAAS,SAAS,eAAe;AAC7B,QAAI,kBAAkB,KAAK,QAAQ;AAC/B,WAAK,oBAAoB,OAAO;AAChC;AAAA,IACJ,OACK;AACD,WAAK,qBAAqB,OAAO;AACjC,WAAK,IAAI,gBAAgB,OAAO;AAAA,IACpC;AAAA,EACJ;AAAA,EACA,eAAe;AACX,WAAO;AAAA,EACX;AAAA,EACA,SAAS,OAAO,SAAS;AACrB,UAAM,SAAS,QAAQ,sBAAsB,MAAM,iBAAiB,CAAA,CAAE;AACtE,UAAM,QAAQ,OAAO,QAAQ,KAAK;AAClC,QAAI,UAAU,IAAI;AACd,aAAO,OAAO,OAAO,CAAC;AAAA,IAC1B,OACK;AACD,aAAO,KAAK,+EAA+E;AAAA,IAC/F;AACA,YAAQ,oBAAoB,IAAI;AAChC,SAAK,KAAK,gBAAgB,OAAO;AACjC,SAAK,oBAAoB,OAAO;AAAA,EACpC;AAAA,EACA,oBAAoB,SAAS;AACzB,UAAM,SAAS,QAAQ,sBAAsB,MAAM,iBAAiB,CAAA,CAAE;AACtE,UAAM,eAAe,QAAQ,0BAA0B,iBAAiB,CAAA,CAAE;AAE1E,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,UAAI,CAAC,OAAO,CAAC,GAAG;AACZ;AAAA,MACJ;AACA,YAAM,QAAQ,OAAO,CAAC;AACtB,UAAI,aAAa,CAAC,KAAK,aAAa,CAAC,MAAM,OAAO;AAC9C,eAAO,KAAK,+EAA+E;AAAA,MAC/F,OACK;AACD,qBAAa,CAAC,IAAI;AAAA,MACtB;AAAA,IACJ;AACA,YAAQ,0BAA0B,iBAAiB,YAAY;AAAA,EACnE;AACJ;AAIA,uBAAuB,wBAAwB;AAC/C,cAAc,0BAA6D,sBAAsB;","x_google_ignoreList":[0,1]}