{"version":3,"file":"Jwc8C3Hw.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Misc/dds.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\nimport { Clamp } from \"../Maths/math.scalar.functions.js\";\n\nimport { Logger } from \"../Misc/logger.js\";\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js\";\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools.js\";\nimport \"../Engines/AbstractEngine/abstractEngine.cubeTexture.js\";\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\n// All values and structures referenced from:\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\nconst DDS_MAGIC = 0x20534444;\nconst //DDSD_CAPS = 0x1,\n//DDSD_HEIGHT = 0x2,\n//DDSD_WIDTH = 0x4,\n//DDSD_PITCH = 0x8,\n//DDSD_PIXELFORMAT = 0x1000,\nDDSD_MIPMAPCOUNT = 0x20000;\n//DDSD_LINEARSIZE = 0x80000,\n//DDSD_DEPTH = 0x800000;\n// var DDSCAPS_COMPLEX = 0x8,\n//     DDSCAPS_MIPMAP = 0x400000,\n//     DDSCAPS_TEXTURE = 0x1000;\nconst DDSCAPS2_CUBEMAP = 0x200;\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n// DDSCAPS2_VOLUME = 0x200000;\nconst //DDPF_ALPHAPIXELS = 0x1,\n//DDPF_ALPHA = 0x2,\nDDPF_FOURCC = 0x4, DDPF_RGB = 0x40, \n//DDPF_YUV = 0x200,\nDDPF_LUMINANCE = 0x20000;\nfunction FourCCToInt32(value) {\n    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n}\nfunction Int32ToFourCC(value) {\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\n}\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\nconst headerLengthInt = 31; // The header length in 32 bit ints\n// Offsets into the header array\nconst off_magic = 0;\nconst off_size = 1;\nconst off_flags = 2;\nconst off_height = 3;\nconst off_width = 4;\nconst off_mipmapCount = 7;\nconst off_pfFlags = 20;\nconst off_pfFourCC = 21;\nconst off_RGBbpp = 22;\nconst off_RMask = 23;\nconst off_GMask = 24;\nconst off_BMask = 25;\nconst off_AMask = 26;\n// var off_caps1 = 27;\nconst off_caps2 = 28;\n// var off_caps3 = 29;\n// var off_caps4 = 30;\nconst off_dxgiFormat = 32;\n/**\n * Class used to provide DDS decompression tools\n */\nexport class DDSTools {\n    /**\n     * Gets DDS information from an array buffer\n     * @param data defines the array buffer view to read data from\n     * @returns the DDS information\n     */\n    static GetDDSInfo(data) {\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\n        let mipmapCount = 1;\n        if (header[off_flags] & DDSD_MIPMAPCOUNT) {\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\n        }\n        const fourCC = header[off_pfFourCC];\n        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\n        let textureType = 0;\n        switch (fourCC) {\n            case FOURCC_D3DFMT_R16G16B16A16F:\n                textureType = 2;\n                break;\n            case FOURCC_D3DFMT_R32G32B32A32F:\n                textureType = 1;\n                break;\n            case FOURCC_DX10:\n                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\n                    textureType = 2;\n                    break;\n                }\n                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\n                    textureType = 1;\n                    break;\n                }\n        }\n        return {\n            width: header[off_width],\n            height: header[off_height],\n            mipmapCount: mipmapCount,\n            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\n            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\n            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\n            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\n            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\n            dxgiFormat: dxgiFormat,\n            textureType: textureType,\n        };\n    }\n    static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Float32Array(dataLength);\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                destArray[index] = FromHalfFloat(srcData[srcPos]);\n                destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\n                destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = lod;\n                }\n                else {\n                    destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        if (DDSTools.StoreLODInAlphaChannel) {\n            const destArray = new Uint16Array(dataLength);\n            const srcData = new Uint16Array(arrayBuffer, dataOffset);\n            let index = 0;\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const srcPos = (x + y * width) * 4;\n                    destArray[index] = srcData[srcPos];\n                    destArray[index + 1] = srcData[srcPos + 1];\n                    destArray[index + 2] = srcData[srcPos + 2];\n                    destArray[index + 3] = ToHalfFloat(lod);\n                    index += 4;\n                }\n            }\n            return destArray;\n        }\n        return new Uint16Array(arrayBuffer, dataOffset, dataLength);\n    }\n    static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        if (DDSTools.StoreLODInAlphaChannel) {\n            const destArray = new Float32Array(dataLength);\n            const srcData = new Float32Array(arrayBuffer, dataOffset);\n            let index = 0;\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const srcPos = (x + y * width) * 4;\n                    destArray[index] = srcData[srcPos];\n                    destArray[index + 1] = srcData[srcPos + 1];\n                    destArray[index + 2] = srcData[srcPos + 2];\n                    destArray[index + 3] = lod;\n                    index += 4;\n                }\n            }\n            return destArray;\n        }\n        return new Float32Array(arrayBuffer, dataOffset, dataLength);\n    }\n    static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Uint16Array(dataLength);\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                destArray[index] = ToHalfFloat(srcData[index]);\n                destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\n                destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = ToHalfFloat(lod);\n                }\n                else {\n                    destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Uint8Array(dataLength);\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                destArray[index] = Clamp(srcData[srcPos]) * 255;\n                destArray[index + 1] = Clamp(srcData[srcPos + 1]) * 255;\n                destArray[index + 2] = Clamp(srcData[srcPos + 2]) * 255;\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = lod;\n                }\n                else {\n                    destArray[index + 3] = Clamp(srcData[srcPos + 3]) * 255;\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Uint8Array(dataLength);\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                destArray[index] = Clamp(FromHalfFloat(srcData[srcPos])) * 255;\n                destArray[index + 1] = Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\n                destArray[index + 2] = Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = lod;\n                }\n                else {\n                    destArray[index + 3] = Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {\n        const byteArray = new Uint8Array(dataLength);\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                byteArray[index] = srcData[srcPos + rOffset];\n                byteArray[index + 1] = srcData[srcPos + gOffset];\n                byteArray[index + 2] = srcData[srcPos + bOffset];\n                byteArray[index + 3] = srcData[srcPos + aOffset];\n                index += 4;\n            }\n        }\n        return byteArray;\n    }\n    static _ExtractLongWordOrder(value) {\n        if (value === 0 || value === 255 || value === -16777216) {\n            return 0;\n        }\n        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\n    }\n    static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {\n        const byteArray = new Uint8Array(dataLength);\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 3;\n                byteArray[index] = srcData[srcPos + rOffset];\n                byteArray[index + 1] = srcData[srcPos + gOffset];\n                byteArray[index + 2] = srcData[srcPos + bOffset];\n                index += 3;\n            }\n        }\n        return byteArray;\n    }\n    static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {\n        const byteArray = new Uint8Array(dataLength);\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = x + y * width;\n                byteArray[index] = srcData[srcPos];\n                index++;\n            }\n        }\n        return byteArray;\n    }\n    /**\n     * Uploads DDS Levels to a Babylon Texture\n     * @internal\n     */\n    static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {\n        let sphericalPolynomialFaces = null;\n        if (info.sphericalPolynomial) {\n            sphericalPolynomialFaces = [];\n        }\n        const ext = !!engine.getCaps().s3tc;\n        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\n        texture.generateMipMaps = loadMipmaps;\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n        let fourCC, width, height, dataLength = 0, dataOffset;\n        let byteArray, mipmapCount, mip;\n        let internalCompressedFormat = 0;\n        let blockBytes = 1;\n        if (header[off_magic] !== DDS_MAGIC) {\n            Logger.Error(\"Invalid magic number in DDS header\");\n            return;\n        }\n        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\n            Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n            return;\n        }\n        if (info.isCompressed && !ext) {\n            Logger.Error(\"Compressed textures are not supported on this platform.\");\n            return;\n        }\n        let bpp = header[off_RGBbpp];\n        dataOffset = header[off_size] + 4;\n        let computeFormats = false;\n        if (info.isFourCC) {\n            fourCC = header[off_pfFourCC];\n            switch (fourCC) {\n                case FOURCC_DXT1:\n                    blockBytes = 8;\n                    internalCompressedFormat = 33777;\n                    break;\n                case FOURCC_DXT3:\n                    blockBytes = 16;\n                    internalCompressedFormat = 33778;\n                    break;\n                case FOURCC_DXT5:\n                    blockBytes = 16;\n                    internalCompressedFormat = 33779;\n                    break;\n                case FOURCC_D3DFMT_R16G16B16A16F:\n                    computeFormats = true;\n                    bpp = 64;\n                    break;\n                case FOURCC_D3DFMT_R32G32B32A32F:\n                    computeFormats = true;\n                    bpp = 128;\n                    break;\n                case FOURCC_DX10: {\n                    // There is an additionnal header so dataOffset need to be changed\n                    dataOffset += 5 * 4; // 5 uints\n                    let supported = false;\n                    switch (info.dxgiFormat) {\n                        case DXGI_FORMAT_R16G16B16A16_FLOAT:\n                            computeFormats = true;\n                            bpp = 64;\n                            supported = true;\n                            break;\n                        case DXGI_FORMAT_R32G32B32A32_FLOAT:\n                            computeFormats = true;\n                            bpp = 128;\n                            supported = true;\n                            break;\n                        case DXGI_FORMAT_B8G8R8X8_UNORM:\n                            info.isRGB = true;\n                            info.isFourCC = false;\n                            bpp = 32;\n                            supported = true;\n                            break;\n                    }\n                    if (supported) {\n                        break;\n                    }\n                }\n                // eslint-disable-next-line no-fallthrough\n                default:\n                    Logger.Error([\"Unsupported FourCC code:\", Int32ToFourCC(fourCC)]);\n                    return;\n            }\n        }\n        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\n        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\n        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\n        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\n        if (computeFormats) {\n            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n        }\n        mipmapCount = 1;\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\n        }\n        const startFace = currentFace || 0;\n        const caps = engine.getCaps();\n        for (let face = startFace; face < faces; face++) {\n            width = header[off_width];\n            height = header[off_height];\n            for (mip = 0; mip < mipmapCount; ++mip) {\n                if (lodIndex === -1 || lodIndex === mip) {\n                    // In case of fixed LOD, if the lod has just been uploaded, early exit.\n                    const i = lodIndex === -1 ? mip : 0;\n                    if (!info.isCompressed && info.isFourCC) {\n                        texture.format = 5;\n                        dataLength = width * height * 4;\n                        let floatArray = null;\n                        if (engine._badOS || engine._badDesktopOS || (!caps.textureHalfFloat && !caps.textureFloat)) {\n                            // Required because iOS has many issues with float and half float generation\n                            if (bpp === 128) {\n                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                                if (sphericalPolynomialFaces && i == 0) {\n                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                                }\n                            }\n                            else if (bpp === 64) {\n                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                                if (sphericalPolynomialFaces && i == 0) {\n                                    sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                                }\n                            }\n                            texture.type = 0;\n                        }\n                        else {\n                            const floatAvailable = caps.textureFloat && ((destTypeMustBeFilterable && caps.textureFloatLinearFiltering) || !destTypeMustBeFilterable);\n                            const halfFloatAvailable = caps.textureHalfFloat && ((destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering) || !destTypeMustBeFilterable);\n                            const destType = (bpp === 128 || (bpp === 64 && !halfFloatAvailable)) && floatAvailable\n                                ? 1\n                                : (bpp === 64 || (bpp === 128 && !floatAvailable)) && halfFloatAvailable\n                                    ? 2\n                                    : 0;\n                            let dataGetter;\n                            let dataGetterPolynomial = null;\n                            switch (bpp) {\n                                case 128: {\n                                    switch (destType) {\n                                        case 1:\n                                            dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = null;\n                                            break;\n                                        case 2:\n                                            dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                                            break;\n                                        case 0:\n                                            dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                                            break;\n                                    }\n                                    break;\n                                }\n                                default: {\n                                    // 64 bpp\n                                    switch (destType) {\n                                        case 1:\n                                            dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = null;\n                                            break;\n                                        case 2:\n                                            dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                                            break;\n                                        case 0:\n                                            dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                                            break;\n                                    }\n                                    break;\n                                }\n                            }\n                            texture.type = destType;\n                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                            if (sphericalPolynomialFaces && i == 0) {\n                                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);\n                            }\n                        }\n                        if (floatArray) {\n                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\n                        }\n                    }\n                    else if (info.isRGB) {\n                        texture.type = 0;\n                        if (bpp === 24) {\n                            texture.format = 4;\n                            dataLength = width * height * 3;\n                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n                        }\n                        else {\n                            // 32\n                            texture.format = 5;\n                            dataLength = width * height * 4;\n                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n                        }\n                    }\n                    else if (info.isLuminance) {\n                        const unpackAlignment = engine._getUnpackAlignement();\n                        const unpaddedRowSize = width;\n                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\n                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\n                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\n                        texture.format = 1;\n                        texture.type = 0;\n                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n                    }\n                    else {\n                        dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes;\n                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\n                        texture.type = 0;\n                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\n                    }\n                }\n                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\n                width *= 0.5;\n                height *= 0.5;\n                width = Math.max(1.0, width);\n                height = Math.max(1.0, height);\n            }\n            if (currentFace !== undefined) {\n                // Loading a single face\n                break;\n            }\n        }\n        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\n            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\n                size: header[off_width],\n                right: sphericalPolynomialFaces[0],\n                left: sphericalPolynomialFaces[1],\n                up: sphericalPolynomialFaces[2],\n                down: sphericalPolynomialFaces[3],\n                front: sphericalPolynomialFaces[4],\n                back: sphericalPolynomialFaces[5],\n                format: 5,\n                type: 1,\n                gammaSpace: false,\n            });\n        }\n        else {\n            info.sphericalPolynomial = undefined;\n        }\n    }\n}\n/**\n * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\n */\nDDSTools.StoreLODInAlphaChannel = false;\n//# sourceMappingURL=dds.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0]}