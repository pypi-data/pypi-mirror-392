{"version":3,"mappings":";;;AASA,IAAI,mBAAmB;AACvB,eAAe,4BAA4B;AAEvC,QAAM,SAAU,YAAY,mBAAmB,aAAa,KAAK,GAAG,KAAK,IAAI,gBAAgB,KAAK,GAAG;AACrG,MAAI,kBAAkB,iBAAiB;AACnC,WAAO,KAAK,iGAAiG;AAAA,EACjH;AAGA,QAAM,EAAE,YAAY,gBAAe,IAAK,MAAK;AAAA,wBAAAA,iBAAA,UAAC,OAAO,eAA0B;AAAA,yBAAAA,iBAAA;AAAA;AAC/E,MAAI,CAAC,gBAAgB,aAAa;AAC9B,UAAM,IAAI,MAAM,yDAAyD;AAAA,EAC7E;AACA,QAAM,UAAU;AAAA,IACZ,uBAAuB;AAAA,IACvB,OAAO;AAAA,IACP,SAAS;AAAA,IACT,OAAO;AAAA,IACP,oBAAoB;AAAA,IACpB,WAAW;AAAA,IACX,8BAA8B;AAAA,EACtC;AACI,QAAM,SAAS,IAAI,gBAAgB,QAAQ,OAAO,OAAO;AAEzD,cAAY,UAAU,IAAG;AAEzB,cAAY,4BAA4B,IAAI,CAAC,MAAM;AAG/C,QAAI,UAAU,MAAM,UAAU,CAAC,OAAO,cAAc,YAAY,UAAU,WAAW,GAAG;AAEpF,cAAO;AAAA,IACX;AAAA,EACJ,CAAC;AACD,SAAO,UAAU,wBAAwB;AACzC,QAAM,WAAW,IAAI,eAAe,MAAM;AAC1C,QAAM,EAAE,gBAAe,IAAK,MAAK;AAAA,6BAAAC,iBAAA,UAAC,OAAO,eAA6B;AAAA,8BAAAA,iBAAA;AAAA;AACtE,QAAM,UAAU,IAAI,cAAc;AAAA,IAC9B;AAAA,IACA,MAAM,gBAAgB;AAAA,IACtB,gBAAgB,gBAAgB;AAAA,IAChC,cAAc,CAAC,gBAAgB;AAAA,EACvC,CAAK;AACD,SAAO;AAAA,IACH;AAAA,IACA,YAAY,EAAE,QAAQ,UAAU,QAAO;AAAA,EAC/C;AACA;AACA,eAAe,yBAAyB;AACpC,MAAI,CAAC,kBAAkB;AACnB,uBAAmB,0BAAyB;AAAA,EAChD;AACA,SAAO,MAAM;AACjB;AACA,MAAM,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjB,aAAa,iBAAiB,WAAW,OAAO,QAAQ,UAAU,SAAS,SAAS;AAChF,UAAM,YAAY,MAAM,uBAAsB;AAC9C,UAAM,aAAa,UAAU;AAC7B,eAAW,OAAO,QAAQ,OAAO,QAAQ,IAAI;AAE7C,UAAM,UAAU,WAAW,OAAO,iBAAiB,WAAW,OAAO,QAAQ,GAAG,OAAO,CAAC,SAAS,CAAC;AAClG,eAAW,SAAS,YAAW;AAC/B,eAAW,SAAS,mBAAmB,WAAW,OAAO;AACzD,eAAW,QAAQ,OAAO,aAAa,kBAAkB,OAAO;AAChE,eAAW,SAAS,KAAI;AACxB,YAAQ,QAAO;AACf,WAAO,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC1C,YAAM,OAAO,UAAU,QAAQ,CAAC,SAAS;AACrC,YAAI,CAAC,MAAM;AACP,iBAAO,IAAI,MAAM,qDAAqD,CAAC;AAAA,QAC3E,OACK;AACD,kBAAQ,IAAI;AAAA,QAChB;AAAA,MACJ,GAAG,UAAU,OAAO;AAAA,IACxB,CAAC;AAAA,EACL;AACJ;AACA,WAAW;AAAA,EACP;AACJ,GAAG,gBAAgB,oBAAoB,IAAI;AAW/B,MAAC,mBAAmB,eAAe;AAcxC,eAAe,gBAAgB,OAAO,QAAQ,QAAQ,iBAAiB,WAAW,aAAa,UAAU,SAAS;AAErH,QAAM,aAAa,MAAM,OAAO,WAAW,GAAG,GAAG,OAAO,MAAM;AAC9D,QAAM,OAAO,IAAI,WAAW,WAAW,MAAM;AAC7C,WAAS,OAAO,QAAQ,MAAM,iBAAiB,UAAU,UAAU,MAAM,QAAW,OAAO;AAC/F;AAaO,eAAe,cAAc,OAAO,QAAQ,MAAM,WAAW,aAAa,UAAU,UAAU,OAAO,gBAAgB,OAAO,SAAS;AAExI,MAAI,gBAAgB,cAAc;AAC9B,UAAM,QAAQ,IAAI,WAAW,KAAK,MAAM;AACxC,QAAI,IAAI,KAAK;AACb,WAAO,KAAK;AACR,YAAM,IAAI,KAAK,CAAC;AAChB,YAAM,CAAC,IAAI,KAAK,MAAM,MAAM,CAAC,IAAI,GAAG;AAAA,IACxC;AACA,WAAO;AAAA,EACX;AACA,QAAM,OAAO,MAAM,eAAe,iBAAiB,MAAM,OAAO,QAAQ,UAAU,SAAS,OAAO;AAClG,MAAI,aAAa,QAAW;AACxB,UAAM,aAAa,MAAM,QAAQ;AAAA,EACrC;AACA,MAAI,KAAK,SAAS,UAAU;AACxB,WAAO,KAAK,qCAAqC,QAAQ,gDAAgD,KAAK,IAAI,YAAY;AAAA,EAClI;AACA,QAAM,SAAS,MAAM,KAAK,YAAW;AACrC,MAAI,eAAe;AACf,WAAO;AAAA,EACX;AACA,SAAO,QAAQ,QAAQ,WAAW,0BAA0B,MAAM,CAAC;AACvE;AAaO,SAAS,SAAS,OAAO,QAAQ,MAAM,iBAAiB,WAAW,aAAa,UAAU,UAAU,OAAO,gBAAgB,OAAO,SAAS;AAE9I,MAAI,aAAa,UAAa,CAAC,iBAAiB;AAC5C,eAAW;AAAA,EACf;AAEA,gBAAc,OAAO,QAAQ,MAAM,UAAU,UAAU,SAAS,eAAe,OAAO,EAEjF,KAAK,CAAC,WAAW;AAClB,QAAI,iBAAiB;AACjB,sBAAgB,MAAM;AAAA,IAC1B;AAAA,EACJ,CAAC;AACL;AAIO,SAAS,UAAU;AACtB,MAAI,CAAC,kBAAkB;AACnB;AAAA,EACJ;AAGA,oBAAkB,KAAK,CAAC,cAAc;AAClC,QAAI,UAAU,kBAAkB,mBAAmB;AAC/C,gBAAU,OAAO,OAAM;AAAA,IAC3B;AACA,QAAI,UAAU,YAAY;AACtB,gBAAU,WAAW,OAAO,QAAO;AACnC,gBAAU,WAAW,SAAS,QAAO;AACrC,gBAAU,WAAW,QAAQ,QAAO;AAAA,IACxC;AAAA,EACJ,CAAC;AACD,qBAAmB;AACvB;AAKY,MAAC,YAAY;AAAA;AAAA,EAErB;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AACJ;AAOA,MAAM,kBAAkB,MAAM;AAE1B,QAAM,WAAW;AACjB,QAAM,gBAAgB;AACtB,QAAM,kBAAkB;AAC5B;AACA,gBAAe","names":["thinEngineClass","passPixelShader"],"ignoreList":[0],"sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Misc/dumpTools.js"],"sourcesContent":["import { __decorate } from \"../tslib.es6.js\";\n\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport { Tools } from \"./tools.js\";\nimport { Clamp } from \"../Maths/math.scalar.functions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"./logger.js\";\nimport { EncodeArrayBufferToBase64 } from \"./stringTools.js\";\nimport { nativeOverride } from \"./decorators.js\";\nlet ResourcesPromise = null;\nasync function _CreateDumpResourcesAsync() {\n    // Create a compatible canvas. Prefer an HTMLCanvasElement if possible to avoid alpha issues with OffscreenCanvas + WebGL in many browsers.\n    const canvas = (EngineStore.LastCreatedEngine?.createCanvas(100, 100) ?? new OffscreenCanvas(100, 100)); // will be resized later\n    if (canvas instanceof OffscreenCanvas) {\n        Logger.Warn(\"DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.\");\n    }\n    // If WebGL via ThinEngine is not available, we cannot encode the data.\n    // If https://github.com/whatwg/html/issues/10142 is resolved, we can migrate to just BitmapRenderer and avoid an engine dependency altogether.\n    const { ThinEngine: thinEngineClass } = await import(\"../Engines/thinEngine.js\");\n    if (!thinEngineClass.IsSupported) {\n        throw new Error(\"DumpData: No WebGL context available. Cannot dump data.\");\n    }\n    const options = {\n        preserveDrawingBuffer: true,\n        depth: false,\n        stencil: false,\n        alpha: true,\n        premultipliedAlpha: false,\n        antialias: false,\n        failIfMajorPerformanceCaveat: false,\n    };\n    const engine = new thinEngineClass(canvas, false, options);\n    // remove this engine from the list of instances to avoid using it for other purposes\n    EngineStore.Instances.pop();\n    // However, make sure to dispose it when no other engines are left\n    EngineStore.OnEnginesDisposedObservable.add((e) => {\n        // guaranteed to run when no other instances are left\n        // only dispose if it's not the current engine\n        if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {\n            // Dump the engine and the associated resources\n            Dispose();\n        }\n    });\n    engine.getCaps().parallelShaderCompile = undefined;\n    const renderer = new EffectRenderer(engine);\n    const { passPixelShader } = await import(\"../Shaders/pass.fragment.js\");\n    const wrapper = new EffectWrapper({\n        engine,\n        name: passPixelShader.name,\n        fragmentShader: passPixelShader.shader,\n        samplerNames: [\"textureSampler\"],\n    });\n    return {\n        canvas: canvas,\n        dumpEngine: { engine, renderer, wrapper },\n    };\n}\nasync function _GetDumpResourcesAsync() {\n    if (!ResourcesPromise) {\n        ResourcesPromise = _CreateDumpResourcesAsync();\n    }\n    return await ResourcesPromise;\n}\nclass EncodingHelper {\n    /**\n     * Encodes image data to the given mime type.\n     * This is put into a helper class so we can apply the nativeOverride decorator to it.\n     * @internal\n     */\n    static async EncodeImageAsync(pixelData, width, height, mimeType, invertY, quality) {\n        const resources = await _GetDumpResourcesAsync();\n        const dumpEngine = resources.dumpEngine;\n        dumpEngine.engine.setSize(width, height, true);\n        // Create the image\n        const texture = dumpEngine.engine.createRawTexture(pixelData, width, height, 5, false, !invertY, 1);\n        dumpEngine.renderer.setViewport();\n        dumpEngine.renderer.applyEffectWrapper(dumpEngine.wrapper);\n        dumpEngine.wrapper.effect._bindTexture(\"textureSampler\", texture);\n        dumpEngine.renderer.draw();\n        texture.dispose();\n        return await new Promise((resolve, reject) => {\n            Tools.ToBlob(resources.canvas, (blob) => {\n                if (!blob) {\n                    reject(new Error(\"EncodeImageAsync: Failed to convert canvas to blob.\"));\n                }\n                else {\n                    resolve(blob);\n                }\n            }, mimeType, quality);\n        });\n    }\n}\n__decorate([\n    nativeOverride\n], EncodingHelper, \"EncodeImageAsync\", null);\n/**\n * Encodes pixel data to an image\n * @param pixelData 8-bit RGBA pixel data\n * @param width the width of the image\n * @param height the height of the image\n * @param mimeType the requested MIME type\n * @param invertY true to invert the image in the Y direction\n * @param quality the quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns a promise that resolves to the encoded image data. Note that the `blob.type` may differ from `mimeType` if it was not supported.\n */\nexport const EncodeImageAsync = EncodingHelper.EncodeImageAsync;\n/**\n * Dumps the current bound framebuffer\n * @param width defines the rendering width\n * @param height defines the rendering height\n * @param engine defines the hosting engine\n * @param successCallback defines the callback triggered once the data are available\n * @param mimeType defines the mime type of the result\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns a void promise\n */\n// Should have \"Async\" in the name but this is a public API and we can't break it now\n// eslint-disable-next-line no-restricted-syntax\nexport async function DumpFramebuffer(width, height, engine, successCallback, mimeType = \"image/png\", fileName, quality) {\n    // Read the contents of the framebuffer\n    const bufferView = await engine.readPixels(0, 0, width, height);\n    const data = new Uint8Array(bufferView.buffer);\n    DumpData(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);\n}\n/**\n * Dumps an array buffer\n * @param width defines the rendering width\n * @param height defines the rendering height\n * @param data the data array\n * @param mimeType defines the mime type of the result\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n * @param invertY true to invert the picture in the Y dimension\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns a promise that resolve to the final data\n */\nexport async function DumpDataAsync(width, height, data, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    // Convert if data are float32\n    if (data instanceof Float32Array) {\n        const data2 = new Uint8Array(data.length);\n        let n = data.length;\n        while (n--) {\n            const v = data[n];\n            data2[n] = Math.round(Clamp(v) * 255);\n        }\n        data = data2;\n    }\n    const blob = await EncodingHelper.EncodeImageAsync(data, width, height, mimeType, invertY, quality);\n    if (fileName !== undefined) {\n        Tools.DownloadBlob(blob, fileName);\n    }\n    if (blob.type !== mimeType) {\n        Logger.Warn(`DumpData: The requested mimeType '${mimeType}' is not supported. The result has mimeType '${blob.type}' instead.`);\n    }\n    const buffer = await blob.arrayBuffer();\n    if (toArrayBuffer) {\n        return buffer;\n    }\n    return `data:${mimeType};base64,${EncodeArrayBufferToBase64(buffer)}`;\n}\n/**\n * Dumps an array buffer\n * @param width defines the rendering width\n * @param height defines the rendering height\n * @param data the data array\n * @param successCallback defines the callback triggered once the data are available\n * @param mimeType defines the mime type of the result\n * @param fileName The name of the file to download. If present, the result will automatically be downloaded. If not defined, and `successCallback` is also not defined, the result will automatically be downloaded with an auto-generated file name.\n * @param invertY true to invert the picture in the Y dimension\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n */\nexport function DumpData(width, height, data, successCallback, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    // For back-compat: if no fileName and no callback, force download the result\n    if (fileName === undefined && !successCallback) {\n        fileName = \"\";\n    }\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    DumpDataAsync(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality)\n        // eslint-disable-next-line github/no-then\n        .then((result) => {\n        if (successCallback) {\n            successCallback(result);\n        }\n    });\n}\n/**\n * Dispose the dump tools associated resources\n */\nexport function Dispose() {\n    if (!ResourcesPromise) {\n        return;\n    }\n    // in cases where the engine is not yet created, we need to wait for it to dispose it\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n    ResourcesPromise?.then((resources) => {\n        if (resources.canvas instanceof HTMLCanvasElement) {\n            resources.canvas.remove();\n        }\n        if (resources.dumpEngine) {\n            resources.dumpEngine.engine.dispose();\n            resources.dumpEngine.renderer.dispose();\n            resources.dumpEngine.wrapper.dispose();\n        }\n    });\n    ResourcesPromise = null;\n}\n/**\n * Object containing a set of static utilities functions to dump data from a canvas\n * @deprecated use functions\n */\nexport const DumpTools = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DumpData,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DumpDataAsync,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DumpFramebuffer,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Dispose,\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst InitSideEffects = () => {\n    // References the dependencies.\n    Tools.DumpData = DumpData;\n    Tools.DumpDataAsync = DumpDataAsync;\n    Tools.DumpFramebuffer = DumpFramebuffer;\n};\nInitSideEffects();\n//# sourceMappingURL=dumpTools.js.map"],"file":"BWOjRsQS.js"}