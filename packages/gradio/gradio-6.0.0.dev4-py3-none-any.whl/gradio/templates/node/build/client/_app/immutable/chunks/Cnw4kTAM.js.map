{"version":3,"file":"Cnw4kTAM.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Math/flowGraphMatrixMathBlocks.js"],"sourcesContent":["import { FlowGraphBlock } from \"../../../flowGraphBlock.js\";\nimport { getRichTypeByFlowGraphType, RichTypeBoolean, RichTypeMatrix, RichTypeNumber, RichTypeQuaternion, RichTypeVector3, } from \"../../../flowGraphRichTypes.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { FlowGraphUnaryOperationBlock } from \"../flowGraphUnaryOperationBlock.js\";\nimport { FlowGraphBinaryOperationBlock } from \"../flowGraphBinaryOperationBlock.js\";\n/**\n * Transposes a matrix.\n */\nexport class FlowGraphTransposeBlock extends FlowGraphUnaryOperationBlock {\n    /**\n     * Creates a new instance of the block.\n     * @param config the configuration of the block\n     */\n    constructor(config) {\n        super(getRichTypeByFlowGraphType(config?.matrixType || \"Matrix\" /* FlowGraphTypes.Matrix */), getRichTypeByFlowGraphType(config?.matrixType || \"Matrix\" /* FlowGraphTypes.Matrix */), (a) => (a.transpose ? a.transpose() : Matrix.Transpose(a)), \"FlowGraphTransposeBlock\" /* FlowGraphBlockNames.Transpose */, config);\n    }\n}\nRegisterClass(\"FlowGraphTransposeBlock\" /* FlowGraphBlockNames.Transpose */, FlowGraphTransposeBlock);\n/**\n * Gets the determinant of a matrix.\n */\nexport class FlowGraphDeterminantBlock extends FlowGraphUnaryOperationBlock {\n    /**\n     * Creates a new instance of the block.\n     * @param config the configuration of the block\n     */\n    constructor(config) {\n        super(getRichTypeByFlowGraphType(config?.matrixType || \"Matrix\" /* FlowGraphTypes.Matrix */), RichTypeNumber, (a) => a.determinant(), \"FlowGraphDeterminantBlock\" /* FlowGraphBlockNames.Determinant */, config);\n    }\n}\nRegisterClass(\"FlowGraphDeterminantBlock\" /* FlowGraphBlockNames.Determinant */, FlowGraphDeterminantBlock);\n/**\n * Inverts a matrix.\n */\nexport class FlowGraphInvertMatrixBlock extends FlowGraphUnaryOperationBlock {\n    /**\n     * Creates a new instance of the inverse block.\n     * @param config the configuration of the block\n     */\n    constructor(config) {\n        super(getRichTypeByFlowGraphType(config?.matrixType || \"Matrix\" /* FlowGraphTypes.Matrix */), getRichTypeByFlowGraphType(config?.matrixType || \"Matrix\" /* FlowGraphTypes.Matrix */), (a) => (a.inverse ? a.inverse() : Matrix.Invert(a)), \"FlowGraphInvertMatrixBlock\" /* FlowGraphBlockNames.InvertMatrix */, config);\n    }\n}\nRegisterClass(\"FlowGraphInvertMatrixBlock\" /* FlowGraphBlockNames.InvertMatrix */, FlowGraphInvertMatrixBlock);\n/**\n * Multiplies two matrices.\n */\nexport class FlowGraphMatrixMultiplicationBlock extends FlowGraphBinaryOperationBlock {\n    /**\n     * Creates a new instance of the multiplication block.\n     * Note - this is similar to the math multiplication if not using matrix per-component multiplication.\n     * @param config the configuration of the block\n     */\n    constructor(config) {\n        super(getRichTypeByFlowGraphType(config?.matrixType || \"Matrix\" /* FlowGraphTypes.Matrix */), getRichTypeByFlowGraphType(config?.matrixType || \"Matrix\" /* FlowGraphTypes.Matrix */), getRichTypeByFlowGraphType(config?.matrixType || \"Matrix\" /* FlowGraphTypes.Matrix */), (a, b) => b.multiply(a), \"FlowGraphMatrixMultiplicationBlock\" /* FlowGraphBlockNames.MatrixMultiplication */, config);\n    }\n}\nRegisterClass(\"FlowGraphMatrixMultiplicationBlock\" /* FlowGraphBlockNames.MatrixMultiplication */, FlowGraphMatrixMultiplicationBlock);\n/**\n * Matrix decompose block\n */\nexport class FlowGraphMatrixDecomposeBlock extends FlowGraphBlock {\n    constructor(config) {\n        super(config);\n        this.input = this.registerDataInput(\"input\", RichTypeMatrix);\n        this.position = this.registerDataOutput(\"position\", RichTypeVector3);\n        this.rotationQuaternion = this.registerDataOutput(\"rotationQuaternion\", RichTypeQuaternion);\n        this.scaling = this.registerDataOutput(\"scaling\", RichTypeVector3);\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeBoolean, false);\n    }\n    _updateOutputs(context) {\n        const cachedExecutionId = context._getExecutionVariable(this, \"executionId\", -1);\n        const cachedPosition = context._getExecutionVariable(this, \"cachedPosition\", null);\n        const cachedRotation = context._getExecutionVariable(this, \"cachedRotation\", null);\n        const cachedScaling = context._getExecutionVariable(this, \"cachedScaling\", null);\n        if (cachedExecutionId === context.executionId && cachedPosition && cachedRotation && cachedScaling) {\n            this.position.setValue(cachedPosition, context);\n            this.rotationQuaternion.setValue(cachedRotation, context);\n            this.scaling.setValue(cachedScaling, context);\n        }\n        else {\n            const matrix = this.input.getValue(context);\n            const position = cachedPosition || new Vector3();\n            const rotation = cachedRotation || new Quaternion();\n            const scaling = cachedScaling || new Vector3();\n            // check matrix last column components should be 0,0,0,1\n            // round them to 4 decimal places\n            const m3 = Math.round(matrix.m[3] * 10000) / 10000;\n            const m7 = Math.round(matrix.m[7] * 10000) / 10000;\n            const m11 = Math.round(matrix.m[11] * 10000) / 10000;\n            const m15 = Math.round(matrix.m[15] * 10000) / 10000;\n            if (m3 !== 0 || m7 !== 0 || m11 !== 0 || m15 !== 1) {\n                this.isValid.setValue(false, context);\n                this.position.setValue(Vector3.Zero(), context);\n                this.rotationQuaternion.setValue(Quaternion.Identity(), context);\n                this.scaling.setValue(Vector3.One(), context);\n                return;\n            }\n            // make the checks for validity\n            const valid = matrix.decompose(scaling, rotation, position);\n            this.isValid.setValue(valid, context);\n            this.position.setValue(position, context);\n            this.rotationQuaternion.setValue(rotation, context);\n            this.scaling.setValue(scaling, context);\n            context._setExecutionVariable(this, \"cachedPosition\", position);\n            context._setExecutionVariable(this, \"cachedRotation\", rotation);\n            context._setExecutionVariable(this, \"cachedScaling\", scaling);\n            context._setExecutionVariable(this, \"executionId\", context.executionId);\n        }\n    }\n    getClassName() {\n        return \"FlowGraphMatrixDecompose\" /* FlowGraphBlockNames.MatrixDecompose */;\n    }\n}\nRegisterClass(\"FlowGraphMatrixDecompose\" /* FlowGraphBlockNames.MatrixDecompose */, FlowGraphMatrixDecomposeBlock);\n/**\n * Matrix compose block\n */\nexport class FlowGraphMatrixComposeBlock extends FlowGraphBlock {\n    constructor(config) {\n        super(config);\n        this.position = this.registerDataInput(\"position\", RichTypeVector3);\n        this.rotationQuaternion = this.registerDataInput(\"rotationQuaternion\", RichTypeQuaternion);\n        this.scaling = this.registerDataInput(\"scaling\", RichTypeVector3);\n        this.value = this.registerDataOutput(\"value\", RichTypeMatrix);\n    }\n    _updateOutputs(context) {\n        const cachedExecutionId = context._getExecutionVariable(this, \"executionId\", -1);\n        const cachedMatrix = context._getExecutionVariable(this, \"cachedMatrix\", null);\n        if (cachedExecutionId === context.executionId && cachedMatrix) {\n            this.value.setValue(cachedMatrix, context);\n        }\n        else {\n            const matrix = Matrix.Compose(this.scaling.getValue(context), this.rotationQuaternion.getValue(context), this.position.getValue(context));\n            this.value.setValue(matrix, context);\n            context._setExecutionVariable(this, \"cachedMatrix\", matrix);\n            context._setExecutionVariable(this, \"executionId\", context.executionId);\n        }\n    }\n    getClassName() {\n        return \"FlowGraphMatrixCompose\" /* FlowGraphBlockNames.MatrixCompose */;\n    }\n}\nRegisterClass(\"FlowGraphMatrixCompose\" /* FlowGraphBlockNames.MatrixCompose */, FlowGraphMatrixComposeBlock);\n//# sourceMappingURL=flowGraphMatrixMathBlocks.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0]}