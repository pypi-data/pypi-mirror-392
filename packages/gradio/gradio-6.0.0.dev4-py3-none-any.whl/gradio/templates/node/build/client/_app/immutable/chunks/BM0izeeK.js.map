{"version":3,"file":"BM0izeeK.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Bones/skeleton.js"],"sourcesContent":["import { Bone } from \"./bone.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Animation } from \"../Animations/animation.js\";\nimport { AnimationRange } from \"../Animations/animationRange.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n    /**\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get useTextureToStoreBoneMatrices() {\n        return this._useTextureToStoreBoneMatrices;\n    }\n    set useTextureToStoreBoneMatrices(value) {\n        this._useTextureToStoreBoneMatrices = value;\n        this._markAsDirty();\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        if (!this._animationPropertiesOverride) {\n            return this._scene.animationPropertiesOverride;\n        }\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /**\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n     */\n    get isUsingTextureForMatrices() {\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    }\n    /**\n     * Gets the unique ID of this skeleton\n     */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /**\n     * Creates a new skeleton\n     * @param name defines the skeleton name\n     * @param id defines the skeleton Id\n     * @param scene defines the hosting scene\n     */\n    constructor(\n    /** defines the skeleton name */\n    name, \n    /** defines the skeleton Id */\n    id, scene) {\n        this.name = name;\n        this.id = id;\n        /**\n         * Defines the list of child bones\n         */\n        this.bones = [];\n        /**\n         * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n         */\n        this.needInitialSkinMatrix = false;\n        this._isDirty = true;\n        this._meshesWithPoseMatrix = new Array();\n        this._identity = Matrix.Identity();\n        this._currentRenderId = -1;\n        this._ranges = {};\n        this._absoluteTransformIsDirty = true;\n        this._canUseTextureForBones = false;\n        this._uniqueId = 0;\n        /** @internal */\n        this._numBonesWithLinkedTransformNode = 0;\n        /** @internal */\n        this._hasWaitingData = null;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * Specifies if the skeleton should be serialized\n         */\n        this.doNotSerialize = false;\n        this._useTextureToStoreBoneMatrices = true;\n        this._animationPropertiesOverride = null;\n        // Events\n        /**\n         * An observable triggered before computing the skeleton's matrices\n         */\n        this.onBeforeComputeObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the skeleton\n         */\n        this.metadata = null;\n        this.bones = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._uniqueId = this._scene.getUniqueId();\n        this._scene.addSkeleton(this);\n        //make sure it will recalculate the matrix next time prepare is called.\n        this._isDirty = true;\n        const engineCaps = this._scene.getEngine().getCaps();\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Skeleton\";\n    }\n    /**\n     * Returns an array containing the root bones\n     * @returns an array containing the root bones\n     */\n    getChildren() {\n        return this.bones.filter((b) => !b.getParent());\n    }\n    // Members\n    /**\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a Float32Array containing matrices data\n     */\n    getTransformMatrices(mesh) {\n        if (this.needInitialSkinMatrix) {\n            if (!mesh) {\n                throw new Error(\"getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided\");\n            }\n            if (!mesh._bonesTransformMatrices) {\n                this.prepare(true);\n            }\n            return mesh._bonesTransformMatrices;\n        }\n        if (!this._transformMatrices || this._isDirty) {\n            this.prepare(!this._transformMatrices);\n        }\n        return this._transformMatrices;\n    }\n    /**\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a raw texture containing the data\n     */\n    getTransformMatrixTexture(mesh) {\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n            return mesh._transformMatrixTexture;\n        }\n        return this._transformMatrixTexture;\n    }\n    /**\n     * Gets the current hosting scene\n     * @returns a scene object\n     */\n    getScene() {\n        return this._scene;\n    }\n    // Methods\n    /**\n     * Gets a string representing the current skeleton data\n     * @param fullDetails defines a boolean indicating if we want a verbose version\n     * @returns a string representing the current skeleton data\n     */\n    toString(fullDetails) {\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n        if (fullDetails) {\n            ret += \", Ranges: {\";\n            let first = true;\n            for (const name in this._ranges) {\n                if (first) {\n                    ret += \", \";\n                    first = false;\n                }\n                ret += name;\n            }\n            ret += \"}\";\n        }\n        return ret;\n    }\n    /**\n     * Get bone's index searching by name\n     * @param name defines bone's name to search for\n     * @returns the indice of the bone. Returns -1 if not found\n     */\n    getBoneIndexByName(name) {\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n            if (this.bones[boneIndex].name === name) {\n                return boneIndex;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Create a new animation range\n     * @param name defines the name of the range\n     * @param from defines the start key\n     * @param to defines the end key\n     */\n    createAnimationRange(name, from, to) {\n        // check name not already in use\n        if (!this._ranges[name]) {\n            this._ranges[name] = new AnimationRange(name, from, to);\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n                if (this.bones[i].animations[0]) {\n                    this.bones[i].animations[0].createRange(name, from, to);\n                }\n            }\n        }\n    }\n    /**\n     * Delete a specific animation range\n     * @param name defines the name of the range\n     * @param deleteFrames defines if frames must be removed as well\n     */\n    deleteAnimationRange(name, deleteFrames = true) {\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\n            }\n        }\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n    }\n    /**\n     * Gets a specific animation range\n     * @param name defines the name of the range to look for\n     * @returns the requested animation range or null if not found\n     */\n    getAnimationRange(name) {\n        return this._ranges[name] || null;\n    }\n    /**\n     * Gets the list of all animation ranges defined on this skeleton\n     * @returns an array\n     */\n    getAnimationRanges() {\n        const animationRanges = [];\n        let name;\n        for (name in this._ranges) {\n            animationRanges.push(this._ranges[name]);\n        }\n        return animationRanges;\n    }\n    /**\n     * Copy animation range from a source skeleton.\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n     * @param source defines the source skeleton\n     * @param name defines the name of the range to copy\n     * @param rescaleAsRequired defines if rescaling must be applied if required\n     * @returns true if operation was successful\n     */\n    copyAnimationRange(source, name, rescaleAsRequired = false) {\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\n            return false;\n        }\n        let ret = true;\n        const frameOffset = this._getHighestAnimationFrame() + 1;\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n        const boneDict = {};\n        const sourceBones = source.bones;\n        let nBones;\n        let i;\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n            boneDict[sourceBones[i].name] = sourceBones[i];\n        }\n        if (this.bones.length !== sourceBones.length) {\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n            ret = false;\n        }\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n            const boneName = this.bones[i].name;\n            const sourceBone = boneDict[boneName];\n            if (sourceBone) {\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n            }\n            else {\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n                ret = false;\n            }\n        }\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\n        const range = source.getAnimationRange(name);\n        if (range) {\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n        }\n        return ret;\n    }\n    /**\n     * Forces the skeleton to go to rest pose\n     */\n    returnToRest() {\n        for (const bone of this.bones) {\n            if (bone._index !== -1) {\n                bone.returnToRest();\n            }\n        }\n    }\n    _getHighestAnimationFrame() {\n        let ret = 0;\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                const highest = this.bones[i].animations[0].getHighestFrame();\n                if (ret < highest) {\n                    ret = highest;\n                }\n            }\n        }\n        return ret;\n    }\n    /**\n     * Begin a specific animation range\n     * @param name defines the name of the range to start\n     * @param loop defines if looping must be turned on (false by default)\n     * @param speedRatio defines the speed ratio to apply (1 by default)\n     * @param onAnimationEnd defines a callback which will be called when animation will end\n     * @returns a new animatable\n     */\n    beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n        const range = this.getAnimationRange(name);\n        if (!range) {\n            return null;\n        }\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n    }\n    /**\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n     * @param skeleton defines the Skeleton containing the animation range to convert\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n     * @returns the original skeleton\n     */\n    static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n        const rangeValue = skeleton.getAnimationRange(range);\n        // We can't make a range additive if it doesn't exist\n        if (!rangeValue) {\n            return null;\n        }\n        // Find any current scene-level animatable belonging to the target that matches the range\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n        let rangeAnimatable = null;\n        for (let index = 0; index < sceneAnimatables.length; index++) {\n            const sceneAnimatable = sceneAnimatables[index];\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\n                rangeAnimatable = sceneAnimatable;\n                break;\n            }\n        }\n        // Convert the animations belonging to the skeleton to additive keyframes\n        const animatables = skeleton.getAnimatables();\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            const animations = animatable.animations;\n            if (!animations) {\n                continue;\n            }\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n            }\n        }\n        // Mark the scene-level animatable as additive\n        if (rangeAnimatable) {\n            rangeAnimatable.isAdditive = true;\n        }\n        return skeleton;\n    }\n    /** @internal */\n    _markAsDirty() {\n        this._isDirty = true;\n        this._absoluteTransformIsDirty = true;\n    }\n    /**\n     * @internal\n     */\n    _registerMeshWithPoseMatrix(mesh) {\n        this._meshesWithPoseMatrix.push(mesh);\n    }\n    /**\n     * @internal\n     */\n    _unregisterMeshWithPoseMatrix(mesh) {\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\n        if (index > -1) {\n            this._meshesWithPoseMatrix.splice(index, 1);\n        }\n    }\n    _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n        this.onBeforeComputeObservable.notifyObservers(this);\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            bone._childUpdateId++;\n            const parentBone = bone.getParent();\n            if (parentBone) {\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\n            }\n            else {\n                if (initialSkinMatrix) {\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\n                }\n                else {\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\n                }\n            }\n            if (bone._index !== -1) {\n                const mappedIndex = bone._index === null ? index : bone._index;\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\n            }\n        }\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n    }\n    /**\n     * Build all resources required to render a skeleton\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\n     */\n    prepare(dontCheckFrameId = false) {\n        if (!dontCheckFrameId) {\n            const currentRenderId = this.getScene().getRenderId();\n            if (this._currentRenderId === currentRenderId) {\n                return;\n            }\n            this._currentRenderId = currentRenderId;\n        }\n        // Update the local matrix of bones with linked transform nodes.\n        if (this._numBonesWithLinkedTransformNode > 0) {\n            for (const bone of this.bones) {\n                if (bone._linkedTransformNode) {\n                    const node = bone._linkedTransformNode;\n                    bone.position = node.position;\n                    if (node.rotationQuaternion) {\n                        bone.rotationQuaternion = node.rotationQuaternion;\n                    }\n                    else {\n                        bone.rotation = node.rotation;\n                    }\n                    bone.scaling = node.scaling;\n                }\n            }\n        }\n        if (this.needInitialSkinMatrix) {\n            for (const mesh of this._meshesWithPoseMatrix) {\n                const poseMatrix = mesh.getPoseMatrix();\n                let needsUpdate = this._isDirty;\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                    needsUpdate = true;\n                }\n                if (!needsUpdate) {\n                    continue;\n                }\n                if (this._synchronizedWithMesh !== mesh) {\n                    this._synchronizedWithMesh = mesh;\n                    // Prepare bones\n                    for (const bone of this.bones) {\n                        if (!bone.getParent()) {\n                            const matrix = bone.getBindMatrix();\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\n                        }\n                    }\n                    if (this.isUsingTextureForMatrices) {\n                        const textureWidth = (this.bones.length + 1) * 4;\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n                            if (mesh._transformMatrixTexture) {\n                                mesh._transformMatrixTexture.dispose();\n                            }\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n                        }\n                    }\n                }\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n                }\n            }\n        }\n        else {\n            if (!this._isDirty) {\n                return;\n            }\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                if (this.isUsingTextureForMatrices) {\n                    if (this._transformMatrixTexture) {\n                        this._transformMatrixTexture.dispose();\n                    }\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n                }\n            }\n            this._computeTransformMatrices(this._transformMatrices, null);\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n                this._transformMatrixTexture.update(this._transformMatrices);\n            }\n        }\n        this._isDirty = false;\n    }\n    /**\n     * Gets the list of animatables currently running for this skeleton\n     * @returns an array of animatables\n     */\n    getAnimatables() {\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\n            this._animatables = [];\n            for (let index = 0; index < this.bones.length; index++) {\n                this._animatables.push(this.bones[index]);\n            }\n        }\n        return this._animatables;\n    }\n    /**\n     * Clone the current skeleton\n     * @param name defines the name of the new skeleton\n     * @param id defines the id of the new skeleton\n     * @returns the new skeleton\n     */\n    clone(name, id) {\n        const result = new Skeleton(name, id || name, this._scene);\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        result.metadata = this.metadata;\n        for (let index = 0; index < this.bones.length; index++) {\n            const source = this.bones[index];\n            let parentBone = null;\n            const parent = source.getParent();\n            if (parent) {\n                const parentIndex = this.bones.indexOf(parent);\n                parentBone = result.bones[parentIndex];\n            }\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\n            bone._index = source._index;\n            if (source._linkedTransformNode) {\n                bone.linkTransformNode(source._linkedTransformNode);\n            }\n            DeepCopier.DeepCopy(source.animations, bone.animations);\n        }\n        if (this._ranges) {\n            result._ranges = {};\n            for (const rangeName in this._ranges) {\n                const range = this._ranges[rangeName];\n                if (range) {\n                    result._ranges[rangeName] = range.clone();\n                }\n            }\n        }\n        this._isDirty = true;\n        result.prepare(true);\n        return result;\n    }\n    /**\n     * Enable animation blending for this skeleton\n     * @param blendingSpeed defines the blending speed to apply\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    enableBlending(blendingSpeed = 0.01) {\n        for (const bone of this.bones) {\n            for (const animation of bone.animations) {\n                animation.enableBlending = true;\n                animation.blendingSpeed = blendingSpeed;\n            }\n        }\n    }\n    /**\n     * Releases all resources associated with the current skeleton\n     */\n    dispose() {\n        this._meshesWithPoseMatrix.length = 0;\n        this.metadata = null;\n        // Animations\n        this.getScene().stopAnimation(this);\n        // Remove from scene\n        this.getScene().removeSkeleton(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.skeletons.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.skeletons.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n            this._transformMatrixTexture = null;\n        }\n    }\n    /**\n     * Serialize the skeleton in a JSON object\n     * @returns a JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.id = this.id;\n        if (this.dimensionsAtRest) {\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n        }\n        serializationObject.bones = [];\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            const parent = bone.getParent();\n            const serializedBone = {\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n                index: bone.getIndex(),\n                name: bone.name,\n                id: bone.id,\n                matrix: bone.getBindMatrix().asArray(),\n                rest: bone.getRestMatrix().asArray(),\n                linkedTransformNodeId: bone.getTransformNode()?.id,\n            };\n            serializationObject.bones.push(serializedBone);\n            if (bone.length) {\n                serializedBone.length = bone.length;\n            }\n            if (bone.metadata) {\n                serializedBone.metadata = bone.metadata;\n            }\n            if (bone.animations && bone.animations.length > 0) {\n                serializedBone.animation = bone.animations[0].serialize();\n            }\n            serializationObject.ranges = [];\n            for (const name in this._ranges) {\n                const source = this._ranges[name];\n                if (!source) {\n                    continue;\n                }\n                const range = {};\n                range.name = name;\n                range.from = source.from;\n                range.to = source.to;\n                serializationObject.ranges.push(range);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a new skeleton from serialized data\n     * @param parsedSkeleton defines the serialized data\n     * @param scene defines the hosting scene\n     * @returns a new skeleton\n     */\n    static Parse(parsedSkeleton, scene) {\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n        if (parsedSkeleton.dimensionsAtRest) {\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n        }\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n        if (parsedSkeleton.metadata) {\n            skeleton.metadata = parsedSkeleton.metadata;\n        }\n        let index;\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\n            const parsedBone = parsedSkeleton.bones[index];\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\n            let parentBone = null;\n            if (parsedBone.parentBoneIndex > -1) {\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n            }\n            const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\n                bone.id = parsedBone.id;\n            }\n            if (parsedBone.length) {\n                bone.length = parsedBone.length;\n            }\n            if (parsedBone.metadata) {\n                bone.metadata = parsedBone.metadata;\n            }\n            if (parsedBone.animation) {\n                bone.animations.push(Animation.Parse(parsedBone.animation));\n            }\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n                skeleton._hasWaitingData = true;\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n            }\n        }\n        // placed after bones, so createAnimationRange can cascade down\n        if (parsedSkeleton.ranges) {\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n                const data = parsedSkeleton.ranges[index];\n                skeleton.createAnimationRange(data.name, data.from, data.to);\n            }\n        }\n        return skeleton;\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     */\n    computeAbsoluteMatrices(forceUpdate = false) {\n        if (this._absoluteTransformIsDirty || forceUpdate) {\n            this.bones[0].computeAbsoluteMatrices();\n            this._absoluteTransformIsDirty = false;\n        }\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     * @deprecated Please use computeAbsoluteMatrices instead\n     */\n    computeAbsoluteTransforms(forceUpdate = false) {\n        this.computeAbsoluteMatrices(forceUpdate);\n    }\n    /**\n     * Gets the root pose matrix\n     * @returns a matrix\n     */\n    getPoseMatrix() {\n        let poseMatrix = null;\n        if (this._meshesWithPoseMatrix.length > 0) {\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n        }\n        return poseMatrix;\n    }\n    /**\n     * Sorts bones per internal index\n     */\n    sortBones() {\n        const bones = [];\n        const visited = new Array(this.bones.length);\n        for (let index = 0; index < this.bones.length; index++) {\n            this._sortBones(index, bones, visited);\n        }\n        this.bones = bones;\n    }\n    _sortBones(index, bones, visited) {\n        if (visited[index]) {\n            return;\n        }\n        visited[index] = true;\n        const bone = this.bones[index];\n        if (!bone) {\n            return;\n        }\n        if (bone._index === undefined) {\n            bone._index = index;\n        }\n        const parentBone = bone.getParent();\n        if (parentBone) {\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n        }\n        bones.push(bone);\n    }\n    /**\n     * Set the current local matrix as the restPose for all bones in the skeleton.\n     */\n    setCurrentPoseAsRest() {\n        for (const b of this.bones) {\n            b.setCurrentPoseAsRest();\n        }\n    }\n}\n//# sourceMappingURL=skeleton.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0]}