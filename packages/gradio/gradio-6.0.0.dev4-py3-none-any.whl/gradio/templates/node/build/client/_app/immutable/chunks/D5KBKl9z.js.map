{"version":3,"file":"D5KBKl9z.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/FlowGraph/flowGraphPathConverterComponent.js","../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Transformers/flowGraphJsonPointerParserBlock.js"],"sourcesContent":["import { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger.js\";\nimport { RichTypeFlowGraphInteger } from \"./flowGraphRichTypes.js\";\nconst PathHasTemplatesRegex = new RegExp(/\\/\\{(\\w+)\\}(?=\\/|$)/g);\n/**\n * @experimental\n * A component that converts a path to an object accessor.\n */\nexport class FlowGraphPathConverterComponent {\n    constructor(path, ownerBlock) {\n        this.path = path;\n        this.ownerBlock = ownerBlock;\n        /**\n         * The templated inputs for the provided path.\n         */\n        this.templatedInputs = [];\n        let match = PathHasTemplatesRegex.exec(path);\n        const templateSet = new Set();\n        while (match) {\n            const [, matchGroup] = match;\n            if (templateSet.has(matchGroup)) {\n                throw new Error(\"Duplicate template variable detected.\");\n            }\n            templateSet.add(matchGroup);\n            this.templatedInputs.push(ownerBlock.registerDataInput(matchGroup, RichTypeFlowGraphInteger, new FlowGraphInteger(0)));\n            match = PathHasTemplatesRegex.exec(path);\n        }\n    }\n    /**\n     * Get the accessor for the path.\n     * @param pathConverter the path converter to use to convert the path to an object accessor.\n     * @param context the context to use.\n     * @returns the accessor for the path.\n     * @throws if the value for a templated input is invalid.\n     */\n    getAccessor(pathConverter, context) {\n        let finalPath = this.path;\n        for (const templatedInput of this.templatedInputs) {\n            const valueToReplace = templatedInput.getValue(context).value;\n            if (typeof valueToReplace !== \"number\" || valueToReplace < 0) {\n                throw new Error(\"Invalid value for templated input.\");\n            }\n            finalPath = finalPath.replace(`{${templatedInput.name}}`, valueToReplace.toString());\n        }\n        return pathConverter.convert(finalPath);\n    }\n}\n//# sourceMappingURL=flowGraphPathConverterComponent.js.map","import { FlowGraphPathConverterComponent } from \"../../../flowGraphPathConverterComponent.js\";\nimport { RichTypeAny } from \"../../../flowGraphRichTypes.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Vector3, Vector4 } from \"../../../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../../../Maths/math.color.js\";\nimport { FlowGraphCachedOperationBlock } from \"../flowGraphCachedOperationBlock.js\";\n/**\n * This block will take a JSON pointer and parse it to get the value from the JSON object.\n * The output is an object and a property name.\n * Optionally, the block can also output the value of the property. This is configurable.\n */\nexport class FlowGraphJsonPointerParserBlock extends FlowGraphCachedOperationBlock {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        super(RichTypeAny, config);\n        this.config = config;\n        this.object = this.registerDataOutput(\"object\", RichTypeAny);\n        this.propertyName = this.registerDataOutput(\"propertyName\", RichTypeAny);\n        this.setterFunction = this.registerDataOutput(\"setFunction\", RichTypeAny, this._setPropertyValue.bind(this));\n        this.getterFunction = this.registerDataOutput(\"getFunction\", RichTypeAny, this._getPropertyValue.bind(this));\n        this.generateAnimationsFunction = this.registerDataOutput(\"generateAnimationsFunction\", RichTypeAny, this._getInterpolationAnimationPropertyInfo.bind(this));\n        this.templateComponent = new FlowGraphPathConverterComponent(config.jsonPointer, this);\n    }\n    _doOperation(context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const value = accessorContainer.info.get(accessorContainer.object);\n        const object = accessorContainer.info.getTarget?.(accessorContainer.object);\n        const propertyName = accessorContainer.info.getPropertyName?.[0](accessorContainer.object);\n        if (!object) {\n            throw new Error(\"Object is undefined\");\n        }\n        else {\n            this.object.setValue(object, context);\n            if (propertyName) {\n                this.propertyName.setValue(propertyName, context);\n            }\n        }\n        return value;\n    }\n    _setPropertyValue(_target, _propertyName, value, context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        if (type.startsWith(\"Color\")) {\n            value = ToColor(value, type);\n        }\n        accessorContainer.info.set?.(value, accessorContainer.object);\n    }\n    _getPropertyValue(_target, _propertyName, context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        const value = accessorContainer.info.get(accessorContainer.object);\n        if (type.startsWith(\"Color\")) {\n            return FromColor(value);\n        }\n        return value;\n    }\n    _getInterpolationAnimationPropertyInfo(_target, _propertyName, context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        return (keys, fps, animationType, easingFunction) => {\n            const animations = [];\n            // make sure keys are of the right type (in case of float3 color/vector)\n            const type = accessorContainer.info.type;\n            if (type.startsWith(\"Color\")) {\n                keys = keys.map((key) => {\n                    return {\n                        frame: key.frame,\n                        value: ToColor(key.value, type),\n                    };\n                });\n            }\n            accessorContainer.info.interpolation?.forEach((info, index) => {\n                const name = accessorContainer.info.getPropertyName?.[index](accessorContainer.object) || \"Animation-interpolation-\" + index;\n                // generate the keys based on interpolation info\n                let newKeys = keys;\n                if (animationType !== info.type) {\n                    // convert the keys to the right type\n                    newKeys = keys.map((key) => {\n                        return {\n                            frame: key.frame,\n                            value: info.getValue(undefined, key.value.asArray ? key.value.asArray() : [key.value], 0, 1),\n                        };\n                    });\n                }\n                const animationData = info.buildAnimations(accessorContainer.object, name, 60, newKeys);\n                for (const animation of animationData) {\n                    if (easingFunction) {\n                        animation.babylonAnimation.setEasingFunction(easingFunction);\n                    }\n                    animations.push(animation.babylonAnimation);\n                }\n            });\n            return animations;\n        };\n    }\n    /**\n     * Gets the class name of this block\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FlowGraphJsonPointerParserBlock\" /* FlowGraphBlockNames.JsonPointerParser */;\n    }\n}\nfunction ToColor(value, expectedValue) {\n    if (value.getClassName().startsWith(\"Color\")) {\n        return value;\n    }\n    if (expectedValue === \"Color3\") {\n        return new Color3(value.x, value.y, value.z);\n    }\n    else if (expectedValue === \"Color4\") {\n        return new Color4(value.x, value.y, value.z, value.w);\n    }\n    return value;\n}\nfunction FromColor(value) {\n    if (value instanceof Color3) {\n        return new Vector3(value.r, value.g, value.b);\n    }\n    else if (value instanceof Color4) {\n        return new Vector4(value.r, value.g, value.b, value.a);\n    }\n    throw new Error(\"Invalid color type\");\n}\nRegisterClass(\"FlowGraphJsonPointerParserBlock\" /* FlowGraphBlockNames.JsonPointerParser */, FlowGraphJsonPointerParserBlock);\n//# sourceMappingURL=flowGraphJsonPointerParserBlock.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0,1]}