{"version":3,"file":"Cs_hASI0.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js"],"sourcesContent":["import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsMatrix, serializeAsVector3 } from \"../../Misc/decorators.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\n\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { SerializationHelper } from \"../../Misc/decorators.serialization.js\";\nimport \"../../Engines/AbstractEngine/abstractEngine.cubeTexture.js\";\n// The default scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\nconst DefaultLodScale = 0.8;\n/**\n * Class for creating a cube texture\n */\nexport class CubeTexture extends BaseTexture {\n    /**\n     * Gets or sets the size of the bounding box associated with the cube texture\n     * When defined, the cubemap will switch to local mode\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n     * @example https://www.babylonjs-playground.com/#RNASML\n     */\n    set boundingBoxSize(value) {\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n            return;\n        }\n        this._boundingBoxSize = value;\n        const scene = this.getScene();\n        if (scene) {\n            scene.markAllMaterialsAsDirty(1);\n        }\n    }\n    /**\n     * Returns the bounding box size\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\n     */\n    get boundingBoxSize() {\n        return this._boundingBoxSize;\n    }\n    /**\n     * Sets texture matrix rotation angle around Y axis in radians.\n     */\n    set rotationY(value) {\n        this._rotationY = value;\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n    }\n    /**\n     * Gets texture matrix rotation angle around Y axis radians.\n     */\n    get rotationY() {\n        return this._rotationY;\n    }\n    /**\n     * Are mip maps generated for this texture or not.\n     */\n    get noMipmap() {\n        return this._noMipmap;\n    }\n    /**\n     * Gets the forced extension (if any)\n     */\n    get forcedExtension() {\n        return this._forcedExtension;\n    }\n    /**\n     * Creates a cube texture from an array of image urls\n     * @param files defines an array of image urls\n     * @param scene defines the hosting scene\n     * @param noMipmap specifies if mip maps are not used\n     * @returns a cube texture\n     */\n    static CreateFromImages(files, scene, noMipmap) {\n        let rootUrlKey = \"\";\n        for (const url of files) {\n            rootUrlKey += url;\n        }\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\n    }\n    /**\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\n     * @param url defines the url of the prefiltered texture\n     * @param scene defines the scene the texture is attached to\n     * @param forcedExtension defines the extension of the file if different from the url\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n     * @returns the prefiltered texture\n     */\n    static CreateFromPrefilteredData(url, scene, forcedExtension = null, createPolynomials = true) {\n        const oldValue = scene.useDelayedTextureLoading;\n        scene.useDelayedTextureLoading = false;\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\n        scene.useDelayedTextureLoading = oldValue;\n        return result;\n    }\n    /**\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\n     * as prefiltered data.\n     * @param rootUrl defines the url of the texture or the root name of the six images\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\n     * @param extensionsOrOptions defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture\n     * @param noMipmap defines if mipmaps should be created or not\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\n     * @param onError defines a callback triggered in case of error during load\n     * @param format defines the internal format to use for the texture once loaded\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n     * @param loaderOptions options to be passed to the loader\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\n     * @returns the cube texture\n     */\n    constructor(rootUrl, sceneOrEngine, extensionsOrOptions = null, noMipmap = false, files = null, onLoad = null, onError = null, format = 5, prefiltered = false, forcedExtension = null, createPolynomials = false, lodScale = DefaultLodScale, lodOffset = 0, loaderOptions, useSRGBBuffer) {\n        super(sceneOrEngine);\n        /**\n         * Observable triggered once the texture has been loaded.\n         */\n        this.onLoadObservable = new Observable();\n        /**\n         * Gets or sets the center of the bounding box associated with the cube texture.\n         * It must define where the camera used to render the texture was set\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\n         */\n        this.boundingBoxPosition = Vector3.Zero();\n        this._rotationY = 0;\n        /** @internal */\n        this._files = null;\n        this._forcedExtension = null;\n        this._extensions = null;\n        this._textureMatrixRefraction = new Matrix();\n        this._buffer = null;\n        this.name = rootUrl;\n        this.url = rootUrl;\n        this._noMipmap = noMipmap;\n        this.hasAlpha = false;\n        this.isCube = true;\n        this._textureMatrix = Matrix.Identity();\n        this.coordinatesMode = Texture.CUBIC_MODE;\n        let extensions = null;\n        let buffer = null;\n        if (extensionsOrOptions !== null && !Array.isArray(extensionsOrOptions)) {\n            extensions = extensionsOrOptions.extensions ?? null;\n            this._noMipmap = extensionsOrOptions.noMipmap ?? false;\n            files = extensionsOrOptions.files ?? null;\n            buffer = extensionsOrOptions.buffer ?? null;\n            this._format = extensionsOrOptions.format ?? 5;\n            prefiltered = extensionsOrOptions.prefiltered ?? false;\n            forcedExtension = extensionsOrOptions.forcedExtension ?? null;\n            this._createPolynomials = extensionsOrOptions.createPolynomials ?? false;\n            this._lodScale = extensionsOrOptions.lodScale ?? DefaultLodScale;\n            this._lodOffset = extensionsOrOptions.lodOffset ?? 0;\n            this._loaderOptions = extensionsOrOptions.loaderOptions;\n            this._useSRGBBuffer = extensionsOrOptions.useSRGBBuffer;\n            onLoad = extensionsOrOptions.onLoad ?? null;\n            onError = extensionsOrOptions.onError ?? null;\n        }\n        else {\n            this._noMipmap = noMipmap;\n            this._format = format;\n            this._createPolynomials = createPolynomials;\n            extensions = extensionsOrOptions;\n            this._loaderOptions = loaderOptions;\n            this._useSRGBBuffer = useSRGBBuffer;\n            this._lodScale = lodScale;\n            this._lodOffset = lodOffset;\n        }\n        if (!rootUrl && !files) {\n            return;\n        }\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files, buffer);\n    }\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"CubeTexture\"\n     */\n    getClassName() {\n        return \"CubeTexture\";\n    }\n    /**\n     * Update the url (and optional buffer) of this texture if url was null during construction.\n     * @param url the url of the texture\n     * @param forcedExtension defines the extension to use\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\n     * @param onError callback called if there was an error during the loading process (defaults to null)\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\n     * @param delayLoad defines if the texture should be loaded now (false by default)\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n     * @param buffer the buffer to use instead of loading from the url\n     */\n    updateURL(url, forcedExtension = null, onLoad = null, prefiltered = false, onError = null, extensions = null, delayLoad = false, files = null, buffer = null) {\n        if (!this.name || this.name.startsWith(\"data:\")) {\n            this.name = url;\n        }\n        this.url = url;\n        if (forcedExtension) {\n            this._forcedExtension = forcedExtension;\n        }\n        const lastDot = url.lastIndexOf(\".\");\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n        const isDDS = extension.indexOf(\".dds\") === 0;\n        const isEnv = extension.indexOf(\".env\") === 0;\n        const isBasis = extension.indexOf(\".basis\") === 0;\n        if (isEnv) {\n            this.gammaSpace = false;\n            this._prefiltered = false;\n            this.anisotropicFilteringLevel = 1;\n        }\n        else {\n            this._prefiltered = prefiltered;\n            if (prefiltered) {\n                this.gammaSpace = false;\n                this.anisotropicFilteringLevel = 1;\n            }\n        }\n        if (files) {\n            this._files = files;\n        }\n        else {\n            if (!isBasis && !isEnv && !isDDS && !extensions) {\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\n            }\n            this._files = this._files || [];\n            this._files.length = 0;\n            if (extensions) {\n                for (let index = 0; index < extensions.length; index++) {\n                    this._files.push(url + extensions[index]);\n                }\n                this._extensions = extensions;\n            }\n        }\n        this._buffer = buffer;\n        if (delayLoad) {\n            this.delayLoadState = 4;\n            this._delayedOnLoad = onLoad;\n            this._delayedOnError = onError;\n        }\n        else {\n            this._loadTexture(onLoad, onError);\n        }\n    }\n    /**\n     * Delays loading of the cube texture\n     * @param forcedExtension defines the extension to use\n     */\n    delayLoad(forcedExtension) {\n        if (this.delayLoadState !== 4) {\n            return;\n        }\n        if (forcedExtension) {\n            this._forcedExtension = forcedExtension;\n        }\n        this.delayLoadState = 1;\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\n    }\n    /**\n     * Returns the reflection texture matrix\n     * @returns the reflection texture matrix\n     */\n    getReflectionTextureMatrix() {\n        return this._textureMatrix;\n    }\n    /**\n     * Sets the reflection texture matrix\n     * @param value Reflection texture matrix\n     */\n    setReflectionTextureMatrix(value) {\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\n            return;\n        }\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n            this.getScene()?.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\n        }\n        this._textureMatrix = value;\n        if (!this.getScene()?.useRightHandedSystem) {\n            return;\n        }\n        const scale = TmpVectors.Vector3[0];\n        const quat = TmpVectors.Quaternion[0];\n        const trans = TmpVectors.Vector3[1];\n        this._textureMatrix.decompose(scale, quat, trans);\n        quat.z *= -1; // these two operations correspond to negating the x and y euler angles\n        quat.w *= -1;\n        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);\n    }\n    /**\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\n     * @returns The refraction matrix\n     */\n    getRefractionTextureMatrix() {\n        return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix;\n    }\n    _loadTexture(onLoad = null, onError = null) {\n        const scene = this.getScene();\n        const oldTexture = this._texture;\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\n        const onLoadProcessing = () => {\n            this.onLoadObservable.notifyObservers(this);\n            if (oldTexture) {\n                oldTexture.dispose();\n                this.getScene()?.markAllMaterialsAsDirty(1);\n            }\n            if (onLoad) {\n                onLoad();\n            }\n        };\n        const errorHandler = (message, exception) => {\n            this._loadingError = true;\n            this._errorObject = { message, exception };\n            if (onError) {\n                onError(message, exception);\n            }\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\n        };\n        if (!this._texture) {\n            if (this._prefiltered) {\n                this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);\n            }\n            else {\n                this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer, this._buffer);\n            }\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\n        }\n        else {\n            if (this._texture.isReady) {\n                Tools.SetImmediate(() => onLoadProcessing());\n            }\n            else {\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\n            }\n        }\n    }\n    /**\n     * Parses text to create a cube texture\n     * @param parsedTexture define the serialized text to read from\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root url of the cube texture\n     * @returns a cube texture\n     */\n    static Parse(parsedTexture, scene, rootUrl) {\n        const texture = SerializationHelper.Parse(() => {\n            let prefiltered = false;\n            if (parsedTexture.prefiltered) {\n                prefiltered = parsedTexture.prefiltered;\n            }\n            return new CubeTexture(rootUrl + (parsedTexture.url ?? parsedTexture.name), scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, undefined, prefiltered, parsedTexture.forcedExtension);\n        }, parsedTexture, scene);\n        // Local Cubemaps\n        if (parsedTexture.boundingBoxPosition) {\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n        }\n        if (parsedTexture.boundingBoxSize) {\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n        }\n        // Animations\n        if (parsedTexture.animations) {\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n                const parsedAnimation = parsedTexture.animations[animationIndex];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n        }\n        return texture;\n    }\n    /**\n     * Makes a clone, or deep copy, of the cube texture\n     * @returns a new cube texture\n     */\n    clone() {\n        let uniqueId = 0;\n        const newCubeTexture = SerializationHelper.Clone(() => {\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);\n            uniqueId = cubeTexture.uniqueId;\n            return cubeTexture;\n        }, this);\n        newCubeTexture.uniqueId = uniqueId;\n        return newCubeTexture;\n    }\n}\n__decorate([\n    serialize()\n], CubeTexture.prototype, \"url\", void 0);\n__decorate([\n    serializeAsVector3()\n], CubeTexture.prototype, \"boundingBoxPosition\", void 0);\n__decorate([\n    serializeAsVector3()\n], CubeTexture.prototype, \"boundingBoxSize\", null);\n__decorate([\n    serialize(\"rotationY\")\n], CubeTexture.prototype, \"rotationY\", null);\n__decorate([\n    serialize(\"files\")\n], CubeTexture.prototype, \"_files\", void 0);\n__decorate([\n    serialize(\"forcedExtension\")\n], CubeTexture.prototype, \"_forcedExtension\", void 0);\n__decorate([\n    serialize(\"extensions\")\n], CubeTexture.prototype, \"_extensions\", void 0);\n__decorate([\n    serializeAsMatrix(\"textureMatrix\")\n], CubeTexture.prototype, \"_textureMatrix\", void 0);\n__decorate([\n    serializeAsMatrix(\"textureMatrixRefraction\")\n], CubeTexture.prototype, \"_textureMatrixRefraction\", void 0);\nTexture._CubeTextureParser = CubeTexture.Parse;\n// Some exporters relies on Tools.Instantiate\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\n//# sourceMappingURL=cubeTexture.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0]}