{"version":3,"file":"webAudioStreamingSound-DS3sS51T.js","sources":["../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/streamingSound.js","../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/streamingSoundInstance.js","../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/webAudio/webAudioStreamingSound.js"],"sourcesContent":["import { AbstractSound } from \"./abstractSound.js\";\n/**\n * Abstract class representing a streaming sound.\n *\n * A streaming sound has a sound buffer that is loaded into memory in chunks as it is played. This allows it to be played\n * more quickly than a static sound, but it also means that it cannot have loop points or playback rate changes.\n *\n * Due to the way streaming sounds are typically implemented, there can be a significant delay when attempting to play\n * a streaming sound for the first time. To prevent this delay, it is recommended to preload instances of the sound\n * using the {@link IStreamingSoundStoredOptions.preloadCount} options, or the {@link preloadInstanceAsync} and\n * {@link preloadInstancesAsync} methods before calling the `play` method.\n *\n * Streaming sounds are created by the {@link CreateStreamingSoundAsync} function.\n */\nexport class StreamingSound extends AbstractSound {\n    constructor(name, engine) {\n        super(name, engine);\n        this._preloadedInstances = new Array();\n    }\n    /**\n     * The number of instances to preload. Defaults to `1`.\n     */\n    get preloadCount() {\n        return this._options.preloadCount ?? 1;\n    }\n    /**\n     * Returns the number of instances that have been preloaded.\n     */\n    get preloadCompletedCount() {\n        return this._preloadedInstances.length;\n    }\n    /**\n     * Preloads an instance of the sound.\n     * @returns A promise that resolves when the instance is preloaded.\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    preloadInstanceAsync() {\n        const instance = this._createInstance();\n        this._addPreloadedInstance(instance);\n        return instance.preloadedPromise;\n    }\n    /**\n     * Preloads the given number of instances of the sound.\n     * @param count - The number of instances to preload.\n     * @returns A promise that resolves when all instances are preloaded.\n     */\n    async preloadInstancesAsync(count) {\n        for (let i = 0; i < count; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.preloadInstanceAsync();\n        }\n        await Promise.all(this._preloadedInstances.map(async (instance) => await instance.preloadedPromise));\n    }\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    play(options = {}) {\n        if (this.state === 5 /* SoundState.Paused */) {\n            this.resume();\n            return;\n        }\n        let instance;\n        if (this.preloadCompletedCount > 0) {\n            instance = this._preloadedInstances[0];\n            instance.startOffset = this.startOffset;\n            this._removePreloadedInstance(instance);\n        }\n        else {\n            instance = this._createInstance();\n        }\n        const onInstanceStateChanged = () => {\n            if (instance.state === 3 /* SoundState.Started */) {\n                this._stopExcessInstances();\n                instance.onStateChangedObservable.removeCallback(onInstanceStateChanged);\n            }\n        };\n        instance.onStateChangedObservable.add(onInstanceStateChanged);\n        options.startOffset ?? (options.startOffset = this.startOffset);\n        options.loop ?? (options.loop = this.loop);\n        options.volume ?? (options.volume = 1);\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n    }\n    /**\n     * Stops the sound.\n     */\n    stop() {\n        this._setState(1 /* SoundState.Stopped */);\n        if (!this._instances) {\n            return;\n        }\n        for (const instance of Array.from(this._instances)) {\n            instance.stop();\n        }\n    }\n    _addPreloadedInstance(instance) {\n        if (!this._preloadedInstances.includes(instance)) {\n            this._preloadedInstances.push(instance);\n        }\n    }\n    _removePreloadedInstance(instance) {\n        const index = this._preloadedInstances.indexOf(instance);\n        if (index !== -1) {\n            this._preloadedInstances.splice(index, 1);\n        }\n    }\n}\n//# sourceMappingURL=streamingSound.js.map","import { Observable } from \"../../Misc/observable.js\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance.js\";\n/** @internal */\nexport class _StreamingSoundInstance extends _AbstractSoundInstance {\n    constructor(sound) {\n        super(sound);\n        /** @internal */\n        this.onReadyObservable = new Observable();\n        /** @internal */\n        this.preloadedPromise = new Promise((resolve, reject) => {\n            this._rejectPreloadedProimse = reject;\n            this._resolvePreloadedPromise = resolve;\n        });\n        this.onErrorObservable.add(this._rejectPreloadedProimse);\n        this.onReadyObservable.add(this._resolvePreloadedPromise);\n    }\n    /** @internal */\n    set startOffset(value) {\n        this._options.startOffset = value;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this.onErrorObservable.clear();\n        this.onReadyObservable.clear();\n        this._resolvePreloadedPromise();\n    }\n}\n//# sourceMappingURL=streamingSoundInstance.js.map","import { Logger } from \"../../Misc/logger.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { StreamingSound } from \"../abstractAudio/streamingSound.js\";\nimport { _StreamingSoundInstance } from \"../abstractAudio/streamingSoundInstance.js\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio.js\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio.js\";\nimport { _CleanUrl } from \"../audioUtils.js\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph.js\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio.js\";\n/** @internal */\nexport class _WebAudioStreamingSound extends StreamingSound {\n    /** @internal */\n    constructor(name, engine, options) {\n        super(name, engine);\n        this._spatial = null;\n        this._spatialAutoUpdate = true;\n        this._spatialMinUpdateTime = 0;\n        this._stereo = null;\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            loop: options.loop ?? false,\n            maxInstances: options.maxInstances ?? Infinity,\n            preloadCount: options.preloadCount ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n        this._subGraph = new _WebAudioStreamingSound._SubGraph(this);\n    }\n    /** @internal */\n    async _initAsync(source, options) {\n        const audioContext = this.engine._audioContext;\n        if (!(audioContext instanceof AudioContext)) {\n            throw new Error(\"Unsupported audio context type.\");\n        }\n        this._audioContext = audioContext;\n        this._source = source;\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        }\n        else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n        await this._subGraph.initAsync(options);\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n        if (this.preloadCount) {\n            await this.preloadInstancesAsync(this.preloadCount);\n        }\n        if (options.autoplay) {\n            this.play(options);\n        }\n        this.engine._addSound(this);\n    }\n    /** @internal */\n    get _inNode() {\n        return this._subGraph._inNode;\n    }\n    /** @internal */\n    get _outNode() {\n        return this._subGraph._outNode;\n    }\n    /** @internal */\n    get spatial() {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n    /** @internal */\n    get stereo() {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._spatial = null;\n        this._stereo = null;\n        this._subGraph.dispose();\n        this.engine._removeSound(this);\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStreamingSound\";\n    }\n    _createInstance() {\n        return new _WebAudioStreamingSoundInstance(this, this._options);\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n        return true;\n    }\n    _initSpatialProperty() {\n        if (!this._spatial) {\n            this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);\n        }\n        return this._spatial;\n    }\n}\n_WebAudioStreamingSound._SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n    get _downstreamNodes() {\n        return this._owner._downstreamNodes ?? null;\n    }\n    get _upstreamNodes() {\n        return this._owner._upstreamNodes ?? null;\n    }\n};\n/** @internal */\nclass _WebAudioStreamingSoundInstance extends _StreamingSoundInstance {\n    constructor(sound, options) {\n        super(sound);\n        this._currentTimeChangedWhilePaused = false;\n        this._enginePlayTime = Infinity;\n        this._enginePauseTime = 0;\n        this._isReady = false;\n        this._isReadyPromise = new Promise((resolve, reject) => {\n            this._resolveIsReadyPromise = resolve;\n            this._rejectIsReadyPromise = reject;\n        });\n        this._onCanPlayThrough = () => {\n            this._isReady = true;\n            this._resolveIsReadyPromise(this._mediaElement);\n            this.onReadyObservable.notifyObservers(this);\n        };\n        this._onEnded = () => {\n            this.onEndedObservable.notifyObservers(this);\n            this.dispose();\n        };\n        this._onError = (reason) => {\n            this._setState(4 /* SoundState.FailedToStart */);\n            this.onErrorObservable.notifyObservers(reason);\n            this._rejectIsReadyPromise(reason);\n            this.dispose();\n        };\n        this._onEngineStateChanged = () => {\n            if (this.engine.state !== \"running\") {\n                return;\n            }\n            if (this._options.loop && this.state === 2 /* SoundState.Starting */) {\n                this.play();\n            }\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        };\n        this._onUserGesture = () => {\n            this.play();\n        };\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n        if (typeof sound._source === \"string\") {\n            this._initFromUrl(sound._source);\n        }\n        else if (Array.isArray(sound._source)) {\n            this._initFromUrls(sound._source);\n        }\n        else if (sound._source instanceof HTMLMediaElement) {\n            this._initFromMediaElement(sound._source);\n        }\n        else {\n            throw new Error(`Invalid streaming sound source (${sound._source}).`);\n        }\n    }\n    /** @internal */\n    get currentTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        const timeSinceLastStart = this._state === 5 /* SoundState.Paused */ ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n    set currentTime(value) {\n        const restart = this._state === 2 /* SoundState.Starting */ || this._state === 3 /* SoundState.Started */;\n        if (restart) {\n            this._mediaElement.pause();\n            this._state = 1 /* SoundState.Stopped */;\n        }\n        this._options.startOffset = value;\n        if (restart) {\n            this.play({ startOffset: value });\n        }\n        else if (this._state === 5 /* SoundState.Paused */) {\n            this._currentTimeChangedWhilePaused = true;\n        }\n    }\n    get _outNode() {\n        return this._volumeNode;\n    }\n    /** @internal */\n    get startTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        return this._enginePlayTime;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this._sourceNode?.disconnect(this._volumeNode);\n        this._sourceNode = null;\n        this._mediaElement.removeEventListener(\"error\", this._onError);\n        this._mediaElement.removeEventListener(\"ended\", this._onEnded);\n        this._mediaElement.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n        for (const source of Array.from(this._mediaElement.children)) {\n            this._mediaElement.removeChild(source);\n        }\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        this.engine.userGestureObservable.removeCallback(this._onUserGesture);\n    }\n    /** @internal */\n    play(options = {}) {\n        if (this._state === 3 /* SoundState.Started */) {\n            return;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        this._mediaElement.loop = this._options.loop;\n        let startOffset = options.startOffset;\n        if (this._currentTimeChangedWhilePaused) {\n            startOffset = this._options.startOffset;\n            this._currentTimeChangedWhilePaused = false;\n        }\n        else if (this._state === 5 /* SoundState.Paused */) {\n            startOffset = this.currentTime + this._options.startOffset;\n        }\n        if (startOffset && startOffset > 0) {\n            this._mediaElement.currentTime = startOffset;\n        }\n        this._volumeNode.gain.value = options.volume ?? 1;\n        this._play();\n    }\n    /** @internal */\n    pause() {\n        if (this._state !== 2 /* SoundState.Starting */ && this._state !== 3 /* SoundState.Started */) {\n            return;\n        }\n        this._setState(5 /* SoundState.Paused */);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n        this._mediaElement.pause();\n    }\n    /** @internal */\n    resume() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            this.play();\n        }\n        else if (this._currentTimeChangedWhilePaused) {\n            this.play();\n        }\n    }\n    /** @internal */\n    stop() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return;\n        }\n        this._stop();\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStreamingSoundInstance\";\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n        return true;\n    }\n    _initFromMediaElement(mediaElement) {\n        Tools.SetCorsBehavior(mediaElement.currentSrc, mediaElement);\n        mediaElement.controls = false;\n        mediaElement.loop = this._options.loop;\n        mediaElement.preload = \"auto\";\n        mediaElement.addEventListener(\"canplaythrough\", this._onCanPlayThrough, { once: true });\n        mediaElement.addEventListener(\"ended\", this._onEnded, { once: true });\n        mediaElement.addEventListener(\"error\", this._onError, { once: true });\n        mediaElement.load();\n        this._sourceNode = new MediaElementAudioSourceNode(this._sound._audioContext, { mediaElement: mediaElement });\n        this._sourceNode.connect(this._volumeNode);\n        if (!this._connect(this._sound)) {\n            throw new Error(\"Connect failed\");\n        }\n        this._mediaElement = mediaElement;\n    }\n    _initFromUrl(url) {\n        const audio = new Audio(_CleanUrl(url));\n        this._initFromMediaElement(audio);\n    }\n    _initFromUrls(urls) {\n        const audio = new Audio();\n        for (const url of urls) {\n            const source = document.createElement(\"source\");\n            source.src = _CleanUrl(url);\n            audio.appendChild(source);\n        }\n        this._initFromMediaElement(audio);\n    }\n    _play() {\n        this._setState(2 /* SoundState.Starting */);\n        if (!this._isReady) {\n            this._playWhenReady();\n            return;\n        }\n        if (this._state !== 2 /* SoundState.Starting */) {\n            return;\n        }\n        if (this.engine.state === \"running\") {\n            const result = this._mediaElement.play();\n            this._enginePlayTime = this.engine.currentTime;\n            this._setState(3 /* SoundState.Started */);\n            // It's possible that the play() method fails on Safari, even if the audio engine's state is \"running\".\n            // This occurs when the audio context is paused by the system and resumed automatically by the audio engine\n            // without a user interaction (e.g. when the Vision Pro exits and reenters immersive mode).\n            // eslint-disable-next-line github/no-then\n            result.catch(() => {\n                this._setState(4 /* SoundState.FailedToStart */);\n                if (this._options.loop) {\n                    this.engine.userGestureObservable.addOnce(this._onUserGesture);\n                }\n            });\n        }\n        else if (this._options.loop) {\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n        else {\n            this.stop();\n            this._setState(4 /* SoundState.FailedToStart */);\n        }\n    }\n    _playWhenReady() {\n        this._isReadyPromise\n            // eslint-disable-next-line github/no-then\n            .then(() => {\n            this._play();\n        })\n            // eslint-disable-next-line github/no-then\n            .catch(() => {\n            Logger.Error(\"Streaming sound instance failed to play\");\n            this._setState(4 /* SoundState.FailedToStart */);\n        });\n    }\n    _stop() {\n        this._mediaElement.pause();\n        this._setState(1 /* SoundState.Stopped */);\n        this._onEnded();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n}\n//# sourceMappingURL=webAudioStreamingSound.js.map"],"names":["StreamingSound","AbstractSound","name","engine","instance","count","i","options","onInstanceStateChanged","index","_StreamingSoundInstance","_AbstractSoundInstance","sound","Observable","resolve","reject","value","_WebAudioStreamingSound","source","audioContext","_HasSpatialAudioOptions","_StereoAudio","_WebAudioStreamingSoundInstance","node","_SpatialWebAudio","_WebAudioBusAndSoundSubGraph","reason","timeSinceLastStart","restart","startOffset","mediaElement","Tools","url","audio","_CleanUrl","urls","result","Logger"],"mappings":"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","x_google_ignoreList":[0,1,2]}