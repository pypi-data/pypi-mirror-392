{"version":3,"file":"input-BWfFfFnB.js","sources":["../../../../node_modules/.pnpm/svelte@5.43.6/node_modules/svelte/src/internal/client/dom/elements/bindings/input.js"],"sourcesContent":["/** @import { Batch } from '../../../reactivity/batch.js' */\nimport { DEV } from 'esm-env';\nimport { render_effect, teardown } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport * as e from '../../../errors.js';\nimport { is } from '../../../proxy.js';\nimport { queue_micro_task } from '../../task.js';\nimport { hydrating } from '../../hydration.js';\nimport { tick, untrack } from '../../../runtime.js';\nimport { is_runes } from '../../../context.js';\nimport { current_batch, previous_batch } from '../../../reactivity/batch.js';\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_value(input, get, set = get) {\n\tvar batches = new WeakSet();\n\n\tlisten_to_event_and_reset_event(input, 'input', async (is_reset) => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\t/** @type {any} */\n\t\tvar value = is_reset ? input.defaultValue : input.value;\n\t\tvalue = is_numberlike_input(input) ? to_number(value) : value;\n\t\tset(value);\n\n\t\tif (current_batch !== null) {\n\t\t\tbatches.add(current_batch);\n\t\t}\n\n\t\t// Because `{#each ...}` blocks work by updating sources inside the flush,\n\t\t// we need to wait a tick before checking to see if we should forcibly\n\t\t// update the input and reset the selection state\n\t\tawait tick();\n\n\t\t// Respect any validation in accessors\n\t\tif (value !== (value = get())) {\n\t\t\tvar start = input.selectionStart;\n\t\t\tvar end = input.selectionEnd;\n\t\t\tvar length = input.value.length;\n\n\t\t\t// the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\n\t\t\t// Restore selection\n\t\t\tif (end !== null) {\n\t\t\t\tvar new_length = input.value.length;\n\t\t\t\t// If cursor was at end and new input is longer, move cursor to new end\n\t\t\t\tif (start === end && end === length && new_length > length) {\n\t\t\t\t\tinput.selectionStart = new_length;\n\t\t\t\t\tinput.selectionEnd = new_length;\n\t\t\t\t} else {\n\t\t\t\t\tinput.selectionStart = start;\n\t\t\t\t\tinput.selectionEnd = Math.min(end, new_length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\t(hydrating && input.defaultValue !== input.value) ||\n\t\t// If defaultValue is set, then value == defaultValue\n\t\t// TODO Svelte 6: remove input.value check and set to empty string?\n\t\t(untrack(get) == null && input.value)\n\t) {\n\t\tset(is_numberlike_input(input) ? to_number(input.value) : input.value);\n\n\t\tif (current_batch !== null) {\n\t\t\tbatches.add(current_batch);\n\t\t}\n\t}\n\n\trender_effect(() => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\tvar value = get();\n\n\t\tif (input === document.activeElement) {\n\t\t\t// we need both, because in non-async mode, render effects run before previous_batch is set\n\t\t\tvar batch = /** @type {Batch} */ (previous_batch ?? current_batch);\n\n\t\t\t// Never rewrite the contents of a focused input. We can get here if, for example,\n\t\t\t// an update is deferred because of async work depending on the input:\n\t\t\t//\n\t\t\t// <input bind:value={query}>\n\t\t\t// <p>{await find(query)}</p>\n\t\t\tif (batches.has(batch)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (is_numberlike_input(input) && value === to_number(input.value)) {\n\t\t\t// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)\n\t\t\treturn;\n\t\t}\n\n\t\tif (input.type === 'date' && !value && !input.value) {\n\t\t\t// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)\n\t\t\t// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)\n\t\t\treturn;\n\t\t}\n\n\t\t// don't set the value of the input if it's the same to allow\n\t\t// minlength to work properly\n\t\tif (value !== input.value) {\n\t\t\t// @ts-expect-error the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\t\t}\n\t});\n}\n\n/** @type {Set<HTMLInputElement[]>} */\nconst pending = new Set();\n\n/**\n * @param {HTMLInputElement[]} inputs\n * @param {null | [number]} group_index\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_group(inputs, group_index, input, get, set = get) {\n\tvar is_checkbox = input.getAttribute('type') === 'checkbox';\n\tvar binding_group = inputs;\n\n\t// needs to be let or related code isn't treeshaken out if it's always false\n\tlet hydration_mismatch = false;\n\n\tif (group_index !== null) {\n\t\tfor (var index of group_index) {\n\t\t\t// @ts-expect-error\n\t\t\tbinding_group = binding_group[index] ??= [];\n\t\t}\n\t}\n\n\tbinding_group.push(input);\n\n\tlisten_to_event_and_reset_event(\n\t\tinput,\n\t\t'change',\n\t\t() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = input.__value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t}\n\n\t\t\tset(value);\n\t\t},\n\t\t// TODO better default value handling\n\t\t() => set(is_checkbox ? [] : null)\n\t);\n\n\trender_effect(() => {\n\t\tvar value = get();\n\n\t\t// If we are hydrating and the value has since changed, then use the update value\n\t\t// from the input instead.\n\t\tif (hydrating && input.defaultChecked !== input.checked) {\n\t\t\thydration_mismatch = true;\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_checkbox) {\n\t\t\tvalue = value || [];\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = value.includes(input.__value);\n\t\t} else {\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = is(input.__value, value);\n\t\t}\n\t});\n\n\tteardown(() => {\n\t\tvar index = binding_group.indexOf(input);\n\n\t\tif (index !== -1) {\n\t\t\tbinding_group.splice(index, 1);\n\t\t}\n\t});\n\n\tif (!pending.has(binding_group)) {\n\t\tpending.add(binding_group);\n\n\t\tqueue_micro_task(() => {\n\t\t\t// necessary to maintain binding group order in all insertion scenarios\n\t\t\tbinding_group.sort((a, b) => (a.compareDocumentPosition(b) === 4 ? -1 : 1));\n\t\t\tpending.delete(binding_group);\n\t\t});\n\t}\n\n\tqueue_micro_task(() => {\n\t\tif (hydration_mismatch) {\n\t\t\tvar value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t} else {\n\t\t\t\tvar hydration_input = binding_group.find((input) => input.checked);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvalue = hydration_input?.__value;\n\t\t\t}\n\n\t\t\tset(value);\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_checked(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', (is_reset) => {\n\t\tvar value = is_reset ? input.defaultChecked : input.checked;\n\t\tset(value);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the update value from the input instead.\n\t\t(hydrating && input.defaultChecked !== input.checked) ||\n\t\t// If defaultChecked is set, then checked == defaultChecked\n\t\tuntrack(get) == null\n\t) {\n\t\tset(input.checked);\n\t}\n\n\trender_effect(() => {\n\t\tvar value = get();\n\t\tinput.checked = Boolean(value);\n\t});\n}\n\n/**\n * @template V\n * @param {Array<HTMLInputElement>} group\n * @param {V} __value\n * @param {boolean} checked\n * @returns {V[]}\n */\nfunction get_binding_group_value(group, __value, checked) {\n\t/** @type {Set<V>} */\n\tvar value = new Set();\n\n\tfor (var i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) {\n\t\t\t// @ts-ignore\n\t\t\tvalue.add(group[i].__value);\n\t\t}\n\t}\n\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement} input\n */\nfunction is_numberlike_input(input) {\n\tvar type = input.type;\n\treturn type === 'number' || type === 'range';\n}\n\n/**\n * @param {string} value\n */\nfunction to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => FileList | null} get\n * @param {(value: FileList | null) => void} set\n */\nexport function bind_files(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', () => {\n\t\tset(input.files);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\thydrating &&\n\t\tinput.files\n\t) {\n\t\tset(input.files);\n\t}\n\n\trender_effect(() => {\n\t\tinput.files = get();\n\t});\n}\n"],"names":["bind_value","input","get","set","batches","listen_to_event_and_reset_event","is_reset","DEV","e.bind_invalid_checkbox_value","value","is_numberlike_input","to_number","current_batch","tick","start","end","length","new_length","hydrating","untrack","render_effect","batch","previous_batch","pending","bind_group","inputs","group_index","is_checkbox","binding_group","hydration_mismatch","index","get_binding_group_value","is","teardown","queue_micro_task","b","hydration_input","bind_checked","group","__value","checked","i","type"],"mappings":"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","x_google_ignoreList":[0]}