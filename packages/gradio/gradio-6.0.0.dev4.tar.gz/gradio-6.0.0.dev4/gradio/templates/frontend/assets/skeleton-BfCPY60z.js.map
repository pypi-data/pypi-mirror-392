{"version":3,"file":"skeleton-BfCPY60z.js","sources":["../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Bones/skeleton.js"],"sourcesContent":["import { Bone } from \"./bone.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Animation } from \"../Animations/animation.js\";\nimport { AnimationRange } from \"../Animations/animationRange.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n    /**\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get useTextureToStoreBoneMatrices() {\n        return this._useTextureToStoreBoneMatrices;\n    }\n    set useTextureToStoreBoneMatrices(value) {\n        this._useTextureToStoreBoneMatrices = value;\n        this._markAsDirty();\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        if (!this._animationPropertiesOverride) {\n            return this._scene.animationPropertiesOverride;\n        }\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /**\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n     */\n    get isUsingTextureForMatrices() {\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    }\n    /**\n     * Gets the unique ID of this skeleton\n     */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /**\n     * Creates a new skeleton\n     * @param name defines the skeleton name\n     * @param id defines the skeleton Id\n     * @param scene defines the hosting scene\n     */\n    constructor(\n    /** defines the skeleton name */\n    name, \n    /** defines the skeleton Id */\n    id, scene) {\n        this.name = name;\n        this.id = id;\n        /**\n         * Defines the list of child bones\n         */\n        this.bones = [];\n        /**\n         * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n         */\n        this.needInitialSkinMatrix = false;\n        this._isDirty = true;\n        this._meshesWithPoseMatrix = new Array();\n        this._identity = Matrix.Identity();\n        this._currentRenderId = -1;\n        this._ranges = {};\n        this._absoluteTransformIsDirty = true;\n        this._canUseTextureForBones = false;\n        this._uniqueId = 0;\n        /** @internal */\n        this._numBonesWithLinkedTransformNode = 0;\n        /** @internal */\n        this._hasWaitingData = null;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * Specifies if the skeleton should be serialized\n         */\n        this.doNotSerialize = false;\n        this._useTextureToStoreBoneMatrices = true;\n        this._animationPropertiesOverride = null;\n        // Events\n        /**\n         * An observable triggered before computing the skeleton's matrices\n         */\n        this.onBeforeComputeObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the skeleton\n         */\n        this.metadata = null;\n        this.bones = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._uniqueId = this._scene.getUniqueId();\n        this._scene.addSkeleton(this);\n        //make sure it will recalculate the matrix next time prepare is called.\n        this._isDirty = true;\n        const engineCaps = this._scene.getEngine().getCaps();\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Skeleton\";\n    }\n    /**\n     * Returns an array containing the root bones\n     * @returns an array containing the root bones\n     */\n    getChildren() {\n        return this.bones.filter((b) => !b.getParent());\n    }\n    // Members\n    /**\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a Float32Array containing matrices data\n     */\n    getTransformMatrices(mesh) {\n        if (this.needInitialSkinMatrix) {\n            if (!mesh) {\n                throw new Error(\"getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided\");\n            }\n            if (!mesh._bonesTransformMatrices) {\n                this.prepare(true);\n            }\n            return mesh._bonesTransformMatrices;\n        }\n        if (!this._transformMatrices || this._isDirty) {\n            this.prepare(!this._transformMatrices);\n        }\n        return this._transformMatrices;\n    }\n    /**\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a raw texture containing the data\n     */\n    getTransformMatrixTexture(mesh) {\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n            return mesh._transformMatrixTexture;\n        }\n        return this._transformMatrixTexture;\n    }\n    /**\n     * Gets the current hosting scene\n     * @returns a scene object\n     */\n    getScene() {\n        return this._scene;\n    }\n    // Methods\n    /**\n     * Gets a string representing the current skeleton data\n     * @param fullDetails defines a boolean indicating if we want a verbose version\n     * @returns a string representing the current skeleton data\n     */\n    toString(fullDetails) {\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n        if (fullDetails) {\n            ret += \", Ranges: {\";\n            let first = true;\n            for (const name in this._ranges) {\n                if (first) {\n                    ret += \", \";\n                    first = false;\n                }\n                ret += name;\n            }\n            ret += \"}\";\n        }\n        return ret;\n    }\n    /**\n     * Get bone's index searching by name\n     * @param name defines bone's name to search for\n     * @returns the indice of the bone. Returns -1 if not found\n     */\n    getBoneIndexByName(name) {\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n            if (this.bones[boneIndex].name === name) {\n                return boneIndex;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Create a new animation range\n     * @param name defines the name of the range\n     * @param from defines the start key\n     * @param to defines the end key\n     */\n    createAnimationRange(name, from, to) {\n        // check name not already in use\n        if (!this._ranges[name]) {\n            this._ranges[name] = new AnimationRange(name, from, to);\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n                if (this.bones[i].animations[0]) {\n                    this.bones[i].animations[0].createRange(name, from, to);\n                }\n            }\n        }\n    }\n    /**\n     * Delete a specific animation range\n     * @param name defines the name of the range\n     * @param deleteFrames defines if frames must be removed as well\n     */\n    deleteAnimationRange(name, deleteFrames = true) {\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\n            }\n        }\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n    }\n    /**\n     * Gets a specific animation range\n     * @param name defines the name of the range to look for\n     * @returns the requested animation range or null if not found\n     */\n    getAnimationRange(name) {\n        return this._ranges[name] || null;\n    }\n    /**\n     * Gets the list of all animation ranges defined on this skeleton\n     * @returns an array\n     */\n    getAnimationRanges() {\n        const animationRanges = [];\n        let name;\n        for (name in this._ranges) {\n            animationRanges.push(this._ranges[name]);\n        }\n        return animationRanges;\n    }\n    /**\n     * Copy animation range from a source skeleton.\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n     * @param source defines the source skeleton\n     * @param name defines the name of the range to copy\n     * @param rescaleAsRequired defines if rescaling must be applied if required\n     * @returns true if operation was successful\n     */\n    copyAnimationRange(source, name, rescaleAsRequired = false) {\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\n            return false;\n        }\n        let ret = true;\n        const frameOffset = this._getHighestAnimationFrame() + 1;\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n        const boneDict = {};\n        const sourceBones = source.bones;\n        let nBones;\n        let i;\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n            boneDict[sourceBones[i].name] = sourceBones[i];\n        }\n        if (this.bones.length !== sourceBones.length) {\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n            ret = false;\n        }\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n            const boneName = this.bones[i].name;\n            const sourceBone = boneDict[boneName];\n            if (sourceBone) {\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n            }\n            else {\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n                ret = false;\n            }\n        }\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\n        const range = source.getAnimationRange(name);\n        if (range) {\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n        }\n        return ret;\n    }\n    /**\n     * Forces the skeleton to go to rest pose\n     */\n    returnToRest() {\n        for (const bone of this.bones) {\n            if (bone._index !== -1) {\n                bone.returnToRest();\n            }\n        }\n    }\n    _getHighestAnimationFrame() {\n        let ret = 0;\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                const highest = this.bones[i].animations[0].getHighestFrame();\n                if (ret < highest) {\n                    ret = highest;\n                }\n            }\n        }\n        return ret;\n    }\n    /**\n     * Begin a specific animation range\n     * @param name defines the name of the range to start\n     * @param loop defines if looping must be turned on (false by default)\n     * @param speedRatio defines the speed ratio to apply (1 by default)\n     * @param onAnimationEnd defines a callback which will be called when animation will end\n     * @returns a new animatable\n     */\n    beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n        const range = this.getAnimationRange(name);\n        if (!range) {\n            return null;\n        }\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n    }\n    /**\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n     * @param skeleton defines the Skeleton containing the animation range to convert\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n     * @returns the original skeleton\n     */\n    static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n        const rangeValue = skeleton.getAnimationRange(range);\n        // We can't make a range additive if it doesn't exist\n        if (!rangeValue) {\n            return null;\n        }\n        // Find any current scene-level animatable belonging to the target that matches the range\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n        let rangeAnimatable = null;\n        for (let index = 0; index < sceneAnimatables.length; index++) {\n            const sceneAnimatable = sceneAnimatables[index];\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\n                rangeAnimatable = sceneAnimatable;\n                break;\n            }\n        }\n        // Convert the animations belonging to the skeleton to additive keyframes\n        const animatables = skeleton.getAnimatables();\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            const animations = animatable.animations;\n            if (!animations) {\n                continue;\n            }\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n            }\n        }\n        // Mark the scene-level animatable as additive\n        if (rangeAnimatable) {\n            rangeAnimatable.isAdditive = true;\n        }\n        return skeleton;\n    }\n    /** @internal */\n    _markAsDirty() {\n        this._isDirty = true;\n        this._absoluteTransformIsDirty = true;\n    }\n    /**\n     * @internal\n     */\n    _registerMeshWithPoseMatrix(mesh) {\n        this._meshesWithPoseMatrix.push(mesh);\n    }\n    /**\n     * @internal\n     */\n    _unregisterMeshWithPoseMatrix(mesh) {\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\n        if (index > -1) {\n            this._meshesWithPoseMatrix.splice(index, 1);\n        }\n    }\n    _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n        this.onBeforeComputeObservable.notifyObservers(this);\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            bone._childUpdateId++;\n            const parentBone = bone.getParent();\n            if (parentBone) {\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\n            }\n            else {\n                if (initialSkinMatrix) {\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\n                }\n                else {\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\n                }\n            }\n            if (bone._index !== -1) {\n                const mappedIndex = bone._index === null ? index : bone._index;\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\n            }\n        }\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n    }\n    /**\n     * Build all resources required to render a skeleton\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\n     */\n    prepare(dontCheckFrameId = false) {\n        if (!dontCheckFrameId) {\n            const currentRenderId = this.getScene().getRenderId();\n            if (this._currentRenderId === currentRenderId) {\n                return;\n            }\n            this._currentRenderId = currentRenderId;\n        }\n        // Update the local matrix of bones with linked transform nodes.\n        if (this._numBonesWithLinkedTransformNode > 0) {\n            for (const bone of this.bones) {\n                if (bone._linkedTransformNode) {\n                    const node = bone._linkedTransformNode;\n                    bone.position = node.position;\n                    if (node.rotationQuaternion) {\n                        bone.rotationQuaternion = node.rotationQuaternion;\n                    }\n                    else {\n                        bone.rotation = node.rotation;\n                    }\n                    bone.scaling = node.scaling;\n                }\n            }\n        }\n        if (this.needInitialSkinMatrix) {\n            for (const mesh of this._meshesWithPoseMatrix) {\n                const poseMatrix = mesh.getPoseMatrix();\n                let needsUpdate = this._isDirty;\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                    needsUpdate = true;\n                }\n                if (!needsUpdate) {\n                    continue;\n                }\n                if (this._synchronizedWithMesh !== mesh) {\n                    this._synchronizedWithMesh = mesh;\n                    // Prepare bones\n                    for (const bone of this.bones) {\n                        if (!bone.getParent()) {\n                            const matrix = bone.getBindMatrix();\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\n                        }\n                    }\n                    if (this.isUsingTextureForMatrices) {\n                        const textureWidth = (this.bones.length + 1) * 4;\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n                            if (mesh._transformMatrixTexture) {\n                                mesh._transformMatrixTexture.dispose();\n                            }\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n                        }\n                    }\n                }\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n                }\n            }\n        }\n        else {\n            if (!this._isDirty) {\n                return;\n            }\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                if (this.isUsingTextureForMatrices) {\n                    if (this._transformMatrixTexture) {\n                        this._transformMatrixTexture.dispose();\n                    }\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n                }\n            }\n            this._computeTransformMatrices(this._transformMatrices, null);\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n                this._transformMatrixTexture.update(this._transformMatrices);\n            }\n        }\n        this._isDirty = false;\n    }\n    /**\n     * Gets the list of animatables currently running for this skeleton\n     * @returns an array of animatables\n     */\n    getAnimatables() {\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\n            this._animatables = [];\n            for (let index = 0; index < this.bones.length; index++) {\n                this._animatables.push(this.bones[index]);\n            }\n        }\n        return this._animatables;\n    }\n    /**\n     * Clone the current skeleton\n     * @param name defines the name of the new skeleton\n     * @param id defines the id of the new skeleton\n     * @returns the new skeleton\n     */\n    clone(name, id) {\n        const result = new Skeleton(name, id || name, this._scene);\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        result.metadata = this.metadata;\n        for (let index = 0; index < this.bones.length; index++) {\n            const source = this.bones[index];\n            let parentBone = null;\n            const parent = source.getParent();\n            if (parent) {\n                const parentIndex = this.bones.indexOf(parent);\n                parentBone = result.bones[parentIndex];\n            }\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\n            bone._index = source._index;\n            if (source._linkedTransformNode) {\n                bone.linkTransformNode(source._linkedTransformNode);\n            }\n            DeepCopier.DeepCopy(source.animations, bone.animations);\n        }\n        if (this._ranges) {\n            result._ranges = {};\n            for (const rangeName in this._ranges) {\n                const range = this._ranges[rangeName];\n                if (range) {\n                    result._ranges[rangeName] = range.clone();\n                }\n            }\n        }\n        this._isDirty = true;\n        result.prepare(true);\n        return result;\n    }\n    /**\n     * Enable animation blending for this skeleton\n     * @param blendingSpeed defines the blending speed to apply\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    enableBlending(blendingSpeed = 0.01) {\n        for (const bone of this.bones) {\n            for (const animation of bone.animations) {\n                animation.enableBlending = true;\n                animation.blendingSpeed = blendingSpeed;\n            }\n        }\n    }\n    /**\n     * Releases all resources associated with the current skeleton\n     */\n    dispose() {\n        this._meshesWithPoseMatrix.length = 0;\n        this.metadata = null;\n        // Animations\n        this.getScene().stopAnimation(this);\n        // Remove from scene\n        this.getScene().removeSkeleton(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.skeletons.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.skeletons.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n            this._transformMatrixTexture = null;\n        }\n    }\n    /**\n     * Serialize the skeleton in a JSON object\n     * @returns a JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.id = this.id;\n        if (this.dimensionsAtRest) {\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n        }\n        serializationObject.bones = [];\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            const parent = bone.getParent();\n            const serializedBone = {\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n                index: bone.getIndex(),\n                name: bone.name,\n                id: bone.id,\n                matrix: bone.getBindMatrix().asArray(),\n                rest: bone.getRestMatrix().asArray(),\n                linkedTransformNodeId: bone.getTransformNode()?.id,\n            };\n            serializationObject.bones.push(serializedBone);\n            if (bone.length) {\n                serializedBone.length = bone.length;\n            }\n            if (bone.metadata) {\n                serializedBone.metadata = bone.metadata;\n            }\n            if (bone.animations && bone.animations.length > 0) {\n                serializedBone.animation = bone.animations[0].serialize();\n            }\n            serializationObject.ranges = [];\n            for (const name in this._ranges) {\n                const source = this._ranges[name];\n                if (!source) {\n                    continue;\n                }\n                const range = {};\n                range.name = name;\n                range.from = source.from;\n                range.to = source.to;\n                serializationObject.ranges.push(range);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a new skeleton from serialized data\n     * @param parsedSkeleton defines the serialized data\n     * @param scene defines the hosting scene\n     * @returns a new skeleton\n     */\n    static Parse(parsedSkeleton, scene) {\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n        if (parsedSkeleton.dimensionsAtRest) {\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n        }\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n        if (parsedSkeleton.metadata) {\n            skeleton.metadata = parsedSkeleton.metadata;\n        }\n        let index;\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\n            const parsedBone = parsedSkeleton.bones[index];\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\n            let parentBone = null;\n            if (parsedBone.parentBoneIndex > -1) {\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n            }\n            const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\n                bone.id = parsedBone.id;\n            }\n            if (parsedBone.length) {\n                bone.length = parsedBone.length;\n            }\n            if (parsedBone.metadata) {\n                bone.metadata = parsedBone.metadata;\n            }\n            if (parsedBone.animation) {\n                bone.animations.push(Animation.Parse(parsedBone.animation));\n            }\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n                skeleton._hasWaitingData = true;\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n            }\n        }\n        // placed after bones, so createAnimationRange can cascade down\n        if (parsedSkeleton.ranges) {\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n                const data = parsedSkeleton.ranges[index];\n                skeleton.createAnimationRange(data.name, data.from, data.to);\n            }\n        }\n        return skeleton;\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     */\n    computeAbsoluteMatrices(forceUpdate = false) {\n        if (this._absoluteTransformIsDirty || forceUpdate) {\n            this.bones[0].computeAbsoluteMatrices();\n            this._absoluteTransformIsDirty = false;\n        }\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     * @deprecated Please use computeAbsoluteMatrices instead\n     */\n    computeAbsoluteTransforms(forceUpdate = false) {\n        this.computeAbsoluteMatrices(forceUpdate);\n    }\n    /**\n     * Gets the root pose matrix\n     * @returns a matrix\n     */\n    getPoseMatrix() {\n        let poseMatrix = null;\n        if (this._meshesWithPoseMatrix.length > 0) {\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n        }\n        return poseMatrix;\n    }\n    /**\n     * Sorts bones per internal index\n     */\n    sortBones() {\n        const bones = [];\n        const visited = new Array(this.bones.length);\n        for (let index = 0; index < this.bones.length; index++) {\n            this._sortBones(index, bones, visited);\n        }\n        this.bones = bones;\n    }\n    _sortBones(index, bones, visited) {\n        if (visited[index]) {\n            return;\n        }\n        visited[index] = true;\n        const bone = this.bones[index];\n        if (!bone) {\n            return;\n        }\n        if (bone._index === undefined) {\n            bone._index = index;\n        }\n        const parentBone = bone.getParent();\n        if (parentBone) {\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n        }\n        bones.push(bone);\n    }\n    /**\n     * Set the current local matrix as the restPose for all bones in the skeleton.\n     */\n    setCurrentPoseAsRest() {\n        for (const b of this.bones) {\n            b.setCurrentPoseAsRest();\n        }\n    }\n}\n//# sourceMappingURL=skeleton.js.map"],"names":["Skeleton","value","name","id","scene","Matrix","Observable","EngineStore","engineCaps","b","mesh","fullDetails","ret","first","boneIndex","cache","from","to","AnimationRange","nBones","deleteFrames","i","animationRanges","source","rescaleAsRequired","frameOffset","boneDict","sourceBones","Logger","skelDimensionsRatio","boneName","sourceBone","range","bone","highest","loop","speedRatio","onAnimationEnd","skeleton","referenceFrame","rangeValue","sceneAnimatables","rangeAnimatable","index","sceneAnimatable","animatables","animations","animIndex","Animation","targetMatrix","initialSkinMatrix","parentBone","mappedIndex","dontCheckFrameId","currentRenderId","node","poseMatrix","needsUpdate","TmpVectors","textureWidth","RawTexture","result","parent","parentIndex","Bone","DeepCopier","rangeName","blendingSpeed","animation","serializationObject","serializedBone","parsedSkeleton","Vector3","parsedBone","parsedBoneIndex","rest","data","forceUpdate","bones","visited"],"mappings":"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","x_google_ignoreList":[0]}