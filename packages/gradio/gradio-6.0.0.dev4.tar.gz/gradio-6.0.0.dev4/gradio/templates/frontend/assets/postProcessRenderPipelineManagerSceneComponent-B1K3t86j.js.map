{"version":3,"file":"postProcessRenderPipelineManagerSceneComponent-B1K3t86j.js","sources":["../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.js","../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js"],"sourcesContent":["import { Observable } from \"../../Misc/observable.js\";\n/**\n * PostProcessRenderPipelineManager class\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n */\nexport class PostProcessRenderPipelineManager {\n    /**\n     * Initializes a PostProcessRenderPipelineManager\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n     */\n    constructor() {\n        this._renderPipelines = {};\n        this._onNewPipelineAddedObservable = new Observable();\n        this._onPipelineRemovedObservable = new Observable();\n    }\n    /**\n     * An event triggered when a pipeline is added to the manager\n     */\n    get onNewPipelineAddedObservable() {\n        return this._onNewPipelineAddedObservable;\n    }\n    /**\n     * An event triggered when a pipeline is removed from the manager\n     */\n    get onPipelineRemovedObservable() {\n        return this._onPipelineRemovedObservable;\n    }\n    /**\n     * Gets the list of supported render pipelines\n     */\n    get supportedPipelines() {\n        const result = [];\n        for (const renderPipelineName in this._renderPipelines) {\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n                const pipeline = this._renderPipelines[renderPipelineName];\n                if (pipeline.isSupported) {\n                    result.push(pipeline);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Adds a pipeline to the manager\n     * @param renderPipeline The pipeline to add\n     */\n    addPipeline(renderPipeline) {\n        this.removePipeline(renderPipeline._name);\n        this._renderPipelines[renderPipeline._name] = renderPipeline;\n        this._onNewPipelineAddedObservable.notifyObservers(renderPipeline);\n    }\n    /**\n     * Remove the pipeline from the manager\n     * @param renderPipelineName the name of the pipeline to remove\n     */\n    removePipeline(renderPipelineName) {\n        const pipeline = this._renderPipelines[renderPipelineName];\n        if (pipeline) {\n            this._onPipelineRemovedObservable.notifyObservers(pipeline);\n            delete this._renderPipelines[renderPipelineName];\n        }\n    }\n    /**\n     * Attaches a camera to the pipeline\n     * @param renderPipelineName The name of the pipeline to attach to\n     * @param cameras the camera to attach\n     * @param unique if the camera can be attached multiple times to the pipeline\n     */\n    attachCamerasToRenderPipeline(renderPipelineName, cameras, unique = false) {\n        const renderPipeline = this._renderPipelines[renderPipelineName];\n        if (!renderPipeline) {\n            return;\n        }\n        renderPipeline._attachCameras(cameras, unique);\n    }\n    /**\n     * Detaches a camera from the pipeline\n     * @param renderPipelineName The name of the pipeline to detach from\n     * @param cameras the camera to detach\n     */\n    detachCamerasFromRenderPipeline(renderPipelineName, cameras) {\n        const renderPipeline = this._renderPipelines[renderPipelineName];\n        if (!renderPipeline) {\n            return;\n        }\n        renderPipeline._detachCameras(cameras);\n    }\n    /**\n     * Enables an effect by name on a pipeline\n     * @param renderPipelineName the name of the pipeline to enable the effect in\n     * @param renderEffectName the name of the effect to enable\n     * @param cameras the cameras that the effect should be enabled on\n     */\n    enableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {\n        const renderPipeline = this._renderPipelines[renderPipelineName];\n        if (!renderPipeline) {\n            return;\n        }\n        renderPipeline._enableEffect(renderEffectName, cameras);\n    }\n    /**\n     * Disables an effect by name on a pipeline\n     * @param renderPipelineName the name of the pipeline to disable the effect in\n     * @param renderEffectName the name of the effect to disable\n     * @param cameras the cameras that the effect should be disabled on\n     */\n    disableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {\n        const renderPipeline = this._renderPipelines[renderPipelineName];\n        if (!renderPipeline) {\n            return;\n        }\n        renderPipeline._disableEffect(renderEffectName, cameras);\n    }\n    /**\n     * Updates the state of all contained render pipelines and disposes of any non supported pipelines\n     */\n    update() {\n        for (const renderPipelineName in this._renderPipelines) {\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n                const pipeline = this._renderPipelines[renderPipelineName];\n                if (!pipeline.isSupported) {\n                    pipeline.dispose();\n                    delete this._renderPipelines[renderPipelineName];\n                }\n                else {\n                    pipeline._update();\n                }\n            }\n        }\n    }\n    /** @internal */\n    _rebuild() {\n        for (const renderPipelineName in this._renderPipelines) {\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n                const pipeline = this._renderPipelines[renderPipelineName];\n                pipeline._rebuild();\n            }\n        }\n    }\n    /**\n     * Disposes of the manager and pipelines\n     */\n    dispose() {\n        for (const renderPipelineName in this._renderPipelines) {\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\n                const pipeline = this._renderPipelines[renderPipelineName];\n                pipeline.dispose();\n            }\n        }\n    }\n}\n//# sourceMappingURL=postProcessRenderPipelineManager.js.map","import { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { PostProcessRenderPipelineManager } from \"./postProcessRenderPipelineManager.js\";\nimport { Scene } from \"../../scene.js\";\nObject.defineProperty(Scene.prototype, \"postProcessRenderPipelineManager\", {\n    get: function () {\n        if (!this._postProcessRenderPipelineManager) {\n            // Register the G Buffer component to the scene.\n            let component = this._getComponent(SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER);\n            if (!component) {\n                component = new PostProcessRenderPipelineManagerSceneComponent(this);\n                this._addComponent(component);\n            }\n            this._postProcessRenderPipelineManager = new PostProcessRenderPipelineManager();\n        }\n        return this._postProcessRenderPipelineManager;\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * Defines the Render Pipeline scene component responsible to rendering pipelines\n */\nexport class PostProcessRenderPipelineManagerSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER, this, this._gatherRenderTargets);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        if (this.scene._postProcessRenderPipelineManager) {\n            this.scene._postProcessRenderPipelineManager._rebuild();\n        }\n    }\n    /**\n     * Disposes the component and the associated resources\n     */\n    dispose() {\n        if (this.scene._postProcessRenderPipelineManager) {\n            this.scene._postProcessRenderPipelineManager.dispose();\n        }\n    }\n    _gatherRenderTargets() {\n        if (this.scene._postProcessRenderPipelineManager) {\n            this.scene._postProcessRenderPipelineManager.update();\n        }\n    }\n}\n//# sourceMappingURL=postProcessRenderPipelineManagerSceneComponent.js.map"],"names":["PostProcessRenderPipelineManager","Observable","result","renderPipelineName","pipeline","renderPipeline","cameras","unique","renderEffectName","Scene","component","SceneComponentConstants","PostProcessRenderPipelineManagerSceneComponent","scene"],"mappings":"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","x_google_ignoreList":[0,1]}