{"version":3,"mappings":"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","names":["ResourcesPromise","_CreateDumpResourcesAsync","canvas","EngineStore","Logger","thinEngineClass","__vitePreload","n","options","engine","e","Dispose","renderer","EffectRenderer","passPixelShader","wrapper","EffectWrapper","_GetDumpResourcesAsync","EncodingHelper","pixelData","width","height","mimeType","invertY","quality","resources","dumpEngine","texture","resolve","reject","Tools","blob","__decorate","nativeOverride","EncodeImageAsync","DumpFramebuffer","successCallback","fileName","bufferView","data","DumpData","DumpDataAsync","toArrayBuffer","data2","v","Clamp","buffer","EncodeArrayBufferToBase64","result","DumpTools","InitSideEffects"],"ignoreList":[0],"sources":["../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Misc/dumpTools.js"],"sourcesContent":["import { __decorate } from \"../tslib.es6.js\";\n\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport { Tools } from \"./tools.js\";\nimport { Clamp } from \"../Maths/math.scalar.functions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"./logger.js\";\nimport { EncodeArrayBufferToBase64 } from \"./stringTools.js\";\nimport { nativeOverride } from \"./decorators.js\";\nlet ResourcesPromise = null;\nasync function _CreateDumpResourcesAsync() {\n    // Create a compatible canvas. Prefer an HTMLCanvasElement if possible to avoid alpha issues with OffscreenCanvas + WebGL in many browsers.\n    const canvas = (EngineStore.LastCreatedEngine?.createCanvas(100, 100) ?? new OffscreenCanvas(100, 100)); // will be resized later\n    if (canvas instanceof OffscreenCanvas) {\n        Logger.Warn(\"DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.\");\n    }\n    // If WebGL via ThinEngine is not available, we cannot encode the data.\n    // If https://github.com/whatwg/html/issues/10142 is resolved, we can migrate to just BitmapRenderer and avoid an engine dependency altogether.\n    const { ThinEngine: thinEngineClass } = await import(\"../Engines/thinEngine.js\");\n    if (!thinEngineClass.IsSupported) {\n        throw new Error(\"DumpData: No WebGL context available. Cannot dump data.\");\n    }\n    const options = {\n        preserveDrawingBuffer: true,\n        depth: false,\n        stencil: false,\n        alpha: true,\n        premultipliedAlpha: false,\n        antialias: false,\n        failIfMajorPerformanceCaveat: false,\n    };\n    const engine = new thinEngineClass(canvas, false, options);\n    // remove this engine from the list of instances to avoid using it for other purposes\n    EngineStore.Instances.pop();\n    // However, make sure to dispose it when no other engines are left\n    EngineStore.OnEnginesDisposedObservable.add((e) => {\n        // guaranteed to run when no other instances are left\n        // only dispose if it's not the current engine\n        if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {\n            // Dump the engine and the associated resources\n            Dispose();\n        }\n    });\n    engine.getCaps().parallelShaderCompile = undefined;\n    const renderer = new EffectRenderer(engine);\n    const { passPixelShader } = await import(\"../Shaders/pass.fragment.js\");\n    const wrapper = new EffectWrapper({\n        engine,\n        name: passPixelShader.name,\n        fragmentShader: passPixelShader.shader,\n        samplerNames: [\"textureSampler\"],\n    });\n    return {\n        canvas: canvas,\n        dumpEngine: { engine, renderer, wrapper },\n    };\n}\nasync function _GetDumpResourcesAsync() {\n    if (!ResourcesPromise) {\n        ResourcesPromise = _CreateDumpResourcesAsync();\n    }\n    return await ResourcesPromise;\n}\nclass EncodingHelper {\n    /**\n     * Encodes image data to the given mime type.\n     * This is put into a helper class so we can apply the nativeOverride decorator to it.\n     * @internal\n     */\n    static async EncodeImageAsync(pixelData, width, height, mimeType, invertY, quality) {\n        const resources = await _GetDumpResourcesAsync();\n        const dumpEngine = resources.dumpEngine;\n        dumpEngine.engine.setSize(width, height, true);\n        // Create the image\n        const texture = dumpEngine.engine.createRawTexture(pixelData, width, height, 5, false, !invertY, 1);\n        dumpEngine.renderer.setViewport();\n        dumpEngine.renderer.applyEffectWrapper(dumpEngine.wrapper);\n        dumpEngine.wrapper.effect._bindTexture(\"textureSampler\", texture);\n        dumpEngine.renderer.draw();\n        texture.dispose();\n        return await new Promise((resolve, reject) => {\n            Tools.ToBlob(resources.canvas, (blob) => {\n                if (!blob) {\n                    reject(new Error(\"EncodeImageAsync: Failed to convert canvas to blob.\"));\n                }\n                else {\n                    resolve(blob);\n                }\n            }, mimeType, quality);\n        });\n    }\n}\n__decorate([\n    nativeOverride\n], EncodingHelper, \"EncodeImageAsync\", null);\n/**\n * Encodes pixel data to an image\n * @param pixelData 8-bit RGBA pixel data\n * @param width the width of the image\n * @param height the height of the image\n * @param mimeType the requested MIME type\n * @param invertY true to invert the image in the Y direction\n * @param quality the quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns a promise that resolves to the encoded image data. Note that the `blob.type` may differ from `mimeType` if it was not supported.\n */\nexport const EncodeImageAsync = EncodingHelper.EncodeImageAsync;\n/**\n * Dumps the current bound framebuffer\n * @param width defines the rendering width\n * @param height defines the rendering height\n * @param engine defines the hosting engine\n * @param successCallback defines the callback triggered once the data are available\n * @param mimeType defines the mime type of the result\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns a void promise\n */\n// Should have \"Async\" in the name but this is a public API and we can't break it now\n// eslint-disable-next-line no-restricted-syntax\nexport async function DumpFramebuffer(width, height, engine, successCallback, mimeType = \"image/png\", fileName, quality) {\n    // Read the contents of the framebuffer\n    const bufferView = await engine.readPixels(0, 0, width, height);\n    const data = new Uint8Array(bufferView.buffer);\n    DumpData(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);\n}\n/**\n * Dumps an array buffer\n * @param width defines the rendering width\n * @param height defines the rendering height\n * @param data the data array\n * @param mimeType defines the mime type of the result\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n * @param invertY true to invert the picture in the Y dimension\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns a promise that resolve to the final data\n */\nexport async function DumpDataAsync(width, height, data, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    // Convert if data are float32\n    if (data instanceof Float32Array) {\n        const data2 = new Uint8Array(data.length);\n        let n = data.length;\n        while (n--) {\n            const v = data[n];\n            data2[n] = Math.round(Clamp(v) * 255);\n        }\n        data = data2;\n    }\n    const blob = await EncodingHelper.EncodeImageAsync(data, width, height, mimeType, invertY, quality);\n    if (fileName !== undefined) {\n        Tools.DownloadBlob(blob, fileName);\n    }\n    if (blob.type !== mimeType) {\n        Logger.Warn(`DumpData: The requested mimeType '${mimeType}' is not supported. The result has mimeType '${blob.type}' instead.`);\n    }\n    const buffer = await blob.arrayBuffer();\n    if (toArrayBuffer) {\n        return buffer;\n    }\n    return `data:${mimeType};base64,${EncodeArrayBufferToBase64(buffer)}`;\n}\n/**\n * Dumps an array buffer\n * @param width defines the rendering width\n * @param height defines the rendering height\n * @param data the data array\n * @param successCallback defines the callback triggered once the data are available\n * @param mimeType defines the mime type of the result\n * @param fileName The name of the file to download. If present, the result will automatically be downloaded. If not defined, and `successCallback` is also not defined, the result will automatically be downloaded with an auto-generated file name.\n * @param invertY true to invert the picture in the Y dimension\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n */\nexport function DumpData(width, height, data, successCallback, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    // For back-compat: if no fileName and no callback, force download the result\n    if (fileName === undefined && !successCallback) {\n        fileName = \"\";\n    }\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    DumpDataAsync(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality)\n        // eslint-disable-next-line github/no-then\n        .then((result) => {\n        if (successCallback) {\n            successCallback(result);\n        }\n    });\n}\n/**\n * Dispose the dump tools associated resources\n */\nexport function Dispose() {\n    if (!ResourcesPromise) {\n        return;\n    }\n    // in cases where the engine is not yet created, we need to wait for it to dispose it\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n    ResourcesPromise?.then((resources) => {\n        if (resources.canvas instanceof HTMLCanvasElement) {\n            resources.canvas.remove();\n        }\n        if (resources.dumpEngine) {\n            resources.dumpEngine.engine.dispose();\n            resources.dumpEngine.renderer.dispose();\n            resources.dumpEngine.wrapper.dispose();\n        }\n    });\n    ResourcesPromise = null;\n}\n/**\n * Object containing a set of static utilities functions to dump data from a canvas\n * @deprecated use functions\n */\nexport const DumpTools = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DumpData,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DumpDataAsync,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DumpFramebuffer,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Dispose,\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst InitSideEffects = () => {\n    // References the dependencies.\n    Tools.DumpData = DumpData;\n    Tools.DumpDataAsync = DumpDataAsync;\n    Tools.DumpFramebuffer = DumpFramebuffer;\n};\nInitSideEffects();\n//# sourceMappingURL=dumpTools.js.map"],"file":"dumpTools-Ze-hMalg.js"}