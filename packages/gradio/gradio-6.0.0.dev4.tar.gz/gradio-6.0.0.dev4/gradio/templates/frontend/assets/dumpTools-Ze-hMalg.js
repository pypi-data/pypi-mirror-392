const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./index-CKSmRzt-.js","./index-bhUlIv2p.js","./index-DcPzVlJ5.css","./pass.fragment-hloclwkQ.js"])))=>i.map(i=>d[i]);
import{aj as D}from"./index-bhUlIv2p.js";import{e as d,aI as A,L as v,aJ as b,E as g,aK as I,aL as T,_ as C,aM as x}from"./index-CKSmRzt-.js";let f=null;async function S(){const n=g.LastCreatedEngine?.createCanvas(100,100)??new OffscreenCanvas(100,100);n instanceof OffscreenCanvas&&v.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");const{ThinEngine:i}=await D(async()=>{const{ThinEngine:t}=await import("./index-CKSmRzt-.js").then(a=>a.co);return{ThinEngine:t}},__vite__mapDeps([0,1,2]),import.meta.url);if(!i.IsSupported)throw new Error("DumpData: No WebGL context available. Cannot dump data.");const r={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1},e=new i(n,!1,r);g.Instances.pop(),g.OnEnginesDisposedObservable.add(t=>{e&&t!==e&&!e.isDisposed&&g.Instances.length===0&&_()}),e.getCaps().parallelShaderCompile=void 0;const o=new I(e),{passPixelShader:s}=await D(async()=>{const{passPixelShader:t}=await import("./pass.fragment-hloclwkQ.js");return{passPixelShader:t}},__vite__mapDeps([3,0,1,2]),import.meta.url),p=new T({engine:e,name:s.name,fragmentShader:s.shader,samplerNames:["textureSampler"]});return{canvas:n,dumpEngine:{engine:e,renderer:o,wrapper:p}}}async function P(){return f||(f=S()),await f}class E{static async EncodeImageAsync(i,r,e,o,s,p){const t=await P(),a=t.dumpEngine;a.engine.setSize(r,e,!0);const c=a.engine.createRawTexture(i,r,e,5,!1,!s,1);return a.renderer.setViewport(),a.renderer.applyEffectWrapper(a.wrapper),a.wrapper.effect._bindTexture("textureSampler",c),a.renderer.draw(),c.dispose(),await new Promise((l,u)=>{d.ToBlob(t.canvas,m=>{m?l(m):u(new Error("EncodeImageAsync: Failed to convert canvas to blob."))},o,p)})}}C([x],E,"EncodeImageAsync",null);const B=E.EncodeImageAsync;async function h(n,i,r,e,o="image/png",s,p){const t=await r.readPixels(0,0,n,i),a=new Uint8Array(t.buffer);y(n,i,a,e,o,s,!0,void 0,p)}async function w(n,i,r,e="image/png",o,s=!1,p=!1,t){if(r instanceof Float32Array){const l=new Uint8Array(r.length);let u=r.length;for(;u--;){const m=r[u];l[u]=Math.round(A(m)*255)}r=l}const a=await E.EncodeImageAsync(r,n,i,e,s,t);o!==void 0&&d.DownloadBlob(a,o),a.type!==e&&v.Warn(`DumpData: The requested mimeType '${e}' is not supported. The result has mimeType '${a.type}' instead.`);const c=await a.arrayBuffer();return p?c:`data:${e};base64,${b(c)}`}function y(n,i,r,e,o="image/png",s,p=!1,t=!1,a){s===void 0&&!e&&(s=""),w(n,i,r,o,s,p,t,a).then(c=>{e&&e(c)})}function _(){f&&(f?.then(n=>{n.canvas instanceof HTMLCanvasElement&&n.canvas.remove(),n.dumpEngine&&(n.dumpEngine.engine.dispose(),n.dumpEngine.renderer.dispose(),n.dumpEngine.wrapper.dispose())}),f=null)}const W={DumpData:y,DumpDataAsync:w,DumpFramebuffer:h,Dispose:_},L=()=>{d.DumpData=y,d.DumpDataAsync=w,d.DumpFramebuffer=h};L();export{_ as Dispose,y as DumpData,w as DumpDataAsync,h as DumpFramebuffer,W as DumpTools,B as EncodeImageAsync};
//# sourceMappingURL=dumpTools-Ze-hMalg.js.map
