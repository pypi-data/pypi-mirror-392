{"version":3,"file":"bvhFileLoader-DfLCIuiD.js","sources":["../../../../node_modules/.pnpm/@babylonjs+loaders@8.36.1_@babylonjs+core@8.36.1_babylonjs-gltf2interface@8.36.1/node_modules/@babylonjs/loaders/BVH/bvhLoader.js","../../../../node_modules/.pnpm/@babylonjs+loaders@8.36.1_@babylonjs+core@8.36.1_babylonjs-gltf2interface@8.36.1/node_modules/@babylonjs/loaders/BVH/bvhFileLoader.js"],"sourcesContent":["import { Animation } from \"@babylonjs/core/Animations/animation.js\";\nimport { Bone } from \"@babylonjs/core/Bones/bone.js\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton.js\";\nimport { Matrix, Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nconst _XPosition = \"Xposition\";\nconst _YPosition = \"Yposition\";\nconst _ZPosition = \"Zposition\";\nconst _XRotation = \"Xrotation\";\nconst _YRotation = \"Yrotation\";\nconst _ZRotation = \"Zrotation\";\nconst _HierarchyNode = \"HIERARCHY\";\nconst _MotionNode = \"MOTION\";\nclass LoaderContext {\n    constructor(skeleton) {\n        this.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;\n        this.list = [];\n        this.root = CreateBVHNode();\n        this.numFrames = 0;\n        this.frameRate = 0;\n        this.skeleton = skeleton;\n    }\n}\nfunction CreateBVHNode() {\n    return {\n        name: \"\",\n        type: \"\",\n        offset: new Vector3(),\n        channels: [],\n        children: [],\n        frames: [],\n        parent: null,\n    };\n}\nfunction CreateBVHKeyFrame() {\n    return {\n        frame: 0,\n        position: new Vector3(),\n        rotation: new Quaternion(),\n    };\n}\n/**\n * Converts the BVH node's offset to a Babylon matrix\n * @param node - The BVH node to convert\n * @returns The converted matrix\n */\nfunction BoneOffset(node) {\n    const x = node.offset.x;\n    const y = node.offset.y;\n    const z = node.offset.z;\n    return Matrix.Translation(x, y, z);\n}\n/**\n * Creates animations for the BVH node\n * @param node - The BVH node to create animations for\n * @param context - The loader context\n * @returns The created animations\n */\nfunction CreateAnimations(node, context) {\n    if (node.frames.length === 0) {\n        return [];\n    }\n    const animations = [];\n    // Create position animation if there are position channels\n    const hasPosition = node.channels.some((c) => c === _XPosition || c === _YPosition || c === _ZPosition);\n    // Create rotation animation if there are rotation channels\n    const hasRotation = node.channels.some((c) => c === _XRotation || c === _YRotation || c === _ZRotation);\n    const posAnim = new Animation(`${node.name}_pos`, \"position\", context.frameRate, Animation.ANIMATIONTYPE_VECTOR3, context.loopMode);\n    const rotAnim = new Animation(`${node.name}_rot`, \"rotationQuaternion\", context.frameRate, Animation.ANIMATIONTYPE_QUATERNION, context.loopMode);\n    const posKeys = [];\n    const rotKeys = [];\n    for (let i = 0; i < node.frames.length; i++) {\n        const frame = node.frames[i];\n        if (hasPosition && frame.position) {\n            posKeys.push({\n                frame: frame.frame,\n                value: frame.position.clone(),\n            });\n        }\n        if (hasRotation) {\n            rotKeys.push({\n                frame: frame.frame,\n                value: frame.rotation.clone(),\n            });\n        }\n    }\n    if (posKeys.length > 0) {\n        posAnim.setKeys(posKeys);\n        animations.push(posAnim);\n    }\n    if (rotKeys.length > 0) {\n        rotAnim.setKeys(rotKeys);\n        animations.push(rotAnim);\n    }\n    return animations;\n}\n/**\n * Converts a BVH node to a Babylon bone\n * @param node - The BVH node to convert\n * @param parent - The parent bone\n * @param context - The loader context\n */\nfunction ConvertNode(node, parent, context) {\n    const matrix = BoneOffset(node);\n    const bone = new Bone(node.name, context.skeleton, parent, matrix);\n    // Create animation for this bone\n    const animations = CreateAnimations(node, context);\n    for (const animation of animations) {\n        if (animation.getKeys() && animation.getKeys().length > 0) {\n            bone.animations.push(animation);\n        }\n    }\n    for (const child of node.children) {\n        ConvertNode(child, bone, context);\n    }\n}\n/**\n * Recursively reads data from a single frame into the bone hierarchy.\n * The bone hierarchy has to be structured in the same order as the BVH file.\n * keyframe data is stored in bone.frames.\n * @param data - splitted string array (frame values), values are shift()ed\n * @param frameNumber - playback time for this keyframe\n * @param bone - the bone to read frame data from\n * @param tokenIndex - the index of the token to read\n */\nfunction ReadFrameData(data, frameNumber, bone, tokenIndex) {\n    if (bone.type === \"ENDSITE\") {\n        // end sites have no motion data\n        return;\n    }\n    // add keyframe\n    const keyframe = CreateBVHKeyFrame();\n    keyframe.frame = frameNumber;\n    keyframe.position = new Vector3();\n    keyframe.rotation = new Quaternion();\n    bone.frames.push(keyframe);\n    let combinedRotation = Matrix.Identity();\n    // parse values for each channel in node\n    for (let i = 0; i < bone.channels.length; ++i) {\n        const channel = bone.channels[i];\n        const value = data[tokenIndex.i++];\n        if (!value) {\n            continue;\n        }\n        const parsedValue = parseFloat(value.trim());\n        if (channel.endsWith(\"position\")) {\n            switch (channel) {\n                case _XPosition:\n                    keyframe.position.x = parsedValue;\n                    break;\n                case _YPosition:\n                    keyframe.position.y = parsedValue;\n                    break;\n                case _ZPosition:\n                    keyframe.position.z = parsedValue;\n                    break;\n            }\n        }\n        else if (channel.endsWith(\"rotation\")) {\n            const angle = Tools.ToRadians(parsedValue);\n            let rotationMatrix;\n            switch (channel) {\n                case _XRotation:\n                    rotationMatrix = Matrix.RotationX(angle);\n                    break;\n                case _YRotation:\n                    rotationMatrix = Matrix.RotationY(angle);\n                    break;\n                case _ZRotation:\n                    rotationMatrix = Matrix.RotationZ(angle);\n                    break;\n            }\n            combinedRotation = rotationMatrix.multiply(combinedRotation);\n        }\n    }\n    Quaternion.FromRotationMatrixToRef(combinedRotation, keyframe.rotation);\n    // parse child nodes\n    for (const child of bone.children) {\n        ReadFrameData(data, frameNumber, child, tokenIndex);\n    }\n}\n/**\n * Recursively parses the HIERARCHY section of the BVH file\n * @param lines - all lines of the file. lines are consumed as we go along\n * @param firstLine - line containing the node type and name e.g. \"JOINT hip\"\n * @param parent - the parent node for hierarchy\n * @param context - the loader context containing the list of nodes and other data\n * @returns a BVH node including children\n */\nfunction ReadNode(lines, firstLine, parent, context) {\n    const node = CreateBVHNode();\n    node.parent = parent;\n    context.list.push(node);\n    // parse node type and name.\n    let tokens = firstLine.trim().split(/\\s+/);\n    if (tokens[0].toUpperCase() === \"END\" && tokens[1].toUpperCase() === \"SITE\") {\n        node.type = \"ENDSITE\";\n        node.name = \"ENDSITE\"; // bvh end sites have no name\n    }\n    else {\n        node.name = tokens[1];\n        node.type = tokens[0].toUpperCase();\n    }\n    // opening bracket\n    if (lines.shift()?.trim() != \"{\") {\n        throw new Error(\"Expected opening { after type & name\");\n    }\n    // parse OFFSET\n    const tokensSplit = lines.shift()?.trim().split(/\\s+/);\n    if (!tokensSplit) {\n        throw new Error(\"Unexpected end of file: missing OFFSET\");\n    }\n    tokens = tokensSplit;\n    if (tokens[0].toUpperCase() != \"OFFSET\") {\n        throw new Error(\"Expected OFFSET, but got: \" + tokens[0]);\n    }\n    if (tokens.length != 4) {\n        throw new Error(\"OFFSET: Invalid number of values\");\n    }\n    const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n    if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        throw new Error(\"OFFSET: Invalid values\");\n    }\n    node.offset = offset;\n    // parse CHANNELS definitions\n    if (node.type != \"ENDSITE\") {\n        tokens = lines.shift()?.trim().split(/\\s+/);\n        if (!tokens) {\n            throw new Error(\"Unexpected end of file: missing CHANNELS\");\n        }\n        if (tokens[0].toUpperCase() != \"CHANNELS\") {\n            throw new Error(\"Expected CHANNELS definition\");\n        }\n        const numChannels = parseInt(tokens[1]);\n        // Skip CHANNELS and the number of channels\n        node.channels = tokens.splice(2, numChannels);\n        node.children = [];\n    }\n    // read children\n    while (lines.length > 0) {\n        const line = lines.shift()?.trim();\n        if (line === \"}\") {\n            // Finish reading the node\n            return node;\n        }\n        else if (line) {\n            node.children.push(ReadNode(lines, line, node, context));\n        }\n    }\n    throw new Error(\"Unexpected end of file: missing closing brace\");\n}\n/**\n * Reads a BVH file, returns a skeleton\n * @param text - The BVH file content\n * @param scene - The scene to add the skeleton to\n * @param assetContainer - The asset container to add the skeleton to\n * @param loadingOptions - The loading options\n * @returns The skeleton\n */\nexport function ReadBvh(text, scene, assetContainer, loadingOptions) {\n    const lines = text.split(\"\\n\");\n    const { loopMode } = loadingOptions;\n    scene._blockEntityCollection = !!assetContainer;\n    const skeleton = new Skeleton(\"\", \"\", scene);\n    skeleton._parentContainer = assetContainer;\n    scene._blockEntityCollection = false;\n    const context = new LoaderContext(skeleton);\n    context.loopMode = loopMode;\n    // read model structure\n    const firstLine = lines.shift();\n    if (!firstLine || firstLine.trim().toUpperCase() !== _HierarchyNode) {\n        throw new Error(\"HIERARCHY expected\");\n    }\n    const nodeLine = lines.shift();\n    if (!nodeLine) {\n        throw new Error(\"Unexpected end of file after HIERARCHY\");\n    }\n    const root = ReadNode(lines, nodeLine.trim(), null, context);\n    // read motion data\n    const motionLine = lines.shift();\n    if (!motionLine || motionLine.trim().toUpperCase() !== _MotionNode) {\n        throw new Error(\"MOTION expected\");\n    }\n    const framesLine = lines.shift();\n    if (!framesLine) {\n        throw new Error(\"Unexpected end of file before frame count\");\n    }\n    const framesTokens = framesLine.trim().split(/[\\s]+/);\n    if (framesTokens.length < 2) {\n        throw new Error(\"Invalid frame count line\");\n    }\n    // number of frames\n    const numFrames = parseInt(framesTokens[1]);\n    if (isNaN(numFrames)) {\n        throw new Error(\"Failed to read number of frames.\");\n    }\n    context.numFrames = numFrames;\n    // frame time\n    const frameTimeLine = lines.shift();\n    if (!frameTimeLine) {\n        throw new Error(\"Unexpected end of file before frame time\");\n    }\n    const frameTimeTokens = frameTimeLine.trim().split(/[\\s]+/);\n    if (frameTimeTokens.length < 3) {\n        throw new Error(\"Invalid frame time line\");\n    }\n    const frameTime = parseFloat(frameTimeTokens[2]);\n    if (isNaN(frameTime)) {\n        throw new Error(\"Failed to read frame time.\");\n    }\n    if (frameTime <= 0) {\n        throw new Error(\"Failed to read frame time. Invalid value \" + frameTime);\n    }\n    context.frameRate = 1 / frameTime;\n    // read frame data line by line\n    for (let i = 0; i < numFrames; ++i) {\n        const frameLine = lines.shift();\n        if (!frameLine) {\n            continue;\n        }\n        const tokens = frameLine.trim().split(/[\\s]+/) || [];\n        ReadFrameData(tokens, i, root, { i: 0 });\n    }\n    context.root = root;\n    ConvertNode(context.root, null, context);\n    context.skeleton.returnToRest();\n    return context.skeleton;\n}\n//# sourceMappingURL=bvhLoader.js.map","import { RegisterSceneLoaderPlugin } from \"@babylonjs/core/Loading/sceneLoader.js\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer.js\";\nimport { Animation } from \"@babylonjs/core/Animations/animation.js\";\nimport { BVHFileLoaderMetadata } from \"./bvhFileLoader.metadata.js\";\nimport { ReadBvh } from \"./bvhLoader.js\";\n/**\n * @experimental\n * BVH file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class BVHFileLoader {\n    /**\n     * Creates loader for bvh motion files\n     * @param loadingOptions - Options for the bvh loader\n     */\n    constructor(loadingOptions) {\n        /**\n         * Name of the loader (\"bvh\")\n         */\n        this.name = BVHFileLoaderMetadata.name;\n        /** @internal */\n        this.extensions = BVHFileLoaderMetadata.extensions;\n        this._loadingOptions = { ...BVHFileLoader._DefaultLoadingOptions, ...(loadingOptions ?? {}) };\n    }\n    static get _DefaultLoadingOptions() {\n        return {\n            loopMode: Animation.ANIMATIONLOOPMODE_CYCLE,\n        };\n    }\n    /** @internal */\n    createPlugin(options) {\n        return new BVHFileLoader(options[BVHFileLoaderMetadata.name]);\n    }\n    /**\n     * If the data string can be loaded directly.\n     * @param data - direct load data\n     * @returns if the data can be loaded directly\n     */\n    canDirectLoad(data) {\n        return this.isBvhHeader(data);\n    }\n    isBvhHeader(text) {\n        return text.split(\"\\n\")[0] == \"HIERARCHY\";\n    }\n    isNotBvhHeader(text) {\n        return !this.isBvhHeader(text);\n    }\n    /**\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\n     * @param _meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the bvh data to load\n     * @returns a promise containing the loaded skeletons and animations\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    importMeshAsync(_meshesNames, scene, data) {\n        if (typeof data !== \"string\") {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects string data.\");\n        }\n        if (this.isNotBvhHeader(data)) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects HIERARCHY header.\");\n        }\n        try {\n            const skeleton = ReadBvh(data, scene, null, this._loadingOptions);\n            return Promise.resolve({\n                meshes: [],\n                particleSystems: [],\n                skeletons: [skeleton],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            });\n        }\n        catch (e) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * Imports all objects from the loaded bvh data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the bvh data to load\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\n    loadAsync(scene, data) {\n        if (typeof data !== \"string\") {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects string data.\");\n        }\n        if (this.isNotBvhHeader(data)) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects HIERARCHY header.\");\n        }\n        // eslint-disable-next-line github/no-then\n        return this.importMeshAsync(null, scene, data).then(() => {\n            // return void\n        });\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @returns The loaded asset container\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    loadAssetContainerAsync(scene, data) {\n        if (typeof data !== \"string\") {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects string data.\");\n        }\n        if (this.isNotBvhHeader(data)) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects HIERARCHY header.\");\n        }\n        const assetContainer = new AssetContainer(scene);\n        try {\n            const skeleton = ReadBvh(data, scene, assetContainer, this._loadingOptions);\n            assetContainer.skeletons.push(skeleton);\n            return Promise.resolve(assetContainer);\n        }\n        catch (e) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(e);\n        }\n    }\n}\nRegisterSceneLoaderPlugin(new BVHFileLoader());\n//# sourceMappingURL=bvhFileLoader.js.map"],"names":["_XPosition","_YPosition","_ZPosition","_XRotation","_YRotation","_ZRotation","_HierarchyNode","_MotionNode","LoaderContext","skeleton","Animation","CreateBVHNode","Vector3","CreateBVHKeyFrame","Quaternion","BoneOffset","node","x","y","z","Matrix","CreateAnimations","context","animations","hasPosition","c","hasRotation","posAnim","rotAnim","posKeys","rotKeys","i","frame","ConvertNode","parent","matrix","bone","Bone","animation","child","ReadFrameData","data","frameNumber","tokenIndex","keyframe","combinedRotation","channel","value","parsedValue","angle","Tools","rotationMatrix","ReadNode","lines","firstLine","tokens","tokensSplit","offset","numChannels","line","ReadBvh","text","scene","assetContainer","loadingOptions","loopMode","Skeleton","nodeLine","root","motionLine","framesLine","framesTokens","numFrames","frameTimeLine","frameTimeTokens","frameTime","frameLine","BVHFileLoader","BVHFileLoaderMetadata","options","_meshesNames","AssetContainer","RegisterSceneLoaderPlugin"],"mappings":"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","x_google_ignoreList":[0,1]}