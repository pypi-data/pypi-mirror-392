{"version":3,"file":"BHfYIJC4.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+loaders@8.36.1_@babylonjs+core@8.36.1_babylonjs-gltf2interface@8.36.1/node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_lod.js"],"sourcesContent":["import { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry.js\";\nconst NAME = \"MSFT_lod\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_lod {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 100;\n        /**\n         * Maximum number of LODs to load, starting from the lowest LOD.\n         */\n        this.maxLODsToLoad = 10;\n        /**\n         * Observable raised when all node LODs of one level are loaded.\n         * The event data is the index of the loaded LOD starting from zero.\n         * Dispose the loader to cancel the loading of the next level of LODs.\n         */\n        this.onNodeLODsLoadedObservable = new Observable();\n        /**\n         * Observable raised when all material LODs of one level are loaded.\n         * The event data is the index of the loaded LOD starting from zero.\n         * Dispose the loader to cancel the loading of the next level of LODs.\n         */\n        this.onMaterialLODsLoadedObservable = new Observable();\n        this._bufferLODs = new Array();\n        this._nodeIndexLOD = null;\n        this._nodeSignalLODs = new Array();\n        this._nodePromiseLODs = new Array();\n        this._nodeBufferLODs = new Array();\n        this._materialIndexLOD = null;\n        this._materialSignalLODs = new Array();\n        this._materialPromiseLODs = new Array();\n        this._materialBufferLODs = new Array();\n        this._loader = loader;\n        // Options takes precedence. The maxLODsToLoad extension property is retained for back compat.\n        // For new extensions, they should only use options.\n        this.maxLODsToLoad = this._loader.parent.extensionOptions[NAME]?.maxLODsToLoad ?? this.maxLODsToLoad;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        this._nodeIndexLOD = null;\n        this._nodeSignalLODs.length = 0;\n        this._nodePromiseLODs.length = 0;\n        this._nodeBufferLODs.length = 0;\n        this._materialIndexLOD = null;\n        this._materialSignalLODs.length = 0;\n        this._materialPromiseLODs.length = 0;\n        this._materialBufferLODs.length = 0;\n        this.onMaterialLODsLoadedObservable.clear();\n        this.onNodeLODsLoadedObservable.clear();\n    }\n    /** @internal */\n    onReady() {\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\n                }\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\n                    if (this._nodeSignalLODs[indexLOD]) {\n                        this._nodeSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n            this._loader._completePromises.push(promise);\n        }\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\n                }\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\n                    if (this._materialSignalLODs[indexLOD]) {\n                        this._materialSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n            this._loader._completePromises.push(promise);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadSceneAsync(context, scene) {\n        const promise = this._loader.loadSceneAsync(context, scene);\n        this._loadBufferLOD(this._bufferLODs, 0);\n        return promise;\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {\n            let firstPromise;\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n                const nodeLOD = nodeLODs[indexLOD];\n                if (indexLOD !== 0) {\n                    this._nodeIndexLOD = indexLOD;\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\n                }\n                const assignWrap = (babylonTransformNode) => {\n                    assign(babylonTransformNode);\n                    babylonTransformNode.setEnabled(false);\n                };\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {\n                    if (indexLOD !== 0) {\n                        // TODO: should not rely on _babylonTransformNode\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\n                        if (previousNodeLOD._babylonTransformNode) {\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\n                            delete previousNodeLOD._babylonTransformNode;\n                        }\n                    }\n                    babylonMesh.setEnabled(true);\n                    return babylonMesh;\n                });\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._nodeIndexLOD = null;\n                    this._nodePromiseLODs[indexLOD].push(promise);\n                }\n            }\n            this._loader.logClose();\n            return await firstPromise;\n        });\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {\n        // Don't load material LODs if already loading a node LOD.\n        if (this._nodeIndexLOD) {\n            return null;\n        }\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {\n            let firstPromise;\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n                const materialLOD = materialLODs[indexLOD];\n                if (indexLOD !== 0) {\n                    this._materialIndexLOD = indexLOD;\n                }\n                const promise = this._loader\n                    ._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                    if (indexLOD === 0) {\n                        assign(babylonMaterial);\n                    }\n                })\n                    .then((babylonMaterial) => {\n                    if (indexLOD !== 0) {\n                        assign(babylonMaterial);\n                        // TODO: should not rely on _data\n                        const previousDataLOD = materialLODs[indexLOD - 1]._data;\n                        if (previousDataLOD[babylonDrawMode]) {\n                            this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\n                            delete previousDataLOD[babylonDrawMode];\n                        }\n                    }\n                    return babylonMaterial;\n                });\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._materialIndexLOD = null;\n                    this._materialPromiseLODs[indexLOD].push(promise);\n                }\n            }\n            this._loader.logClose();\n            return await firstPromise;\n        });\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    _loadUriAsync(context, property, uri) {\n        // Defer the loading of uris if loading a node or material LOD.\n        if (this._nodeIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._nodeIndexLOD - 1;\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred();\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(async () => {\n                return await this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n        else if (this._materialIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._materialIndexLOD - 1;\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred();\n            return this._materialSignalLODs[previousIndexLOD].promise.then(async () => {\n                return await this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n        return null;\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadBufferAsync(context, buffer, byteOffset, byteLength) {\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\n            if (!this._loader.bin) {\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n            }\n            const loadAsync = async (bufferLODs, indexLOD) => {\n                const start = byteOffset;\n                const end = start + byteLength - 1;\n                let bufferLOD = bufferLODs[indexLOD];\n                if (bufferLOD) {\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\n                }\n                else {\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\n                    bufferLODs[indexLOD] = bufferLOD;\n                }\n                return await bufferLOD.loaded.promise.then((data) => {\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\n                });\n            };\n            this._loader.log(`deferred`);\n            if (this._nodeIndexLOD !== null) {\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\n            }\n            else if (this._materialIndexLOD !== null) {\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\n            }\n            else {\n                return loadAsync(this._bufferLODs, 0);\n            }\n        }\n        return null;\n    }\n    _loadBufferLOD(bufferLODs, indexLOD) {\n        const bufferLOD = bufferLODs[indexLOD];\n        if (bufferLOD) {\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\n            this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then((data) => {\n                bufferLOD.loaded.resolve(data);\n            }, (error) => {\n                bufferLOD.loaded.reject(error);\n            });\n        }\n    }\n    /**\n     * @returns an array of LOD properties from lowest to highest.\n     * @param context\n     * @param property\n     * @param array\n     * @param ids\n     */\n    _getLODs(context, property, array, ids) {\n        if (this.maxLODsToLoad <= 0) {\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\n        }\n        const properties = [];\n        for (let i = ids.length - 1; i >= 0; i--) {\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\n            if (properties.length === this.maxLODsToLoad) {\n                return properties;\n            }\n        }\n        properties.push(property);\n        return properties;\n    }\n    _disposeTransformNode(babylonTransformNode) {\n        const babylonMaterials = [];\n        const babylonMaterial = babylonTransformNode.material;\n        if (babylonMaterial) {\n            babylonMaterials.push(babylonMaterial);\n        }\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\n            if (babylonMesh.material) {\n                babylonMaterials.push(babylonMesh.material);\n            }\n        }\n        babylonTransformNode.dispose();\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\n        this._disposeMaterials(babylonMaterialsToDispose);\n    }\n    _disposeMaterials(babylonMaterials) {\n        const babylonTextures = {};\n        for (const babylonMaterial of babylonMaterials) {\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\n            }\n            babylonMaterial.dispose();\n        }\n        for (const uniqueId in babylonTextures) {\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\n                    delete babylonTextures[uniqueId];\n                }\n            }\n        }\n        for (const uniqueId in babylonTextures) {\n            babylonTextures[uniqueId].dispose();\n        }\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_lod(loader));\n//# sourceMappingURL=MSFT_lod.js.map"],"names":["babylonMaterial"],"mappings":"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","x_google_ignoreList":[0]}