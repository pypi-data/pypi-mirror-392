{"version":3,"file":"BeyHUpYj.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/Animation/flowGraphInterpolationBlock.js"],"sourcesContent":["\nimport { FlowGraphBlock } from \"../../../flowGraphBlock.js\";\nimport { getRichTypeByAnimationType, getRichTypeByFlowGraphType, RichTypeAny, RichTypeNumber } from \"../../../flowGraphRichTypes.js\";\nimport { Animation } from \"../../../../Animations/animation.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * This block is responsible for interpolating between two values.\n * The babylon concept used is Animation, and it is the output of this block.\n *\n * Note that values will be parsed when the in connection is triggered. until then changing the value will not trigger a new interpolation.\n *\n * Internally this block uses the Animation class.\n *\n * Note that if the interpolation is already running a signal will be sent to stop the animation group running it.\n */\nexport class FlowGraphInterpolationBlock extends FlowGraphBlock {\n    constructor(config = {}) {\n        super(config);\n        /**\n         * The keyframes to interpolate between.\n         * Each keyframe has a duration input and a value input.\n         */\n        this.keyFrames = [];\n        const type = typeof config?.animationType === \"string\"\n            ? getRichTypeByFlowGraphType(config.animationType)\n            : getRichTypeByAnimationType(config?.animationType ?? 0);\n        const numberOfKeyFrames = config?.keyFramesCount ?? 1;\n        const duration = this.registerDataInput(`duration_0`, RichTypeNumber, 0);\n        const value = this.registerDataInput(`value_0`, type);\n        this.keyFrames.push({ duration, value });\n        for (let i = 1; i < numberOfKeyFrames + 1; i++) {\n            const duration = this.registerDataInput(`duration_${i}`, RichTypeNumber, i === numberOfKeyFrames ? config.duration : undefined);\n            const value = this.registerDataInput(`value_${i}`, type);\n            this.keyFrames.push({ duration, value });\n        }\n        this.initialValue = this.keyFrames[0].value;\n        this.endValue = this.keyFrames[numberOfKeyFrames].value;\n        this.easingFunction = this.registerDataInput(\"easingFunction\", RichTypeAny);\n        this.animation = this.registerDataOutput(\"animation\", RichTypeAny);\n        this.propertyName = this.registerDataInput(\"propertyName\", RichTypeAny, config?.propertyName);\n        this.customBuildAnimation = this.registerDataInput(\"customBuildAnimation\", RichTypeAny);\n    }\n    _updateOutputs(context) {\n        const interpolationAnimations = context._getGlobalContextVariable(\"interpolationAnimations\", []);\n        const propertyName = this.propertyName.getValue(context);\n        const easingFunction = this.easingFunction.getValue(context);\n        const animation = this._createAnimation(context, propertyName, easingFunction);\n        // If an old animation exists, it will be ignored here.\n        // This is because if the animation is running and they both have the same target, the old will be stopped.\n        // This doesn't happen here, it happens in the play animation block.\n        this.animation.setValue(animation, context);\n        // to make sure no 2 interpolations are running on the same target, we will mark the animation in the context\n        if (Array.isArray(animation)) {\n            for (const anim of animation) {\n                interpolationAnimations.push(anim.uniqueId);\n            }\n        }\n        else {\n            interpolationAnimations.push(animation.uniqueId);\n        }\n        context._setGlobalContextVariable(\"interpolationAnimations\", interpolationAnimations);\n    }\n    _createAnimation(context, propertyName, easingFunction) {\n        const type = this.initialValue.richType;\n        const keys = [];\n        // add initial value\n        const currentValue = this.initialValue.getValue(context) || type.defaultValue;\n        keys.push({ frame: 0, value: currentValue });\n        const numberOfKeyFrames = this.config?.numberOfKeyFrames ?? 1;\n        for (let i = 1; i < numberOfKeyFrames + 1; i++) {\n            const duration = this.keyFrames[i].duration?.getValue(context);\n            let value = this.keyFrames[i].value?.getValue(context);\n            if (i === numberOfKeyFrames - 1) {\n                value = value || type.defaultValue;\n            }\n            if (duration !== undefined && value) {\n                // convert duration to frames, based on 60 fps\n                keys.push({ frame: duration * 60, value });\n            }\n        }\n        const customBuildAnimation = this.customBuildAnimation.getValue(context);\n        if (customBuildAnimation) {\n            return customBuildAnimation(null, null, context)(keys, 60, type.animationType, easingFunction);\n        }\n        if (typeof propertyName === \"string\") {\n            const animation = Animation.CreateAnimation(propertyName, type.animationType, 60, easingFunction);\n            animation.setKeys(keys);\n            return [animation];\n        }\n        else {\n            const animations = propertyName.map((name) => {\n                const animation = Animation.CreateAnimation(name, type.animationType, 60, easingFunction);\n                animation.setKeys(keys);\n                return animation;\n            });\n            return animations;\n        }\n    }\n    getClassName() {\n        return \"FlowGraphInterpolationBlock\" /* FlowGraphBlockNames.ValueInterpolation */;\n    }\n}\nRegisterClass(\"FlowGraphInterpolationBlock\" /* FlowGraphBlockNames.ValueInterpolation */, FlowGraphInterpolationBlock);\n// #L54P2C\n//# sourceMappingURL=flowGraphInterpolationBlock.js.map"],"names":["duration","value"],"mappings":"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","x_google_ignoreList":[0]}