{"version":3,"file":"DZZg-ZvA.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractSound.js","../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractSoundInstance.js"],"sourcesContent":["import { Observable } from \"../../Misc/observable.js\";\nimport { AbstractSoundSource } from \"./abstractSoundSource.js\";\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport class AbstractSound extends AbstractSoundSource {\n    constructor(name, engine) {\n        super(name, engine, 3 /* AudioNodeType.HAS_INPUTS_AND_OUTPUTS */); // Inputs are for instances.\n        this._newestInstance = null;\n        this._privateInstances = new Set();\n        this._state = 1 /* SoundState.Stopped */;\n        this._instances = this._privateInstances;\n        /**\n         * Observable for when the sound stops playing.\n         */\n        this.onEndedObservable = new Observable();\n        this._onInstanceEnded = (instance) => {\n            if (this._newestInstance === instance) {\n                this._newestInstance = null;\n            }\n            this._privateInstances.delete(instance);\n            if (this._instances.size === 0) {\n                this._state = 1 /* SoundState.Stopped */;\n                this.onEndedObservable.notifyObservers(this);\n            }\n            instance.dispose();\n        };\n    }\n    /**\n     * The number of active instances of the sound that are currently playing.\n     */\n    get activeInstancesCount() {\n        return this._instances.size;\n    }\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    get autoplay() {\n        return this._options.autoplay;\n    }\n    /**\n     * The current playback time of the sound, in seconds.\n     */\n    get currentTime() {\n        const instance = this._getNewestInstance();\n        return instance ? instance.currentTime : 0;\n    }\n    set currentTime(value) {\n        this.startOffset = value;\n        const instance = this._getNewestInstance();\n        if (instance) {\n            instance.currentTime = value;\n        }\n    }\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    get loop() {\n        return this._options.loop;\n    }\n    set loop(value) {\n        this._options.loop = value;\n    }\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    get maxInstances() {\n        return this._options.maxInstances;\n    }\n    set maxInstances(value) {\n        this._options.maxInstances = value;\n    }\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    get startOffset() {\n        return this._options.startOffset;\n    }\n    set startOffset(value) {\n        this._options.startOffset = value;\n    }\n    /**\n     * The state of the sound.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Releases associated resources.\n     */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this._newestInstance = null;\n        this._privateInstances.clear();\n        this.onEndedObservable.clear();\n    }\n    /**\n     * Pauses the sound.\n     */\n    pause() {\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.pause();\n        }\n        this._state = 5 /* SoundState.Paused */;\n    }\n    /**\n     * Resumes the sound.\n     */\n    resume() {\n        if (this._state !== 5 /* SoundState.Paused */) {\n            return;\n        }\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.resume();\n        }\n        this._state = 3 /* SoundState.Started */;\n    }\n    _beforePlay(instance) {\n        if (this.state === 5 /* SoundState.Paused */ && this._instances.size > 0) {\n            this.resume();\n            return;\n        }\n        instance.onEndedObservable.addOnce(this._onInstanceEnded);\n        this._privateInstances.add(instance);\n        this._newestInstance = instance;\n    }\n    _afterPlay(instance) {\n        this._state = instance.state;\n    }\n    _getNewestInstance() {\n        if (this._instances.size === 0) {\n            return null;\n        }\n        if (!this._newestInstance) {\n            const it = this._instances.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                this._newestInstance = next.value;\n            }\n        }\n        return this._newestInstance;\n    }\n    _setState(state) {\n        this._state = state;\n    }\n    _stopExcessInstances() {\n        if (this.maxInstances < Infinity) {\n            const numberOfInstancesToStop = Array.from(this._instances).filter((instance) => instance.state === 3 /* SoundState.Started */).length - this.maxInstances;\n            const it = this._instances.values();\n            for (let i = 0; i < numberOfInstancesToStop; i++) {\n                const instance = it.next().value;\n                instance.stop();\n            }\n        }\n    }\n}\n//# sourceMappingURL=abstractSound.js.map","import { Observable } from \"../../Misc/observable.js\";\nimport { AbstractAudioNode } from \"./abstractAudioNode.js\";\n/** @internal */\nexport class _AbstractSoundInstance extends AbstractAudioNode {\n    constructor(sound) {\n        super(sound.engine, 2 /* AudioNodeType.HAS_OUTPUTS */);\n        this._state = 1 /* SoundState.Stopped */;\n        /** Observable triggered when the sound instance's playback ends */\n        this.onEndedObservable = new Observable();\n        /** Observable triggered if the sound instance encounters an error and can not be played */\n        this.onErrorObservable = new Observable();\n        /** Observable triggered when the sound instance's state changes */\n        this.onStateChangedObservable = new Observable();\n        this._sound = sound;\n    }\n    /** The playback state of the sound instance */\n    get state() {\n        return this._state;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this.onEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n    _setState(value) {\n        if (this._state === value) {\n            return;\n        }\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(this);\n        if (this._state === 1 /* SoundState.Stopped */) {\n            this.onEndedObservable.notifyObservers(this);\n        }\n    }\n}\n//# sourceMappingURL=abstractSoundInstance.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0,1]}