{"version":3,"file":"xXkJf1cS.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/staticSound.js","../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/staticSoundBuffer.js","../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/abstractAudio/staticSoundInstance.js","../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/AudioV2/webAudio/webAudioStaticSound.js"],"sourcesContent":["import { AbstractSound } from \"./abstractSound.js\";\n/**\n * Abstract class representing a static sound.\n *\n * A static sound has a sound buffer that is loaded into memory all at once. This allows it to have more capabilities\n * than a streaming sound, such as loop points and playback rate changes, but it also means that the sound must be\n * fully downloaded and decoded before it can be played, which may take a long time for sounds with long durations.\n *\n * To prevent downloading and decoding a sound multiple times, a sound's buffer can be shared with other sounds.\n * See {@link CreateSoundBufferAsync}, {@link StaticSoundBuffer} and {@link StaticSound.buffer} for more information.\n *\n * Static sounds are created by the {@link CreateSoundAsync} function.\n */\nexport class StaticSound extends AbstractSound {\n    constructor(name, engine) {\n        super(name, engine);\n    }\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    get duration() {\n        return this._options.duration;\n    }\n    set duration(value) {\n        this._options.duration = value;\n    }\n    /**\n     * The start of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     */\n    get loopStart() {\n        return this._options.loopStart;\n    }\n    set loopStart(value) {\n        this._options.loopStart = value;\n    }\n    /**\n     * The end of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     */\n    get loopEnd() {\n        return this._options.loopEnd;\n    }\n    set loopEnd(value) {\n        this._options.loopEnd = value;\n    }\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Gets combined with {@link playbackRate} to determine the final pitch.\n     */\n    get pitch() {\n        return this._options.pitch;\n    }\n    set pitch(value) {\n        this._options.pitch = value;\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.pitch = value;\n        }\n    }\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Gets combined with {@link pitch} to determine the final playback rate.\n     */\n    get playbackRate() {\n        return this._options.playbackRate;\n    }\n    set playbackRate(value) {\n        this._options.playbackRate = value;\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.playbackRate = value;\n        }\n    }\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    play(options = {}) {\n        if (this.state === 5 /* SoundState.Paused */) {\n            this.resume();\n            return;\n        }\n        options.duration ?? (options.duration = this.duration);\n        options.loop ?? (options.loop = this.loop);\n        options.loopStart ?? (options.loopStart = this.loopStart);\n        options.loopEnd ?? (options.loopEnd = this.loopEnd);\n        options.startOffset ?? (options.startOffset = this.startOffset);\n        options.volume ?? (options.volume = 1);\n        options.waitTime ?? (options.waitTime = 0);\n        const instance = this._createInstance();\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n        this._stopExcessInstances();\n    }\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     * @param options - The options to use when stopping the sound.\n     */\n    stop(options = {}) {\n        if (options.waitTime && 0 < options.waitTime) {\n            this._setState(0 /* SoundState.Stopping */);\n        }\n        else {\n            this._setState(1 /* SoundState.Stopped */);\n        }\n        if (!this._instances) {\n            return;\n        }\n        for (const instance of Array.from(this._instances)) {\n            instance.stop(options);\n        }\n    }\n}\n//# sourceMappingURL=staticSound.js.map","let StaticSoundBufferId = 1;\n/**\n * Abstract class representing a static sound buffer.\n *\n * A static sound buffer is a fully downloaded and decoded array of audio data that is ready to be played.\n *\n * Static sound buffers can be reused multiple times by different {@link StaticSound} instances.\n *\n * Static sound buffers are created by the {@link CreateSoundBufferAsync} function.\n *\n * @see {@link StaticSound.buffer}\n */\nexport class StaticSoundBuffer {\n    constructor(engine) {\n        /**\n         * The name of the sound buffer.\n         */\n        this.name = `StaticSoundBuffer #${StaticSoundBufferId++}`;\n        this.engine = engine;\n    }\n}\n//# sourceMappingURL=staticSoundBuffer.js.map","import { _AbstractSoundInstance } from \"./abstractSoundInstance.js\";\n/** @internal */\nexport class _StaticSoundInstance extends _AbstractSoundInstance {\n}\n//# sourceMappingURL=staticSoundInstance.js.map","import { StaticSound } from \"../abstractAudio/staticSound.js\";\nimport { StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer.js\";\nimport { _StaticSoundInstance } from \"../abstractAudio/staticSoundInstance.js\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio.js\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio.js\";\nimport { _CleanUrl, _FileExtensionRegex } from \"../audioUtils.js\";\nimport { _WebAudioParameterComponent } from \"./components/webAudioParameterComponent.js\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph.js\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio.js\";\n/** @internal */\nexport class _WebAudioStaticSound extends StaticSound {\n    /** @internal */\n    constructor(name, engine, options) {\n        super(name, engine);\n        this._spatial = null;\n        this._spatialAutoUpdate = true;\n        this._spatialMinUpdateTime = 0;\n        this._stereo = null;\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            duration: options.duration ?? 0,\n            loop: options.loop ?? false,\n            loopEnd: options.loopEnd ?? 0,\n            loopStart: options.loopStart ?? 0,\n            maxInstances: options.maxInstances ?? Infinity,\n            pitch: options.pitch ?? 0,\n            playbackRate: options.playbackRate ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n        this._subGraph = new _WebAudioStaticSound._SubGraph(this);\n    }\n    /** @internal */\n    async _initAsync(source, options) {\n        this._audioContext = this.engine._audioContext;\n        if (source instanceof _WebAudioStaticSoundBuffer) {\n            this._buffer = source;\n        }\n        else if (typeof source === \"string\" || Array.isArray(source) || source instanceof ArrayBuffer || source instanceof AudioBuffer) {\n            this._buffer = (await this.engine.createSoundBufferAsync(source, options));\n        }\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        }\n        else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n        await this._subGraph.initAsync(options);\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n        if (options.autoplay) {\n            this.play();\n        }\n        this.engine._addSound(this);\n    }\n    /** @internal */\n    get buffer() {\n        return this._buffer;\n    }\n    /** @internal */\n    get _inNode() {\n        return this._subGraph._inNode;\n    }\n    /** @internal */\n    get _outNode() {\n        return this._subGraph._outNode;\n    }\n    /** @internal */\n    get spatial() {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n    /** @internal */\n    get stereo() {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n    /** @internal */\n    async cloneAsync(options = null) {\n        const clone = await this.engine.createSoundAsync(this.name, options?.cloneBuffer ? this.buffer.clone() : this.buffer, this._options);\n        clone.outBus = options?.outBus ? options.outBus : this.outBus;\n        return clone;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._spatial?.dispose();\n        this._spatial = null;\n        this._stereo = null;\n        this._subGraph.dispose();\n        this.engine._removeSound(this);\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStaticSound\";\n    }\n    _createInstance() {\n        return new _WebAudioStaticSoundInstance(this, this._options);\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n        return true;\n    }\n    _initSpatialProperty() {\n        if (!this._spatial) {\n            this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);\n        }\n        return this._spatial;\n    }\n}\n_WebAudioStaticSound._SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n    get _downstreamNodes() {\n        return this._owner._downstreamNodes ?? null;\n    }\n    get _upstreamNodes() {\n        return this._owner._upstreamNodes ?? null;\n    }\n};\n/** @internal */\nexport class _WebAudioStaticSoundBuffer extends StaticSoundBuffer {\n    /** @internal */\n    constructor(engine) {\n        super(engine);\n    }\n    async _initAsync(source, options) {\n        if (source instanceof AudioBuffer) {\n            this._audioBuffer = source;\n        }\n        else if (typeof source === \"string\") {\n            await this._initFromUrlAsync(source);\n        }\n        else if (Array.isArray(source)) {\n            await this._initFromUrlsAsync(source, options.skipCodecCheck ?? false);\n        }\n        else if (source instanceof ArrayBuffer) {\n            await this._initFromArrayBufferAsync(source);\n        }\n    }\n    /** @internal */\n    get channelCount() {\n        return this._audioBuffer.numberOfChannels;\n    }\n    /** @internal */\n    get duration() {\n        return this._audioBuffer.duration;\n    }\n    /** @internal */\n    get length() {\n        return this._audioBuffer.length;\n    }\n    /** @internal */\n    get sampleRate() {\n        return this._audioBuffer.sampleRate;\n    }\n    /** @internal */\n    clone(options = null) {\n        const audioBuffer = new AudioBuffer({\n            length: this._audioBuffer.length,\n            numberOfChannels: this._audioBuffer.numberOfChannels,\n            sampleRate: this._audioBuffer.sampleRate,\n        });\n        for (let i = 0; i < this._audioBuffer.numberOfChannels; i++) {\n            audioBuffer.copyToChannel(this._audioBuffer.getChannelData(i), i);\n        }\n        const buffer = new _WebAudioStaticSoundBuffer(this.engine);\n        buffer._audioBuffer = audioBuffer;\n        buffer.name = options?.name ? options.name : this.name;\n        return buffer;\n    }\n    async _initFromArrayBufferAsync(arrayBuffer) {\n        this._audioBuffer = await this.engine._audioContext.decodeAudioData(arrayBuffer);\n    }\n    async _initFromUrlAsync(url) {\n        url = _CleanUrl(url);\n        await this._initFromArrayBufferAsync(await (await fetch(url)).arrayBuffer());\n    }\n    async _initFromUrlsAsync(urls, skipCodecCheck) {\n        for (const url of urls) {\n            if (skipCodecCheck) {\n                // eslint-disable-next-line no-await-in-loop\n                await this._initFromUrlAsync(url);\n            }\n            else {\n                const matches = url.match(_FileExtensionRegex);\n                const format = matches?.at(1);\n                if (format && this.engine.isFormatValid(format)) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        await this._initFromUrlAsync(url);\n                    }\n                    catch {\n                        if (format && 0 < format.length) {\n                            this.engine.flagInvalidFormat(format);\n                        }\n                    }\n                }\n            }\n            if (this._audioBuffer) {\n                break;\n            }\n        }\n    }\n}\n/** @internal */\nclass _WebAudioStaticSoundInstance extends _StaticSoundInstance {\n    constructor(sound, options) {\n        super(sound);\n        this._enginePlayTime = 0;\n        this._enginePauseTime = 0;\n        this._isConnected = false;\n        this._pitch = null;\n        this._playbackRate = null;\n        this._sourceNode = null;\n        this._onEnded = () => {\n            this._enginePlayTime = 0;\n            this.onEndedObservable.notifyObservers(this);\n            this._deinitSourceNode();\n        };\n        this._onEngineStateChanged = () => {\n            if (this.engine.state !== \"running\") {\n                return;\n            }\n            if (this._options.loop && this.state === 2 /* SoundState.Starting */) {\n                this.play();\n            }\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        };\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n        this._initSourceNode();\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._pitch?.dispose();\n        this._playbackRate?.dispose();\n        this._sourceNode = null;\n        this.stop();\n        this._deinitSourceNode();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n    /** @internal */\n    get currentTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        const timeSinceLastStart = this._state === 5 /* SoundState.Paused */ ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n    set currentTime(value) {\n        const restart = this._state === 2 /* SoundState.Starting */ || this._state === 3 /* SoundState.Started */;\n        if (restart) {\n            // Stop source node without sending `onEndedObservable` so instance's `dispose` function is not called.\n            const sourceNode = this._sourceNode;\n            this._deinitSourceNode();\n            sourceNode?.stop();\n            this._state = 1 /* SoundState.Stopped */;\n        }\n        this._options.startOffset = value;\n        if (restart) {\n            this.play();\n        }\n    }\n    get _outNode() {\n        return this._volumeNode;\n    }\n    /** @internal */\n    set pitch(value) {\n        this._pitch?.setTargetValue(value);\n    }\n    /** @internal */\n    set playbackRate(value) {\n        this._playbackRate?.setTargetValue(value);\n    }\n    /** @internal */\n    get startTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        return this._enginePlayTime;\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStaticSoundInstance\";\n    }\n    /** @internal */\n    play(options = {}) {\n        if (this._state === 3 /* SoundState.Started */) {\n            return;\n        }\n        if (options.duration !== undefined) {\n            this._options.duration = options.duration;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        if (options.loopStart !== undefined) {\n            this._options.loopStart = options.loopStart;\n        }\n        if (options.loopEnd !== undefined) {\n            this._options.loopEnd = options.loopEnd;\n        }\n        if (options.startOffset !== undefined) {\n            this._options.startOffset = options.startOffset;\n        }\n        let startOffset = this._options.startOffset;\n        if (this._state === 5 /* SoundState.Paused */) {\n            startOffset += this.currentTime;\n            startOffset %= this._sound.buffer.duration;\n        }\n        this._enginePlayTime = this.engine.currentTime + (options.waitTime ?? 0);\n        this._volumeNode.gain.value = options.volume ?? 1;\n        this._initSourceNode();\n        if (this.engine.state === \"running\") {\n            this._setState(3 /* SoundState.Started */);\n            this._sourceNode?.start(this._enginePlayTime, startOffset, this._options.duration > 0 ? this._options.duration : undefined);\n        }\n        else if (this._options.loop) {\n            this._setState(2 /* SoundState.Starting */);\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n    }\n    /** @internal */\n    pause() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            return;\n        }\n        this._setState(5 /* SoundState.Paused */);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n        this._sourceNode?.stop();\n        this._deinitSourceNode();\n    }\n    /** @internal */\n    resume() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            this.play();\n        }\n    }\n    /** @internal */\n    stop(options = {}) {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return;\n        }\n        const engineStopTime = this.engine.currentTime + (options.waitTime ?? 0);\n        this._sourceNode?.stop(engineStopTime);\n        if (options.waitTime === undefined || options.waitTime <= 0) {\n            this._setState(1 /* SoundState.Stopped */);\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        }\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n            this._isConnected = true;\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n            this._isConnected = false;\n        }\n        return true;\n    }\n    _deinitSourceNode() {\n        if (!this._sourceNode) {\n            return;\n        }\n        if (this._isConnected && !this._disconnect(this._sound)) {\n            throw new Error(\"Disconnect failed\");\n        }\n        this._sourceNode.disconnect(this._volumeNode);\n        this._sourceNode.removeEventListener(\"ended\", this._onEnded);\n        this._sourceNode = null;\n    }\n    _initSourceNode() {\n        if (!this._sourceNode) {\n            this._sourceNode = new AudioBufferSourceNode(this._sound._audioContext, { buffer: this._sound.buffer._audioBuffer });\n            this._sourceNode.addEventListener(\"ended\", this._onEnded, { once: true });\n            this._sourceNode.connect(this._volumeNode);\n            if (!this._connect(this._sound)) {\n                throw new Error(\"Connect failed\");\n            }\n            this._pitch = new _WebAudioParameterComponent(this.engine, this._sourceNode.detune);\n            this._playbackRate = new _WebAudioParameterComponent(this.engine, this._sourceNode.playbackRate);\n        }\n        const node = this._sourceNode;\n        node.detune.value = this._sound.pitch;\n        node.loop = this._options.loop;\n        node.loopEnd = this._options.loopEnd;\n        node.loopStart = this._options.loopStart;\n        node.playbackRate.value = this._sound.playbackRate;\n    }\n}\n//# sourceMappingURL=webAudioStaticSound.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0,1,2,3]}