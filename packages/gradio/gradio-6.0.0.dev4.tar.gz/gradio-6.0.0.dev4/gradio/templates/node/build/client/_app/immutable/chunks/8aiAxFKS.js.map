{"version":3,"file":"8aiAxFKS.js","sources":["../../../../../../../../node_modules/.pnpm/@babylonjs+core@8.36.1/node_modules/@babylonjs/core/Lights/pointLight.js","../../../../../../../../node_modules/.pnpm/@babylonjs+loaders@8.36.1_@babylonjs+core@8.36.1_babylonjs-gltf2interface@8.36.1/node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_lights_punctual.js"],"sourcesContent":["import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nimport { ShadowLight } from \"./shadowLight.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nNode.AddNodeConstructor(\"Light_Type_0\", (name, scene) => {\n    return () => new PointLight(name, Vector3.Zero(), scene);\n});\n/**\n * A point light is a light defined by an unique point in world space.\n * The light is emitted in every direction from this point.\n * A good example of a point light is a standard light bulb.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class PointLight extends ShadowLight {\n    /**\n     * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     * This specifies what angle the shadow will use to be created.\n     *\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n     */\n    get shadowAngle() {\n        return this._shadowAngle;\n    }\n    /**\n     * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     * This specifies what angle the shadow will use to be created.\n     *\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n     */\n    set shadowAngle(value) {\n        this._shadowAngle = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Gets the direction if it has been set.\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n     */\n    set direction(value) {\n        const previousNeedCube = this.needCube();\n        this._direction = value;\n        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {\n            const iterator = this._shadowGenerators.values();\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                const shadowGenerator = key.value;\n                shadowGenerator.recreateShadowMap();\n            }\n        }\n    }\n    /**\n     * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.\n     * A PointLight emits the light in every direction.\n     * It can cast shadows.\n     * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :\n     * ```javascript\n     * var pointLight = new PointLight(\"pl\", camera.position, scene);\n     * ```\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The light friendly name\n     * @param position The position of the point light in the scene\n     * @param scene The scene the lights belongs to\n     */\n    constructor(name, position, scene) {\n        super(name, scene);\n        this._shadowAngle = Math.PI / 2;\n        this.position = position;\n    }\n    /**\n     * Returns the string \"PointLight\"\n     * @returns the class name\n     */\n    getClassName() {\n        return \"PointLight\";\n    }\n    /**\n     * Returns the integer 0.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    getTypeID() {\n        return Light.LIGHTTYPEID_POINTLIGHT;\n    }\n    /**\n     * Specifies whether or not the shadowmap should be a cube texture.\n     * @returns true if the shadowmap needs to be a cube texture.\n     */\n    needCube() {\n        return !this.direction;\n    }\n    /**\n     * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\n     */\n    getShadowDirection(faceIndex) {\n        if (this.direction) {\n            return super.getShadowDirection(faceIndex);\n        }\n        else {\n            switch (faceIndex) {\n                case 0:\n                    return new Vector3(1.0, 0.0, 0.0);\n                case 1:\n                    return new Vector3(-1.0, 0.0, 0.0);\n                case 2:\n                    return new Vector3(0.0, -1.0, 0.0);\n                case 3:\n                    return new Vector3(0.0, 1.0, 0.0);\n                case 4:\n                    return new Vector3(0.0, 0.0, 1.0);\n                case 5:\n                    return new Vector3(0.0, 0.0, -1.0);\n            }\n        }\n        return Vector3.Zero();\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as a left-handed perspective projection matrix with the following settings :\n     * - fov = PI / 2\n     * - aspect ratio : 1.0\n     * - z-near and far equal to the active camera minZ and maxZ.\n     * Returns the PointLight.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        const minZ = this.getDepthMinZ(activeCamera);\n        const maxZ = this.getDepthMaxZ(activeCamera);\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1.0, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, undefined, useReverseDepthBuffer);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The point light\n     */\n    transferToEffect(effect, lightIndex) {\n        const offset = this._scene.floatingOriginOffset;\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z, 0.0, lightIndex);\n        }\n        else {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, 0, lightIndex);\n        }\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, 0, 0, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        const offset = this._scene.floatingOriginOffset;\n        if (this.computeTransformedInformation()) {\n            effect.setFloat3(lightDataUniformName, this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z);\n        }\n        else {\n            effect.setFloat3(lightDataUniformName, this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z);\n        }\n        return this;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"POINTLIGHT\" + lightIndex] = true;\n    }\n}\n__decorate([\n    serialize()\n], PointLight.prototype, \"shadowAngle\", null);\n// Register Class Name\nRegisterClass(\"BABYLON.PointLight\", PointLight);\n//# sourceMappingURL=pointLight.js.map","import { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\nimport { Light } from \"@babylonjs/core/Lights/light.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry.js\";\nconst NAME = \"KHR_lights_punctual\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_lights {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        delete this._lights;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._lights = extension.lights;\n            ArrayItem.Assign(this._lights);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {\n            this._loader._allMaterialsDirtyRequired = true;\n            return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\n                let babylonLight;\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\n                const name = light.name || babylonMesh.name;\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\n                switch (light.type) {\n                    case \"directional\" /* KHRLightsPunctual_LightType.DIRECTIONAL */: {\n                        const babylonDirectionalLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\n                        babylonDirectionalLight.position.setAll(0);\n                        babylonLight = babylonDirectionalLight;\n                        break;\n                    }\n                    case \"point\" /* KHRLightsPunctual_LightType.POINT */: {\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\n                        break;\n                    }\n                    case \"spot\" /* KHRLightsPunctual_LightType.SPOT */: {\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\n                        babylonLight = babylonSpotLight;\n                        break;\n                    }\n                    default: {\n                        this._loader.babylonScene._blockEntityCollection = false;\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\n                    }\n                }\n                babylonLight._parentContainer = this._loader._assetContainer;\n                this._loader.babylonScene._blockEntityCollection = false;\n                light._babylonLight = babylonLight;\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n                babylonLight.parent = babylonMesh;\n                this._loader._babylonLights.push(babylonLight);\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\n                assign(babylonMesh);\n            });\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_lights(loader));\n//# sourceMappingURL=KHR_lights_punctual.js.map"],"names":[],"mappings":"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","x_google_ignoreList":[0,1]}