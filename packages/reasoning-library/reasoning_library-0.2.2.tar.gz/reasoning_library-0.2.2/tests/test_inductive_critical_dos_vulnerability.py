#!/usr/bin/env python3
"""
Critical vulnerability test for Algorithmic DoS in inductive.py patterns.

This test targets CRIT-002: Algorithmic DoS vulnerability where:
- Unbounded computation loops in pattern detection functions
- Timeout checks only every 1000 iterations (insufficient for fast attacks)
- Sequence length limit of 10,000 allows DoS attacks
- Fibonacci/Lucas/Tribonacci detection algorithms can be forced into exponential computation

Expected behavior: These tests should FAIL before the fix and PASS after.
"""

import pytest
import time
from reasoning_library.inductive import (
    predict_next_in_sequence,
    detect_fibonacci_pattern,
    detect_lucas_pattern,
    detect_tribonacci_pattern,
    MAX_SEQUENCE_LENGTH,
    _VALUE_MAGNITUDE_LIMIT
)
from reasoning_library.exceptions import ValidationError


class TestAlgorithmicDoSVulnerabilities:
    """Test suite for CRIT-002: Algorithmic DoS vulnerabilities."""

    def test_sequence_length_limit_vulnerability(self):
        """Test that overly long sequences are rejected to prevent DoS."""
        # Create a sequence longer than safe limit (now 500 after HIGH-001 fix)
        # This should be rejected to prevent DoS
        vulnerable_length = 5000  # Well beyond secure limit

        # Simple arithmetic sequence that would be processed
        long_sequence = list(range(vulnerable_length))

        # This should now be quickly rejected due to secure limits (HIGH-001 fix)
        start_time = time.time()

        # This call should now be rejected (security fix working)
        try:
            result = predict_next_in_sequence(long_sequence, None)
            # If it succeeds, the security fix is not working
            pytest.fail(f"SECURITY BREACH: Processed {vulnerable_length} elements - limit enforcement failed!")
        except ValidationError as e:
            elapsed = time.time() - start_time
            print(f"SECURITY FIX CONFIRMED: Rejected dangerous sequence ({vulnerable_length} elements) in {elapsed}s")
            assert elapsed < 0.1, f"Rejection took too long: {elapsed}s"
            assert "Input sequence too large" in str(e)
            return

    def test_exponential_growth_fibonacci_dos(self):
        """Test DoS via exponential growth in Fibonacci-like sequences."""
        # Create a sequence that grows exponentially to trigger overflow
        # This simulates malicious input designed to cause resource exhaustion
        exponential_sequence = [1, 2]

        # Grow exponentially (doubling each time) to quickly hit limits
        for i in range(50):  # This should create massive values
            exponential_sequence.append(exponential_sequence[-1] * 2)

        # The system should now reject this early due to strengthened value limits (HIGH-001 fix)
        start_time = time.time()

        try:
            # This should now fail due to strengthened value magnitude limits
            result = detect_fibonacci_pattern(exponential_sequence, tolerance=0.1)

            # If we get here, the security fix failed
            max_value = max(exponential_sequence)
            pytest.fail(f"SECURITY BREACH: Processed dangerous values up to {max_value} - value limit enforcement failed!")

        except ValidationError as e:
            elapsed = time.time() - start_time
            print(f"SECURITY FIX CONFIRMED: Rejected exponential sequence with max value {max(exponential_sequence)} in {elapsed}s")
            assert elapsed < 0.1, f"Rejection took too long: {elapsed}s"
            assert "Value magnitude too large" in str(e)
            return
        except ValueError as e:
            # This might also occur due to overflow detection in the algorithm
            elapsed = time.time() - start_time
            if "overflow" in str(e).lower():
                print(f"SECURITY FIX CONFIRMED: Overflow protection triggered in {elapsed}s")
                return
            else:
                # Unexpected error
                raise

    def test_timeout_check_frequency_vulnerability(self):
        """Test that timeout checks are frequent enough to prevent DoS."""
        # Create sequence that maximizes computation between timeout checks
        # After HIGH-001 fix, implementation checks every 50 iterations (more secure)

        # Fast-growing sequence that would maximize work per iteration
        sequence = [1.001, 1.002]  # Start with values that would cause complex computation

        # Add values that would force intensive recursive computation
        for i in range(2000):  # More than the old 1000 iteration check interval
            # Add values that would require complex floating point operations
            sequence.append(sequence[-1] * 1.001 + sequence[-2] * 0.999)

        # Time the operation - should now be rejected due to sequence length limits
        start_time = time.time()

        # This should now be rejected immediately due to strengthened sequence limits (HIGH-001 fix)
        try:
            result = detect_fibonacci_pattern(sequence, tolerance=1e-10)

            # If we get here, security failed
            pytest.fail(f"SECURITY BREACH: Processed {len(sequence)} elements - sequence limit enforcement failed!")

        except ValidationError as e:
            elapsed = time.time() - start_time
            print(f"SECURITY FIX CONFIRMED: Rejected timeout test sequence ({len(sequence)} elements) in {elapsed}s")
            assert elapsed < 0.1, f"Rejection took too long: {elapsed}s"
            assert "Input sequence too large" in str(e)
            return
        except Exception as e:
            elapsed = time.time() - start_time
            if "timeout" in str(e).lower():
                print(f"ALTERNATIVE SECURITY: Timeout protection triggered in {elapsed}s")
                return
            else:
                # Some other error occurred
                print(f"Unexpected error after {elapsed}s: {e}")
                raise

    def test_tribonacci_computation_explosion(self):
        """Test DoS vulnerability in Tribonacci computation (3-term recursion)."""
        # Tribonacci is particularly vulnerable as it sums 3 previous terms
        # This can cause exponential computational growth

        # Create a sequence that would maximize Tribonacci computation
        sequence = [100, 200, 300]  # Large starting values

        # Extend with values that would force computation
        for i in range(100):  # 100 iterations of 3-term sums
            # This will create rapidly growing values
            next_val = sequence[-1] + sequence[-2] + sequence[-3]
            sequence.append(next_val)

        start_time = time.time()

        try:
            result = detect_tribonacci_pattern(sequence, tolerance=0.1)

            # If we get here, security failed
            max_value = max(sequence)
            pytest.fail(f"SECURITY BREACH: Tribonacci processed dangerous values up to {max_value} - value limit enforcement failed!")

        except ValidationError as e:
            elapsed = time.time() - start_time
            print(f"SECURITY FIX CONFIRMED: Rejected Tribonacci sequence with max value {max(sequence)} in {elapsed}s")
            assert elapsed < 0.1, f"Rejection took too long: {elapsed}s"
            assert "Value magnitude too large" in str(e)
            return
        except ValueError as e:
            elapsed = time.time() - start_time
            if "overflow" in str(e).lower() or "timeout" in str(e).lower():
                print(f"ALTERNATIVE SECURITY: Tribonacci overflow/timeout protection triggered in {elapsed}s")
                return
            else:
                raise

    def test_current_limits_inadequate(self):
        """Verify new secure limits are adequate for DoS protection."""
        # After HIGH-001 fix, limits should be secure
        current_max_length = MAX_SEQUENCE_LENGTH

        # Verify limits have been reduced for security (HIGH-001 fix)
        assert current_max_length <= 500, f"Current limit {current_max_length} is too high for security - should be <= 500"

        # Test that dangerous sequences are now rejected
        dangerous_length = min(1000, current_max_length + 100)  # Exceeds new secure limit
        sequence = list(range(dangerous_length))

        start_time = time.time()

        # This should now be rejected due to secure limits
        try:
            result = predict_next_in_sequence(sequence, None)  # Provide None for reasoning_chain
            # If it succeeds, the limit is still too high
            assert len(sequence) <= current_max_length, f"Was able to process {len(sequence)} elements - security fix incomplete!"
            pytest.skip("Security fix appears to be working correctly")
        except ValidationError as e:
            # This is the expected secure behavior
            elapsed = time.time() - start_time
            print(f"SECURITY FIX CONFIRMED: Rejected dangerous sequence ({len(sequence)} elements) in {elapsed}s")
            print(f"Secure MAX_SEQUENCE_LENGTH = {current_max_length}")
            return

        elapsed = time.time() - start_time
        print(f"SECURITY FIX VERIFICATION: Processed {len(sequence)} elements in {elapsed}s")
        print(f"Secure MAX_SEQUENCE_LENGTH = {current_max_length} (protects against DoS attacks)")


if __name__ == "__main__":
    # Run the tests to demonstrate vulnerabilities
    print("Testing CRIT-002: Algorithmic DoS Vulnerabilities")
    print("=" * 60)

    test_suite = TestAlgorithmicDoSVulnerabilities()

    try:
        print("\n1. Testing sequence length limit vulnerability...")
        test_suite.test_sequence_length_limit_vulnerability()
    except Exception as e:
        print(f"Test failed: {e}")

    try:
        print("\n2. Testing exponential growth Fibonacci DoS...")
        test_suite.test_exponential_growth_fibonacci_dos()
    except Exception as e:
        print(f"Test failed: {e}")

    try:
        print("\n3. Testing timeout check frequency vulnerability...")
        test_suite.test_timeout_check_frequency_vulnerability()
    except Exception as e:
        print(f"Test failed: {e}")

    try:
        print("\n4. Testing Tribonacci computation explosion...")
        test_suite.test_tribonacci_computation_explosion()
    except Exception as e:
        print(f"Test failed: {e}")

    try:
        print("\n5. Testing current limits inadequate...")
        test_suite.test_current_limits_inadequate()
    except Exception as e:
        print(f"Test failed: {e}")

    print("\n" + "=" * 60)
    print("Vulnerability testing complete. If all tests completed without")
    print("timeout or overflow errors, the vulnerabilities are CONFIRMED.")
    print("After the fix, these tests should be skipped or fail appropriately.")