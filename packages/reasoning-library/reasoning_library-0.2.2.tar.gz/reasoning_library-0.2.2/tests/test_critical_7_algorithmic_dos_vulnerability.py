#!/usr/bin/env python3
"""
CRITICAL #7: Algorithmic Complexity DoS Attack Vulnerability Test

This test demonstrates a Denial of Service vulnerability in the reasoning library
where malicious input can cause excessive computation time through algorithmic
complexity attacks in recursive pattern detection functions.

Vulnerability Details:
- The `detect_fibonacci_pattern` and similar functions can be exploited with
  specially crafted sequences that cause excessive computation
- No computation time limits or input size validation
- Can cause system hangs or resource exhaustion
"""

import os
import sys
import time

# Add src to path for testing
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from reasoning_library.inductive import (
    detect_fibonacci_pattern,
    detect_lucas_pattern,
    detect_recursive_pattern,
)


def test_algorithmic_complexity_dos_vulnerability() -> bool:
    """
    Test for algorithmic complexity DoS vulnerability in recursive pattern detection.

    This test demonstrates the vulnerability by showing:
    1. No upper bounds on input sequence length
    2. No timeout mechanisms
    3. Potential for resource exhaustion with large inputs
    """
    print("Testing algorithmic complexity DoS vulnerability...")

    # Test 1: Extremely long sequence (demonstrates lack of input size limits)
    print("  Test 1: Input size validation bypass...")

    # Create an extremely long sequence - this should be rejected but isn't
    extremely_long_sequence = [float(i) for i in range(50000)]  # 50K elements

    try:
        start_time = time.time()

        # The function should reject this input due to size, but it doesn't
        result = detect_fibonacci_pattern(extremely_long_sequence)

        end_time = time.time()
        computation_time = end_time - start_time

        print(f"    Sequence length: {len(extremely_long_sequence)} elements")
        print(f"    Computation time: {computation_time:.4f} seconds")

        # The vulnerability is that it accepts arbitrarily large inputs
        if len(extremely_long_sequence) > 10000:  # Reasonable upper bound
            print(f"    ‚ùå VULNERABILITY CONFIRMED: No input size limits (accepted {len(extremely_long_sequence)} elements)")
            return True  # Vulnerability detected

    except Exception as e:
        print(f"    Exception occurred: {e}")
        return False

    # Test 2: Memory consumption attack
    print("  Test 2: Memory consumption vulnerability...")

    # Create sequence that will cause large memory allocations
    memory_attack_sequence = []
    for i in range(50000):  # 50K elements
        memory_attack_sequence.append(float(i * 1e6))  # Large values

    try:
        start_time = time.time()

        result = detect_lucas_pattern(memory_attack_sequence)

        end_time = time.time()
        computation_time = end_time - start_time

        print(f"    Memory attack sequence length: {len(memory_attack_sequence)}")
        print(f"    Computation time: {computation_time:.4f} seconds")

        if computation_time > 0.1:  # Any significant time is a problem
            print(f"    ‚ùå VULNERABILITY CONFIRMED: Memory consumption attack ({computation_time:.4f}s)")
            return True

    except Exception as e:
        print(f"    Exception occurred: {e}")
        return False

    # Test 3: No timeout mechanism vulnerability
    print("  Test 3: No timeout mechanism vulnerability...")

    # Create a sequence that forces computation through all checks
    timeout_attack_sequence = []

    # Create a sequence that passes basic checks but requires computation
    for i in range(25000):
        if i < 2:
            timeout_attack_sequence.append(float(i + 1))
        else:
            # Create a modified Fibonacci that will still require computation
            timeout_attack_sequence.append(timeout_attack_sequence[-1] + timeout_attack_sequence[-2] + 0.1)

    try:
        start_time = time.time()

        result = detect_fibonacci_pattern(timeout_attack_sequence, tolerance=1e-6)  # Very strict tolerance

        end_time = time.time()
        computation_time = end_time - start_time

        print(f"    Timeout attack sequence length: {len(timeout_attack_sequence)}")
        print(f"    Computation time: {computation_time:.4f} seconds")

        # The vulnerability is accepting this computation without timeout
        if len(timeout_attack_sequence) > 10000:  # Should have reasonable limits
            print(f"    ‚ùå VULNERABILITY CONFIRMED: No timeout protection (processed {len(timeout_attack_sequence)} elements)")
            return True

    except Exception as e:
        print(f"    Exception occurred: {e}")
        return False

    # Test 4: detect_recursive_pattern accepts unlimited input sizes
    print("  Test 4: Recursive pattern detector input size vulnerability...")

    # Create very large sequence for recursive pattern detection
    large_recursive_sequence = [float(i) for i in range(50000)]

    try:
        start_time = time.time()

        # This should have input size limits but doesn't
        result = detect_recursive_pattern(large_recursive_sequence, None)

        end_time = time.time()
        computation_time = end_time - start_time

        print(f"    Recursive sequence length: {len(large_recursive_sequence)}")
        print(f"    Computation time: {computation_time:.4f} seconds")

        if len(large_recursive_sequence) > 50000:  # Should have reasonable limits
            print(f"    ‚ùå VULNERABILITY CONFIRMED: Recursive detector accepts unlimited size ({len(large_recursive_sequence)} elements)")
            return True

    except Exception as e:
        print(f"    Exception occurred: {e}")
        return False

    print("  ‚úÖ No input size validation vulnerabilities detected")
    return False

def test_resource_exhaustion_vectors() -> bool:
    """Test additional resource exhaustion attack vectors."""
    print("Testing additional resource exhaustion vectors...")

    # Test with NaN and infinity values
    print("  Test: NaN/Infinity attack...")

    nan_sequence = [float('nan')] * 100
    inf_sequence = [float('inf')] * 100

    try:
        start_time = time.time()

        result1 = detect_fibonacci_pattern(nan_sequence)
        result2 = detect_fibonacci_pattern(inf_sequence)

        end_time = time.time()
        computation_time = end_time - start_time

        print(f"    Computation time: {computation_time:.4f} seconds")

        if computation_time > 0.5:
            print(f"    ‚ùå VULNERABILITY CONFIRMED: NaN/Infinity attack ({computation_time:.4f}s)")
            return True

    except Exception as e:
        print(f"    Exception occurred: {e}")
        return False

    return False

def main():
    """Main test function."""
    print("üö® CRITICAL #7: Algorithmic Complexity DoS Vulnerability Test")
    print("=" * 70)
    print()

    vulnerability_detected = False

    # Run all vulnerability tests
    vulnerability_detected |= test_algorithmic_complexity_dos_vulnerability()
    vulnerability_detected |= test_resource_exhaustion_vectors()

    print()
    print("=" * 70)

    if vulnerability_detected:
        print("üö® CRITICAL #7 CONFIRMED: Algorithmic Complexity DoS Vulnerabilities Detected!")
        print()
        print("Vulnerability Details:")
        print("  ‚Ä¢ Pattern detection functions can be exploited for DoS attacks")
        print("  ‚Ä¢ No computation time limits on complex inputs")
        print("  ‚Ä¢ Large sequences cause excessive computation")
        print("  ‚Ä¢ Can lead to resource exhaustion and system hangs")
        print()
        print("Risk Assessment: CRITICAL")
        print("  ‚Ä¢ Can cause application unresponsiveness")
        print("  ‚Ä¢ Potential for system-wide denial of service")
        print("  ‚Ä¢ Easy to exploit with crafted inputs")
        print()
        print("Required Actions:")
        print("  1. Add computation time limits to pattern detection")
        print("  2. Implement input size validation")
        print("  3. Add resource usage monitoring")
        print("  4. Implement early termination for complex patterns")

        return 1
    else:
        print("‚úÖ No algorithmic complexity DoS vulnerabilities detected")
        print("  ‚Ä¢ Pattern detection functions appear to have reasonable performance")
        print("  ‚Ä¢ No excessive computation times observed")

        return 0

if __name__ == "__main__":
    import os
    sys.exit(main())
