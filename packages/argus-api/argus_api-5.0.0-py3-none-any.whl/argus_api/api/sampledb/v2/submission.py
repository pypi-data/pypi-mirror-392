"""Autogenerated API"""

from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(extending=("sampledb", "v2", "submission"), module=argus_cli_module)
def submission_advanced_search(
    customer: str = None,
    endTimestamp: str = None,
    excludeFlags: str = None,
    fileName: str = None,
    id: str = None,
    includeFlags: str = None,
    keywords: str = None,
    metaData: dict = None,
    mimeType: str = None,
    sampleSha256: str = None,
    startTimestamp: str = None,
    subCriteria: dict = None,
    timeFieldStrategy: str = None,
    tlp: str = None,
    userAgent: dict = None,
    indexEndTimestamp: str = "now",
    indexStartTimestamp: str = "now - 1 month",
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = "all",
    limit: int = 25,
    offset: int = 0,
    sortBy: str = None,
    timeMatchStrategy: str = "any",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Advanced search for submissions (PUBLIC)

    :param list customer: Restrict the search to submissions owned by certain customers identified by id or shortname
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\). Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/api\/general\_integration\_guide\/08\-time\_fields.html\#api\-iguide\-general\-time\-search
    :param list excludeFlags: Restrict the search to submissions not containing any of the specified flags
    :param list fileName: Restrict the search to submissions with any of the file names defined
    :param list id: Restrict the search to submissions with any of the IDs defined
    :param list includeFlags: Restrict the search to submissions containing any of the specified flags
    :param list keywords: A set of keywords to search for
    :param list metaData: Restrict the search to submissions with any of the meta data properties defined
    :param list mimeType: Restrict the search to submissions with any of the mime types defined
    :param list sampleSha256: Restrict the search to submissions with any of the sample sha256s defined
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\). Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/api\/general\_integration\_guide\/08\-time\_fields.html\#api\-iguide\-general\-time\-search
    :param list subCriteria: Search sub criteria
    :param list timeFieldStrategy: Restrict the search by timestamp \(indicated by startTimestamp and endTimestamp\) to these fields. Default is \'all\'
    :param list tlp: Restrict the search to submissions where it must contain any of the defined TLPs
    :param list userAgent: Restrict the search to submissions with any of the user agents defined
    :param str indexEndTimestamp: Restrict search to data before this time \(epoch millis\)Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/api\/general\_integration\_guide\/08\-time\_fields.html\#api\-iguide\-general\-time\-search
    :param str indexStartTimestamp: Restrict search to data after this time \(epoch millis\)Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/api\/general\_integration\_guide\/08\-time\_fields.html\#api\-iguide\-general\-time\-search
    :param list keywordFieldStrategy: Restrict to search only in the selected keyword fields
    :param str keywordMatchStrategy: Whether all or any \(default\) of the fields must match one or more of the keywords
    :param int limit: Limit the number of search results
    :param int offset: Skip a number of search results
    :param list sortBy: Specify the order of results. Prefix with \'\-\' to order descending.
    :param str timeMatchStrategy: Whether all or any \(default\) of the fields must match the time period \(indicated by startTimestamp and endTimestamp\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/submission/search".format()
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send fileName if the argument was provided, don't send null values
    if fileName is not None:
        body.update({"fileName": fileName})
    # Only send id if the argument was provided, don't send null values
    if id is not None:
        body.update({"id": id})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send metaData if the argument was provided, don't send null values
    if metaData is not None:
        body.update({"metaData": metaData})
    # Only send mimeType if the argument was provided, don't send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})
    # Only send sampleSha256 if the argument was provided, don't send null values
    if sampleSha256 is not None:
        body.update({"sampleSha256": sampleSha256})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        body.update({"indexEndTimestamp": indexEndTimestamp})
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        body.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "submission"), module=argus_cli_module)
def submission_simple_search(
    keywords: str = None,
    offset: int = 0,
    limit: int = 25,
    sortBy: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = "any",
    indexStartTimestamp: str = "now - 1 month",
    indexEndTimestamp: str = "now",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Simple search for submissions (PUBLIC)

    :param list keywords: A set of keywords to search for
    :param int offset: Number of results to skip
    :param int limit: Maximum number of returned results
    :param list sortBy: Fields to sort the results by. Prefix with \'\-\' to sort descending
    :param list keywordFieldStrategy: Which fields to search on
    :param str keywordMatchStrategy: Whether the keywords must match all or any of the keyword fields
    :param str indexStartTimestamp: Restrict search to data after this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details
    :param str indexEndTimestamp: Restrict search to data before this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/submission".format()
    headers = {}

    query_parameters = {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        query_parameters.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        query_parameters.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        query_parameters.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        query_parameters.update({"indexEndTimestamp": indexEndTimestamp})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "submission"), module=argus_cli_module)
def submission_statistics(
    customer: str = None,
    endTimestamp: str = None,
    excludeFlags: str = None,
    fileName: str = None,
    groupBy: dict = None,
    id: str = None,
    includeFlags: str = None,
    keywords: str = None,
    metaData: dict = None,
    mimeType: str = None,
    sampleSha256: str = None,
    startTimestamp: str = None,
    statistics: dict = None,
    subCriteria: dict = None,
    timeFieldStrategy: str = None,
    timeline: dict = None,
    tlp: str = None,
    userAgent: dict = None,
    indexEndTimestamp: str = "now",
    indexStartTimestamp: str = "now - 1 month",
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = "all",
    timeMatchStrategy: str = "any",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Aggregation for Submission statistics (INTERNAL)

    :param list customer: Restrict the search to submissions owned by certain customers identified by id or shortname
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\). Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/api\/general\_integration\_guide\/08\-time\_fields.html\#api\-iguide\-general\-time\-search
    :param list excludeFlags: Restrict the search to submissions not containing any of the specified flags
    :param list fileName: Restrict the search to submissions with any of the file names defined
    :param list groupBy: The fields by which to group statistics
    :param list id: Restrict the search to submissions with any of the IDs defined
    :param list includeFlags: Restrict the search to submissions containing any of the specified flags
    :param list keywords: A set of keywords to search for
    :param list metaData: Restrict the search to submissions with any of the meta data properties defined
    :param list mimeType: Restrict the search to submissions with any of the mime types defined
    :param list sampleSha256: Restrict the search to submissions with any of the sample sha256s defined
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\). Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/api\/general\_integration\_guide\/08\-time\_fields.html\#api\-iguide\-general\-time\-search
    :param list statistics: The numerical fields for which to generate metrics
    :param list subCriteria: Search sub criteria
    :param list timeFieldStrategy: Restrict the search by timestamp \(indicated by startTimestamp and endTimestamp\) to these fields. Default is \'all\'
    :param list timeline: The timestamp fields for which to generate statistics
    :param list tlp: Restrict the search to submissions where it must contain any of the defined TLPs
    :param list userAgent: Restrict the search to submissions with any of the user agents defined
    :param str indexEndTimestamp: Restrict search to data before this time \(epoch millis\)Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies.
    :param str indexStartTimestamp: Restrict search to data after this time \(epoch millis\)Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies.
    :param list keywordFieldStrategy: Restrict to search only in the selected keyword fields
    :param str keywordMatchStrategy: Whether all or any \(default\) of the fields must match one or more of the keywords
    :param str timeMatchStrategy: Whether all or any \(default\) of the fields must match the time period \(indicated by startTimestamp and endTimestamp\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/submission/statistics".format()
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send fileName if the argument was provided, don't send null values
    if fileName is not None:
        body.update({"fileName": fileName})
    # Only send groupBy if the argument was provided, don't send null values
    if groupBy is not None:
        body.update({"groupBy": groupBy})
    # Only send id if the argument was provided, don't send null values
    if id is not None:
        body.update({"id": id})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send metaData if the argument was provided, don't send null values
    if metaData is not None:
        body.update({"metaData": metaData})
    # Only send mimeType if the argument was provided, don't send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})
    # Only send sampleSha256 if the argument was provided, don't send null values
    if sampleSha256 is not None:
        body.update({"sampleSha256": sampleSha256})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send statistics if the argument was provided, don't send null values
    if statistics is not None:
        body.update({"statistics": statistics})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeline if the argument was provided, don't send null values
    if timeline is not None:
        body.update({"timeline": timeline})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        body.update({"indexEndTimestamp": indexEndTimestamp})
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        body.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
