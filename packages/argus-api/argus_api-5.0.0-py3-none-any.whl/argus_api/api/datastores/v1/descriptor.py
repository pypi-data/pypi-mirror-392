"""Autogenerated API"""

from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(extending=("datastores", "v1", "descriptor"), module=argus_cli_module)
def add_data_store_descriptor(
    description: str,
    name: str,
    behaviourType: str = "CENTRAL",
    dataType: str = "MAP",
    expireData: bool = None,
    globalData: bool = None,
    lifeTime: int = None,
    useLowerCaseKeys: bool = False,
    readFunction: str = None,
    writeFunction: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Adds a new datastore descriptor. (PUBLIC)

    :param str description: A textual description of the datastore.
    :param str name: Name for the new datastore\, must be unique.
    :param str behaviourType: The behaviour of the datastore. CENTRAL datastores are only updated centrally\, but may be used in distributed processing. LOCAL and DISTRIBUTED datastores are not stored centrally\, but updated in the distributed system. DISTRIBUTED may be shared between processing nodes.
    :param str dataType: The type of data stored in the datastore \(MAP or LIST\). Maps have keys with values\, lists only have keys.
    :param bool expireData: If true\, the datastore entries will expire after the configured time period since added\/last updated.
    :param bool globalData: If true\, the datastore only accepts global data \(not customer bound\).
    :param int lifeTime: The requested expiry time in milliseconds. Requires a positive value \(if expireData is true\).
    :param bool useLowerCaseKeys: Boolean flag that determines whether to use lower case keys.
    :param str readFunction: Specify the read function for this datastore. Default is \'viewDataStoreEntry\'.
    :param str writeFunction: Specify the write function for this datastore. Default is \'updateDataStoreEntry\'.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/datastores/v1/descriptor".format()
    headers = {}

    body = body or {}
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send behaviourType if the argument was provided, don't send null values
    if behaviourType is not None:
        body.update({"behaviourType": behaviourType})
    # Only send dataType if the argument was provided, don't send null values
    if dataType is not None:
        body.update({"dataType": dataType})
    # Only send expireData if the argument was provided, don't send null values
    if expireData is not None:
        body.update({"expireData": expireData})
    # Only send globalData if the argument was provided, don't send null values
    if globalData is not None:
        body.update({"globalData": globalData})
    # Only send lifeTime if the argument was provided, don't send null values
    if lifeTime is not None:
        body.update({"lifeTime": lifeTime})
    # Only send useLowerCaseKeys if the argument was provided, don't send null values
    if useLowerCaseKeys is not None:
        body.update({"useLowerCaseKeys": useLowerCaseKeys})
    # Only send readFunction if the argument was provided, don't send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send writeFunction if the argument was provided, don't send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("datastores", "v1", "descriptor"), module=argus_cli_module)
def delete_data_store_descriptor(
    dataStore: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Deletes an existing datastore descriptor. (PUBLIC)

    :param str dataStore: Store name
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises DatastoreNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/datastores/v1/descriptor/{dataStore}".format(dataStore=dataStore)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("datastores", "v1", "descriptor"), module=argus_cli_module)
def get_descriptor(
    dataStore: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns a datastore descriptor identified by its name. (PUBLIC)

    :param str dataStore: Store name
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises DatastoreNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/datastores/v1/descriptor/{dataStore}".format(dataStore=dataStore)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("datastores", "v1", "descriptor"), module=argus_cli_module)
def search_descriptors(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    includeFlags: int = None,
    excludeFlags: int = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    sortBy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Returns an array of datastore descriptors matching search criteria. (PUBLIC)

    :param int limit: Max number of results.
    :param int offset: Skip the first \(offset\) objects. By default\, return result from first object.
    :param bool includeDeleted: Set to true to include deleted objects. By default\, exclude deleted objects.
    :param int includeFlags: Only include objects which have includeFlags set.
    :param int excludeFlags: Exclude objects which have excludeFlags set.
    :param list subCriteria: Set additional criterias which are applied using a logical OR.
    :param bool exclude: Only relevant for subcriteria. If set to true\, objects matching this subcriteria object will be excluded.
    :param bool required: Only relevant for subcriteria. If set to true\, objects matching this subcriteria are required \(AND\-ed together with parent criteria\).
    :param list keywords: Search for datastores matching keywords.
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\).
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords \(default match all keywords\).
    :param list sortBy: List of properties to sort by \(prefix with \"\-\" to sort descending\).
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/datastores/v1/descriptor/search".format()
    headers = {}

    body = body or {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, don't send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, don't send null values
    if required is not None:
        body.update({"required": required})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("datastores", "v1", "descriptor"), module=argus_cli_module)
def search_descriptors_simple(
    keywords: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    keywordMatch: str = "all",
    keywordField: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns an array of datastore descriptors matching search parameters. (PUBLIC)

    :param list keywords: Search by keywords
    :param list sortBy: Sort search result
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param str keywordMatch: Set match strategy for keyword search
    :param list keywordField: Set field strategy for keyword search
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/datastores/v1/descriptor".format()
    headers = {}

    query_parameters = {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send keywordMatch if the argument was provided, don't send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send keywordField if the argument was provided, don't send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("datastores", "v1", "descriptor"), module=argus_cli_module)
def update_data_store_descriptor(
    dataStore: str,
    description: str = None,
    expireData: bool = None,
    globalData: bool = None,
    lifeTime: int = None,
    name: str = None,
    readFunction: str = None,
    writeFunction: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Updates an existing datastore descriptor. (PUBLIC)

    :param str dataStore: Store name
    :param str description: If set\, change the textual description of this datastore.
    :param bool expireData: If set\, change the expire data flag on this datastore. Default is no change.
    :param bool globalData: If set\, change the global data flag on this datastore. Default is no change.
    :param int lifeTime: If set \(to a positive value\)\, change the expiry time of this datastore. Requires that the store has enabled expireData. Default is no change.
    :param str name: If set\, change the name of this datastore. All entries will be updated \(may take long time for large stores\).
    :param str readFunction: If set\, change the read function for this datastore. Default is no change.
    :param str writeFunction: If set\, change the write function for this datastore. Default is no change.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises DatastoreNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/datastores/v1/descriptor/{dataStore}".format(dataStore=dataStore)
    headers = {}

    body = body or {}
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send expireData if the argument was provided, don't send null values
    if expireData is not None:
        body.update({"expireData": expireData})
    # Only send globalData if the argument was provided, don't send null values
    if globalData is not None:
        body.update({"globalData": globalData})
    # Only send lifeTime if the argument was provided, don't send null values
    if lifeTime is not None:
        body.update({"lifeTime": lifeTime})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send readFunction if the argument was provided, don't send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send writeFunction if the argument was provided, don't send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
