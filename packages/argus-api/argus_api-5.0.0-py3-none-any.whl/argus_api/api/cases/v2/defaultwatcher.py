"""Autogenerated API"""

from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(extending=("cases", "v2", "defaultwatcher"), module=argus_cli_module)
def add_default_watcher(
    customer: str,
    service: str,
    caseType: str = None,
    priority: str = None,
    subject: str = None,
    disabled: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Define a new default watcher (DEV)

    :param str customer: Which customer to subscribe to updates for.
    :param str service: Which service to subscribe to updates for.
    :param list caseType: Which case types this watcher should be enabled for. If not set\, it will be enabled for all case types.
    :param list priority: Which priorities this watcher should be enabled for. If not set\, it will be enabled for all priorities.
    :param str subject: Which user or group to create a subscription for. If not set\, the default is the current user.
    :param bool disabled: If true\, this will create a disabled subscription \(which may override inherited group subscriptions\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/defaultwatcher".format()
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        body.update({"service": service})
    # Only send caseType if the argument was provided, don't send null values
    if caseType is not None:
        body.update({"caseType": caseType})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send subject if the argument was provided, don't send null values
    if subject is not None:
        body.update({"subject": subject})
    # Only send disabled if the argument was provided, don't send null values
    if disabled is not None:
        body.update({"disabled": disabled})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "defaultwatcher"), module=argus_cli_module)
def delete_default_watcher(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Delete a default watcher (DEV)

    :param str id:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/defaultwatcher/{id}".format(id=id)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "defaultwatcher"), module=argus_cli_module)
def get_default_watcher(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Get a default watcher (DEV)

    :param str id:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/defaultwatcher/{id}".format(id=id)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "defaultwatcher"), module=argus_cli_module)
def list_current_user_default_watchers(
    customer: str = None,
    service: str = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = 0,
    includeGroups: bool = True,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List default watchers for the current user. (DEV)

    :param list customer: Filter by customer
    :param list service: Filter by service
    :param list sortBy: Define sort order
    :param int limit: Limit number of results
    :param int offset: Skip initial results
    :param bool includeGroups: If true\, also include default watchers defined for parent user groups
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/defaultwatcher/currentuser".format()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        query_parameters.update({"service": service})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeGroups if the argument was provided, don't send null values
    if includeGroups is not None:
        query_parameters.update({"includeGroups": includeGroups})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "defaultwatcher"), module=argus_cli_module)
def list_default_watchers(
    customer: str = None,
    service: str = None,
    caseType: str = None,
    priority: str = None,
    accessMode: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List default watchers for a specified service. NOTE: This endpoint fetches converted Customer Contacts, until migration of Default Watchers have finished. See GET /defaultwatcher/new (PUBLIC)

    :param list customer: Filter watchers by customer
    :param list service: Filter watchers by service
    :param list caseType: Filter watchers by caseType
    :param list priority: Filter watchers by priority
    :param str accessMode: Filter watchers by access mode
    :param int offset:
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/defaultwatcher".format()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        query_parameters.update({"service": service})
    # Only send caseType if the argument was provided, don't send null values
    if caseType is not None:
        query_parameters.update({"caseType": caseType})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        query_parameters.update({"priority": priority})
    # Only send accessMode if the argument was provided, don't send null values
    if accessMode is not None:
        query_parameters.update({"accessMode": accessMode})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "defaultwatcher"), module=argus_cli_module)
def list_default_watchers_new(
    customer: str = None,
    service: str = None,
    caseType: str = None,
    priority: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List default watchers. NOTE: this is a temporary migration endpoint, using new underlying data, and NOT returning legacy Customer contacts. The endpoint will replace GET /defaultwatcher when migration is done.  (DEV)

    :param list customer: Filter watchers by customer
    :param list service: Filter watchers by service
    :param list caseType: Filter watchers by caseType
    :param list priority: Filter watchers by priority
    :param int offset:
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/defaultwatcher/new".format()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        query_parameters.update({"service": service})
    # Only send caseType if the argument was provided, don't send null values
    if caseType is not None:
        query_parameters.update({"caseType": caseType})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        query_parameters.update({"priority": priority})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "defaultwatcher"), module=argus_cli_module)
def search_default_watchers(
    accessMode: str = None,
    caseType: str = None,
    customer: str = None,
    includeDeleted: bool = None,
    priority: str = None,
    service: str = None,
    sortBy: str = None,
    subject: str = None,
    subjectInheritanceStrategy: str = None,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Search default watchers. NOTE: This endpoint fetches new DefaultWatcher data, and not the converted Customer Contacts.  (DEV)

    :param str accessMode: Limit result to default watchers defined for this access mode
    :param list caseType: Limit result to default watchers defined for these case types
    :param list customer: Limit result to default watchers defined for these customers \(by ID or shortname\)
    :param bool includeDeleted: If true\, also include deleted default watchers.
    :param list priority: Limit result to default watchers defined for these case priorities
    :param list service: Limit result to default watchers defined for these case services \(by ID or shortname\)
    :param list sortBy: Specify the order of results. Prefix with \'\-\' to order descending.
    :param list subject: Limit result to default watchers matching these users\/groups \(by ID or shortname\)
    :param str subjectInheritanceStrategy: Select strategy to use when filtering by subject.
    :param int limit: Limit results
    :param int offset: Skip first results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/defaultwatcher/search".format()
    headers = {}

    body = body or {}
    # Only send accessMode if the argument was provided, don't send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})
    # Only send caseType if the argument was provided, don't send null values
    if caseType is not None:
        body.update({"caseType": caseType})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        body.update({"service": service})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send subject if the argument was provided, don't send null values
    if subject is not None:
        body.update({"subject": subject})
    # Only send subjectInheritanceStrategy if the argument was provided, don't send null values
    if subjectInheritanceStrategy is not None:
        body.update({"subjectInheritanceStrategy": subjectInheritanceStrategy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "defaultwatcher"), module=argus_cli_module)
def update_default_watcher(
    id: str,
    caseType: str = None,
    priority: str = None,
    disabled: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update an existing default watcher (DEV)

    :param str id:
    :param list caseType: If set\, update case types this watcher should be enabled for. Default is no change.
    :param list priority: If set\, update priorities this watcher should be enabled for. Default is no change.
    :param bool disabled: If set\, change the disabled flag for this watcher.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/defaultwatcher/{id}".format(id=id)
    headers = {}

    body = body or {}
    # Only send caseType if the argument was provided, don't send null values
    if caseType is not None:
        body.update({"caseType": caseType})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send disabled if the argument was provided, don't send null values
    if disabled is not None:
        body.update({"disabled": disabled})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
