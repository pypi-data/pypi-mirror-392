"""Autogenerated API"""

from argus_api.session import get_session as _get_session
from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from argus_api.session import ArgusAPISession


def get_notifications(
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns a list of current user's notifications (DEV)

    :param int limit: Limit number of results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/notifications/v2/notification".format()

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def notification_bulk_seen(
    endTimestamp: int = None,
    notificationIDs: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Marks notifications as seen, either by timestamp or specified ids (DEV)

    :param int endTimestamp: Timestamp on the day until which to mark notifications as seen. Defaults to time of request.
    :param list notificationIDs: UUID of notifications to mark as seen. If empty or null\, all are set to seen.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/notifications/v2/notification/seen".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send notificationIDs if the argument was provided, don't send null values
    if notificationIDs is not None:
        body.update({"notificationIDs": notificationIDs})

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def notification_seen(
    notificationID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Marks a single notification as seen (DEV)

    :param str notificationID: Notification ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/notifications/v2/notification/{notificationID}/seen".format(
        notificationID=notificationID
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def search_notifications(
    channels: str = None,
    endTimestamp: int = None,
    excludeFlags: str = None,
    includeFlags: str = None,
    objectCustomer: str = None,
    objectID: str = None,
    operation: str = None,
    service: str = None,
    startTimestamp: int = None,
    user: str = None,
    includeContext: bool = False,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns a list of current user's notifications matching the search criteria (DEV)

    :param list channels: Restrict search to return notifications which was attempted to send in at least one off the specified channels. Defaults to no channel restrictions.
    :param int endTimestamp: Restrict search to return notifications created before the timestamp. Defaults to now.
    :param list excludeFlags: Restrict search to return notifications which have the specified flags unset.
    :param list includeFlags: Restrict search to return notifications which have the specified flags set.
    :param list objectCustomer: Limit to notifications generated by the specified customers. Can be a list of shortnames and\/or customerIDs
    :param list objectID: Limit to notification generated by the specified set of Argus objects by their IDs
    :param list operation: Limit to notifications generated by the specified Argus operations
    :param list service: Limit to notifications generated by the specified Argus services.
    :param int startTimestamp: Restrict search to return notifications created after the timestamp. Defaults to no restrictions.
    :param list user: Restrict search to return notifications generated by specified users. Can be shortnames or userIds.
    :param bool includeContext: Specify if service specific notification context should be included
    :param int limit: Limit number of returning notifications.
    :param int offset: Offset notifications
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/notifications/v2/notification/search".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send channels if the argument was provided, don't send null values
    if channels is not None:
        body.update({"channels": channels})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send objectCustomer if the argument was provided, don't send null values
    if objectCustomer is not None:
        body.update({"objectCustomer": objectCustomer})
    # Only send objectID if the argument was provided, don't send null values
    if objectID is not None:
        body.update({"objectID": objectID})
    # Only send operation if the argument was provided, don't send null values
    if operation is not None:
        body.update({"operation": operation})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        body.update({"service": service})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send includeContext if the argument was provided, don't send null values
    if includeContext is not None:
        body.update({"includeContext": includeContext})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
