"""Autogenerated API"""

from argus_api.session import get_session as _get_session
from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from argus_api.session import ArgusAPISession
from requests import Response


def find_aggregated_event_stats(
    alarmID: int = None,
    associatedCaseID: int = None,
    attackCategoryID: int = None,
    countRawEvents: bool = None,
    customer: str = None,
    customerID: int = None,
    cutoff: int = None,
    destinationGeoCountry: str = None,
    destinationIP: str = None,
    destinationIPMinBits: int = None,
    destinationPort: str = None,
    domain: str = None,
    endTimestamp: str = None,
    eventIdentifier: dict = None,
    exclude: bool = None,
    excludeFlag: dict = None,
    excludeFlags: str = None,
    geoCountry: str = None,
    groupBy: str = None,
    includeDeleted: bool = None,
    includeFlag: dict = None,
    includeFlags: str = None,
    includeOthers: bool = None,
    indexEndTime: int = None,
    indexStartTime: int = None,
    ip: str = None,
    lastUpdatedTimestamp: int = None,
    locationID: int = None,
    maxSeverity: str = None,
    minCount: int = None,
    minSeverity: str = None,
    port: str = None,
    productionCustomers: bool = None,
    properties: dict = None,
    required: bool = None,
    resolution: int = None,
    resolutionUnit: str = None,
    severity: str = None,
    signature: str = None,
    sourceGeoCountry: str = None,
    sourceIP: str = None,
    sourceIPMinBits: int = None,
    sourcePort: str = None,
    startTimestamp: str = None,
    subCriteria: dict = None,
    timeFieldStrategy: str = None,
    exactMatchProperties: bool = True,
    multivaluePropertySeparator: str = "comma",
    skipFutureEvents: bool = False,
    timeFrameStrategy: str = "startEndTimestamp",
    includeUnpublished: bool = True,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Fetch aggregated event stats (PUBLIC)

    :param list alarmID: Search for events having an attack identifier \(signature\) mapped to any of these alarms.
    :param list associatedCaseID: Search for events associated to one of these cases\, 0 will match events NOT associated with any case
    :param list attackCategoryID: Search for events having an attack identifier \(signature\) mapped to any of these categories.
    :param bool countRawEvents: Return the number of raw events \(not the number of aggregated events\)
    :param list customer: Search for events by customer \(id or shortname\).
    :param list customerID: DEPRECATED\! Use customer instead
    :param int cutoff: If set\, keep the \<cutoff\> biggest records\, and cut off the rest.
    :param list destinationGeoCountry: Search for events where destination IP is registered in any of these countries.
    :param list destinationIP:
    :param int destinationIPMinBits: Do not include destination CIDR\-networks with wider mask than this
    :param list destinationPort:
    :param list domain: Search for events having one of these domains. The domains are not validated
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list eventIdentifier: Search for events specified by full ID \(type\/timestamp\/customerID\/eventID\).
    :param bool exclude: Exclude these criteria from the parent criteria.
    :param dict excludeFlag:
    :param list excludeFlags: Exclude objects with these flags set
    :param list geoCountry: Search for events where source or destination IP is registered in any of these countries.
    :param list groupBy: Group results by these fields
    :param bool includeDeleted: Also include deleted objects \(where implemented\)
    :param dict includeFlag:
    :param list includeFlags: Search objects with these flags set
    :param bool includeOthers: If true \(default\)\, records which are cut off are collected into a common \"other\" record
    :param int indexEndTime: Last created time of the indices searched.
    :param int indexStartTime: Earliest created time of the indices searched.
    :param list ip:
    :param int lastUpdatedTimestamp: Match only with events marked with a last updated time greater or equal to this.
    :param list locationID: Search for events having these locations.
    :param str maxSeverity:
    :param int minCount: Search for events with aggregated count at least this high
    :param str minSeverity:
    :param list port:
    :param bool productionCustomers: If set\, apply a customer filter for customers marked as \'not in production\'. If true\, EXCLUDE customers \'not in production\'. If false\, REQUIRE customers \'not in production\'. Default is unset \(no filter on production customers\).
    :param dict properties: Search for events having these properties \(logical AND\).
    :param bool required: Only relevant for subcriteria. If set to true\, objects matching this subcriteria are required \(AND\-ed together with parent criteria\).
    :param int resolution: Divide results into timeframes with this size \(in milliseconds\)
    :param str resolutionUnit: For use with date histogram\, this will bind the intervals to the unit given.Calendar units\, such as weeks\, months\, and years\, can only be used with a resolution of 1. Default is milliseconds
    :param list severity: Search events with specified severity. Can\'t be used together with minSeverity\/maxSeverity.
    :param list signature:
    :param list sourceGeoCountry: Search for events where source IP is registered in any of these countries.
    :param list sourceIP:
    :param int sourceIPMinBits: Do not include source CIDR\-networks with wider mask than this
    :param list sourcePort:
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list subCriteria: Allow subcriteria \(include or exclude\)\, to refine search arbitrarily
    :param list timeFieldStrategy: Defines which timestamps will be included in the search\, will default to startTimestamp\/endTimestamp.This field cannot be used alongside the lastUpdateTime field due to backwards compatibility.
    :param bool exactMatchProperties: If set to true\, will execute in\-memory filtering to only match events that have exact match of properties specified at top level \"properties\" field of search request. WARN\: The count of response would not be reliable\, as the filtering is applied in\-memory of application server\, but the count was done by search engine.
    :param str multivaluePropertySeparator: Separator that is going to be used when formatting the multi\-value properties of the found events.
    :param bool skipFutureEvents: Whether service should generate endTimestamp by current timestamp.
    :param str timeFrameStrategy: Configures the aggregation search to use start\/end timestamp or just event timestamp for the timeframe of the search.
    :param bool includeUnpublished: If set to false\, will exclude unpublished events \(i.e. events that have publicationTimestamp in the future\).
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v1/aggregated/stats".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send alarmID if the argument was provided, don't send null values
    if alarmID is not None:
        body.update({"alarmID": alarmID})
    # Only send associatedCaseID if the argument was provided, don't send null values
    if associatedCaseID is not None:
        body.update({"associatedCaseID": associatedCaseID})
    # Only send attackCategoryID if the argument was provided, don't send null values
    if attackCategoryID is not None:
        body.update({"attackCategoryID": attackCategoryID})
    # Only send countRawEvents if the argument was provided, don't send null values
    if countRawEvents is not None:
        body.update({"countRawEvents": countRawEvents})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send cutoff if the argument was provided, don't send null values
    if cutoff is not None:
        body.update({"cutoff": cutoff})
    # Only send destinationGeoCountry if the argument was provided, don't send null values
    if destinationGeoCountry is not None:
        body.update({"destinationGeoCountry": destinationGeoCountry})
    # Only send destinationIP if the argument was provided, don't send null values
    if destinationIP is not None:
        body.update({"destinationIP": destinationIP})
    # Only send destinationIPMinBits if the argument was provided, don't send null values
    if destinationIPMinBits is not None:
        body.update({"destinationIPMinBits": destinationIPMinBits})
    # Only send destinationPort if the argument was provided, don't send null values
    if destinationPort is not None:
        body.update({"destinationPort": destinationPort})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send eventIdentifier if the argument was provided, don't send null values
    if eventIdentifier is not None:
        body.update({"eventIdentifier": eventIdentifier})
    # Only send exclude if the argument was provided, don't send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send excludeFlag if the argument was provided, don't send null values
    if excludeFlag is not None:
        body.update({"excludeFlag": excludeFlag})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send geoCountry if the argument was provided, don't send null values
    if geoCountry is not None:
        body.update({"geoCountry": geoCountry})
    # Only send groupBy if the argument was provided, don't send null values
    if groupBy is not None:
        body.update({"groupBy": groupBy})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeFlag if the argument was provided, don't send null values
    if includeFlag is not None:
        body.update({"includeFlag": includeFlag})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send includeOthers if the argument was provided, don't send null values
    if includeOthers is not None:
        body.update({"includeOthers": includeOthers})
    # Only send indexEndTime if the argument was provided, don't send null values
    if indexEndTime is not None:
        body.update({"indexEndTime": indexEndTime})
    # Only send indexStartTime if the argument was provided, don't send null values
    if indexStartTime is not None:
        body.update({"indexStartTime": indexStartTime})
    # Only send ip if the argument was provided, don't send null values
    if ip is not None:
        body.update({"ip": ip})
    # Only send lastUpdatedTimestamp if the argument was provided, don't send null values
    if lastUpdatedTimestamp is not None:
        body.update({"lastUpdatedTimestamp": lastUpdatedTimestamp})
    # Only send locationID if the argument was provided, don't send null values
    if locationID is not None:
        body.update({"locationID": locationID})
    # Only send maxSeverity if the argument was provided, don't send null values
    if maxSeverity is not None:
        body.update({"maxSeverity": maxSeverity})
    # Only send minCount if the argument was provided, don't send null values
    if minCount is not None:
        body.update({"minCount": minCount})
    # Only send minSeverity if the argument was provided, don't send null values
    if minSeverity is not None:
        body.update({"minSeverity": minSeverity})
    # Only send port if the argument was provided, don't send null values
    if port is not None:
        body.update({"port": port})
    # Only send productionCustomers if the argument was provided, don't send null values
    if productionCustomers is not None:
        body.update({"productionCustomers": productionCustomers})
    # Only send properties if the argument was provided, don't send null values
    if properties is not None:
        body.update({"properties": properties})
    # Only send required if the argument was provided, don't send null values
    if required is not None:
        body.update({"required": required})
    # Only send resolution if the argument was provided, don't send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send resolutionUnit if the argument was provided, don't send null values
    if resolutionUnit is not None:
        body.update({"resolutionUnit": resolutionUnit})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        body.update({"signature": signature})
    # Only send sourceGeoCountry if the argument was provided, don't send null values
    if sourceGeoCountry is not None:
        body.update({"sourceGeoCountry": sourceGeoCountry})
    # Only send sourceIP if the argument was provided, don't send null values
    if sourceIP is not None:
        body.update({"sourceIP": sourceIP})
    # Only send sourceIPMinBits if the argument was provided, don't send null values
    if sourceIPMinBits is not None:
        body.update({"sourceIPMinBits": sourceIPMinBits})
    # Only send sourcePort if the argument was provided, don't send null values
    if sourcePort is not None:
        body.update({"sourcePort": sourcePort})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send exactMatchProperties if the argument was provided, don't send null values
    if exactMatchProperties is not None:
        body.update({"exactMatchProperties": exactMatchProperties})
    # Only send multivaluePropertySeparator if the argument was provided, don't send null values
    if multivaluePropertySeparator is not None:
        body.update({"multivaluePropertySeparator": multivaluePropertySeparator})
    # Only send skipFutureEvents if the argument was provided, don't send null values
    if skipFutureEvents is not None:
        body.update({"skipFutureEvents": skipFutureEvents})
    # Only send timeFrameStrategy if the argument was provided, don't send null values
    if timeFrameStrategy is not None:
        body.update({"timeFrameStrategy": timeFrameStrategy})
    # Only send includeUnpublished if the argument was provided, don't send null values
    if includeUnpublished is not None:
        body.update({"includeUnpublished": includeUnpublished})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def find_aggregated_events(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    customerID: int = None,
    exclude: bool = None,
    required: bool = None,
    eventIdentifier: dict = None,
    locationID: int = None,
    severity: str = None,
    customer: str = None,
    alarmID: int = None,
    attackCategoryID: int = None,
    sourceGeoCountry: str = None,
    destinationGeoCountry: str = None,
    geoCountry: str = None,
    domain: str = None,
    properties: dict = None,
    productionCustomers: bool = None,
    minCount: int = None,
    associatedCaseID: int = None,
    sourceIPMinBits: int = None,
    destinationIPMinBits: int = None,
    subCriteria: dict = None,
    timeFieldStrategy: str = None,
    signature: str = None,
    endTimestamp: str = None,
    startTimestamp: str = None,
    sortBy: str = None,
    excludeFlag: dict = None,
    includeFlag: dict = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    lastUpdatedTimestamp: int = None,
    indexStartTime: int = None,
    indexEndTime: int = None,
    destinationIP: str = None,
    sourceIP: str = None,
    ip: str = None,
    destinationPort: str = None,
    sourcePort: str = None,
    port: str = None,
    minSeverity: str = None,
    maxSeverity: str = None,
    skipFutureEvents: bool = False,
    exactMatchProperties: bool = True,
    multivaluePropertySeparator: str = "comma",
    includeUnpublished: bool = True,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Search for aggregated events (PUBLIC)

    :param int limit: Limit results
    :param int offset: Offset results
    :param bool includeDeleted: Also include deleted objects \(where implemented\)
    :param list customerID: DEPRECATED\! Use customer instead
    :param bool exclude: Exclude these criteria from the parent criteria.
    :param bool required: Only relevant for subcriteria. If set to true\, objects matching this subcriteria are required \(AND\-ed together with parent criteria\).
    :param list eventIdentifier: Search for events specified by full ID \(type\/timestamp\/customerID\/eventID\).
    :param list locationID: Search for events having these locations.
    :param list severity: Search events with specified severity. Can\'t be used together with minSeverity\/maxSeverity.
    :param list customer: Search for events by customer \(id or shortname\).
    :param list alarmID: Search for events having an attack identifier \(signature\) mapped to any of these alarms.
    :param list attackCategoryID: Search for events having an attack identifier \(signature\) mapped to any of these categories.
    :param list sourceGeoCountry: Search for events where source IP is registered in any of these countries.
    :param list destinationGeoCountry: Search for events where destination IP is registered in any of these countries.
    :param list geoCountry: Search for events where source or destination IP is registered in any of these countries.
    :param list domain: Search for events having one of these domains. The domains are not validated
    :param dict properties: Search for events having these properties \(logical AND\).
    :param bool productionCustomers: If set\, apply a customer filter for customers marked as \'not in production\'. If true\, EXCLUDE customers \'not in production\'. If false\, REQUIRE customers \'not in production\'. Default is unset \(no filter on production customers\).
    :param int minCount: Search for events with aggregated count at least this high
    :param list associatedCaseID: Search for events associated to one of these cases\, 0 will match events NOT associated with any case
    :param int sourceIPMinBits: Do not include source CIDR\-networks with wider mask than this
    :param int destinationIPMinBits: Do not include destination CIDR\-networks with wider mask than this
    :param list subCriteria: Allow subcriteria \(include or exclude\)\, to refine search arbitrarily
    :param list timeFieldStrategy: Defines which timestamps will be included in the search\, will default to startTimestamp\/endTimestamp.This field cannot be used alongside the lastUpdateTime field due to backwards compatibility.
    :param list signature:
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list sortBy: Order results by these properties \(prefix with \- to sort descending\)
    :param dict excludeFlag:
    :param dict includeFlag:
    :param list includeFlags: Search objects with these flags set
    :param list excludeFlags: Exclude objects with these flags set
    :param int lastUpdatedTimestamp: Match only with events marked with a last updated time greater or equal to this.
    :param int indexStartTime: Earliest created time of the indices searched.
    :param int indexEndTime: Last created time of the indices searched.
    :param list destinationIP:
    :param list sourceIP:
    :param list ip:
    :param list destinationPort:
    :param list sourcePort:
    :param list port:
    :param str minSeverity:
    :param str maxSeverity:
    :param bool skipFutureEvents: Whether service should generate endTimestamp by current timestamp.
    :param bool exactMatchProperties: If set to true\, will execute in\-memory filtering to only match events that have exact match of properties specified at top level \"properties\" field of search request. WARN\: The count of response would not be reliable\, as the filtering is applied in\-memory of application server\, but the count was done by search engine.
    :param str multivaluePropertySeparator: Separator that is going to be used when formatting the multi\-value properties of the found events.
    :param bool includeUnpublished: If set to false\, will exclude unpublished events \(i.e. events that have publicationTimestamp in the future\).
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/events/v1/aggregated/search".format()

    session = api_session or _get_session()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    body = body or {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send exclude if the argument was provided, don't send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, don't send null values
    if required is not None:
        body.update({"required": required})
    # Only send eventIdentifier if the argument was provided, don't send null values
    if eventIdentifier is not None:
        body.update({"eventIdentifier": eventIdentifier})
    # Only send locationID if the argument was provided, don't send null values
    if locationID is not None:
        body.update({"locationID": locationID})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send alarmID if the argument was provided, don't send null values
    if alarmID is not None:
        body.update({"alarmID": alarmID})
    # Only send attackCategoryID if the argument was provided, don't send null values
    if attackCategoryID is not None:
        body.update({"attackCategoryID": attackCategoryID})
    # Only send sourceGeoCountry if the argument was provided, don't send null values
    if sourceGeoCountry is not None:
        body.update({"sourceGeoCountry": sourceGeoCountry})
    # Only send destinationGeoCountry if the argument was provided, don't send null values
    if destinationGeoCountry is not None:
        body.update({"destinationGeoCountry": destinationGeoCountry})
    # Only send geoCountry if the argument was provided, don't send null values
    if geoCountry is not None:
        body.update({"geoCountry": geoCountry})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send properties if the argument was provided, don't send null values
    if properties is not None:
        body.update({"properties": properties})
    # Only send productionCustomers if the argument was provided, don't send null values
    if productionCustomers is not None:
        body.update({"productionCustomers": productionCustomers})
    # Only send minCount if the argument was provided, don't send null values
    if minCount is not None:
        body.update({"minCount": minCount})
    # Only send associatedCaseID if the argument was provided, don't send null values
    if associatedCaseID is not None:
        body.update({"associatedCaseID": associatedCaseID})
    # Only send sourceIPMinBits if the argument was provided, don't send null values
    if sourceIPMinBits is not None:
        body.update({"sourceIPMinBits": sourceIPMinBits})
    # Only send destinationIPMinBits if the argument was provided, don't send null values
    if destinationIPMinBits is not None:
        body.update({"destinationIPMinBits": destinationIPMinBits})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        body.update({"signature": signature})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send excludeFlag if the argument was provided, don't send null values
    if excludeFlag is not None:
        body.update({"excludeFlag": excludeFlag})
    # Only send includeFlag if the argument was provided, don't send null values
    if includeFlag is not None:
        body.update({"includeFlag": includeFlag})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send lastUpdatedTimestamp if the argument was provided, don't send null values
    if lastUpdatedTimestamp is not None:
        body.update({"lastUpdatedTimestamp": lastUpdatedTimestamp})
    # Only send indexStartTime if the argument was provided, don't send null values
    if indexStartTime is not None:
        body.update({"indexStartTime": indexStartTime})
    # Only send indexEndTime if the argument was provided, don't send null values
    if indexEndTime is not None:
        body.update({"indexEndTime": indexEndTime})
    # Only send destinationIP if the argument was provided, don't send null values
    if destinationIP is not None:
        body.update({"destinationIP": destinationIP})
    # Only send sourceIP if the argument was provided, don't send null values
    if sourceIP is not None:
        body.update({"sourceIP": sourceIP})
    # Only send ip if the argument was provided, don't send null values
    if ip is not None:
        body.update({"ip": ip})
    # Only send destinationPort if the argument was provided, don't send null values
    if destinationPort is not None:
        body.update({"destinationPort": destinationPort})
    # Only send sourcePort if the argument was provided, don't send null values
    if sourcePort is not None:
        body.update({"sourcePort": sourcePort})
    # Only send port if the argument was provided, don't send null values
    if port is not None:
        body.update({"port": port})
    # Only send minSeverity if the argument was provided, don't send null values
    if minSeverity is not None:
        body.update({"minSeverity": minSeverity})
    # Only send maxSeverity if the argument was provided, don't send null values
    if maxSeverity is not None:
        body.update({"maxSeverity": maxSeverity})
    # Only send skipFutureEvents if the argument was provided, don't send null values
    if skipFutureEvents is not None:
        body.update({"skipFutureEvents": skipFutureEvents})
    # Only send exactMatchProperties if the argument was provided, don't send null values
    if exactMatchProperties is not None:
        body.update({"exactMatchProperties": exactMatchProperties})
    # Only send multivaluePropertySeparator if the argument was provided, don't send null values
    if multivaluePropertySeparator is not None:
        body.update({"multivaluePropertySeparator": multivaluePropertySeparator})
    # Only send includeUnpublished if the argument was provided, don't send null values
    if includeUnpublished is not None:
        body.update({"includeUnpublished": includeUnpublished})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_aggregated_events(
    customerID: int = None,
    signature: str = None,
    ip: dict = None,
    startTimestamp: str = "-24hours",
    endTimestamp: str = "now",
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Simple search for aggregated events (PUBLIC)

    :param list customerID: Limit to customerID
    :param list signature: Limit to signature
    :param list ip: Limit to ip\/network
    :param str startTimestamp: Limit to events after this timestamp \(default is last 24 hours\).
    :param str endTimestamp: Limit to events before this timestamp. Defaults to now.
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/events/v1/aggregated".format()

    session = api_session or _get_session()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    query_parameters = {}
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        query_parameters.update({"signature": signature})
    # Only send ip if the argument was provided, don't send null values
    if ip is not None:
        query_parameters.update({"ip": ip})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_events(
    update: dict,
    eventIdentifiers: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Add event assessments (INTERNAL)

    :param dict update:
    :param list eventIdentifiers: Update events specified by full ID \(type\/timestamp\/customerID\/eventID\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises EventsNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v1/aggregated".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send update if the argument was provided, don't send null values
    if update is not None:
        body.update({"update": update})
    # Only send eventIdentifiers if the argument was provided, don't send null values
    if eventIdentifiers is not None:
        body.update({"eventIdentifiers": eventIdentifiers})

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_events_bulk(
    criteria: dict,
    update: dict,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Assess events in bulk mode (INTERNAL)

    :param dict criteria:
    :param dict update:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises EventsNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v1/aggregated/bulk".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send criteria if the argument was provided, don't send null values
    if criteria is not None:
        body.update({"criteria": criteria})
    # Only send update if the argument was provided, don't send null values
    if update is not None:
        body.update({"update": update})

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
