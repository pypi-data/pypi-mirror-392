"""Autogenerated API"""

from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("authentication", "v1", "sms", "authenticate"), module=argus_cli_module
)
def disable_current_user_sms_authentication(
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Disable the current users SMS authentication method (PUBLIC)

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/sms/disable".format()
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("authentication", "v1", "sms", "authenticate"), module=argus_cli_module
)
def legacy_sms_authentication(
    mode: str,
    passcode: str,
    userName: str,
    cookie: str = None,
    domain: str = None,
    requestedAuthorizations: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Initiate a new user session using SMS authentication (PUBLIC)

    :param str mode: Use PASSWORD for initial request\, and SMS to respond with SMS code
    :param str passcode: Password or SMS code
    :param str userName: Username to authenticate
    :param str cookie: When responding with SMS code\, set the SMS session cookie returned by challenge
    :param str domain: User domain
    :param list requestedAuthorizations: Allow client to request authorizations as part of the authentication transaction. The client is not guaranteed to get the requested authorizations. The setPassword authorization is only returned if the current user has the FORCE\_PW\_CHANGE flag set.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/sms/authenticate".format()
    headers = {}

    body = body or {}
    # Only send mode if the argument was provided, don't send null values
    if mode is not None:
        body.update({"mode": mode})
    # Only send passcode if the argument was provided, don't send null values
    if passcode is not None:
        body.update({"passcode": passcode})
    # Only send userName if the argument was provided, don't send null values
    if userName is not None:
        body.update({"userName": userName})
    # Only send cookie if the argument was provided, don't send null values
    if cookie is not None:
        body.update({"cookie": cookie})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send requestedAuthorizations if the argument was provided, don't send null values
    if requestedAuthorizations is not None:
        body.update({"requestedAuthorizations": requestedAuthorizations})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("authentication", "v1", "sms", "authenticate"), module=argus_cli_module
)
def send_sms_validation_code(
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Request an SMS validation token to validate user presence. The returned token must be used when requesting authorization token. (INTERNAL)

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/sms/authorize".format()
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("authentication", "v1", "sms", "authenticate"), module=argus_cli_module
)
def sms_authentication(
    mode: str,
    passcode: str,
    userName: str,
    cookie: str = None,
    domain: str = None,
    requestedAuthorizations: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Initiate a new user session using SMS authentication (PUBLIC)

    :param str mode: Use PASSWORD for initial request\, and SMS to respond with SMS code
    :param str passcode: Password or SMS code
    :param str userName: Username to authenticate
    :param str cookie: When responding with SMS code\, set the SMS session cookie returned by challenge
    :param str domain: User domain
    :param list requestedAuthorizations: Allow client to request authorizations as part of the authentication transaction. The client is not guaranteed to get the requested authorizations. The setPassword authorization is only returned if the current user has the FORCE\_PW\_CHANGE flag set.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/sms/authentication".format()
    headers = {}

    body = body or {}
    # Only send mode if the argument was provided, don't send null values
    if mode is not None:
        body.update({"mode": mode})
    # Only send passcode if the argument was provided, don't send null values
    if passcode is not None:
        body.update({"passcode": passcode})
    # Only send userName if the argument was provided, don't send null values
    if userName is not None:
        body.update({"userName": userName})
    # Only send cookie if the argument was provided, don't send null values
    if cookie is not None:
        body.update({"cookie": cookie})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send requestedAuthorizations if the argument was provided, don't send null values
    if requestedAuthorizations is not None:
        body.update({"requestedAuthorizations": requestedAuthorizations})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("authentication", "v1", "sms", "authenticate"), module=argus_cli_module
)
def sms_user_authorization(
    cookie: str,
    nextURI: str,
    operation: str,
    token: str,
    context: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Request an authorization token using an SMS validation code (INTERNAL)

    :param str cookie: The cookie returned from the send\-sms request
    :param str nextURI: The URI to redirect\/route to after successful authorization. The URI will be validated according to policy. The authorization token returned from successful authorization should be appended as a query parameter to this URI.
    :param str operation: The name of the operation to authorize
    :param str token: The token received via SMS
    :param dict context: Context variables to scope this authorization. All context variables required by the executing service must be present and equal to those provided here.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/sms/authorize".format()
    headers = {}

    body = body or {}
    # Only send cookie if the argument was provided, don't send null values
    if cookie is not None:
        body.update({"cookie": cookie})
    # Only send nextURI if the argument was provided, don't send null values
    if nextURI is not None:
        body.update({"nextURI": nextURI})
    # Only send operation if the argument was provided, don't send null values
    if operation is not None:
        body.update({"operation": operation})
    # Only send token if the argument was provided, don't send null values
    if token is not None:
        body.update({"token": token})
    # Only send context if the argument was provided, don't send null values
    if context is not None:
        body.update({"context": context})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
