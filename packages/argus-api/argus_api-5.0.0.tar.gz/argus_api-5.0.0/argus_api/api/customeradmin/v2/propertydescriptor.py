"""Autogenerated API"""

from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def add_property_descriptor(
    key: str,
    localizedDescriptions: dict,
    section: str,
    type: str,
    defaultValue: dict = None,
    externallyManaged: bool = None,
    hidden: bool = None,
    localizedNames: dict = None,
    overwriteIfExists: bool = None,
    readFunction: str = None,
    schema: dict = None,
    uiSchema: dict = None,
    writeFunction: str = None,
    sectionIndex: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Create a new property descriptor (PUBLIC)

    :param str key: Key of the new property descriptor
    :param dict localizedDescriptions: Property descriptor descriptions mapped by language. Supported languages are\: english\, norwegian. Description in English is required.
    :param str section: Section of the property.
    :param str type: Type of the property.
    :param dict defaultValue:
    :param bool externallyManaged: If true\, mark this property as externally managed.
    :param bool hidden: If true\, this property will be hidden in the UI.
    :param dict localizedNames: Property descriptor names mapped by language. Supported languages are\: english\, norwegian. If no name is set\, this defaults to the property key
    :param bool overwriteIfExists: If true\, overwrite existing property if already defined. Default is to fail with a 412 error.
    :param str readFunction: The function required to read this property for a customer \(default is viewCustomers\).
    :param dict schema:
    :param dict uiSchema:
    :param str writeFunction: The function required to write this property for a customer \(default is updateCustomer\).
    :param int sectionIndex: Section index for the property. If set this is used to force a sort order. Default is 0\, resulting in alphabetical sorting.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor".format()
    headers = {}

    body = body or {}
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        body.update({"key": key})
    # Only send localizedDescriptions if the argument was provided, don't send null values
    if localizedDescriptions is not None:
        body.update({"localizedDescriptions": localizedDescriptions})
    # Only send section if the argument was provided, don't send null values
    if section is not None:
        body.update({"section": section})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send defaultValue if the argument was provided, don't send null values
    if defaultValue is not None:
        body.update({"defaultValue": defaultValue})
    # Only send externallyManaged if the argument was provided, don't send null values
    if externallyManaged is not None:
        body.update({"externallyManaged": externallyManaged})
    # Only send hidden if the argument was provided, don't send null values
    if hidden is not None:
        body.update({"hidden": hidden})
    # Only send localizedNames if the argument was provided, don't send null values
    if localizedNames is not None:
        body.update({"localizedNames": localizedNames})
    # Only send overwriteIfExists if the argument was provided, don't send null values
    if overwriteIfExists is not None:
        body.update({"overwriteIfExists": overwriteIfExists})
    # Only send readFunction if the argument was provided, don't send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send schema if the argument was provided, don't send null values
    if schema is not None:
        body.update({"schema": schema})
    # Only send uiSchema if the argument was provided, don't send null values
    if uiSchema is not None:
        body.update({"uiSchema": uiSchema})
    # Only send writeFunction if the argument was provided, don't send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})
    # Only send sectionIndex if the argument was provided, don't send null values
    if sectionIndex is not None:
        body.update({"sectionIndex": sectionIndex})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def add_property_descriptor_enum_entry(
    idOrKey: str,
    localizedDescriptions: dict,
    localizedValues: dict,
    value: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Create a new property descriptor enum entry (PUBLIC)

    :param str idOrKey: Id or key of the descriptor
    :param dict localizedDescriptions: Property descriptor enum value descriptions mapped by language. Supported languages are\: english\, norwegian. Description in English is required.
    :param dict localizedValues: Property descriptor enum values mapped by language. Supported languages are\: english\, norwegian. Value in English is required.
    :param str value: Value of the new enum entry
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/{idOrKey}/values".format(
        idOrKey=idOrKey
    )
    headers = {}

    body = body or {}
    # Only send localizedDescriptions if the argument was provided, don't send null values
    if localizedDescriptions is not None:
        body.update({"localizedDescriptions": localizedDescriptions})
    # Only send localizedValues if the argument was provided, don't send null values
    if localizedValues is not None:
        body.update({"localizedValues": localizedValues})
    # Only send value if the argument was provided, don't send null values
    if value is not None:
        body.update({"value": value})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def delete_property_descriptor(
    idOrKey: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Delete a property descriptor (PUBLIC)

    :param str idOrKey: Property descriptor UUID or key
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/{idOrKey}".format(idOrKey=idOrKey)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def delete_property_descriptor_enum_entry(
    idOrKey: str,
    idOrValue: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Delete a property descriptor enum entry (PUBLIC)

    :param str idOrKey: Property descriptor UUID or key
    :param str idOrValue: Property descriptor enum entry UUID or value
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/{idOrKey}/values/{idOrValue}".format(
        idOrKey=idOrKey, idOrValue=idOrValue
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def get_property_descriptor(
    idOrKey: str,
    includeSchema: bool = None,
    includeUISchema: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns a property descriptor identified by its UUID or key (PUBLIC)

    :param str idOrKey: Property descriptor UUID or key
    :param bool includeSchema: Include JSONSchema\, defaults to false
    :param bool includeUISchema: Include UISchema\, defaults to false
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/{idOrKey}".format(idOrKey=idOrKey)
    headers = {}

    query_parameters = {}
    # Only send includeSchema if the argument was provided, don't send null values
    if includeSchema is not None:
        query_parameters.update({"includeSchema": includeSchema})
    # Only send includeUISchema if the argument was provided, don't send null values
    if includeUISchema is not None:
        query_parameters.update({"includeUISchema": includeUISchema})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def get_property_descriptor_json_schema(
    idOrKey: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns JSON Schema for a property descriptor identified by its UUID or key. (PUBLIC)

    :param str idOrKey: Property descriptor UUID or key
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/{idOrKey}/jsonschema".format(
        idOrKey=idOrKey
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def list_property_descriptor_enum_entries(
    idOrKey: str,
    keywords: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns property descriptor enum entries defined by query parameters (PUBLIC)

    :param str idOrKey: Property descriptor UUID or key
    :param list keywords: Search by keyword
    :param list sortBy: Sort search result
    :param int offset: By how many records to offset results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/{idOrKey}/values".format(
        idOrKey=idOrKey
    )
    headers = {}

    query_parameters = {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def list_property_descriptors(
    keywords: str = None,
    section: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    includeSchema: bool = False,
    includeUISchema: bool = False,
    includeDeleted: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns property descriptors defined by query parameters (PUBLIC)

    :param list keywords: Search by keyword
    :param list section: Search by section
    :param list sortBy: Sort search result
    :param int offset: By how many records to offset results
    :param int limit: Maximum number of returned results
    :param bool includeSchema: Set to true to include schema in response.
    :param bool includeUISchema: Set to true to include UISchema
    :param bool includeDeleted: Set to true to include deleted objects. By default\, exclude deleted objects.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor".format()
    headers = {}

    query_parameters = {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send section if the argument was provided, don't send null values
    if section is not None:
        query_parameters.update({"section": section})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send includeSchema if the argument was provided, don't send null values
    if includeSchema is not None:
        query_parameters.update({"includeSchema": includeSchema})
    # Only send includeUISchema if the argument was provided, don't send null values
    if includeUISchema is not None:
        query_parameters.update({"includeUISchema": includeUISchema})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def search_property_descriptor(
    excludeFlags: str = None,
    includeFlags: str = None,
    keywords: str = None,
    limit: int = None,
    offset: int = None,
    section: str = None,
    subCriteria: dict = None,
    type: str = None,
    includeDeleted: bool = False,
    includeSchema: bool = False,
    includeUISchema: bool = False,
    sortBy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Returns property descriptors defined by SearchPropertyDescriptorRequest (PUBLIC)

    :param list excludeFlags: Exclude objects which have excludeFlags set.
    :param list includeFlags: Only include objects which have includeFlags set.
    :param list keywords: Search for property descriptor by keywords. Searches through keys and default values.
    :param int limit: Max number of results.
    :param int offset: Skip the first \(offset\) objects. By default\, return result from first object.
    :param list section: Restrict search to a section.
    :param list subCriteria: Set additional criteria
    :param list type: Restrict search to a type.
    :param bool includeDeleted: Set to true to include deleted objects. By default\, exclude deleted objects.
    :param bool includeSchema: If true\, include schema of descriptors in response
    :param bool includeUISchema: If true\, include UI schema of descriptors in response
    :param list sortBy: Specify the order of results. Prefix with \'\-\' to order descending.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/search".format()
    headers = {}

    body = body or {}
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send section if the argument was provided, don't send null values
    if section is not None:
        body.update({"section": section})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeSchema if the argument was provided, don't send null values
    if includeSchema is not None:
        body.update({"includeSchema": includeSchema})
    # Only send includeUISchema if the argument was provided, don't send null values
    if includeUISchema is not None:
        body.update({"includeUISchema": includeUISchema})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def search_property_descriptor_enum_entries(
    idOrKey: str,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    keywords: str = None,
    limit: int = None,
    offset: int = None,
    subCriteria: dict = None,
    sortBy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Returns property descriptors defined by SearchPropertyDescriptorEnumEntryRequest (PUBLIC)

    :param str idOrKey: Property descriptor UUID or key
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\).
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords \(default match all keywords\).
    :param list keywords: Search for property descriptor by keywords. Searches through keys and default values.
    :param int limit: Max number of results.
    :param int offset: Skip the first \(offset\) objects. By default\, return result from first object.
    :param list subCriteria: Set additional criteria
    :param list sortBy: Specify the order of results. Prefix with \'\-\' to order descending.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/{idOrKey}/values/search".format(
        idOrKey=idOrKey
    )
    headers = {}

    body = body or {}
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def update_property_descriptor(
    idOrKey: str,
    defaultValue: dict = None,
    externallyManaged: bool = None,
    hidden: bool = None,
    localizedDescriptions: dict = None,
    localizedNames: dict = None,
    readFunction: str = None,
    schema: dict = None,
    section: str = None,
    sectionIndex: int = None,
    type: str = None,
    uischema: dict = None,
    writeFunction: str = None,
    deprecated: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update a property descriptor object. (PUBLIC)

    :param str idOrKey: Property descriptor UUID or key
    :param dict defaultValue:
    :param bool externallyManaged: If set\, change the externally managed flag.
    :param bool hidden: If set\, change the hidden flag.
    :param dict localizedDescriptions: If set\, update the localized descriptions of the property.
    :param dict localizedNames: If set\, update the localized names of the property.
    :param str readFunction: If set\, change the function required to read this property for a customer.
    :param dict schema:
    :param str section: If set\, change the section of the property.
    :param int sectionIndex: If set\, change the section index of the property.
    :param str type: If set\, update the type of the property.
    :param dict uischema:
    :param str writeFunction: If set\, change the function required to write this property for a customer.
    :param bool deprecated: If set\, change the deprecated flag.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/{idOrKey}".format(idOrKey=idOrKey)
    headers = {}

    body = body or {}
    # Only send defaultValue if the argument was provided, don't send null values
    if defaultValue is not None:
        body.update({"defaultValue": defaultValue})
    # Only send externallyManaged if the argument was provided, don't send null values
    if externallyManaged is not None:
        body.update({"externallyManaged": externallyManaged})
    # Only send hidden if the argument was provided, don't send null values
    if hidden is not None:
        body.update({"hidden": hidden})
    # Only send localizedDescriptions if the argument was provided, don't send null values
    if localizedDescriptions is not None:
        body.update({"localizedDescriptions": localizedDescriptions})
    # Only send localizedNames if the argument was provided, don't send null values
    if localizedNames is not None:
        body.update({"localizedNames": localizedNames})
    # Only send readFunction if the argument was provided, don't send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send schema if the argument was provided, don't send null values
    if schema is not None:
        body.update({"schema": schema})
    # Only send section if the argument was provided, don't send null values
    if section is not None:
        body.update({"section": section})
    # Only send sectionIndex if the argument was provided, don't send null values
    if sectionIndex is not None:
        body.update({"sectionIndex": sectionIndex})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send uischema if the argument was provided, don't send null values
    if uischema is not None:
        body.update({"uischema": uischema})
    # Only send writeFunction if the argument was provided, don't send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})
    # Only send deprecated if the argument was provided, don't send null values
    if deprecated is not None:
        body.update({"deprecated": deprecated})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("customeradmin", "v2", "propertydescriptor"), module=argus_cli_module
)
def update_property_descriptor_enum_entry(
    idOrKey: str,
    idOrValue: str,
    localizedDescriptions: dict = None,
    localizedValues: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update a property descriptor enum entry object. (PUBLIC)

    :param str idOrKey: Property descriptor UUID or key
    :param str idOrValue: Enum entry UUID or value
    :param dict localizedDescriptions: Descriptions. Mapped by language.
    :param dict localizedValues: Values. Mapped by language. Note\: English value updates only translation and not the value used for fetching the entry.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/propertydescriptor/{idOrKey}/values/{idOrValue}".format(
        idOrKey=idOrKey, idOrValue=idOrValue
    )
    headers = {}

    body = body or {}
    # Only send localizedDescriptions if the argument was provided, don't send null values
    if localizedDescriptions is not None:
        body.update({"localizedDescriptions": localizedDescriptions})
    # Only send localizedValues if the argument was provided, don't send null values
    if localizedValues is not None:
        body.update({"localizedValues": localizedValues})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
