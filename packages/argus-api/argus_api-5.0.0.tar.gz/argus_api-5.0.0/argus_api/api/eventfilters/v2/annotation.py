"""Autogenerated API"""

from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def add_annotation_filter(
    actions: dict,
    customer: str,
    description: str,
    filters: dict,
    name: str,
    authoredByUser: str = None,
    commitID: str = None,
    labels: str = None,
    shortName: str = None,
    enabled: bool = False,
    externallyManaged: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Adds an annotation filter (INTERNAL)

    :param dict actions:
    :param str customer: The shortname or ID of the customer the filter belongs to. To create a global filter set the value to \'0\'
    :param str description: A description of the filter
    :param dict filters:
    :param str name: The name of the filter
    :param str authoredByUser: The user that submitted the Filter\-as\-Code change. Should be used with externallyManaged\=true.
    :param str commitID: The commit ID of the Filter\-as\-Code change. Should be used with externallyManaged\=true.
    :param list labels: A set of labels which can be used to categorize the filter
    :param str shortName: Optional short name of the filter.
    :param bool enabled: Whether or not the filter is enabled
    :param bool externallyManaged: Whether or not the filter code is externally managed
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation".format()
    headers = {}

    body = body or {}
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send authoredByUser if the argument was provided, don't send null values
    if authoredByUser is not None:
        body.update({"authoredByUser": authoredByUser})
    # Only send commitID if the argument was provided, don't send null values
    if commitID is not None:
        body.update({"commitID": commitID})
    # Only send labels if the argument was provided, don't send null values
    if labels is not None:
        body.update({"labels": labels})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send enabled if the argument was provided, don't send null values
    if enabled is not None:
        body.update({"enabled": enabled})
    # Only send externallyManaged if the argument was provided, don't send null values
    if externallyManaged is not None:
        body.update({"externallyManaged": externallyManaged})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def delete_annotation_filter(
    idOrShortName: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Deletes an annotation filter (INTERNAL)

    :param str idOrShortName: ID or short name of filter to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{idOrShortName}".format(
        idOrShortName=idOrShortName
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def disable_annotation_filter(
    id: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Disables an annotation filter (INTERNAL)

    :param int id: ID of filter
    :param str comment: A comment describing why the filter was enabled\/disabled
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{id}/disable".format(id=id)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def disable_annotation_filter_on_instance(
    filterID: int,
    instanceID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Disables an annotation filter on instance (INTERNAL)

    :param int filterID: ID of the filter
    :param int instanceID: ID of the instance
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{filterID}/{instanceID}/disable".format(
        filterID=filterID, instanceID=instanceID
    )
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def duplicate_annotation_filter(
    id: int,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Duplicates a annotation filter (INTERNAL)

    :param int id: ID of filter
    :param str customer: The customer the duplicate should belong to \(id or shortname\). Use \'0\' to create a global filter\, If this field is not set the default is using the same customer as the original filter.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{id}/duplicate".format(id=id)
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def enable_annotation_filter(
    id: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Enables an annotation filter (INTERNAL)

    :param int id: ID of filter
    :param str comment: A comment describing why the filter was enabled\/disabled
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{id}/enable".format(id=id)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def enable_annotation_filter_on_instance(
    filterID: int,
    instanceID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Enables an annotation filter on instance (INTERNAL)

    :param int filterID: ID of the filter
    :param int instanceID: ID of the instance
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{filterID}/{instanceID}/enable".format(
        filterID=filterID, instanceID=instanceID
    )
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def get_annotation_filter(
    idOrShortName: str,
    revision: int = None,
    includeCode: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Gets an annotation filter (INTERNAL)

    :param str idOrShortName: ID or short name of filter
    :param int revision: The expected revision of the filter
    :param bool includeCode: Whether to include code in AnnotationFilter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{idOrShortName}".format(
        idOrShortName=idOrShortName
    )
    headers = {}

    query_parameters = {}
    # Only send revision if the argument was provided, don't send null values
    if revision is not None:
        query_parameters.update({"revision": revision})
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        query_parameters.update({"includeCode": includeCode})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def get_annotation_filter_status(
    id: int,
    limit: int = 25,
    offset: int = 0,
    status: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Gets the status of a annotation filters instances (INTERNAL)

    :param int id: ID of filter
    :param int limit: Limit result
    :param int offset: Offset result
    :param str status: Status of instances to include in the results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{id}/status".format(id=id)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        query_parameters.update({"status": status})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def list_annotation_filter(
    keywords: str = None,
    includeCode: bool = None,
    sortBy: str = None,
    keywordMatchStrategy: str = "all",
    keywordFieldStrategy: str = None,
    timestampMatchStrategy: str = "all",
    timestampFieldStrategy: str = None,
    startTimestamp: int = 0,
    endTimestamp: int = 0,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Simple search for annotation filters (INTERNAL)

    :param list keywords: Search by keywords
    :param bool includeCode: Whether to include code in results
    :param list sortBy: Field to sort by
    :param str keywordMatchStrategy: Set match strategy for keyword search
    :param list keywordFieldStrategy: Set field strategy for keyword search
    :param str timestampMatchStrategy: Set match strategy for timestamp filtering
    :param list timestampFieldStrategy: Set field strategy for timestamp filtering
    :param int startTimestamp: Lower bound timestamp filter value
    :param int endTimestamp: Upper bound timestamp filter value
    :param int limit: Limit result
    :param int offset: Offset result
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation".format()
    headers = {}

    query_parameters = {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        query_parameters.update({"includeCode": includeCode})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        query_parameters.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        query_parameters.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send timestampMatchStrategy if the argument was provided, don't send null values
    if timestampMatchStrategy is not None:
        query_parameters.update({"timestampMatchStrategy": timestampMatchStrategy})
    # Only send timestampFieldStrategy if the argument was provided, don't send null values
    if timestampFieldStrategy is not None:
        query_parameters.update({"timestampFieldStrategy": timestampFieldStrategy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def list_annotation_filter_revisions(
    id: int,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Gets a annotation filters earlier revisions (INTERNAL)

    :param int id: ID of filter to fetch revisions for
    :param int limit: The max amount of revisions to return
    :param int offset: The number of revisions to skip before returning
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{id}/revisions".format(id=id)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def revert_annotation_filter(
    filterID: int,
    comment: str,
    revisionID: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Reverts an annotation filter to a previous revision (INTERNAL)

    :param int filterID: ID of the filter to revert\( must be the current version of a filter\)
    :param str comment: A comment describing why the filter was reverted
    :param int revisionID: The ID of the filter to revert to. Must be a revision of the filter to revert
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{filterID}/revert".format(filterID=filterID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send revisionID if the argument was provided, don't send null values
    if revisionID is not None:
        body.update({"revisionID": revisionID})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def revive_annotation_filter(
    id: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Revives a deleted a annotation filter (INTERNAL)

    :param int id: ID of filter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{id}/revive".format(id=id)
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def search_annotation_filter(
    customer: str = None,
    excludeFlags: str = None,
    filterID: int = None,
    includeAscendingCustomers: bool = None,
    includeFlags: str = None,
    keywords: str = None,
    sortBy: str = None,
    subCriteria: dict = None,
    user: str = None,
    endTimestamp: str = None,
    includeCode: bool = False,
    includeDeleted: bool = False,
    includeDescendingCustomers: bool = True,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = "all",
    limit: int = 25,
    offset: int = 0,
    startTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = "any",
    userFieldStrategy: str = None,
    userMatchStrategy: str = "all",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Searches for annotation filters (INTERNAL)

    :param list customer: Limit search to filters with the given customers\, identified by id or shortname
    :param list excludeFlags: Flags to exclude
    :param list filterID: Limit search to filters with the given IDs
    :param bool includeAscendingCustomers: When limiting filters by customer\, include filters of ascending customers \(default is false\)
    :param list includeFlags: Flags to include
    :param list keywords: Search for keywords against fields defined by keywordFieldStrategy
    :param list sortBy: Specify the order of results. Prefix with \'\-\' to order descending.
    :param list subCriteria: Subcriteria to add to the search
    :param list user: Search using users identified by id or shortname. If given a group\, we will resolve all members of the group recursively
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param bool includeCode: Whether or not to include code in the result object. The code is only returned if set to true
    :param bool includeDeleted: Set to true to include deleted filters \(excluded by default\).
    :param bool includeDescendingCustomers: When limiting filters by customer\, include filters of descending customers \(default is true\)
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\)
    :param int limit: Limit maximum amount of results
    :param int offset: Skip specified amount of results
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list timeFieldStrategy: Defines which timestamps will be included in the search \(default lastUpdated\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\)
    :param list userFieldStrategy: Defines which fields will be searched by user \(default all supported fields\)
    :param str userMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/search".format()
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send filterID if the argument was provided, don't send null values
    if filterID is not None:
        body.update({"filterID": filterID})
    # Only send includeAscendingCustomers if the argument was provided, don't send null values
    if includeAscendingCustomers is not None:
        body.update({"includeAscendingCustomers": includeAscendingCustomers})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        body.update({"includeCode": includeCode})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeDescendingCustomers if the argument was provided, don't send null values
    if includeDescendingCustomers is not None:
        body.update({"includeDescendingCustomers": includeDescendingCustomers})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userMatchStrategy if the argument was provided, don't send null values
    if userMatchStrategy is not None:
        body.update({"userMatchStrategy": userMatchStrategy})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def search_annotation_filter_status(
    customer: str = None,
    filterID: int = None,
    filterStatus: str = None,
    filterType: str = None,
    limit: int = None,
    loggingStatus: str = None,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Search for annotation filters instance statuses for filters that match the criteria (INTERNAL)

    :param list customer:
    :param list filterID:
    :param list filterStatus:
    :param str filterType:
    :param int limit:
    :param list loggingStatus:
    :param int offset:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/status/search".format()
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send filterID if the argument was provided, don't send null values
    if filterID is not None:
        body.update({"filterID": filterID})
    # Only send filterStatus if the argument was provided, don't send null values
    if filterStatus is not None:
        body.update({"filterStatus": filterStatus})
    # Only send filterType if the argument was provided, don't send null values
    if filterType is not None:
        body.update({"filterType": filterType})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send loggingStatus if the argument was provided, don't send null values
    if loggingStatus is not None:
        body.update({"loggingStatus": loggingStatus})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def set_annotation_filter_log_level(
    id: int,
    logLevel: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Sets the log level of a annotation filter (INTERNAL)

    :param int id: ID of filter
    :param str logLevel: The new log level of the filter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{id}/logging".format(id=id)
    headers = {}

    body = body or {}
    # Only send logLevel if the argument was provided, don't send null values
    if logLevel is not None:
        body.update({"logLevel": logLevel})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(
    extending=("eventfilters", "v2", "annotation"), module=argus_cli_module
)
def update_annotation_filter(
    idOrShortName: str,
    comment: str,
    actions: dict = None,
    addLabels: str = None,
    authoredByUser: str = None,
    commitID: str = None,
    description: str = None,
    externallyManaged: bool = None,
    filters: dict = None,
    name: str = None,
    removeLabels: str = None,
    setLabels: str = None,
    shortName: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Updates an annotation filter (INTERNAL)

    :param str idOrShortName: ID or short name of filter
    :param str comment: A comment describing why the filter was created
    :param dict actions:
    :param list addLabels: A set of labels to add to the filter.  Will be applied after removing labels. Will throw an exception if used in conjunction with setLabels
    :param str authoredByUser: The user that submitted the Filter\-as\-Code change. Should be used with externallyManaged\=true or existing filter should have that flag set.
    :param str commitID: The commit ID of the Filter\-as\-Code change. Should be used with externallyManaged\=true or existing filter should have that flag set.
    :param str description: A description of the filter
    :param bool externallyManaged: Whether or not the filter code is externally managed
    :param dict filters:
    :param str name: The name of the filter
    :param list removeLabels: A set of labels to remove from the filter.  Will be applied before adding labels and ignore filters that are not present. Will throw an exception if used in conjunction with setLabels
    :param list setLabels: Replace the current set of labels with these. Will throw an exception if used in conjunction with addLabels or removeLabels
    :param str shortName: Optional short name of the filter \(no change if left blank\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/annotation/{idOrShortName}".format(
        idOrShortName=idOrShortName
    )
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send addLabels if the argument was provided, don't send null values
    if addLabels is not None:
        body.update({"addLabels": addLabels})
    # Only send authoredByUser if the argument was provided, don't send null values
    if authoredByUser is not None:
        body.update({"authoredByUser": authoredByUser})
    # Only send commitID if the argument was provided, don't send null values
    if commitID is not None:
        body.update({"commitID": commitID})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send externallyManaged if the argument was provided, don't send null values
    if externallyManaged is not None:
        body.update({"externallyManaged": externallyManaged})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send removeLabels if the argument was provided, don't send null values
    if removeLabels is not None:
        body.update({"removeLabels": removeLabels})
    # Only send setLabels if the argument was provided, don't send null values
    if setLabels is not None:
        body.update({"setLabels": setLabels})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
