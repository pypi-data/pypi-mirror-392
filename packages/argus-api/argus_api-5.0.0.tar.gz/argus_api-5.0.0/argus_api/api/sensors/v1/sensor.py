"""Autogenerated API"""

from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def acknowledge_sensor(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Acknowledge a sensor by its ID (INTERNAL)

    :param int sensorID: ID of sensor to acknowledge
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/acknowledge".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def acknowledge_sensors(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Acknowledge Sensors by their ID Any comment will be applied to ALL specified sensors. (INTERNAL)

    :param list sensorID: ID of sensors to acknowledge
    :param str comment: Any comments to append to the request. NB\: Each Sensor specified in the request will receive the same comment. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/acknowledge".format()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def add_comment(
    sensorID: int,
    comment: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Add comment to a sensor (INTERNAL)

    :param int sensorID: SensorID
    :param str comment: Any comments to append to the request
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def bulk_cancel_sensor_downtime(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Cancels downtime for supplied sensorIDs (INTERNAL)

    :param list sensorID: Cancel downtime for these Sensor IDs
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/downtime".format()
    headers = {}

    query_parameters = {}
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def bulk_schedule_sensor_downtime(
    fromTime: int = None,
    toTime: int = None,
    keepDowntimeOnUpdate: bool = None,
    comment: str = None,
    sensorIDs: int = None,
    sensorID: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Schedules downtime for provided sensorIDs (INTERNAL)

    :param int fromTime: Timestamp in epoch ms from which the requested change takes effect.
    :param int toTime: Timestamp in epoch ms until which the requested change takes effect.
    :param bool keepDowntimeOnUpdate: Flag to maintain existing downtime configurations. If set\, downtime will not automatically end when the Sensor registers a new event.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param list sensorIDs: IDs of the Sensors for which we want to schedule downtime.
    :param dict sensorID: Request to schedule downtime for several Sensors
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/downtime".format()
    headers = {}

    body = body or {}
    # Only send fromTime if the argument was provided, don't send null values
    if fromTime is not None:
        body.update({"fromTime": fromTime})
    # Only send toTime if the argument was provided, don't send null values
    if toTime is not None:
        body.update({"toTime": toTime})
    # Only send keepDowntimeOnUpdate if the argument was provided, don't send null values
    if keepDowntimeOnUpdate is not None:
        body.update({"keepDowntimeOnUpdate": keepDowntimeOnUpdate})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        body.update({"sensorID": sensorID})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def bulk_update_contractual_status(
    sensorIDs: int,
    contractual: bool,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update Sensors' contractual statusAny comment will be applied to ALL specified sensors.The operation will only return Sensors that were actually updated. (INTERNAL)

    :param list sensorIDs: IDs of Sensors to remove acknowledgement.
    :param bool contractual: Whether to set or unset the Sensors\' contractual status
    :param str comment: Any comments to append to the request. NB\: Each Sensor specified in the request will receive the same comment. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/contractual".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send contractual if the argument was provided, don't send null values
    if contractual is not None:
        body.update({"contractual": contractual})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def bulk_update_expected_update_interval(
    sensorIDs: int,
    expectedUpdateTimeIntervalMillis: int = None,
    overrideUpdateTimeFlag: bool = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update Sensors' expected update time intervals Any comment will be applied to ALL specified sensors. The operation will only return Sensors that were actually updated. (INTERNAL)

    :param list sensorIDs: IDs of Sensors whose expected update time interval we want to update.
    :param int expectedUpdateTimeIntervalMillis: The new expected update time interval in milliseconds
    :param bool overrideUpdateTimeFlag: Whether to set the override update time flag on sensors lacking it in the request
    :param str comment: Any comments to append to the request NB\: Each Sensor specified in the request will receive the same comment. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/updateInterval".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send expectedUpdateTimeIntervalMillis if the argument was provided, don't send null values
    if expectedUpdateTimeIntervalMillis is not None:
        body.update(
            {"expectedUpdateTimeIntervalMillis": expectedUpdateTimeIntervalMillis}
        )
    # Only send overrideUpdateTimeFlag if the argument was provided, don't send null values
    if overrideUpdateTimeFlag is not None:
        body.update({"overrideUpdateTimeFlag": overrideUpdateTimeFlag})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def bulk_update_initial_tuning(
    sensorID: int,
    initialTuning: bool,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Bulk updating initial tuning property for Sensors by their IDs. If provided any comment will be applied to ALL updated sensors. (INTERNAL)

    :param list sensorID: ID of sensors to remove acknowledgement
    :param bool initialTuning: Desired new Sensor initial tuning status
    :param str comment: Any comments to append to the request. NB\: Each Sensor specified in the request will receive the same comment. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/initialtuning".format()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})
    # Only send initialTuning if the argument was provided, don't send null values
    if initialTuning is not None:
        query_parameters.update({"initialTuning": initialTuning})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def cancel_sensor_downtime(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Cancels downtime for supplied sensorID (INTERNAL)

    :param int sensorID:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/downtime".format(sensorID=sensorID)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def cluster_sensor(
    sensorID: int,
    clusterSensorID: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Cluster sensor (INTERNAL)

    :param int sensorID: ID of the sensor to cluster
    :param int clusterSensorID: Sensor with which we want to cluster
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/cluster".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send clusterSensorID if the argument was provided, don't send null values
    if clusterSensorID is not None:
        body.update({"clusterSensorID": clusterSensorID})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def create_sensor(
    location: str,
    customer: str,
    application: str,
    information: str = None,
    hostname: str = None,
    ipAddress: str = None,
    additionalData: str = None,
    reportingSeverity: str = None,
    sslTerminating: bool = None,
    clusterSensorID: int = 0,
    expectedUpdateTime: int = 0,
    scheduledDowntimeFromTime: int = 0,
    scheduledDowntimeUntilTime: int = 0,
    active: bool = False,
    monitored: bool = False,
    monitoredOnlyDaytime: bool = False,
    initialTuning: bool = False,
    overrideDefaultUpdateTime: bool = False,
    sharedCustomerData: bool = False,
    contractual: bool = False,
    otEnvironment: bool = False,
    restrictedITEnvironment: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Creates a Sensor (INTERNAL)

    :param str location: Sensor Location ID or short name. The Location must be Global or belong to the same Customer as this Sensor.
    :param str customer: Sensor Customer ID or short name
    :param str application: Sensor type ID or short name
    :param str information: Sensor information
    :param str hostname: Sensor hostname. One of hostname or ipAddresss must be defined. Attempts to create a Sensor with a duplicate hostname for the same customer will be rejected. If you need to make a Sensor with a duplicate hostname ensure the additional data field\'s contents are unique. Sensor hostname allows letters\, numbers and special characters \(.\_\:\;\-\).
    :param str ipAddress: Sensor\'s IP address\, one of hostname or ipAddress must be assigned Attempts to create a Sensor with a duplicate IP address for the same customer will be rejected. If you need to make a Sensor with a duplicate IP address ensure the additional data field\'s contents are unique. \[format\:ip\]
    :param str additionalData: Any additional data
    :param str reportingSeverity: If specified overwrite the ReportingSeverity level for this Sensor\'s Application
    :param bool sslTerminating:
    :param int clusterSensorID: ID of the Sensor this new Sensor will be clustered with. 0 if unclustered.
    :param int expectedUpdateTime: When the Sensor is expected to be updated\, 0 if not known\/never
    :param int scheduledDowntimeFromTime: Time from which the Sensor will be offline\, 0 if not scheduled
    :param int scheduledDowntimeUntilTime: Time until which the Sensor will be offline\, 0 if not scheduled
    :param bool active: Sensor active flag
    :param bool monitored: Sensor monitored flag
    :param bool monitoredOnlyDaytime: Sensor is monitored only daytime flag
    :param bool initialTuning: Sensor\'s initial tuning status
    :param bool overrideDefaultUpdateTime: Override default update time
    :param bool sharedCustomerData: Sensor\'s shared customer data flag
    :param bool contractual: Whether the Sensor contributes to the customer\'s contractual Sensor limit
    :param bool otEnvironment: Whether the Sensor is in an OT environment
    :param bool restrictedITEnvironment: Whether the Sensor is in a restricted IT environment
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor".format()
    headers = {}

    body = body or {}
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send application if the argument was provided, don't send null values
    if application is not None:
        body.update({"application": application})
    # Only send information if the argument was provided, don't send null values
    if information is not None:
        body.update({"information": information})
    # Only send hostname if the argument was provided, don't send null values
    if hostname is not None:
        body.update({"hostname": hostname})
    # Only send ipAddress if the argument was provided, don't send null values
    if ipAddress is not None:
        body.update({"ipAddress": ipAddress})
    # Only send additionalData if the argument was provided, don't send null values
    if additionalData is not None:
        body.update({"additionalData": additionalData})
    # Only send reportingSeverity if the argument was provided, don't send null values
    if reportingSeverity is not None:
        body.update({"reportingSeverity": reportingSeverity})
    # Only send sslTerminating if the argument was provided, don't send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})
    # Only send clusterSensorID if the argument was provided, don't send null values
    if clusterSensorID is not None:
        body.update({"clusterSensorID": clusterSensorID})
    # Only send expectedUpdateTime if the argument was provided, don't send null values
    if expectedUpdateTime is not None:
        body.update({"expectedUpdateTime": expectedUpdateTime})
    # Only send scheduledDowntimeFromTime if the argument was provided, don't send null values
    if scheduledDowntimeFromTime is not None:
        body.update({"scheduledDowntimeFromTime": scheduledDowntimeFromTime})
    # Only send scheduledDowntimeUntilTime if the argument was provided, don't send null values
    if scheduledDowntimeUntilTime is not None:
        body.update({"scheduledDowntimeUntilTime": scheduledDowntimeUntilTime})
    # Only send active if the argument was provided, don't send null values
    if active is not None:
        body.update({"active": active})
    # Only send monitored if the argument was provided, don't send null values
    if monitored is not None:
        body.update({"monitored": monitored})
    # Only send monitoredOnlyDaytime if the argument was provided, don't send null values
    if monitoredOnlyDaytime is not None:
        body.update({"monitoredOnlyDaytime": monitoredOnlyDaytime})
    # Only send initialTuning if the argument was provided, don't send null values
    if initialTuning is not None:
        body.update({"initialTuning": initialTuning})
    # Only send overrideDefaultUpdateTime if the argument was provided, don't send null values
    if overrideDefaultUpdateTime is not None:
        body.update({"overrideDefaultUpdateTime": overrideDefaultUpdateTime})
    # Only send sharedCustomerData if the argument was provided, don't send null values
    if sharedCustomerData is not None:
        body.update({"sharedCustomerData": sharedCustomerData})
    # Only send contractual if the argument was provided, don't send null values
    if contractual is not None:
        body.update({"contractual": contractual})
    # Only send otEnvironment if the argument was provided, don't send null values
    if otEnvironment is not None:
        body.update({"otEnvironment": otEnvironment})
    # Only send restrictedITEnvironment if the argument was provided, don't send null values
    if restrictedITEnvironment is not None:
        body.update({"restrictedITEnvironment": restrictedITEnvironment})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def create_sensor_interface(
    sensorID: int,
    interfaceName: str,
    location: str,
    customer: str = None,
    comment: str = None,
    active: bool = False,
    sslTerminating: bool = False,
    otEnvironment: bool = False,
    restrictedITEnvironment: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Adds an interface to a sensor (INTERNAL)

    :param int sensorID: ID of sensor to which we want to add the interface
    :param str interfaceName: Name of the Sensor Interface. Must be unique per Sensor.
    :param str location: Location ID or short name of the Sensor\'s Interface.
    :param str customer: Customer id or shortname of the Interface.If neither the Interface nor Sensor\'s Location is Global\, the Interface and Sensor Customer must be the sameunless the shared data flag is set on the Sensor
    :param str comment: Comment describing why the Interface was added
    :param bool active: Status of the Sensor Interface
    :param bool sslTerminating: Interface\'s SSL terminating flag
    :param bool otEnvironment: Interface\'s OT environment flag
    :param bool restrictedITEnvironment: Interface\'s restricted IT environment flag
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send interfaceName if the argument was provided, don't send null values
    if interfaceName is not None:
        body.update({"interfaceName": interfaceName})
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send active if the argument was provided, don't send null values
    if active is not None:
        body.update({"active": active})
    # Only send sslTerminating if the argument was provided, don't send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})
    # Only send otEnvironment if the argument was provided, don't send null values
    if otEnvironment is not None:
        body.update({"otEnvironment": otEnvironment})
    # Only send restrictedITEnvironment if the argument was provided, don't send null values
    if restrictedITEnvironment is not None:
        body.update({"restrictedITEnvironment": restrictedITEnvironment})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def decluster_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Decluster sensor (INTERNAL)

    :param int sensorID: ID of the sensor to decluster
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/cluster".format(sensorID=sensorID)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def delete_interface(
    sensorID: int,
    interface: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Deletes one of a Sensor's interfaces by its ID or name (INTERNAL)

    :param int sensorID: ID of the sensor to which the interface belongs
    :param str interface: ID of the interface
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises Sensor,Interface,OrLocationNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface/{interface}".format(
        sensorID=sensorID, interface=interface
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def delete_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Delete sensor by ID (INTERNAL)

    :param int sensorID: ID of sensor to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}".format(sensorID=sensorID)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def delete_sensor_comment(
    sensorID: int,
    timestamp: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Deletes a comment (INTERNAL)

    :param int sensorID: Delete comment from this sensor
    :param int timestamp: Delete comment made at this timestamp
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment/{timestamp}".format(
        sensorID=sensorID, timestamp=timestamp
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def delete_sensors(
    sensorIDs: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Delete sensors by ID (INTERNAL)

    :param list sensorIDs: IDs of Sensors we want to update.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/delete".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def disable_monitoring(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Disable sensor monitoring (INTERNAL)

    :param int sensorID: ID for sensor to disable monitoring
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/monitoring/disable".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def disable_monitoring_bulk(
    sensorIDs: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Bulk disable sensor monitoring (INTERNAL)

    :param list sensorIDs: IDs of Sensors whose monitoring we want to update.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/monitoring/disable".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def disable_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Deactivates a sensor (INTERNAL)

    :param int sensorID:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/disable".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def disable_sensors(
    comment: str = None,
    sensorIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Bulk deactivation of Sensors (INTERNAL)

    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param list sensorIDs: IDs of Sensors to deactivate.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/disable".format()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def enable_monitoring(
    sensorID: int,
    daytime: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Enable sensor monitoring. To set daytime only monitoring use the 'daytime' queryParm. (INTERNAL)

    :param int sensorID: ID for sensor to enable monitoring
    :param bool daytime: Daytime only monitoring flag
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/monitoring/enable".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send daytime if the argument was provided, don't send null values
    if daytime is not None:
        query_parameters.update({"daytime": daytime})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def enable_monitoring_bulk(
    sensorIDs: int,
    comment: str = None,
    daytime: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Bulk enable sensor monitoring. To set daytime only monitoring use the 'daytime' queryParm. (INTERNAL)

    :param list sensorIDs: IDs of Sensors whose monitoring we want to update.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param bool daytime: Daytime only monitoring flag
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/monitoring/enable".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send daytime if the argument was provided, don't send null values
    if daytime is not None:
        query_parameters.update({"daytime": daytime})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def enable_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Activates a sensor (INTERNAL)

    :param int sensorID:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/enable".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def enable_sensors(
    comment: str = None,
    sensorIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Bulk activation of sensors (INTERNAL)

    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param list sensorIDs: IDs of Sensors to activate.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/enable".format()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def get_interface(
    sensorID: int,
    interfaceNameOrID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Gets one of a Sensor's interfaces (INTERNAL)

    :param int sensorID: ID of the sensor to which the interface belongs
    :param str interfaceNameOrID: ID or name of the Interface
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises SensorOrInterfaceNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface/{interfaceNameOrID}".format(
        sensorID=sensorID, interfaceNameOrID=interfaceNameOrID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def get_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch sensor by ID (INTERNAL)

    :param int sensorID: ID of sensor to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}".format(sensorID=sensorID)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def get_sensor_comment(
    sensorID: int,
    timestamp: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch comment by timestamp for sensor (INTERNAL)

    :param int sensorID: SensorID
    :param int timestamp: Timestamp
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment/{timestamp}".format(
        sensorID=sensorID, timestamp=timestamp
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def get_sensor_comments(
    sensorID: int,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch sensor comments by sensor ID (INTERNAL)

    :param int sensorID: ID of sensor to fetch comments for
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comments".format(sensorID=sensorID)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def get_sensor_status_by_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Gets status for a sensor (INTERNAL)

    :param int sensorID: ID of sensor whose status we want to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/status".format(sensorID=sensorID)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def get_sensors(
    customerID: int = None,
    customer: str = None,
    applicationID: int = None,
    applicationName: str = None,
    keywords: str = None,
    minExpectedUpdateTime: int = None,
    maxExpectedUpdateTime: int = None,
    lastUpdatedTimestamp: int = None,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List sensors (INTERNAL)

    :param list customerID: Limit search to these customer IDs
    :param list customer: Limit search to these customer ids or shortname
    :param list applicationID:
    :param list applicationName: Limit search to these applications by name
    :param list keywords: Limit search by sensor hostname or IP address
    :param int minExpectedUpdateTime: Filter by sensors with expectedUpdateTime at least this value in millis
    :param int maxExpectedUpdateTime: Filter by sensors with expectedUpdateTime at most this value in millis
    :param int lastUpdatedTimestamp:
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/sensors/v1/sensor".format()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    query_parameters = {}
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send applicationID if the argument was provided, don't send null values
    if applicationID is not None:
        query_parameters.update({"applicationID": applicationID})
    # Only send applicationName if the argument was provided, don't send null values
    if applicationName is not None:
        query_parameters.update({"applicationName": applicationName})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send minExpectedUpdateTime if the argument was provided, don't send null values
    if minExpectedUpdateTime is not None:
        query_parameters.update({"minExpectedUpdateTime": minExpectedUpdateTime})
    # Only send maxExpectedUpdateTime if the argument was provided, don't send null values
    if maxExpectedUpdateTime is not None:
        query_parameters.update({"maxExpectedUpdateTime": maxExpectedUpdateTime})
    # Only send lastUpdatedTimestamp if the argument was provided, don't send null values
    if lastUpdatedTimestamp is not None:
        query_parameters.update({"lastUpdatedTimestamp": lastUpdatedTimestamp})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def list_sensor_comments(
    sensorID: int,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch comments for sensor (INTERNAL)

    :param int sensorID: SensorID
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment".format(sensorID=sensorID)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def list_sensor_interfaces(
    sensorID: int,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Gets a Sensor's interfaces (INTERNAL)

    :param int sensorID: ID of the sensor to which the interface belongs
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises SensorNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface".format(sensorID=sensorID)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def remove_acknowledgement_sensor(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Remove acknowledgement for a sensor by its ID.  (INTERNAL)

    :param int sensorID: ID of sensor to remove acknowledgment
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/removeacknowledgement".format(
        sensorID=sensorID
    )
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def remove_acknowledgement_sensors(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Bulk remove acknowledgement for Sensors by their IDs. Any comment will be applied to ALL specified sensors. (INTERNAL)

    :param list sensorID: ID of sensors to remove acknowledgement
    :param str comment: Any comments to append to the request. NB\: Each Sensor specified in the request will receive the same comment. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/removeacknowledgement".format()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def restore_sensor(
    sensorID: int,
    enable: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Restore sensor by ID (INTERNAL)

    :param int sensorID: ID of sensor to restore
    :param bool enable: Whether to enable the Sensor at the same time as restoring it.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/restore".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send enable if the argument was provided, don't send null values
    if enable is not None:
        body.update({"enable": enable})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def restore_sensors(
    sensorIDs: int,
    comment: str = None,
    enable: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Restore sensors by ID (INTERNAL)

    :param list sensorIDs: IDs of Sensors we want to update.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param bool enable: Whether to enable the Sensors at the same time as restoring them.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/restore".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send enable if the argument was provided, don't send null values
    if enable is not None:
        body.update({"enable": enable})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def schedule_sensor_downtime(
    sensorID: int,
    fromTime: int = None,
    toTime: int = None,
    keepDowntimeOnUpdate: bool = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Schedules downtime for supplied sensorID (INTERNAL)

    :param int sensorID:
    :param int fromTime: Timestamp in epoch ms from which the requested change takes effect.
    :param int toTime: Timestamp in epoch ms until which the requested change takes effect.
    :param bool keepDowntimeOnUpdate: Flag to maintain existing downtime configurations. If set\, downtime will not automatically end when the Sensor registers a new event.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/downtime".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send fromTime if the argument was provided, don't send null values
    if fromTime is not None:
        body.update({"fromTime": fromTime})
    # Only send toTime if the argument was provided, don't send null values
    if toTime is not None:
        body.update({"toTime": toTime})
    # Only send keepDowntimeOnUpdate if the argument was provided, don't send null values
    if keepDowntimeOnUpdate is not None:
        body.update({"keepDowntimeOnUpdate": keepDowntimeOnUpdate})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def search_sensors(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    customerID: int = None,
    keywords: str = None,
    customer: str = None,
    minExpectedUpdateTimeInterval: int = None,
    maxExpectedUpdateTimeInterval: int = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    sortBy: str = None,
    excludeFlag: dict = None,
    includeFlag: dict = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    sensorID: int = None,
    locationName: str = None,
    applicationName: str = None,
    keywordMatchStrategy: str = "any",
    keywordFieldStrategy: str = None,
    timeMatchStrategy: str = "any",
    timeFieldStrategy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Search sensors (INTERNAL)

    :param int limit: Limit results
    :param int offset: Offset results
    :param bool includeDeleted: Also include deleted objects \(where implemented\)
    :param list customerID: Limit result to objects belonging to these customers
    :param list keywords: Search for sensors matching these hostnames or IP\-addresses
    :param list customer: Search for sensors belonging to customers identified by their ID or shortname
    :param int minExpectedUpdateTimeInterval: Filter sensors by min expected update time interval in millis
    :param int maxExpectedUpdateTimeInterval: Filter sensors by max expected update time interval in millis
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list sortBy: Order results by these properties \(prefix with \- to sort descending\)
    :param dict excludeFlag: Search criteria for Sensors
    :param dict includeFlag: Search criteria for Sensors
    :param list includeFlags: Search objects with these flags set
    :param list excludeFlags: Exclude objects with these flags set
    :param list sensorID: Search for specific sensors by ID
    :param list locationName: Use location instead.
    :param list applicationName: Search for sensors by application type
    :param str keywordMatchStrategy: Defines how strictly different keywords should be matched \(default match any keywords\)
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(defaults to all supported fields\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start\/endTimestamp
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/search".format()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    body = body or {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send minExpectedUpdateTimeInterval if the argument was provided, don't send null values
    if minExpectedUpdateTimeInterval is not None:
        body.update({"minExpectedUpdateTimeInterval": minExpectedUpdateTimeInterval})
    # Only send maxExpectedUpdateTimeInterval if the argument was provided, don't send null values
    if maxExpectedUpdateTimeInterval is not None:
        body.update({"maxExpectedUpdateTimeInterval": maxExpectedUpdateTimeInterval})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send excludeFlag if the argument was provided, don't send null values
    if excludeFlag is not None:
        body.update({"excludeFlag": excludeFlag})
    # Only send includeFlag if the argument was provided, don't send null values
    if includeFlag is not None:
        body.update({"includeFlag": includeFlag})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        body.update({"sensorID": sensorID})
    # Only send locationName if the argument was provided, don't send null values
    if locationName is not None:
        body.update({"locationName": locationName})
    # Only send applicationName if the argument was provided, don't send null values
    if applicationName is not None:
        body.update({"applicationName": applicationName})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def submit_sensor_status_bulk(
    records: dict,
    ignoreOnFailed: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Submit sensor status records in a bulk operation (INTERNAL)

    :param list records: Sensor status records for submission
    :param bool ignoreOnFailed: If set to true submitted records with errors will be discarded and all remaining records will be processed. If set to false errors will fail the whole request.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/status".format()
    headers = {}

    body = body or {}
    # Only send records if the argument was provided, don't send null values
    if records is not None:
        body.update({"records": records})
    # Only send ignoreOnFailed if the argument was provided, don't send null values
    if ignoreOnFailed is not None:
        body.update({"ignoreOnFailed": ignoreOnFailed})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def update_initial_tuning(
    sensorID: int,
    initialTuning: bool,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update initial tuning property for a Sensor. (INTERNAL)

    :param int sensorID: ID of sensor to change initial tuning status
    :param bool initialTuning: Desired new Sensor initial tuning status
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/initialtuning".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send initialTuning if the argument was provided, don't send null values
    if initialTuning is not None:
        query_parameters.update({"initialTuning": initialTuning})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def update_interface(
    sensorID: int,
    interface: str,
    newInterfaceName: str = None,
    location: str = None,
    active: bool = None,
    otenvironment: bool = None,
    sslTerminating: bool = False,
    otEnvironment: bool = False,
    restrictedITEnvironment: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update Interface by ID (INTERNAL)

    :param int sensorID: ID of the Sensor to which the Interface belongs
    :param str interface: ID of the Interface we want to update
    :param str newInterfaceName: If specified\, set new name of the Sensor Interface. Must be unique per Sensor.
    :param str location: New Location ID or short name of the Sensor Interface.
    :param bool active: New Status of the Sensor interface
    :param bool otenvironment:
    :param bool sslTerminating: Sensor interface\'s new SSL terminating status
    :param bool otEnvironment: Sensor interface\'s new OT environment flag
    :param bool restrictedITEnvironment: Sensor interface\'s new restricted IT environment flag
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface/{interface}".format(
        sensorID=sensorID, interface=interface
    )
    headers = {}

    body = body or {}
    # Only send newInterfaceName if the argument was provided, don't send null values
    if newInterfaceName is not None:
        body.update({"newInterfaceName": newInterfaceName})
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send active if the argument was provided, don't send null values
    if active is not None:
        body.update({"active": active})
    # Only send otenvironment if the argument was provided, don't send null values
    if otenvironment is not None:
        body.update({"otenvironment": otenvironment})
    # Only send sslTerminating if the argument was provided, don't send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})
    # Only send otEnvironment if the argument was provided, don't send null values
    if otEnvironment is not None:
        body.update({"otEnvironment": otEnvironment})
    # Only send restrictedITEnvironment if the argument was provided, don't send null values
    if restrictedITEnvironment is not None:
        body.update({"restrictedITEnvironment": restrictedITEnvironment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sensors", "v1", "sensor"), module=argus_cli_module)
def update_sensor(
    sensorID: int,
    location: str = None,
    clusterSensorID: int = None,
    information: str = None,
    hostname: str = None,
    ipAddress: str = None,
    additionalData: str = None,
    application: str = None,
    expectedUpdateTime: int = None,
    reportingSeverity: str = None,
    sslterminating: bool = None,
    initialTuning: bool = False,
    overrideDefaultUpdateTime: bool = False,
    sharedCustomerData: bool = False,
    sslTerminating: bool = False,
    contractual: bool = False,
    otEnvironment: bool = False,
    restrictedITEnvironment: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update sensor by ID (INTERNAL)

    :param int sensorID: ID of sensor to update
    :param str location: ID or shortname of the Sensor\'s location
    :param int clusterSensorID: Deprecated. Please use the dedicated clustering endpoint\(s\) instead.
    :param str information: Sensor information
    :param str hostname: Sensor hostname. Unless the Sensor\'s additional data is unique the hostname must also be unique for its owning customer. If removing the hostname the Sensor must have a valid IP address. Sensor hostname allows letters\, numbers and special characters \(.\_\:\;\-\).
    :param str ipAddress: Sensor\'s IP address. Unless the Sensor\'s additional data is unique the IP address must also be unique for its owning customer. If removing the IP address the Sensor must have a valid IP address. \[format\:ip\]
    :param str additionalData: Additional identifier
    :param str application: ID or shortname of Sensor type
    :param int expectedUpdateTime: Expected updated time\, only set if overrideDefaultUpdateTime is true
    :param str reportingSeverity: If specified overwrite the ReportingSeverity level for this Sensor\'s Application
    :param bool sslterminating:
    :param bool initialTuning: If specified un\/set the flag indicating the Sensor is in initial tuning
    :param bool overrideDefaultUpdateTime: Sensor\'s override default update time flag
    :param bool sharedCustomerData: If specified un\/set the flag indicating the Sensor shares data between customers
    :param bool sslTerminating: If specified un\/set the flag indicating the Sensor is SSL terminating
    :param bool contractual: If specified un\/set the flag indicating the Sensor contributes to the customer\'s contractual Sensor limit
    :param bool otEnvironment: If specified un\/set the flag indicating the Sensor is in an OT environment
    :param bool restrictedITEnvironment: If specified un\/set the flag indicating the Sensor is in a restricted IT environment
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send clusterSensorID if the argument was provided, don't send null values
    if clusterSensorID is not None:
        body.update({"clusterSensorID": clusterSensorID})
    # Only send information if the argument was provided, don't send null values
    if information is not None:
        body.update({"information": information})
    # Only send hostname if the argument was provided, don't send null values
    if hostname is not None:
        body.update({"hostname": hostname})
    # Only send ipAddress if the argument was provided, don't send null values
    if ipAddress is not None:
        body.update({"ipAddress": ipAddress})
    # Only send additionalData if the argument was provided, don't send null values
    if additionalData is not None:
        body.update({"additionalData": additionalData})
    # Only send application if the argument was provided, don't send null values
    if application is not None:
        body.update({"application": application})
    # Only send expectedUpdateTime if the argument was provided, don't send null values
    if expectedUpdateTime is not None:
        body.update({"expectedUpdateTime": expectedUpdateTime})
    # Only send reportingSeverity if the argument was provided, don't send null values
    if reportingSeverity is not None:
        body.update({"reportingSeverity": reportingSeverity})
    # Only send sslterminating if the argument was provided, don't send null values
    if sslterminating is not None:
        body.update({"sslterminating": sslterminating})
    # Only send initialTuning if the argument was provided, don't send null values
    if initialTuning is not None:
        body.update({"initialTuning": initialTuning})
    # Only send overrideDefaultUpdateTime if the argument was provided, don't send null values
    if overrideDefaultUpdateTime is not None:
        body.update({"overrideDefaultUpdateTime": overrideDefaultUpdateTime})
    # Only send sharedCustomerData if the argument was provided, don't send null values
    if sharedCustomerData is not None:
        body.update({"sharedCustomerData": sharedCustomerData})
    # Only send sslTerminating if the argument was provided, don't send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})
    # Only send contractual if the argument was provided, don't send null values
    if contractual is not None:
        body.update({"contractual": contractual})
    # Only send otEnvironment if the argument was provided, don't send null values
    if otEnvironment is not None:
        body.update({"otEnvironment": otEnvironment})
    # Only send restrictedITEnvironment if the argument was provided, don't send null values
    if restrictedITEnvironment is not None:
        body.update({"restrictedITEnvironment": restrictedITEnvironment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
