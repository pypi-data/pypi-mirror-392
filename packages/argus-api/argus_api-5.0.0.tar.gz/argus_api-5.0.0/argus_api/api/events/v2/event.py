"""Autogenerated API"""

from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def assess_event(
    timestamp: int,
    customerID: int,
    eventID: str,
    associateCase: int = None,
    comment: str = None,
    disableFlag: str = None,
    disassociateCase: int = None,
    enableFlag: str = None,
    newSeverity: str = None,
    trigger: str = None,
    handledByAnalyst: bool = False,
    assessmentProperty: dict = None,
    autoAcknowledge: bool = True,
    publishIfUnpublished: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Assess event (DEV)

    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param list associateCase: Case IDs that are going to be associated with this event \(not required\). Specified cases must be readable to the current user and they must belong to same customer as this event.
    :param str comment: Assessment comment to the event \(not required\).
    :param list disableFlag: Which flags to disable. Overlap with enableFlag will be an invalid request.
    :param list disassociateCase: Case IDs that are going to be disassociated from this event \(should not overlap with case IDs that are going to be associated with this event\, not required\).
    :param list enableFlag: Which flags to enable. Overlap with disableFlag will be an invalid request.
    :param str newSeverity: New severity of the event \(if not set\, keep current severity\).
    :param list trigger: Set of checks which will be run after assessment \(not required\).
    :param bool handledByAnalyst: If true\, then the event will be flagged as manually assessed by an analyst.
    :param list assessmentProperty: Properties that will be added to the event during assessment. All property keys have to adhere to regex \^\[a\-z\]\[a\-zA\-Z0\-9\]\*\(\\.\[a\-z\]\[a\-zA\-Z0\-9\]\*\)\*\$ A prefix \'meta.argus.assessment.\' will be prepended to every key when doing the assessment.
    :param bool autoAcknowledge: If false\, the event will not be automatically acknowledged on assessment. In this case\, the client has to explicitly set the acknowledged\-flag in the request for the event to be acknowledged.
    :param bool publishIfUnpublished: If true\, the publicationTimestamp field of the event will be set to now if it is in the future.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises EventsNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{timestamp}/{customerID}/{eventID}/assess".format(
        timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    body = body or {}
    # Only send associateCase if the argument was provided, don't send null values
    if associateCase is not None:
        body.update({"associateCase": associateCase})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send disableFlag if the argument was provided, don't send null values
    if disableFlag is not None:
        body.update({"disableFlag": disableFlag})
    # Only send disassociateCase if the argument was provided, don't send null values
    if disassociateCase is not None:
        body.update({"disassociateCase": disassociateCase})
    # Only send enableFlag if the argument was provided, don't send null values
    if enableFlag is not None:
        body.update({"enableFlag": enableFlag})
    # Only send newSeverity if the argument was provided, don't send null values
    if newSeverity is not None:
        body.update({"newSeverity": newSeverity})
    # Only send trigger if the argument was provided, don't send null values
    if trigger is not None:
        body.update({"trigger": trigger})
    # Only send handledByAnalyst if the argument was provided, don't send null values
    if handledByAnalyst is not None:
        body.update({"handledByAnalyst": handledByAnalyst})
    # Only send assessmentProperty if the argument was provided, don't send null values
    if assessmentProperty is not None:
        body.update({"assessmentProperty": assessmentProperty})
    # Only send autoAcknowledge if the argument was provided, don't send null values
    if autoAcknowledge is not None:
        body.update({"autoAcknowledge": autoAcknowledge})
    # Only send publishIfUnpublished if the argument was provided, don't send null values
    if publishIfUnpublished is not None:
        body.update({"publishIfUnpublished": publishIfUnpublished})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def assess_event_bulk(
    assessment: dict,
    search: dict,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Bulk assess events (DEV)

    :param dict assessment:
    :param dict search:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/assess".format()
    headers = {}

    body = body or {}
    # Only send assessment if the argument was provided, don't send null values
    if assessment is not None:
        body.update({"assessment": assessment})
    # Only send search if the argument was provided, don't send null values
    if search is not None:
        body.update({"search": search})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def assess_event_by_compatibility_path(
    type: str,
    timestamp: int,
    customerID: int,
    eventID: str,
    associateCase: int = None,
    comment: str = None,
    disableFlag: str = None,
    disassociateCase: int = None,
    enableFlag: str = None,
    newSeverity: str = None,
    trigger: str = None,
    handledByAnalyst: bool = False,
    assessmentProperty: dict = None,
    autoAcknowledge: bool = True,
    publishIfUnpublished: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Assess event (by compatibility path) (DEV)

    :param str type: Event type \(ignored\, provided for path compatibility\)
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param list associateCase: Case IDs that are going to be associated with this event \(not required\). Specified cases must be readable to the current user and they must belong to same customer as this event.
    :param str comment: Assessment comment to the event \(not required\).
    :param list disableFlag: Which flags to disable. Overlap with enableFlag will be an invalid request.
    :param list disassociateCase: Case IDs that are going to be disassociated from this event \(should not overlap with case IDs that are going to be associated with this event\, not required\).
    :param list enableFlag: Which flags to enable. Overlap with disableFlag will be an invalid request.
    :param str newSeverity: New severity of the event \(if not set\, keep current severity\).
    :param list trigger: Set of checks which will be run after assessment \(not required\).
    :param bool handledByAnalyst: If true\, then the event will be flagged as manually assessed by an analyst.
    :param list assessmentProperty: Properties that will be added to the event during assessment. All property keys have to adhere to regex \^\[a\-z\]\[a\-zA\-Z0\-9\]\*\(\\.\[a\-z\]\[a\-zA\-Z0\-9\]\*\)\*\$ A prefix \'meta.argus.assessment.\' will be prepended to every key when doing the assessment.
    :param bool autoAcknowledge: If false\, the event will not be automatically acknowledged on assessment. In this case\, the client has to explicitly set the acknowledged\-flag in the request for the event to be acknowledged.
    :param bool publishIfUnpublished: If true\, the publicationTimestamp field of the event will be set to now if it is in the future.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{type}/{timestamp}/{customerID}/{eventID}/assess".format(
        type=type, timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    body = body or {}
    # Only send associateCase if the argument was provided, don't send null values
    if associateCase is not None:
        body.update({"associateCase": associateCase})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send disableFlag if the argument was provided, don't send null values
    if disableFlag is not None:
        body.update({"disableFlag": disableFlag})
    # Only send disassociateCase if the argument was provided, don't send null values
    if disassociateCase is not None:
        body.update({"disassociateCase": disassociateCase})
    # Only send enableFlag if the argument was provided, don't send null values
    if enableFlag is not None:
        body.update({"enableFlag": enableFlag})
    # Only send newSeverity if the argument was provided, don't send null values
    if newSeverity is not None:
        body.update({"newSeverity": newSeverity})
    # Only send trigger if the argument was provided, don't send null values
    if trigger is not None:
        body.update({"trigger": trigger})
    # Only send handledByAnalyst if the argument was provided, don't send null values
    if handledByAnalyst is not None:
        body.update({"handledByAnalyst": handledByAnalyst})
    # Only send assessmentProperty if the argument was provided, don't send null values
    if assessmentProperty is not None:
        body.update({"assessmentProperty": assessmentProperty})
    # Only send autoAcknowledge if the argument was provided, don't send null values
    if autoAcknowledge is not None:
        body.update({"autoAcknowledge": autoAcknowledge})
    # Only send publishIfUnpublished if the argument was provided, don't send null values
    if publishIfUnpublished is not None:
        body.update({"publishIfUnpublished": publishIfUnpublished})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def get_event(
    timestamp: int,
    customerID: int,
    eventID: str,
    includeProperties: str = None,
    includeAllProperties: bool = False,
    includeComments: bool = False,
    includeSubEvents: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches corresponding event (DEV)

    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param list includeProperties: Which properties to include in the response \(if includeAllProperties\=false\) \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param bool includeAllProperties: Whether to include all properties
    :param bool includeComments: Whether to include comments
    :param bool includeSubEvents: Whether to include sub\-event IDs
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{timestamp}/{customerID}/{eventID}".format(
        timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    query_parameters = {}
    # Only send includeProperties if the argument was provided, don't send null values
    if includeProperties is not None:
        query_parameters.update({"includeProperties": includeProperties})
    # Only send includeAllProperties if the argument was provided, don't send null values
    if includeAllProperties is not None:
        query_parameters.update({"includeAllProperties": includeAllProperties})
    # Only send includeComments if the argument was provided, don't send null values
    if includeComments is not None:
        query_parameters.update({"includeComments": includeComments})
    # Only send includeSubEvents if the argument was provided, don't send null values
    if includeSubEvents is not None:
        query_parameters.update({"includeSubEvents": includeSubEvents})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def get_event_compatibility(
    type: str,
    timestamp: int,
    customerID: int,
    eventID: str,
    includeProperties: str = None,
    includeAllProperties: bool = False,
    includeComments: bool = False,
    includeSubEvents: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches corresponding event (by compatibility path) (DEV)

    :param str type: Event type \(ignored\, provided for path compatibility\)
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param list includeProperties: Which properties to include in the response \(if includeAllProperties\=false\) \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param bool includeAllProperties: Whether to include all properties
    :param bool includeComments: Whether to include comments
    :param bool includeSubEvents: Whether to include sub\-event IDs
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{type}/{timestamp}/{customerID}/{eventID}".format(
        type=type, timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    query_parameters = {}
    # Only send includeProperties if the argument was provided, don't send null values
    if includeProperties is not None:
        query_parameters.update({"includeProperties": includeProperties})
    # Only send includeAllProperties if the argument was provided, don't send null values
    if includeAllProperties is not None:
        query_parameters.update({"includeAllProperties": includeAllProperties})
    # Only send includeComments if the argument was provided, don't send null values
    if includeComments is not None:
        query_parameters.update({"includeComments": includeComments})
    # Only send includeSubEvents if the argument was provided, don't send null values
    if includeSubEvents is not None:
        query_parameters.update({"includeSubEvents": includeSubEvents})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def get_event_links(
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches links of the corresponding event (DEV)

    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{timestamp}/{customerID}/{eventID}/links".format(
        timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def get_event_links_compatibility(
    type: str,
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches links of the corresponding event (DEV)

    :param str type: Event type
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{type}/{timestamp}/{customerID}/{eventID}/links".format(
        type=type, timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def get_event_statistics(
    associatedCase: int = None,
    attack: dict = None,
    customer: str = None,
    domain: str = None,
    endTimestamp: str = None,
    endpoint: dict = None,
    eventIdentifier: str = None,
    excludeFlag: str = None,
    groupBy: dict = None,
    includeFlag: str = None,
    productionCustomers: bool = None,
    property: dict = None,
    severity: str = None,
    startTimestamp: str = None,
    subCriteria: dict = None,
    timeFieldStrategy: str = None,
    timeline: dict = None,
    type: str = None,
    timeMatchStrategy: str = "any",
    includeUnpublished: bool = True,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Generate the requested statistics for events matching the provided search criteria. (DEV)

    :param list associatedCase: Restrict search to events associated to cases with these IDs. NOTE\: Searching for ID 0 will return events that are not associated to any cases.
    :param list attack: Restrict search to events matching these attack criteria. These criteria follow sub request logic\, which means that they are by default OR\-ed together\, but will be AND\-ed together if you set required\=true. You can also use exclude\=true to match on the negation of the query
    :param list customer: Which customers to search for events for. Search by id or short name
    :param list domain: Restrict search to events with one of these domains set
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list endpoint: Restrict search to events with endpoints matching these criteria These criteria follow sub request logic\, which means that they are by default OR\-ed together\, but will be AND\-ed together if you set required\=true. You can also use exclude\=true to match on the negation of the query
    :param list eventIdentifier: Which event identifiers to search for
    :param list excludeFlag: Restrict search to events with NONE of these flags set
    :param list groupBy: The list of fields to group by The order in the list will determine the hierarchy of the aggregations and their buckets.
    :param list includeFlag: Restrict search to events with ALL of these flags set
    :param bool productionCustomers: Restricts the search to customers that either are\, or are not in production. If null we don\'t filter \(default\) If true we only return production customers If false\, we exclude all production customers
    :param list property: Restrict search to events with properties matching these criteria. These criteria follow sub request logic\, which means that they are by default OR\-ed together\, but will be AND\-ed together if you set required\=true. You can also use exclude\=true to match on the negation of the query.
    :param list severity: Which severities to search for
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list subCriteria: The set of sub criteria to add to the search
    :param list timeFieldStrategy: Which time fields to search for
    :param list timeline: The set of time range metrics used to create histogram buckets
    :param list type: Restrict search to of events of this type. If nothing is specified we will return all types
    :param str timeMatchStrategy: Which time match strategy to use. Defaults to matching if any
    :param bool includeUnpublished: If set to false\, will exclude unpublished events \(i.e. events that have publicationTimestamp in the future\).
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/statistics".format()
    headers = {}

    body = body or {}
    # Only send associatedCase if the argument was provided, don't send null values
    if associatedCase is not None:
        body.update({"associatedCase": associatedCase})
    # Only send attack if the argument was provided, don't send null values
    if attack is not None:
        body.update({"attack": attack})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send endpoint if the argument was provided, don't send null values
    if endpoint is not None:
        body.update({"endpoint": endpoint})
    # Only send eventIdentifier if the argument was provided, don't send null values
    if eventIdentifier is not None:
        body.update({"eventIdentifier": eventIdentifier})
    # Only send excludeFlag if the argument was provided, don't send null values
    if excludeFlag is not None:
        body.update({"excludeFlag": excludeFlag})
    # Only send groupBy if the argument was provided, don't send null values
    if groupBy is not None:
        body.update({"groupBy": groupBy})
    # Only send includeFlag if the argument was provided, don't send null values
    if includeFlag is not None:
        body.update({"includeFlag": includeFlag})
    # Only send productionCustomers if the argument was provided, don't send null values
    if productionCustomers is not None:
        body.update({"productionCustomers": productionCustomers})
    # Only send property if the argument was provided, don't send null values
    if property is not None:
        body.update({"property": property})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeline if the argument was provided, don't send null values
    if timeline is not None:
        body.update({"timeline": timeline})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send includeUnpublished if the argument was provided, don't send null values
    if includeUnpublished is not None:
        body.update({"includeUnpublished": includeUnpublished})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def get_payload(
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch specified event payload (DEV)

    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Unique UUID for the event
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{timestamp}/{customerID}/{eventID}/payload".format(
        timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def get_payload_compatibility(
    type: str,
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch specified event payload. This variant accepts a type parameter which is not used but should make it easier to paste in AGGR-ids from the v1 api. (DEV)

    :param str type: Event type \(ignored\, provided for path compatibility\)
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Unique UUID for the event
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{type}/{timestamp}/{customerID}/{eventID}/payload".format(
        type=type, timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def get_pcap(
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> Response:
    r"""Fetch specified event payload as PCAP (DEV)

    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Unique UUID for the event
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/events/v2/event/{timestamp}/{customerID}/{eventID}/pcap".format(
        timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}
    headers["content"] = None

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def get_pcap_compatibility(
    type: str,
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> Response:
    r"""Fetch specified event payload as PCAP. This variant accepts a type parameter which is not used but should make it easier to paste in AGGR-ids from the v1 api. (DEV)

    :param str type: Event type \(ignored\, provided for path compatibility\)
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Unique UUID for the event
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/events/v2/event/{type}/{timestamp}/{customerID}/{eventID}/pcap".format(
        type=type, timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}
    headers["content"] = None

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def list_event_lineage(
    timestamp: int,
    customerID: int,
    eventID: str,
    sortBy: str = None,
    limit: int = None,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches the lineage of an event (DEV)

    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param list sortBy: List of properties to sort by \(prefix with \"\-\" to sort descending\) Only accepts createdTimestamp and \-createdTimestamp If no value is given\, it defaults to sorting by createdTimestamp descending
    :param int limit: The max number of events to return
    :param int offset: The offset of the search
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{timestamp}/{customerID}/{eventID}/lineage".format(
        timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    query_parameters = {}
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def list_event_lineage_compatibility(
    timestamp: int,
    customerID: int,
    eventID: str,
    sortBy: str = None,
    limit: int = None,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches the lineage of an event (DEV)

    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param list sortBy: List of properties to sort by \(prefix with \"\-\" to sort descending\) Only accepts createdTimestamp and \-createdTimestamp If no value is given\, it defaults to sorting by createdTimestamp descending
    :param int limit: The max number of events to return
    :param int offset: The offset of the search
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{type}/{timestamp}/{customerID}/{eventID}/lineage".format(
        timestamp=timestamp, customerID=customerID, eventID=eventID
    )
    headers = {}

    query_parameters = {}
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def list_events(
    type: str = None,
    customer: str = None,
    signature: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    limit: int = None,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Simple search for events (DEV)

    :param list type: Limit to events of this type
    :param list customer: Limit to customer
    :param list signature: Limit to signature
    :param int startTimestamp: Only look for events after this timestamp
    :param int endTimestamp: Only look for events before this timestamp
    :param int limit: The max number of events to return
    :param int offset: The offset of the search
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/events/v2/event".format()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    query_parameters = {}
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        query_parameters.update({"type": type})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        query_parameters.update({"signature": signature})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def reindex_events(
    eventID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Reindexes a set of events into the search engine (INTERNAL)

    :param list eventID: The events that should be reindexed. The set should contain event IDs on the Argus EventID format\, e.g. AGGR\/10000\/1\/8bf1732c\-f845\-409a\-8425\-8fad3b5007ab. If one of the IDs is malformed\, or does not match an event you have access to the request will fail.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/reindex".format()
    headers = {}

    body = body or {}
    # Only send eventID if the argument was provided, don't send null values
    if eventID is not None:
        body.update({"eventID": eventID})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def search_events(
    associatedCase: int = None,
    attack: dict = None,
    customer: str = None,
    domain: str = None,
    endTimestamp: str = None,
    endpoint: dict = None,
    eventIdentifier: str = None,
    excludeFlag: str = None,
    includeFlag: str = None,
    includeProperties: str = None,
    indexEndTimestamp: str = None,
    indexStartTimestamp: str = None,
    productionCustomers: bool = None,
    property: dict = None,
    severity: str = None,
    sortBy: str = None,
    startTimestamp: str = None,
    subCriteria: dict = None,
    timeFieldStrategy: str = None,
    type: str = None,
    includeAllProperties: bool = False,
    includeComments: bool = False,
    includeSubEvents: bool = False,
    limit: int = 25,
    offset: int = 0,
    timeMatchStrategy: str = "any",
    includeUnpublished: bool = True,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Searches for events (DEV)

    :param list associatedCase: Restrict search to events associated to cases with these IDs. NOTE\: Searching for ID 0 will return events that are not associated to any cases.
    :param list attack: Restrict search to events matching these attack criteria. These criteria follow sub request logic\, which means that they are by default OR\-ed together\, but will be AND\-ed together if you set required\=true. You can also use exclude\=true to match on the negation of the query
    :param list customer: Which customers to search for events for. Search by id or short name
    :param list domain: Restrict search to events with one of these domains set
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list endpoint: Restrict search to events with endpoints matching these criteria These criteria follow sub request logic\, which means that they are by default OR\-ed together\, but will be AND\-ed together if you set required\=true. You can also use exclude\=true to match on the negation of the query
    :param list eventIdentifier: Which event identifiers to search for
    :param list excludeFlag: Restrict search to events with NONE of these flags set
    :param list includeFlag: Restrict search to events with ALL of these flags set
    :param list includeProperties: Which properties to include \(if includeAllProperties\=false\).
    :param str indexEndTimestamp: Only search in indexes before or on this day. Defaults to current day. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param str indexStartTimestamp: Only search in indexes after or on this day. Defaults to current day. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param bool productionCustomers: Restricts the search to customers that either are\, or are not in production. If null we don\'t filter \(default\) If true we only return production customers If false\, we exclude all production customers
    :param list property: Restrict search to events with properties matching these criteria. These criteria follow sub request logic\, which means that they are by default OR\-ed together\, but will be AND\-ed together if you set required\=true. You can also use exclude\=true to match on the negation of the query.
    :param list severity: Which severities to search for
    :param list sortBy: Specify the order of results. Prefix with \'\-\' to order descending.
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list subCriteria: The set of sub criteria to add to the search
    :param list timeFieldStrategy: Which time fields to search for
    :param list type: Restrict search to of events of this type. If nothing is specified we will return all types
    :param bool includeAllProperties: Whether to include all properties \(overrides the selection of \'includeProperties\' if set to true\).
    :param bool includeComments: Whether to include comments.
    :param bool includeSubEvents: Whether to include sub\-events\' IDs \(only for aggregated events\).
    :param int limit: Limit the results to the specified amount. If set to 0 we will stream all results matching the query
    :param int offset: Skip specified amount of results
    :param str timeMatchStrategy: Which time match strategy to use. Defaults to matching if any
    :param bool includeUnpublished: Whether to include unpublished events \(publicationTimestamp in the future\).
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/events/v2/event/search".format()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    body = body or {}
    # Only send associatedCase if the argument was provided, don't send null values
    if associatedCase is not None:
        body.update({"associatedCase": associatedCase})
    # Only send attack if the argument was provided, don't send null values
    if attack is not None:
        body.update({"attack": attack})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send endpoint if the argument was provided, don't send null values
    if endpoint is not None:
        body.update({"endpoint": endpoint})
    # Only send eventIdentifier if the argument was provided, don't send null values
    if eventIdentifier is not None:
        body.update({"eventIdentifier": eventIdentifier})
    # Only send excludeFlag if the argument was provided, don't send null values
    if excludeFlag is not None:
        body.update({"excludeFlag": excludeFlag})
    # Only send includeFlag if the argument was provided, don't send null values
    if includeFlag is not None:
        body.update({"includeFlag": includeFlag})
    # Only send includeProperties if the argument was provided, don't send null values
    if includeProperties is not None:
        body.update({"includeProperties": includeProperties})
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        body.update({"indexEndTimestamp": indexEndTimestamp})
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        body.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send productionCustomers if the argument was provided, don't send null values
    if productionCustomers is not None:
        body.update({"productionCustomers": productionCustomers})
    # Only send property if the argument was provided, don't send null values
    if property is not None:
        body.update({"property": property})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send includeAllProperties if the argument was provided, don't send null values
    if includeAllProperties is not None:
        body.update({"includeAllProperties": includeAllProperties})
    # Only send includeComments if the argument was provided, don't send null values
    if includeComments is not None:
        body.update({"includeComments": includeComments})
    # Only send includeSubEvents if the argument was provided, don't send null values
    if includeSubEvents is not None:
        body.update({"includeSubEvents": includeSubEvents})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send includeUnpublished if the argument was provided, don't send null values
    if includeUnpublished is not None:
        body.update({"includeUnpublished": includeUnpublished})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def submit_events(
    payload: dict = None,
    id: dict = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    signature: str = None,
    severity: str = None,
    count: int = None,
    location: str = None,
    protocol: str = None,
    source: dict = None,
    destination: dict = None,
    flags: str = None,
    properties: dict = None,
    subEvents: str = None,
    uri: str = None,
    fqdn: str = None,
    aggregationKey: str = None,
    associatedCaseID: int = None,
    associatedCaseIDs: int = None,
    finalized: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Submit event to central storage. (INTERNAL)

    :param dict payload:
    :param dict id:
    :param int startTimestamp:
    :param int endTimestamp:
    :param str signature: Event signature. If set\, the system will automatically assign alarm and attack category based on this value.
    :param str severity: Event severity. When creating a new event\, the default severity is low.
    :param int count: Number of occurrences this event represents. The value must be at least 1\, which is the default.
    :param str location: The sensor location \(id or shortname\) where this event was observed. If set\, this location must be resolvable for the current user\, and must either belong to the same customer as this event\, or be a global location.
    :param str protocol: The protocol id or well\-known name. Numeric protocol ID must be between 0 and 255. Protocol name must be well known \(icmp\, tcp\, udp\, esp\, ah\)
    :param dict source:
    :param dict destination:
    :param list flags: Event flags requested by the client for this event. On updating an existing event\, existing flags will be retained\, and flags in the update will be added. Flags that have a PARTIAL flag have custom handling. If FINALIZED flag is set\, additional updates to this event will be ignored.
    :param dict properties: Custom properties for this event. Each property key may have multiple values. On updating an existing event\, setting an existing property will overwrite existing value. The max length of property keys is 50 characters. Keys longer than that will be truncated to the first 50. If there are duplicate keys\, one will overwrite the other. This will also happen if there are duplicates after truncation. The max length of property values are 1024 characters for each value. Any value longer than this will be truncated to 1024 characters.
    :param list subEvents: IDs \(on form TYPE\/timestamp\/customer\/UUID\) for subevents to this event. Subevents may not be stored yet. System will validate that all subevents have the same customer as this event.
    :param str uri: URI observed in this event.
    :param str fqdn: FQDN \(fqdn\) observed in this event.
    :param str aggregationKey: Client specified aggregation key for this event.
    :param int associatedCaseID: Associated case ID. If set\, the associated case must be readable for the current user\, and must belong to the same customer as this event.
    :param list associatedCaseIDs: Add one or more case associations to an event\, not required. If set\, the associated case must be readable for the current user\, and must belong to the same customer as this event.
    :param dict finalized:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event".format()
    headers = {}

    body = body or {}
    # Only send payload if the argument was provided, don't send null values
    if payload is not None:
        body.update({"payload": payload})
    # Only send id if the argument was provided, don't send null values
    if id is not None:
        body.update({"id": id})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        body.update({"signature": signature})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send count if the argument was provided, don't send null values
    if count is not None:
        body.update({"count": count})
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send protocol if the argument was provided, don't send null values
    if protocol is not None:
        body.update({"protocol": protocol})
    # Only send source if the argument was provided, don't send null values
    if source is not None:
        body.update({"source": source})
    # Only send destination if the argument was provided, don't send null values
    if destination is not None:
        body.update({"destination": destination})
    # Only send flags if the argument was provided, don't send null values
    if flags is not None:
        body.update({"flags": flags})
    # Only send properties if the argument was provided, don't send null values
    if properties is not None:
        body.update({"properties": properties})
    # Only send subEvents if the argument was provided, don't send null values
    if subEvents is not None:
        body.update({"subEvents": subEvents})
    # Only send uri if the argument was provided, don't send null values
    if uri is not None:
        body.update({"uri": uri})
    # Only send fqdn if the argument was provided, don't send null values
    if fqdn is not None:
        body.update({"fqdn": fqdn})
    # Only send aggregationKey if the argument was provided, don't send null values
    if aggregationKey is not None:
        body.update({"aggregationKey": aggregationKey})
    # Only send associatedCaseID if the argument was provided, don't send null values
    if associatedCaseID is not None:
        body.update({"associatedCaseID": associatedCaseID})
    # Only send associatedCaseIDs if the argument was provided, don't send null values
    if associatedCaseIDs is not None:
        body.update({"associatedCaseIDs": associatedCaseIDs})
    # Only send finalized if the argument was provided, don't send null values
    if finalized is not None:
        body.update({"finalized": finalized})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v2", "event"), module=argus_cli_module)
def submit_events_bulk(
    events: dict,
    onError: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Submit a bulk of events to central storage. (INTERNAL)

    :param list events: Events to submit in this bulk.
    :param str onError: Define how validation errors on single events should be handled. Using mode dropInvalid\, invalid events will be ignored and reported in the response. The default mode is rejectAll\, which will cause a 412 error on the entire request on a valiation failure for any event.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/bulk".format()
    headers = {}

    body = body or {}
    # Only send events if the argument was provided, don't send null values
    if events is not None:
        body.update({"events": events})
    # Only send onError if the argument was provided, don't send null values
    if onError is not None:
        body.update({"onError": onError})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
