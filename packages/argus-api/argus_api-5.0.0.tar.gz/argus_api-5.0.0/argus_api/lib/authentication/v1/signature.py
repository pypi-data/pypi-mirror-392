"""Autogenerated API"""

from argus_api.session import get_session as _get_session
from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from argus_api.session import ArgusAPISession


def enroll_public_key(
    algorithm: str,
    authorization: str,
    challengeID: str,
    name: str,
    publicKey: str,
    type: str,
    attestationObject: str = None,
    clientData: str = None,
    protection: str = None,
    validDays: int = None,
    validSources: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Enroll new public key (PUBLIC)

    :param str algorithm: The key algorithm
    :param str authorization: The authorization token to permit enrolling this key. Token must be valid for operation \'publickey.enroll\'
    :param str challengeID: ID of the challenge this request is bound to
    :param str name: A name to associate with the key
    :param str publicKey:
    :param str type: The type of the key
    :param str attestationObject:
    :param str clientData:
    :param str protection: The protection level selected by client
    :param int validDays: Number of days this key is valid\, default is 1 year \(which is also the default maximum\).
    :param list validSources: Valid source IPs\/networks. Default is valid from all IPs.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/enroll".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send algorithm if the argument was provided, don't send null values
    if algorithm is not None:
        body.update({"algorithm": algorithm})
    # Only send authorization if the argument was provided, don't send null values
    if authorization is not None:
        body.update({"authorization": authorization})
    # Only send challengeID if the argument was provided, don't send null values
    if challengeID is not None:
        body.update({"challengeID": challengeID})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send publicKey if the argument was provided, don't send null values
    if publicKey is not None:
        body.update({"publicKey": publicKey})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send attestationObject if the argument was provided, don't send null values
    if attestationObject is not None:
        body.update({"attestationObject": attestationObject})
    # Only send clientData if the argument was provided, don't send null values
    if clientData is not None:
        body.update({"clientData": clientData})
    # Only send protection if the argument was provided, don't send null values
    if protection is not None:
        body.update({"protection": protection})
    # Only send validDays if the argument was provided, don't send null values
    if validDays is not None:
        body.update({"validDays": validDays})
    # Only send validSources if the argument was provided, don't send null values
    if validSources is not None:
        body.update({"validSources": validSources})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def enroll_webauthn_key(
    attestationObject: str,
    authorization: str,
    challengeID: str,
    clientData: str,
    webAuthnKeyID: str,
    validDays: int = None,
    validSources: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Enroll new webauthn key (PUBLIC)

    :param str attestationObject:
    :param str authorization: The authorization token to permit enrolling this key. Token must be valid for operation \'publickey.enroll\'
    :param str challengeID: ID of the challenge this request is bound to
    :param str clientData:
    :param str webAuthnKeyID:
    :param int validDays: Number of days this key is valid\, default is 1 year \(which is also the default maximum\).
    :param list validSources: Valid source IPs\/networks. Default is valid from all IPs.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/webauthn/enroll".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send attestationObject if the argument was provided, don't send null values
    if attestationObject is not None:
        body.update({"attestationObject": attestationObject})
    # Only send authorization if the argument was provided, don't send null values
    if authorization is not None:
        body.update({"authorization": authorization})
    # Only send challengeID if the argument was provided, don't send null values
    if challengeID is not None:
        body.update({"challengeID": challengeID})
    # Only send clientData if the argument was provided, don't send null values
    if clientData is not None:
        body.update({"clientData": clientData})
    # Only send webAuthnKeyID if the argument was provided, don't send null values
    if webAuthnKeyID is not None:
        body.update({"webAuthnKeyID": webAuthnKeyID})
    # Only send validDays if the argument was provided, don't send null values
    if validDays is not None:
        body.update({"validDays": validDays})
    # Only send validSources if the argument was provided, don't send null values
    if validSources is not None:
        body.update({"validSources": validSources})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_public_key_enrollment_options(
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get enrollment options before enrolling new public key (PUBLIC)

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/enroll".format()

    session = api_session or _get_session()
    headers = {}

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_webauthn_authentication_options(
    userName: str,
    domain: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Request parameters for authenticating using webauthn (DEPRECATED, use POST /signature/webauthn/authentication/challenge) (PUBLIC)

    :param str userName: Username of the user preparing to authenticate
    :param str domain: User domain
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises ValidationErrorException: on 412
    :raises IfTheCurrentIpHasSubmittedTooManyChallengesWithinAShortTimeFrame.TheClientShouldSlowDown.Exception: on 429
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/webauthn/authentication".format()

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send userName if the argument was provided, don't send null values
    if userName is not None:
        query_parameters.update({"userName": userName})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_webauthn_create_options(
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Request parameters for enrolling new webauthn key (Deprecated, use POST /signature/webauthn/enroll/challenge instead) (PUBLIC)

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/webauthn/enroll".format()

    session = api_session or _get_session()
    headers = {}

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_webauthn_user_authorization_options(
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Request an webauthn validation token to validate user presence. The returned token must be used when requesting authorization token. (INTERNAL)

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/webauthn/authorize".format()

    session = api_session or _get_session()
    headers = {}

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def initialize_public_key_device_enrollment_session(
    enrollmentID: str,
    deviceName: str,
    userID: int = None,
    deviceID: dict = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Initialize enrollment session, binding the session to the enrolling device (DEV)

    :param str enrollmentID:
    :param str deviceName: String identifying enrolling device \(for tracking only\)
    :param int userID: ID of the user to enroll. This should be passed from the device enrollment request endpoint via other channel \(QR\-link\)
    :param dict deviceID: Request from an enrolling device to initialize the enrollment session. This should be done after passing the information about the created enrollment session from a session create request.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = (
        "/authentication/v1/signature/enroll/device/{enrollmentID}/initialize".format(
            enrollmentID=enrollmentID
        )
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send deviceName if the argument was provided, don't send null values
    if deviceName is not None:
        body.update({"deviceName": deviceName})
    # Only send userID if the argument was provided, don't send null values
    if userID is not None:
        body.update({"userID": userID})
    # Only send deviceID if the argument was provided, don't send null values
    if deviceID is not None:
        body.update({"deviceID": deviceID})

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_public_keys(
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""List current user enrolled public keys (PUBLIC)

    :param int limit: Maximum number of values to return
    :param int offset: Skip this number of records
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature".format()

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def poll_public_key_enrollment_challenge(
    enrollmentID: str,
    enrollmentToken: str,
    userID: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Poll for key generation challenge. This requires the user to have validated the session. If session is not validated, the endpoint will return 206, and the client should try again. (DEV)

    :param str enrollmentID:
    :param str enrollmentToken: Secret enrollment token\, which was returned from the initialization endpoint.
    :param int userID: ID of the user to enroll. This should be passed from the device enrollment request endpoint via other channel \(QR\-link\).
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = (
        "/authentication/v1/signature/enroll/device/{enrollmentID}/challenge".format(
            enrollmentID=enrollmentID
        )
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send enrollmentToken if the argument was provided, don't send null values
    if enrollmentToken is not None:
        body.update({"enrollmentToken": enrollmentToken})
    # Only send userID if the argument was provided, don't send null values
    if userID is not None:
        body.update({"userID": userID})

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def register_public_key_device_enrollment_key(
    enrollmentID: str,
    algorithm: str,
    enrollmentToken: str,
    name: str,
    protection: str,
    publicKey: str,
    type: str,
    attestationObject: str = None,
    clientData: str = None,
    userID: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Register the key generated for this enrollment. This requires a valid session. The key must be generated using the challenge returned from the challenge endpoint. This ends the enrollment flow. (DEV)

    :param str enrollmentID:
    :param str algorithm: The key algorithm
    :param str enrollmentToken: Secret enrollment token\, which was returned from the initialization endpoint.
    :param str name: A name to associate with the key
    :param str protection: The protection level selected by client
    :param str publicKey:
    :param str type: The type of the key
    :param str attestationObject:
    :param str clientData:
    :param int userID: ID of the user to enroll. This should be passed from the device enrollment request endpoint via other channel \(QR\-link\).
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/enroll/device/{enrollmentID}/key".format(
        enrollmentID=enrollmentID
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send algorithm if the argument was provided, don't send null values
    if algorithm is not None:
        body.update({"algorithm": algorithm})
    # Only send attestationObject if the argument was provided, don't send null values
    if attestationObject is not None:
        body.update({"attestationObject": attestationObject})
    # Only send clientData if the argument was provided, don't send null values
    if clientData is not None:
        body.update({"clientData": clientData})
    # Only send enrollmentToken if the argument was provided, don't send null values
    if enrollmentToken is not None:
        body.update({"enrollmentToken": enrollmentToken})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send protection if the argument was provided, don't send null values
    if protection is not None:
        body.update({"protection": protection})
    # Only send publicKey if the argument was provided, don't send null values
    if publicKey is not None:
        body.update({"publicKey": publicKey})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send userID if the argument was provided, don't send null values
    if userID is not None:
        body.update({"userID": userID})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def request_public_key_device_enrollment_session(
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Request a new enrollment session to enroll a new device (DEV)

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/enroll/device".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def request_webauthn_authentication_challenge(
    domain: str,
    password: str,
    userName: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Request parameters for authenticating using webauthn (PUBLIC)

    :param str domain: User domain
    :param str password: Static Argus\-password for user
    :param str userName: Username to authenticate
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises ValidationErrorException: on 412
    :raises IfTheCurrentIpHasSubmittedTooManyChallengesWithinAShortTimeFrame.TheClientShouldSlowDown.Exception: on 429
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/webauthn/authentication/challenge".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send password if the argument was provided, don't send null values
    if password is not None:
        body.update({"password": password})
    # Only send userName if the argument was provided, don't send null values
    if userName is not None:
        body.update({"userName": userName})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def request_webauthn_enrollment_challenge(
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Request parameters for enrolling new webauthn key (PUBLIC)

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/webauthn/enroll/challenge".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def revoke_key(
    keyID: int,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Revoke public key (PUBLIC)

    :param int keyID: ID of key to revoke
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/{keyID}".format(keyID=keyID)

    session = api_session or _get_session()
    headers = {}

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def verify_public_key_device_enrollment_session(
    enrollmentID: str,
    authorizationToken: str,
    verificationCode: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Verify device bound to enrollment session. This will allow the device holding the session to enroll a public key. (DEV)

    :param str enrollmentID:
    :param str authorizationToken: The authorization token to permit enrolling this key. Token must be valid for operation \'publickey.enroll\'
    :param str verificationCode: The verification code shown on the enrolling device after initializing. Use this to verify that the correct device has bound to the enrollment session.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/enroll/device/{enrollmentID}/verify".format(
        enrollmentID=enrollmentID
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send authorizationToken if the argument was provided, don't send null values
    if authorizationToken is not None:
        body.update({"authorizationToken": authorizationToken})
    # Only send verificationCode if the argument was provided, don't send null values
    if verificationCode is not None:
        body.update({"verificationCode": verificationCode})

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def webauthn_authentication(
    authenticatorData: str,
    challengeID: str,
    clientData: str,
    signature: str,
    userName: str,
    webauthnKeyID: str,
    domain: str = None,
    requestedAuthorizations: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Initiate a new user session using WebAuthn authentication (PUBLIC)

    :param str authenticatorData:
    :param str challengeID: The challenge ID returned from the GET \/webauthn\/authenticate
    :param str clientData:
    :param str signature:
    :param str userName: Username to authenticate
    :param str webauthnKeyID:
    :param str domain: User domain
    :param list requestedAuthorizations: Allow client to request authorizations as part of the authentication transaction. The client is not guaranteed to get the requested authorizations. The setPassword authorization is only returned if the current user has the FORCE\_PW\_CHANGE flag set.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/webauthn/authentication".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send authenticatorData if the argument was provided, don't send null values
    if authenticatorData is not None:
        body.update({"authenticatorData": authenticatorData})
    # Only send challengeID if the argument was provided, don't send null values
    if challengeID is not None:
        body.update({"challengeID": challengeID})
    # Only send clientData if the argument was provided, don't send null values
    if clientData is not None:
        body.update({"clientData": clientData})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        body.update({"signature": signature})
    # Only send userName if the argument was provided, don't send null values
    if userName is not None:
        body.update({"userName": userName})
    # Only send webauthnKeyID if the argument was provided, don't send null values
    if webauthnKeyID is not None:
        body.update({"webauthnKeyID": webauthnKeyID})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send requestedAuthorizations if the argument was provided, don't send null values
    if requestedAuthorizations is not None:
        body.update({"requestedAuthorizations": requestedAuthorizations})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def webauthn_user_authorization(
    authenticatorData: str,
    challengeID: str,
    clientData: str,
    nextURI: str,
    operation: str,
    signature: str,
    webauthnKeyID: str,
    context: dict = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Request an authorization token using a WebAuthn signature (INTERNAL)

    :param str authenticatorData:
    :param str challengeID: The challenge ID returned from the GET \/webauthn\/authenticate
    :param str clientData:
    :param str nextURI: The URI to redirect\/route to after successful authorization. The URI will be validated according to policy. The authorization token returned from successful authorization should be appended as a query parameter to this URI.
    :param str operation: The name of the operation to authorize
    :param str signature:
    :param str webauthnKeyID:
    :param dict context: Context variables to scope this authorization. All context variables required by the executing service must be present and equal to those provided here.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/signature/webauthn/authorize".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send authenticatorData if the argument was provided, don't send null values
    if authenticatorData is not None:
        body.update({"authenticatorData": authenticatorData})
    # Only send challengeID if the argument was provided, don't send null values
    if challengeID is not None:
        body.update({"challengeID": challengeID})
    # Only send clientData if the argument was provided, don't send null values
    if clientData is not None:
        body.update({"clientData": clientData})
    # Only send nextURI if the argument was provided, don't send null values
    if nextURI is not None:
        body.update({"nextURI": nextURI})
    # Only send operation if the argument was provided, don't send null values
    if operation is not None:
        body.update({"operation": operation})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        body.update({"signature": signature})
    # Only send webauthnKeyID if the argument was provided, don't send null values
    if webauthnKeyID is not None:
        body.update({"webauthnKeyID": webauthnKeyID})
    # Only send context if the argument was provided, don't send null values
    if context is not None:
        body.update({"context": context})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
