"""Autogenerated API"""

from argus_api.session import get_session as _get_session
from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from argus_api.session import ArgusAPISession
from requests import Response


def add_asset(
    assetDefinition: str,
    criticality: dict,
    name: str,
    components: dict = None,
    customer: str = None,
    dataSource: str = None,
    description: str = None,
    owner: str = None,
    shortName: str = None,
    ttl: int = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Creates a new Asset (PUBLIC)

    :param str assetDefinition: ID or short name of asset definition\, it should exist within current user\'s domain
    :param dict criticality: Request to set a Group or Asset\'s criticality triad
    :param str name: Name of asset
    :param list components: Specify components to be added with the asset
    :param str customer: ID or short name of customer\, if not specified then current user\'s customer will be assigned
    :param str dataSource: ID or short name of the Data Source
    :param str description: Description of asset. May use HTML\, which will be sanitized
    :param str owner: ID or username of user who owns the asset. When username is specified\, it should exist within current user\'s domain
    :param str shortName: Customer unique short name of asset. If not specified will be set to the new asset\'s generated\/assigned UUID.
    :param int ttl: Time to live duration of this asset since last seen\, 0 means won\'t expire.
    :param bool forceIndex: Whether to force an Elasticsearch index refresh making the new Asset immediately searchable.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send assetDefinition if the argument was provided, don't send null values
    if assetDefinition is not None:
        body.update({"assetDefinition": assetDefinition})
    # Only send criticality if the argument was provided, don't send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send components if the argument was provided, don't send null values
    if components is not None:
        body.update({"components": components})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send dataSource if the argument was provided, don't send null values
    if dataSource is not None:
        body.update({"dataSource": dataSource})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send owner if the argument was provided, don't send null values
    if owner is not None:
        body.update({"owner": owner})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send ttl if the argument was provided, don't send null values
    if ttl is not None:
        body.update({"ttl": ttl})

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_asset_definition(
    name: str,
    shortName: str,
    component: str = None,
    description: str = None,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Creates a new AssetDefinition (INTERNAL)

    :param str name: Asset definition name
    :param str shortName: Asset definition short name\, required and unique per domain
    :param list component: Component definitions \(ID or short name\) to be included for the asset definition
    :param str description: Optional Asset definition description. Will be HTML sanitized
    :param str domain: Asset\/Component definitions will be available globally \(in all domains\)\, so \'domain\' no longer needs to be specified.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send component if the argument was provided, don't send null values
    if component is not None:
        body.update({"component": component})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_asset_link(
    origin: str,
    definition: str,
    target: str,
    ttl: int = None,
    customer: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Creates a new AssetLink (TEST)

    :param str origin: Asset Link Origin Asset ID or short name
    :param str definition: The id or shortname of the link definition.
    :param str target: The id or the shortname of the target asset.
    :param int ttl: Optional TTL in millis that will set the link\'s expiry timestamp on creation and when refreshing the link if a new TTL is not provided.
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when asset short name was provided
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{origin}/link".format(origin=origin)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send definition if the argument was provided, don't send null values
    if definition is not None:
        body.update({"definition": definition})
    # Only send target if the argument was provided, don't send null values
    if target is not None:
        body.update({"target": target})
    # Only send ttl if the argument was provided, don't send null values
    if ttl is not None:
        body.update({"ttl": ttl})

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_asset_link_definition(
    localizedDescriptions: dict,
    property: str,
    shortName: str,
    bindings: dict = None,
    inverse: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Creates a new AssetLinkDefinition (TEST)

    :param dict localizedDescriptions: The localized descriptions of the link definition. There must be at least one entry and English is required.
    :param str property: The link definition\'s property describing the relationship e.g. parentOf
    :param str shortName: The globally unique shortname of the link definition
    :param list bindings: The Asset Link Bindings permitted by the Asset Link Definition.
    :param str inverse: The optional inverse of the link definition\'s property e.g. childOf
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/link/definition".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send localizedDescriptions if the argument was provided, don't send null values
    if localizedDescriptions is not None:
        body.update({"localizedDescriptions": localizedDescriptions})
    # Only send property if the argument was provided, don't send null values
    if property is not None:
        body.update({"property": property})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send bindings if the argument was provided, don't send null values
    if bindings is not None:
        body.update({"bindings": bindings})
    # Only send inverse if the argument was provided, don't send null values
    if inverse is not None:
        body.update({"inverse": inverse})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_asset_link_definition_binding(
    definition: str,
    origin: str,
    target: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Creates a new AssetLinkBinding on an existing active AssetLinkDefinition (TEST)

    :param str definition: Asset Link Definition ID or short name
    :param str origin: The Asset Definition id or shortname for origin Assets of the relationship represented by this binding.
    :param str target: The Asset Definition id or shortname for target Assets of the relationship represented by this binding.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/link/definition/{definition}/binding".format(
        definition=definition
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send origin if the argument was provided, don't send null values
    if origin is not None:
        body.update({"origin": origin})
    # Only send target if the argument was provided, don't send null values
    if target is not None:
        body.update({"target": target})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def calculate_asset_statistics(
    ancestor: str = None,
    asset: str = None,
    assetByVulnerability: dict = None,
    assetDefinition: str = None,
    component: dict = None,
    criticality: dict = None,
    customer: str = None,
    dataSource: str = None,
    excludeFlags: str = None,
    fieldAggregation: dict = None,
    hasGroups: bool = None,
    includeFlags: str = None,
    keywords: str = None,
    maximumTotalCvss: float = None,
    minimumTotalCvss: float = None,
    parent: str = None,
    rangeMetric: dict = None,
    statisticsMetric: dict = None,
    subCriteria: dict = None,
    user: str = None,
    endTimestamp: str = None,
    includeDeleted: bool = False,
    includeGroupInfo: bool = True,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = "any",
    startTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = "any",
    userFieldStrategy: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Generate the requested statistics for Assets matching the provided search criteria. (PUBLIC)

    :param list ancestor: Search for Assets in the hierarchy below this ancestor AssetGroup identified by its ID or short name.\<br \/\>This will resolve all descendant Asset Groups and expand the search to return Assets belonging to them in the hierarchy below these \'ancestor\' groups
    :param list asset: Search for Assets with these Asset IDs or short names
    :param dict assetByVulnerability: Search criteria for searching for Assets by Vulnerability properties
    :param list assetDefinition: Search for Assets with these AssetDefinition IDs or short names
    :param list component: Search for Assets by their components using AND search mode i.e. all criteria must match.\<br \/\>If you want different behaviour try using subcriteria
    :param list criticality: Search for Assets by Confidentiality\, Availability and Integrity.\<br \/\>All criteria values must match for an Asset to match. Use sub\-criteria for OR query behaviour.
    :param list customer: Search for Assets with these Customer IDs or short names
    :param list dataSource: Search for Assets detected and reported by these data sources\, identified by id or shortName
    :param list excludeFlags: Explicitly filter out Assets that contain these flags
    :param list fieldAggregation:  The fields by which to group statistics. The order of fieldAggregations in the request will determine the hierarchy of the aggregations and their buckets.
    :param bool hasGroups: Set to filter on\/out Assets belonging to a group
    :param list includeFlags: Explicitly search for Assets that contain these flags
    :param list keywords: Search for keywords against fields defined by a KeywordFieldStrategy
    :param float maximumTotalCvss: Search for Assets with at most this CVSS score
    :param float minimumTotalCvss: Search for Assets with at least this CVSS score
    :param list parent: Search for Assets with these parent AssetGroup IDs or short names
    :param list rangeMetric: The timestamp fields for which to generate statistics.
    :param list statisticsMetric: The numerical fields for which to generate metrics.
    :param list subCriteria: Set additional criteria that are applied with logical OR by default
    :param list user: Search for Assets by associated user IDs or short names defined by the UserFieldStrategy
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param bool includeDeleted: Whether to include deleted assets
    :param bool includeGroupInfo: Whether to include Assets\' parent group info in the search response
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match any keywords\)
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start\/endTimestamp
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\)
    :param list userFieldStrategy: Defines which user fields to filter with the submitted user value\(s\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/statistics".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send ancestor if the argument was provided, don't send null values
    if ancestor is not None:
        body.update({"ancestor": ancestor})
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send assetByVulnerability if the argument was provided, don't send null values
    if assetByVulnerability is not None:
        body.update({"assetByVulnerability": assetByVulnerability})
    # Only send assetDefinition if the argument was provided, don't send null values
    if assetDefinition is not None:
        body.update({"assetDefinition": assetDefinition})
    # Only send component if the argument was provided, don't send null values
    if component is not None:
        body.update({"component": component})
    # Only send criticality if the argument was provided, don't send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send dataSource if the argument was provided, don't send null values
    if dataSource is not None:
        body.update({"dataSource": dataSource})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send fieldAggregation if the argument was provided, don't send null values
    if fieldAggregation is not None:
        body.update({"fieldAggregation": fieldAggregation})
    # Only send hasGroups if the argument was provided, don't send null values
    if hasGroups is not None:
        body.update({"hasGroups": hasGroups})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send maximumTotalCvss if the argument was provided, don't send null values
    if maximumTotalCvss is not None:
        body.update({"maximumTotalCvss": maximumTotalCvss})
    # Only send minimumTotalCvss if the argument was provided, don't send null values
    if minimumTotalCvss is not None:
        body.update({"minimumTotalCvss": minimumTotalCvss})
    # Only send parent if the argument was provided, don't send null values
    if parent is not None:
        body.update({"parent": parent})
    # Only send rangeMetric if the argument was provided, don't send null values
    if rangeMetric is not None:
        body.update({"rangeMetric": rangeMetric})
    # Only send statisticsMetric if the argument was provided, don't send null values
    if statisticsMetric is not None:
        body.update({"statisticsMetric": statisticsMetric})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeGroupInfo if the argument was provided, don't send null values
    if includeGroupInfo is not None:
        body.update({"includeGroupInfo": includeGroupInfo})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def delete_asset(
    idOrShortName: str,
    customer: str = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Delete asset (PUBLIC)

    :param str idOrShortName: Asset ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when short name was provided
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that updates to the Asset are immediately searchable.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}".format(idOrShortName=idOrShortName)

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def delete_asset_definition(
    definition: str,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Marks a AssetDefinition as deleted (INTERNAL)

    :param str definition: AssetDefinition ID or short name
    :param str domain: Domain ID or name \(default is user\'s domain\)\, only used when definition is short name
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition/{definition}".format(definition=definition)

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def delete_asset_link(
    asset: str,
    link: str,
    customer: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Delete an existing active Asset Link identified by its id and origin Asset's id or shortname (TEST)

    :param str asset: Asset link origin Asset id or shortname
    :param str link: Asset Link id
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when asset short name was provided
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{asset}/link/{link}".format(asset=asset, link=link)

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def delete_asset_link_binding(
    definition: str,
    binding: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Delete an active AssetLinkBinding from an AssetLinkDefinition (TEST)

    :param str definition: Asset Link Definition ID or short name
    :param str binding: Asset Link Binding ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/link/definition/{definition}/binding/{binding}".format(
        definition=definition, binding=binding
    )

    session = api_session or _get_session()
    headers = {}

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def delete_asset_link_definition(
    definition: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Delete an existing active Asset Link Definition identified by its ID or shortName (TEST)

    :param str definition: Asset Link Definition ID or short name
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/link/definition/{definition}".format(
        definition=definition
    )

    session = api_session or _get_session()
    headers = {}

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_asset(
    idOrShortName: str,
    customer: str = None,
    includeDeletedComponents: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get Asset (PUBLIC)

    :param str idOrShortName: Asset ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when the asset\'s short name was provided to retrieve the asset
    :param bool includeDeletedComponents: Include deleted components in the response
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}".format(idOrShortName=idOrShortName)

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send includeDeletedComponents if the argument was provided, don't send null values
    if includeDeletedComponents is not None:
        query_parameters.update({"includeDeletedComponents": includeDeletedComponents})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_asset_ancestors(
    idOrShortName: str,
    customer: str = None,
    offset: int = 0,
    limit: int = 0,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get Asset Ancestors (PUBLIC)

    :param str idOrShortName: Asset ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when the asset\'s short name was provided to retrieve the asset
    :param int offset: How many Asset Ancestors to skip\, defaults to 0
    :param int limit: How many Asset Ancestors to return\, defaults to all
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}/ancestors".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_asset_component(
    idOrShortName: str,
    id: str,
    customer: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get Asset Component (INTERNAL)

    :param str idOrShortName: Asset ID or short name
    :param str id: Asset Component ID
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when the asset\'s short name was provided to retrieve the asset
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}/component/{id}".format(
        idOrShortName=idOrShortName, id=id
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_asset_components(
    idOrShortName: str,
    customer: str = None,
    includeDeleted: bool = None,
    offset: int = None,
    limit: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns Asset Components in the order in which they were created. Supports pagination i.e. offset and limit and filtering deleted components (INTERNAL)

    :param str idOrShortName: Asset ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when the asset\'s short name was provided to retrieve the asset
    :param bool includeDeleted: Whether to include deleted components
    :param int offset: How many components to skip
    :param int limit: How many components to return
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}/components".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_asset_definition(
    definition: str,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get AssetDefinition (INTERNAL)

    :param str definition: AssetDefinition ID or short name
    :param str domain: Domain ID or name \(default is user\'s domain\)\, only used when definition is short name
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition/{definition}".format(definition=definition)

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_asset_link_definition(
    definition: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get an AssetLinkDefinition and its active (non-deleted) bindings (TEST)

    :param str definition: AssetLinkDefinition ID or short name
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/link/definition/{definition}".format(
        definition=definition
    )

    session = api_session or _get_session()
    headers = {}

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_asset_link_definition_bindings(
    definition: str,
    limit: int = 25,
    offset: int = 0,
    includeDeleted: bool = False,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get AssetLinkBindings for a specific AssetLinkDefinition (TEST)

    :param str definition: AssetLinkDefinition ID or short name
    :param int limit: Limit results
    :param int offset: Offset results.
    :param bool includeDeleted: Include deleted bindings in the response
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/link/definition/{definition}/bindings".format(
        definition=definition
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_asset_parents(
    idOrShortName: str,
    customer: str = None,
    offset: int = 0,
    limit: int = 0,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get Asset Parents (PUBLIC)

    :param str idOrShortName: Asset ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when the asset\'s short name was provided to retrieve the asset
    :param int offset: How many Assets Parents to skip\, defaults to 0
    :param int limit: How many Assets Parents to return\, defaults to all
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}/parents".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_vulnerability_by_asset(
    asset: str,
    customer: str = None,
    includeRawOutput: bool = False,
    includeDeleted: bool = False,
    offset: int = 0,
    limit: int = 0,
    skipCount: bool = False,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get Vulnerabilities observed on the requested Asset. (PUBLIC)

    :param str asset: Asset ID or short name.
    :param str customer: Customer ID or short name \(default is user\'s customer\) to help resolve asset\, only used when asset\'s short name was provided.
    :param bool includeRawOutput: Whether to include raw output\, not included by default
    :param bool includeDeleted: Whether to include deleted vulnerabilities\, not included by default
    :param int offset: How many vulnerabilities to skip\, defaults to 0
    :param int limit: How many vulnerabilities to return\, defaults to all of them
    :param bool skipCount: Whether to skip counting vulnerabilities and simply return them
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{asset}/vulnerability".format(asset=asset)

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send includeRawOutput if the argument was provided, don't send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send skipCount if the argument was provided, don't send null values
    if skipCount is not None:
        query_parameters.update({"skipCount": skipCount})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_vulnerability_by_asset_and_vulnerability_id(
    asset: str,
    vulnerabilityID: str,
    customer: str = None,
    includeRawOutput: bool = False,
    includeDeleted: bool = False,
    offset: int = 0,
    limit: int = 0,
    skipCount: bool = False,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get Vulnerabilities observed on the requested Asset with the same Vulnerability Definition (PUBLIC)

    :param str asset: Asset ID or short name.
    :param str vulnerabilityID: Identifier of vulnerability \(e.g. CVE\-2015\-3429\)
    :param str customer: Customer ID or short name \(default is user\'s customer\) to help resolve asset\, only used when asset\'s short name was provided.
    :param bool includeRawOutput: Whether to include raw output\, not included by default
    :param bool includeDeleted: Whether to include deleted vulnerabilities\, not included by default
    :param int offset: How many Vulnerabilities to skip\, defaults to 0
    :param int limit: How many Vulnerabilities to return\, defaults to all
    :param bool skipCount: Whether to skip counting vulnerabilities and simply return them
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{asset}/vulnerability/{vulnerabilityID}".format(
        asset=asset, vulnerabilityID=vulnerabilityID
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send includeRawOutput if the argument was provided, don't send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send skipCount if the argument was provided, don't send null values
    if skipCount is not None:
        query_parameters.update({"skipCount": skipCount})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_asset_link_definitions(
    definition: str = None,
    limit: int = 25,
    offset: int = 0,
    includeDeleted: bool = False,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""List AssetLinkDefinitions (TEST)

    :param list definition: AssetLinkDefinition ID or short name
    :param int limit: Limit results
    :param int offset: Offset results.
    :param bool includeDeleted: Include deleted definition in the response
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/link/definition".format()

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send definition if the argument was provided, don't send null values
    if definition is not None:
        query_parameters.update({"definition": definition})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_asset_links(
    asset: str,
    customer: str = None,
    limit: int = 25,
    offset: int = 0,
    includeDeleted: bool = False,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""List AssetLinks (TEST)

    :param str asset: Origin Asset ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when the asset\'s short name was provided to retrieve the asset
    :param int limit: Limit results
    :param int offset: Offset results.
    :param bool includeDeleted: Include deleted links in the response
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{asset}/link".format(asset=asset)

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_asset_vulnerabilities(
    idOrShortName: str,
    customer: str = None,
    includeRawOutput: bool = False,
    includeDeleted: bool = False,
    offset: int = 0,
    limit: int = 0,
    skipCount: bool = False,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get Vulnerabilities observed on the requested Asset. (PUBLIC)

    :param str idOrShortName: Asset ID or short name.
    :param str customer: Customer ID or short name \(default is user\'s customer\) to help resolve asset\, only used when asset\'s short name was provided.
    :param bool includeRawOutput: Whether to include raw output\, not included by default
    :param bool includeDeleted: Whether to include deleted vulnerabilities\, not included by default
    :param int offset: How many vulnerabilities to skip\, defaults to 0
    :param int limit: How many vulnerabilities to return\, defaults to all of them
    :param bool skipCount: Whether to skip counting vulnerabilities and simply return them
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}/vulnerabilities".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send includeRawOutput if the argument was provided, don't send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send skipCount if the argument was provided, don't send null values
    if skipCount is not None:
        query_parameters.update({"skipCount": skipCount})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_asset_vulnerabilities_by_id(
    idOrShortName: str,
    vulnerabilityID: str,
    customer: str = None,
    includeRawOutput: bool = False,
    includeDeleted: bool = False,
    offset: int = 0,
    limit: int = 0,
    skipCount: bool = False,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Get Vulnerabilities observed on the requested Asset with the same Vulnerability Definition (PUBLIC)

    :param str idOrShortName: Asset ID or short name.
    :param str vulnerabilityID: Identifier of vulnerability \(e.g. CVE\-2015\-3429\)
    :param str customer: Customer ID or short name \(default is user\'s customer\) to help resolve asset\, only used when asset\'s short name was provided.
    :param bool includeRawOutput: Whether to include raw output\, not included by default
    :param bool includeDeleted: Whether to include deleted vulnerabilities\, not included by default
    :param int offset: How many Vulnerabilities to skip\, defaults to 0
    :param int limit: How many Vulnerabilities to return\, defaults to all
    :param bool skipCount: Whether to skip counting vulnerabilities and simply return them
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}/vulnerabilities/{vulnerabilityID}".format(
        idOrShortName=idOrShortName, vulnerabilityID=vulnerabilityID
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send includeRawOutput if the argument was provided, don't send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send skipCount if the argument was provided, don't send null values
    if skipCount is not None:
        query_parameters.update({"skipCount": skipCount})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_assets(
    customer: str = None,
    asset: str = None,
    parent: str = None,
    dataSource: str = None,
    keywords: str = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = 0,
    includeDeleted: bool = False,
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    timeFieldStrategy: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Basic Asset search. If keywords are present, they must all must be present in at least one of the keyword fields. Check the documentation for the KeywordFieldStrategy field for more details. If start/end timestamps are present, the range must be valid for at least one of the requested time stamp fields. Check the documentation for the TimestampFieldStrategy field for more details. Limit and offset added together cannot exceed 10'000 (PUBLIC)

    :param list customer: Customer ids or short names
    :param list asset: Asset ids or short names
    :param list parent: Asset parent group ids or short names
    :param list dataSource: Data source\, identified by id or shortname\, that detected the Asset
    :param list keywords: Limit search by asset field \(short name\, name\, and description\) keywords
    :param list sortBy: Field\(s\) to sort by \- refer to the search POST endpoint to see which fields are permitted
    :param int limit: Limit results. The sum of limit and offset must be \<\= 10\'000 when not streaming
    :param int offset: Offset results. The sum of limit and offset must be \<\= 10\'000 when not streaming
    :param bool includeDeleted: Include deleted
    :param str startTimestamp: Lower bound timestamp filter value
    :param str endTimestamp: Upper bound timestamp filter value
    :param list timeFieldStrategy: Which time field\(s\) to filter by timestamp start\/end
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset".format()

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        query_parameters.update({"asset": asset})
    # Only send parent if the argument was provided, don't send null values
    if parent is not None:
        query_parameters.update({"parent": parent})
    # Only send dataSource if the argument was provided, don't send null values
    if dataSource is not None:
        query_parameters.update({"dataSource": dataSource})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        query_parameters.update({"timeFieldStrategy": timeFieldStrategy})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def overwrite_asset_data_source(
    asset: str,
    datasource: str,
    customer: str = None,
    cascade: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Overwrite the Asset's DataSource (DEV)

    :param str asset: Asset ID or short name
    :param str datasource: DataSource ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when asset short name was provided
    :param bool cascade: Whether to update the asset\'s active components
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{asset}/datasource".format(asset=asset)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send datasource if the argument was provided, don't send null values
    if datasource is not None:
        query_parameters.update({"datasource": datasource})
    # Only send cascade if the argument was provided, don't send null values
    if cascade is not None:
        query_parameters.update({"cascade": cascade})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def recalculate_asset(
    idOrShortName: str,
    customer: str = None,
    recalculateGroups: bool = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Force a recalculation of an Asset's vulnerabilityCount and totalCVSS fields.NB: any changes are propagated up the Asset Group hierarchy if recalculateGroups is set and the Asset belongs to any group(s). (INTERNAL)

    :param str idOrShortName: Asset ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when asset short name was provided
    :param bool recalculateGroups: Whether to recalculate counts for groups in the hierarchy above the affected asset
    :param bool forceIndex: Whether to force an Elasticsearch index refresh making the recalculated asset immediately searchable.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}/recalculate".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send recalculateGroups if the argument was provided, don't send null values
    if recalculateGroups is not None:
        query_parameters.update({"recalculateGroups": recalculateGroups})
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def refresh_asset_link(
    asset: str,
    link: str,
    ttl: int = None,
    customer: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Refresh an existing active Asset Link identified by its id and origin Asset's id or shortname (TEST)

    :param str asset: Asset link origin Asset id or shortname
    :param str link: Asset Link id
    :param int ttl: How long the link is considered valid. If set will override the existing TTL on the link.
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when asset short name was provided
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{asset}/link/{link}".format(asset=asset, link=link)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send ttl if the argument was provided, don't send null values
    if ttl is not None:
        body.update({"ttl": ttl})

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def reindex_asset(
    assetID: str,
    recursive: str = "none",
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Re-indexes specified Assets (INTERNAL)

    :param list assetID: A set of asset IDs to be re\-indexed
    :param str recursive: Enumerated type of recursion strategy\(none \- reindex just assets\, all \- reindex assets and associated vulnerabilities
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/bulk/reindex".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send assetID if the argument was provided, don't send null values
    if assetID is not None:
        body.update({"assetID": assetID})
    # Only send recursive if the argument was provided, don't send null values
    if recursive is not None:
        body.update({"recursive": recursive})

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def search_asset_definitions(
    definition: str = None,
    domain: str = None,
    keywords: str = None,
    order: str = None,
    sortBy: str = None,
    subCriteria: dict = None,
    user: str = None,
    endTimestamp: str = None,
    includeDeleted: bool = False,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = "all",
    limit: int = 25,
    offset: int = 0,
    startTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = "any",
    userFieldStrategy: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Search AssetDefinitions with specified criteria (INTERNAL)

    :param list definition: Restrict to specified Asset definitions \(ID or short name\)
    :param list domain: Restrict to specified domains \(domain ID or name\)
    :param list keywords: Search for keywords against fields defined by keywordFieldStrategy
    :param list order:
    :param list sortBy: Specify the order of results. Prefix with \'\-\' to order descending.
    :param list subCriteria: Set additional criteria which are applied with logical OR by default
    :param list user: Search for Asset Definitions by associated user IDs or short names defined by the UserFieldStrategy
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param bool includeDeleted: Whether include deleted results
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\)
    :param int limit: Limit maximum amount of results
    :param int offset: Skip specified amount of results
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list timeFieldStrategy: Defines which timestamps will be included in the search \(default lastUpdatedTimestamp\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\)
    :param list userFieldStrategy: Defines which user fields to filter with the submitted user value\(s\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition/search".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send definition if the argument was provided, don't send null values
    if definition is not None:
        body.update({"definition": definition})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send order if the argument was provided, don't send null values
    if order is not None:
        body.update({"order": order})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def search_asset_definitions_simplified(
    keywords: str = None,
    definition: str = None,
    domain: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    keywordField: str = None,
    keywordMatch: str = "all",
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    timeField: str = None,
    timeMatch: str = "any",
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Search AssetDefinitions with specified query parameters (INTERNAL)

    :param list keywords: Search by keywords
    :param list definition: Search by definitions \(ID or short name\)
    :param list domain: Search by domains \(domain ID or name\)
    :param list sortBy: Sort search result
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param list keywordField: Set field strategy for keyword search
    :param str keywordMatch: Set match strategy for keyword search
    :param str startTimestamp: Start timestamp for time range search
    :param str endTimestamp: End timestamp for time range search
    :param list timeField: Set field strategy for time range search
    :param str timeMatch: Set match strategy for time range search
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition".format()

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send definition if the argument was provided, don't send null values
    if definition is not None:
        query_parameters.update({"definition": definition})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send keywordField if the argument was provided, don't send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    # Only send keywordMatch if the argument was provided, don't send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send timeField if the argument was provided, don't send null values
    if timeField is not None:
        query_parameters.update({"timeField": timeField})
    # Only send timeMatch if the argument was provided, don't send null values
    if timeMatch is not None:
        query_parameters.update({"timeMatch": timeMatch})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def search_assets(
    ancestor: str = None,
    asset: str = None,
    assetByVulnerability: dict = None,
    assetDefinition: str = None,
    component: dict = None,
    criticality: dict = None,
    customer: str = None,
    dataSource: str = None,
    excludeFlags: str = None,
    hasGroups: bool = None,
    includeFlags: str = None,
    keywords: str = None,
    maximumTotalCvss: float = None,
    minimumTotalCvss: float = None,
    order: str = None,
    parent: str = None,
    sortBy: str = None,
    subCriteria: dict = None,
    user: str = None,
    exportFields: str = None,
    exportComponents: str = None,
    endTimestamp: str = None,
    includeDeleted: bool = False,
    includeGroupInfo: bool = True,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = "any",
    limit: int = 25,
    offset: int = 0,
    startTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = "any",
    userFieldStrategy: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Search Assets (PUBLIC)

    :param list ancestor: Search for Assets in the hierarchy below this ancestor AssetGroup identified by its ID or short name.\<br \/\>This will resolve all descendant Asset Groups and expand the search to return Assets belonging to them in the hierarchy below these \'ancestor\' groups
    :param list asset: Search for Assets with these Asset IDs or short names
    :param dict assetByVulnerability: Search criteria for searching for Assets by Vulnerability properties
    :param list assetDefinition: Search for Assets with these AssetDefinition IDs or short names
    :param list component: Search for Assets by their components using AND search mode i.e. all criteria must match.\<br \/\>If you want different behaviour try using subcriteria
    :param list criticality: Search for Assets by Confidentiality\, Availability and Integrity.\<br \/\>All criteria values must match for an Asset to match. Use sub\-criteria for OR query behaviour.
    :param list customer: Search for Assets with these Customer IDs or short names
    :param list dataSource: Search for Assets detected and reported by these data sources\, identified by id or shortName
    :param list excludeFlags: Explicitly filter out Assets that contain these flags
    :param bool hasGroups: Set to filter on\/out Assets belonging to a group
    :param list includeFlags: Explicitly search for Assets that contain these flags
    :param list keywords: Search for keywords against fields defined by a KeywordFieldStrategy
    :param float maximumTotalCvss: Search for Assets with at most this CVSS score
    :param float minimumTotalCvss: Search for Assets with at least this CVSS score
    :param list order:
    :param list parent: Search for Assets with these parent AssetGroup IDs or short names
    :param list sortBy: Specify the order of results. Prefix with \'\-\' to order descending.
    :param list subCriteria: Set additional criteria that are applied with logical OR by default
    :param list user: Search for Assets by associated user IDs or short names defined by the UserFieldStrategy
    :param list exportFields: Select order of and fields to export.
    :param list exportComponents: Select which component values to include in the export.
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param bool includeDeleted: Whether to include deleted Assets
    :param bool includeGroupInfo: Whether to include Assets\' parent group info in the search response
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match any keywords\)
    :param int limit: Limit the results to the specified amount
    :param int offset: Skip specified amount of results
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start\/endTimestamp
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\)
    :param list userFieldStrategy: Defines which user fields to filter with the submitted user value\(s\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/assets/v2/asset/search".format()

    session = api_session or _get_session()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    body = body or {}
    # Only send ancestor if the argument was provided, don't send null values
    if ancestor is not None:
        body.update({"ancestor": ancestor})
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send assetByVulnerability if the argument was provided, don't send null values
    if assetByVulnerability is not None:
        body.update({"assetByVulnerability": assetByVulnerability})
    # Only send assetDefinition if the argument was provided, don't send null values
    if assetDefinition is not None:
        body.update({"assetDefinition": assetDefinition})
    # Only send component if the argument was provided, don't send null values
    if component is not None:
        body.update({"component": component})
    # Only send criticality if the argument was provided, don't send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send dataSource if the argument was provided, don't send null values
    if dataSource is not None:
        body.update({"dataSource": dataSource})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send hasGroups if the argument was provided, don't send null values
    if hasGroups is not None:
        body.update({"hasGroups": hasGroups})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send maximumTotalCvss if the argument was provided, don't send null values
    if maximumTotalCvss is not None:
        body.update({"maximumTotalCvss": maximumTotalCvss})
    # Only send minimumTotalCvss if the argument was provided, don't send null values
    if minimumTotalCvss is not None:
        body.update({"minimumTotalCvss": minimumTotalCvss})
    # Only send order if the argument was provided, don't send null values
    if order is not None:
        body.update({"order": order})
    # Only send parent if the argument was provided, don't send null values
    if parent is not None:
        body.update({"parent": parent})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeGroupInfo if the argument was provided, don't send null values
    if includeGroupInfo is not None:
        body.update({"includeGroupInfo": includeGroupInfo})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})

    query_parameters = {}
    # Only send exportFields if the argument was provided, don't send null values
    if exportFields is not None:
        query_parameters.update({"exportFields": exportFields})
    # Only send exportComponents if the argument was provided, don't send null values
    if exportComponents is not None:
        query_parameters.update({"exportComponents": exportComponents})

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_asset(
    idOrShortName: str,
    addComponents: dict = None,
    criticality: dict = None,
    deleteComponents: str = None,
    description: str = None,
    name: str = None,
    owner: str = None,
    shortName: str = None,
    ttl: int = None,
    customer: str = None,
    forceIndex: bool = None,
    updateLastSeen: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Updates an existing Asset (PUBLIC)

    :param str idOrShortName: Asset ID or short name
    :param list addComponents: Specify components to be added with the asset
    :param dict criticality: Request to update a Group or Asset\'s criticality triad
    :param list deleteComponents: Specify IDs of the components to be deleted from the asset
    :param str description: Update description of asset. Support HTML\, which will be sanitized
    :param str name: Update name of asset
    :param str owner: Update owner of asset\, specified by user ID or username. When username is specified\, it should exist within current user\'s domain
    :param str shortName: Update short name of asset
    :param int ttl: Time to live duration of this asset since last seen\, 0 means won\'t expire.
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when asset short name was provided
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that changes to the Asset are immediately searchable.
    :param bool updateLastSeen: Temporary field added to make updating lastSeenTimestamp\/UserId easier.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/{idOrShortName}".format(idOrShortName=idOrShortName)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send addComponents if the argument was provided, don't send null values
    if addComponents is not None:
        body.update({"addComponents": addComponents})
    # Only send criticality if the argument was provided, don't send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send deleteComponents if the argument was provided, don't send null values
    if deleteComponents is not None:
        body.update({"deleteComponents": deleteComponents})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send owner if the argument was provided, don't send null values
    if owner is not None:
        body.update({"owner": owner})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send ttl if the argument was provided, don't send null values
    if ttl is not None:
        body.update({"ttl": ttl})

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    # Only send updateLastSeen if the argument was provided, don't send null values
    if updateLastSeen is not None:
        query_parameters.update({"updateLastSeen": updateLastSeen})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_asset_definition(
    definition: str,
    addComponent: str = None,
    deleteComponent: str = None,
    description: str = None,
    name: str = None,
    shortName: str = None,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Updates an existing AssetDefinition (INTERNAL)

    :param str definition: AssetDefinition ID or short name
    :param list addComponent: Component definitions \(ID or short name\) to be added to the asset definition\, they have to belong to same domain as asset definition.
    :param list deleteComponent: Component definitions \(\(ID or short name\)\) to be deleted from the asset definition
    :param str description: Optional Asset definition description. Will be HTML sanitized
    :param str name: Update asset definition name
    :param str shortName: Update asset definition short name
    :param str domain: Domain ID or name \(default is user\'s domain\)\, required when definition is identified by short name
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/definition/{definition}".format(definition=definition)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send addComponent if the argument was provided, don't send null values
    if addComponent is not None:
        body.update({"addComponent": addComponent})
    # Only send deleteComponent if the argument was provided, don't send null values
    if deleteComponent is not None:
        body.update({"deleteComponent": deleteComponent})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_asset_link_definition(
    definition: str,
    addBinding: dict = None,
    inverse: str = None,
    localizedDescriptions: dict = None,
    property: str = None,
    removeBinding: str = None,
    shortName: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Updates an existing active AssetLinkDefinition (TEST)

    :param str definition: Asset Link Definition ID or short name
    :param list addBinding: Asset Link Bindings to be added to the asset definition.
    :param str inverse: The optional inverse of the link definition\'s property e.g. childOf
    :param dict localizedDescriptions: The localized descriptions of the link definition. There must be always be at English defined.
    :param str property: The link definition\'s property describing the relationship e.g. parentOf
    :param list removeBinding: Asset Link Bindings to be deleted and removed from the asset definition.
    :param str shortName: New globally unique shortname for the Asset Link Definition.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/asset/link/definition/{definition}".format(
        definition=definition
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send addBinding if the argument was provided, don't send null values
    if addBinding is not None:
        body.update({"addBinding": addBinding})
    # Only send inverse if the argument was provided, don't send null values
    if inverse is not None:
        body.update({"inverse": inverse})
    # Only send localizedDescriptions if the argument was provided, don't send null values
    if localizedDescriptions is not None:
        body.update({"localizedDescriptions": localizedDescriptions})
    # Only send property if the argument was provided, don't send null values
    if property is not None:
        body.update({"property": property})
    # Only send removeBinding if the argument was provided, don't send null values
    if removeBinding is not None:
        body.update({"removeBinding": removeBinding})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
