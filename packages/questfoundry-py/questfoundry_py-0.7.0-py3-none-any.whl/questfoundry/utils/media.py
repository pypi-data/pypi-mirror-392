"""Media file utilities for workspace integration."""

import hashlib
import logging
from pathlib import Path
from typing import Any

from ..models.artifact import Artifact

logger = logging.getLogger(__name__)


class MediaWorkspace:
    """
    Workspace manager for generated media files (images, audio).

    Provides consistent file naming, directory structure, and metadata tracking
    for media assets generated by roles like Illustrator and AudioProducer.
    """

    def __init__(self, workspace_path: Path):
        """
        Initialize media workspace.

        Args:
            workspace_path: Base path for workspace directory
        """
        self.workspace_path = workspace_path
        self.images_dir = workspace_path / "renders"
        self.audio_dir = workspace_path / "audio"

        # Create directories if they don't exist
        self.images_dir.mkdir(parents=True, exist_ok=True)
        self.audio_dir.mkdir(parents=True, exist_ok=True)

    def save_image(
        self,
        image_data: bytes,
        artifact_id: str,
        metadata: dict[str, Any] | None = None,
        format: str = "png",
    ) -> Path:
        """
        Save generated image to workspace.

        Args:
            image_data: Image bytes
            artifact_id: Artifact ID for the image
            metadata: Optional metadata to save alongside image
            format: Image format (png, jpg, etc.)

        Returns:
            Path to saved image file
        """
        # Generate filename based on artifact ID
        filename = f"{artifact_id}.{format}"
        image_path = self.images_dir / filename

        # Save image
        image_path.write_bytes(image_data)
        logger.info(f"Saved image to {image_path}")

        # Save metadata if provided
        if metadata:
            metadata_path = self.images_dir / f"{artifact_id}.metadata.json"
            import json

            metadata_path.write_text(json.dumps(metadata, indent=2))
            logger.debug(f"Saved image metadata to {metadata_path}")

        return image_path

    def save_audio(
        self,
        audio_data: bytes,
        artifact_id: str,
        metadata: dict[str, Any] | None = None,
        format: str = "mp3",
    ) -> Path:
        """
        Save generated audio to workspace.

        Args:
            audio_data: Audio bytes
            artifact_id: Artifact ID for the audio
            metadata: Optional metadata to save alongside audio
            format: Audio format (mp3, wav, etc.)

        Returns:
            Path to saved audio file
        """
        # Generate filename based on artifact ID
        filename = f"{artifact_id}.{format}"
        audio_path = self.audio_dir / filename

        # Save audio
        audio_path.write_bytes(audio_data)
        logger.info(f"Saved audio to {audio_path}")

        # Save metadata if provided
        if metadata:
            metadata_path = self.audio_dir / f"{artifact_id}.metadata.json"
            import json

            metadata_path.write_text(json.dumps(metadata, indent=2))
            logger.debug(f"Saved audio metadata to {metadata_path}")

        return audio_path

    def get_image_path(self, artifact_id: str, format: str = "png") -> Path:
        """
        Get path for an image artifact.

        Args:
            artifact_id: Artifact ID
            format: Image format

        Returns:
            Path to image file
        """
        return self.images_dir / f"{artifact_id}.{format}"

    def get_audio_path(self, artifact_id: str, format: str = "mp3") -> Path:
        """
        Get path for an audio artifact.

        Args:
            artifact_id: Artifact ID
            format: Audio format

        Returns:
            Path to audio file
        """
        return self.audio_dir / f"{artifact_id}.{format}"

    def create_artifact_for_image(
        self,
        artifact_id: str,
        image_path: Path,
        artifact_type: str = "render",
        metadata: dict[str, Any] | None = None,
    ) -> Artifact:
        """
        Create an artifact record for a saved image.

        Args:
            artifact_id: Artifact ID
            image_path: Path to saved image
            artifact_type: Type of artifact (e.g., 'render', 'illustration')
            metadata: Additional metadata

        Returns:
            Artifact instance
        """
        data = {
            "file_path": str(image_path.relative_to(self.workspace_path)),
            "absolute_path": str(image_path.absolute()),
        }

        if metadata:
            data.update(metadata)

        return Artifact(
            type=artifact_type,
            data=data,
            metadata={"id": artifact_id},
        )

    def create_artifact_for_audio(
        self,
        artifact_id: str,
        audio_path: Path,
        artifact_type: str = "audio_asset",
        metadata: dict[str, Any] | None = None,
    ) -> Artifact:
        """
        Create an artifact record for saved audio.

        Args:
            artifact_id: Artifact ID
            audio_path: Path to saved audio
            artifact_type: Type of artifact (e.g., 'audio_asset', 'narration')
            metadata: Additional metadata

        Returns:
            Artifact instance
        """
        data = {
            "file_path": str(audio_path.relative_to(self.workspace_path)),
            "absolute_path": str(audio_path.absolute()),
        }

        if metadata:
            data.update(metadata)

        return Artifact(
            type=artifact_type,
            data=data,
            metadata={"id": artifact_id},
        )

    def generate_artifact_id(self, content: str, prefix: str = "") -> str:
        """
        Generate deterministic artifact ID from content.

        Args:
            content: Content to hash (e.g., prompt text)
            prefix: Optional prefix for the ID

        Returns:
            Artifact ID string
        """
        # Create hash of content
        content_hash = hashlib.sha256(content.encode()).hexdigest()[:12]

        if prefix:
            return f"{prefix}_{content_hash}"
        return content_hash
