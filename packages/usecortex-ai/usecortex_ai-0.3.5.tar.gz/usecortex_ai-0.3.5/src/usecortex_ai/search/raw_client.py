# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.service_unavailable_error import ServiceUnavailableError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.actual_error_response import ActualErrorResponse
from ..types.bm_25_operator_type import Bm25OperatorType
from ..types.retrieve_mode import RetrieveMode
from ..types.retrieve_response import RetrieveResponse
from ..types.search_chunk import SearchChunk
from .types.alpha import Alpha

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawSearchClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def qna(
        self,
        *,
        question: str,
        session_id: str,
        tenant_id: str,
        context_list: typing.Optional[typing.Sequence[str]] = OMIT,
        search_modes: typing.Optional[typing.Sequence[str]] = OMIT,
        sub_tenant_id: typing.Optional[str] = OMIT,
        highlight_chunks: typing.Optional[bool] = OMIT,
        stream: typing.Optional[bool] = OMIT,
        search_alpha: typing.Optional[float] = OMIT,
        recency_bias: typing.Optional[float] = OMIT,
        ai_generation: typing.Optional[bool] = OMIT,
        top_n: typing.Optional[int] = OMIT,
        user_name: typing.Optional[str] = OMIT,
        user_instructions: typing.Optional[str] = OMIT,
        multi_step_reasoning: typing.Optional[bool] = OMIT,
        auto_agent_routing: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Ask a question to your uploaded knowledge base and let Cortex AI answer it.

        Parameters
        ----------
        question : str
            The question to be answered

        session_id : str
            Unique identifier for the conversation session. Keep it same when the current question refers to a previous answer or question

        tenant_id : str
            Identifier for the tenant/organization

        context_list : typing.Optional[typing.Sequence[str]]
            List of context strings to provide additional information

        search_modes : typing.Optional[typing.Sequence[str]]
            List of search modes to use for finding relevant information

        sub_tenant_id : typing.Optional[str]
            Identifier for sub-tenant within the tenant

        highlight_chunks : typing.Optional[bool]
            Whether to return text chunks in the response along with final LLM generated answer

        stream : typing.Optional[bool]
            Whether to stream the response

        search_alpha : typing.Optional[float]
            Closer to 0.0 means a exact keyword search will be performed, closer to 1.0 means semantics of the search will be considered. In most cases, you wont have to toggle it yourself.

        recency_bias : typing.Optional[float]
            Bias towards more recent information (0.0 to 1.0)

        ai_generation : typing.Optional[bool]
            Whether to use AI for generating responses

        top_n : typing.Optional[int]
            Number of top results to return

        user_name : typing.Optional[str]
            Name of the user making the request. This helps LLM to know the user's name if semantics around the username are involved in query. Its generally a good practice to include it possible.

        user_instructions : typing.Optional[str]
            Custom instructions for the AI response to add to our proprietary prompt. This can be used to provide additional context or instructions for the LLM to follow so that the answers are tailored towards your application style

        multi_step_reasoning : typing.Optional[bool]
            Enable advanced multi-step reasoning for complex queries. When enabled, the AI will automatically break down complex questions into multiple research steps to provide more comprehensive and accurate answers.

        auto_agent_routing : typing.Optional[bool]
            Enable intelligent agent routing to automatically select the most suitable AI agent for your specific query type. Different agents are optimized for various use cases like social media, code, conversations, general knowledge, etc.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Additional metadata for the request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "search/qna",
            method="POST",
            json={
                "question": question,
                "session_id": session_id,
                "tenant_id": tenant_id,
                "context_list": context_list,
                "search_modes": search_modes,
                "sub_tenant_id": sub_tenant_id,
                "highlight_chunks": highlight_chunks,
                "stream": stream,
                "search_alpha": search_alpha,
                "recency_bias": recency_bias,
                "ai_generation": ai_generation,
                "top_n": top_n,
                "user_name": user_name,
                "user_instructions": user_instructions,
                "multi_step_reasoning": multi_step_reasoning,
                "auto_agent_routing": auto_agent_routing,
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self,
        *,
        query: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = OMIT,
        max_chunks: typing.Optional[int] = OMIT,
        mode: typing.Optional[RetrieveMode] = OMIT,
        alpha: typing.Optional[Alpha] = OMIT,
        recency_bias: typing.Optional[float] = OMIT,
        personalise_search: typing.Optional[bool] = OMIT,
        graph_context: typing.Optional[bool] = OMIT,
        extra_context: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RetrieveResponse]:
        """
        Search for relevant content within your indexed sources.

        This API returns the chunks related to the query you make. We use neural (embedding) search to give you the most relevant chunks.
        Results are ranked by relevance and can be customized with parameters like result limits and recency preferences.

        Parameters
        ----------
        query : str
            Search terms to find relevant content

        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        max_chunks : typing.Optional[int]
            Maximum number of results to return

        mode : typing.Optional[RetrieveMode]
            Retrieval mode to use ('fast' or 'accurate')

        alpha : typing.Optional[Alpha]
            Search ranking algorithm parameter (0.0-1.0 or 'auto')

        recency_bias : typing.Optional[float]
            Preference for newer content (0.0 = no bias, 1.0 = strong recency preference)

        personalise_search : typing.Optional[bool]
            Enable personalized search results based on user preferences

        graph_context : typing.Optional[bool]
            Enable graph context for search results

        extra_context : typing.Optional[str]
            Additional context provided by the user to guide retrieval

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RetrieveResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "search/retrieve",
            method="POST",
            json={
                "query": query,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "max_chunks": max_chunks,
                "mode": mode,
                "alpha": convert_and_respect_annotation_metadata(object_=alpha, annotation=Alpha, direction="write"),
                "recency_bias": recency_bias,
                "personalise_search": personalise_search,
                "graph_context": graph_context,
                "extra_context": extra_context,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrieveResponse,
                    parse_obj_as(
                        type_=RetrieveResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def full_text_search(
        self,
        *,
        query: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = OMIT,
        operator: typing.Optional[Bm25OperatorType] = OMIT,
        max_chunks: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[SearchChunk]]:
        """
        Perform full text search for exact matches within your indexed sources.

        Use this endpoint to find content chunks using BM25-based text matching with configurable operators.
        Choose between 'OR' and 'AND' operators to control how search terms are combined for precise text matching.

        Parameters
        ----------
        query : str
            Search terms to find in your content

        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        operator : typing.Optional[Bm25OperatorType]
            How to combine search terms (OR or AND)

        max_chunks : typing.Optional[int]
            Maximum number of results to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[SearchChunk]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "search/full-text-search",
            method="POST",
            json={
                "query": query,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "operator": operator,
                "max_chunks": max_chunks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SearchChunk],
                    parse_obj_as(
                        type_=typing.List[SearchChunk],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawSearchClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def qna(
        self,
        *,
        question: str,
        session_id: str,
        tenant_id: str,
        context_list: typing.Optional[typing.Sequence[str]] = OMIT,
        search_modes: typing.Optional[typing.Sequence[str]] = OMIT,
        sub_tenant_id: typing.Optional[str] = OMIT,
        highlight_chunks: typing.Optional[bool] = OMIT,
        stream: typing.Optional[bool] = OMIT,
        search_alpha: typing.Optional[float] = OMIT,
        recency_bias: typing.Optional[float] = OMIT,
        ai_generation: typing.Optional[bool] = OMIT,
        top_n: typing.Optional[int] = OMIT,
        user_name: typing.Optional[str] = OMIT,
        user_instructions: typing.Optional[str] = OMIT,
        multi_step_reasoning: typing.Optional[bool] = OMIT,
        auto_agent_routing: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Ask a question to your uploaded knowledge base and let Cortex AI answer it.

        Parameters
        ----------
        question : str
            The question to be answered

        session_id : str
            Unique identifier for the conversation session. Keep it same when the current question refers to a previous answer or question

        tenant_id : str
            Identifier for the tenant/organization

        context_list : typing.Optional[typing.Sequence[str]]
            List of context strings to provide additional information

        search_modes : typing.Optional[typing.Sequence[str]]
            List of search modes to use for finding relevant information

        sub_tenant_id : typing.Optional[str]
            Identifier for sub-tenant within the tenant

        highlight_chunks : typing.Optional[bool]
            Whether to return text chunks in the response along with final LLM generated answer

        stream : typing.Optional[bool]
            Whether to stream the response

        search_alpha : typing.Optional[float]
            Closer to 0.0 means a exact keyword search will be performed, closer to 1.0 means semantics of the search will be considered. In most cases, you wont have to toggle it yourself.

        recency_bias : typing.Optional[float]
            Bias towards more recent information (0.0 to 1.0)

        ai_generation : typing.Optional[bool]
            Whether to use AI for generating responses

        top_n : typing.Optional[int]
            Number of top results to return

        user_name : typing.Optional[str]
            Name of the user making the request. This helps LLM to know the user's name if semantics around the username are involved in query. Its generally a good practice to include it possible.

        user_instructions : typing.Optional[str]
            Custom instructions for the AI response to add to our proprietary prompt. This can be used to provide additional context or instructions for the LLM to follow so that the answers are tailored towards your application style

        multi_step_reasoning : typing.Optional[bool]
            Enable advanced multi-step reasoning for complex queries. When enabled, the AI will automatically break down complex questions into multiple research steps to provide more comprehensive and accurate answers.

        auto_agent_routing : typing.Optional[bool]
            Enable intelligent agent routing to automatically select the most suitable AI agent for your specific query type. Different agents are optimized for various use cases like social media, code, conversations, general knowledge, etc.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Additional metadata for the request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "search/qna",
            method="POST",
            json={
                "question": question,
                "session_id": session_id,
                "tenant_id": tenant_id,
                "context_list": context_list,
                "search_modes": search_modes,
                "sub_tenant_id": sub_tenant_id,
                "highlight_chunks": highlight_chunks,
                "stream": stream,
                "search_alpha": search_alpha,
                "recency_bias": recency_bias,
                "ai_generation": ai_generation,
                "top_n": top_n,
                "user_name": user_name,
                "user_instructions": user_instructions,
                "multi_step_reasoning": multi_step_reasoning,
                "auto_agent_routing": auto_agent_routing,
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self,
        *,
        query: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = OMIT,
        max_chunks: typing.Optional[int] = OMIT,
        mode: typing.Optional[RetrieveMode] = OMIT,
        alpha: typing.Optional[Alpha] = OMIT,
        recency_bias: typing.Optional[float] = OMIT,
        personalise_search: typing.Optional[bool] = OMIT,
        graph_context: typing.Optional[bool] = OMIT,
        extra_context: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RetrieveResponse]:
        """
        Search for relevant content within your indexed sources.

        This API returns the chunks related to the query you make. We use neural (embedding) search to give you the most relevant chunks.
        Results are ranked by relevance and can be customized with parameters like result limits and recency preferences.

        Parameters
        ----------
        query : str
            Search terms to find relevant content

        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        max_chunks : typing.Optional[int]
            Maximum number of results to return

        mode : typing.Optional[RetrieveMode]
            Retrieval mode to use ('fast' or 'accurate')

        alpha : typing.Optional[Alpha]
            Search ranking algorithm parameter (0.0-1.0 or 'auto')

        recency_bias : typing.Optional[float]
            Preference for newer content (0.0 = no bias, 1.0 = strong recency preference)

        personalise_search : typing.Optional[bool]
            Enable personalized search results based on user preferences

        graph_context : typing.Optional[bool]
            Enable graph context for search results

        extra_context : typing.Optional[str]
            Additional context provided by the user to guide retrieval

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RetrieveResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "search/retrieve",
            method="POST",
            json={
                "query": query,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "max_chunks": max_chunks,
                "mode": mode,
                "alpha": convert_and_respect_annotation_metadata(object_=alpha, annotation=Alpha, direction="write"),
                "recency_bias": recency_bias,
                "personalise_search": personalise_search,
                "graph_context": graph_context,
                "extra_context": extra_context,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrieveResponse,
                    parse_obj_as(
                        type_=RetrieveResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def full_text_search(
        self,
        *,
        query: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = OMIT,
        operator: typing.Optional[Bm25OperatorType] = OMIT,
        max_chunks: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[SearchChunk]]:
        """
        Perform full text search for exact matches within your indexed sources.

        Use this endpoint to find content chunks using BM25-based text matching with configurable operators.
        Choose between 'OR' and 'AND' operators to control how search terms are combined for precise text matching.

        Parameters
        ----------
        query : str
            Search terms to find in your content

        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        operator : typing.Optional[Bm25OperatorType]
            How to combine search terms (OR or AND)

        max_chunks : typing.Optional[int]
            Maximum number of results to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[SearchChunk]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "search/full-text-search",
            method="POST",
            json={
                "query": query,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "operator": operator,
                "max_chunks": max_chunks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SearchChunk],
                    parse_obj_as(
                        type_=typing.List[SearchChunk],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
