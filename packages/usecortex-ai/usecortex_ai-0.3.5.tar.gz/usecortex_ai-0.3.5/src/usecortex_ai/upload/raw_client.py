# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from .. import core
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.service_unavailable_error import ServiceUnavailableError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.actual_error_response import ActualErrorResponse
from ..types.app_sources_upload_data import AppSourcesUploadData
from ..types.batch_upload_data import BatchUploadData
from ..types.markdown_upload_request import MarkdownUploadRequest
from ..types.processing_status import ProcessingStatus
from ..types.single_upload_data import SingleUploadData
from ..types.source_model import SourceModel
from ..types.webpage_scrape_request import WebpageScrapeRequest

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawUploadClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def batch_upload(
        self,
        *,
        tenant_id: str,
        files: typing.List[core.File],
        sub_tenant_id: typing.Optional[str] = None,
        file_ids: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchUploadData]:
        """
        Upload multiple documents simultaneously for efficient bulk processing.

        This endpoint allows you to upload several files at once, which is ideal for large document collections or periodic data imports. Each file gets processed asynchronously, and you can track the progress of individual files using their returned file IDs.

        The system automatically handles file parsing, content extraction, and indexing across all uploaded documents. You'll receive confirmation once all files are queued for processing.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        files : typing.List[core.File]
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_ids : typing.Optional[str]
            Optional JSON string array of file IDs for the uploaded content. If not provided or empty, will be generated automatically.

        tenant_metadata : typing.Optional[str]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"


        document_metadata : typing.Optional[str]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"



        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/batch_upload",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={
                "file_ids": file_ids,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def batch_update(
        self,
        *,
        tenant_id: str,
        files: typing.List[core.File],
        sub_tenant_id: typing.Optional[str] = None,
        source_ids: typing.Optional[typing.List[str]] = OMIT,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchUploadData]:
        """
        Update multiple existing documents with new content and metadata.

        Use this endpoint when you need to replace or modify several documents that are already in your knowledge base. Each file must correspond to an existing source ID, ensuring that updates are applied to the correct documents.

        The system processes updates asynchronously, allowing you to continue working while your documents are re-indexed. Track the progress using the returned file IDs to know when updates are complete.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        files : typing.List[core.File]
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        source_ids : typing.Optional[typing.List[str]]
            List of source IDs corresponding to the files being updated

        tenant_metadata : typing.Optional[str]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"


        document_metadata : typing.Optional[str]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"



        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/batch_update",
            method="PATCH",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={
                "source_ids": source_ids,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_document(
        self,
        *,
        tenant_id: str,
        file: core.File,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Upload a single document for processing and indexing into your knowledge base.

        This endpoint accepts documents in various formats and processes them for search and retrieval. You can include custom metadata to help organize and categorize your content.

        The system extracts text content, processes it asynchronously, and makes it available for search queries. You can track the processing status using the returned file ID.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        file : core.File
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[str]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"


        document_metadata : typing.Optional[str]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"



        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/upload_document",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_document(
        self,
        *,
        source_id: str,
        tenant_id: str,
        file: core.File,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Replace an existing document with updated content.

        This endpoint allows you to update a specific document that's already in your knowledge base. Provide the source ID of the document you want to modify, along with the new file content.

        The system will process your update asynchronously and re-index the document with the new content. You can monitor the progress using the returned file ID.

        Parameters
        ----------
        source_id : str
            The source ID of the document to update

        tenant_id : str
            Unique identifier for the tenant/organization

        file : core.File
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        tenant_metadata : typing.Optional[str]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"


        document_metadata : typing.Optional[str]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"



        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/update_document",
            method="PATCH",
            params={
                "source_id": source_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_app_sources(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[SourceModel],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AppSourcesUploadData]:
        """
        Upload structured data from applications or APIs for indexing.

        This endpoint is designed for importing data from applications. If you are specifically using Cortex to provide search to an application, you should prefer this endpoint. It accepts structured source objects and allows you to clearly define contents of attachments

        The system processes each source asynchronously and makes the content available for search and retrieval. Use this when you need to integrate search and indexing from data in your applications into your knowledge base.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        request : typing.Sequence[SourceModel]

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AppSourcesUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/upload_app_sources",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[SourceModel], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AppSourcesUploadData,
                    parse_obj_as(
                        type_=AppSourcesUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_markdown(
        self,
        *,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Upload text or markdown content directly for processing.

        This endpoint accepts plain text or markdown-formatted content that you want to add to your knowledge base. It's perfect for notes, documentation, articles, or any text-based content you want to make searchable.

        You can include custom metadata to help organize and categorize your content. You can track the processing status using the returned file ID.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        content : str
            The text or markdown content to upload

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/upload_markdown",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "content": content,
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_text(
        self,
        *,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Upload text or markdown content directly for processing.

        This endpoint accepts plain text or markdown-formatted content that you want to add to your knowledge base. It's perfect for notes, documentation, articles, or any text-based content you want to make searchable.

        You can include custom metadata to help organize and categorize your content. You can track the processing status using the returned file ID.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        content : str
            The text or markdown content to upload

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/upload_text",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "content": content,
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_markdown(
        self,
        *,
        source_id: str,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Update existing text or markdown content with new information.

        This endpoint allows you to modify text or markdown content that's already in your knowledge base. Provide the source ID of the content you want to update, along with the new text.

        The system will reprocess and re-index the updated content asynchronously. Use this when you need to correct information, add details, or refresh existing documentation.

        Parameters
        ----------
        source_id : str
            The source ID of the document to update

        tenant_id : str
            Unique identifier for the tenant/organization

        content : str
            The text or markdown content to upload

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/update_markdown",
            method="PATCH",
            params={
                "source_id": source_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "content": content,
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_text(
        self,
        *,
        source_id: str,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Update existing text or markdown content with new information.

        This endpoint allows you to modify text or markdown content that's already in your knowledge base. Provide the source ID of the content you want to update, along with the new text.

        The system will reprocess and re-index the updated content asynchronously. Use this when you need to correct information, add details, or refresh existing documentation.

        Parameters
        ----------
        source_id : str
            The source ID of the document to update

        tenant_id : str
            Unique identifier for the tenant/organization

        content : str
            The text or markdown content to upload

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/update_text",
            method="PATCH",
            params={
                "source_id": source_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "content": content,
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def batch_upload_markdown(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[MarkdownUploadRequest],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchUploadData]:
        """
        Upload multiple markdown/text documents simultaneously for efficient bulk processing.

        This endpoint allows you to upload several markdown or text contents at once. Each content item gets processed asynchronously, and you can track the progress using their returned file IDs.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        request : typing.Sequence[MarkdownUploadRequest]

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/batch_upload_markdown",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[MarkdownUploadRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def batch_upload_text(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[MarkdownUploadRequest],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchUploadData]:
        """
        Upload multiple markdown/text documents simultaneously for efficient bulk processing.

        This endpoint allows you to upload several markdown or text contents at once. Each content item gets processed asynchronously, and you can track the progress using their returned file IDs.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        request : typing.Sequence[MarkdownUploadRequest]

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/batch_upload_text",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[MarkdownUploadRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def upload_embeddings(
        self,
        *,
        tenant_id: str,
        embeddings: typing.Sequence[typing.Sequence[float]],
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Upload pre-computed embeddings for advanced similarity search.

        This endpoint accepts vector embeddings that you've generated externally, allowing you to integrate with custom embedding models or existing vector databases. The embeddings represent chunks of your content as numerical vectors.

        The system stores these embeddings and makes them available for semantic search and similarity matching. Use this when you want to leverage specialized embedding models or have existing vector representations.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        embeddings : typing.Sequence[typing.Sequence[float]]
            The embeddings of source you want to index

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            The Source ID of the target source you want to index

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/upload_embeddings",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "embeddings": embeddings,
                "file_id": file_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_embeddings(
        self,
        *,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        embeddings: typing.Optional[typing.Dict[str, typing.Sequence[float]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Update existing embeddings with new vector representations.

        This endpoint allows you to modify embeddings that are already stored in your knowledge base. Provide updated vector representations for specific chunks of content, identified by their chunk IDs.

        The system will replace the existing embeddings with your new ones, ensuring that similarity searches reflect the most current vector representations. Use this when you need to update embeddings due to model improvements or content changes.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        embeddings : typing.Optional[typing.Dict[str, typing.Sequence[float]]]
            The embeddings of source you want to index

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/update_embeddings",
            method="PATCH",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "embeddings": embeddings,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def scrape_webpage(
        self,
        *,
        web_url: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Extract and index content from web pages automatically.

        This endpoint initiates web scraping for the specified URL, extracting the main content, text, and structure from the webpage. It's perfect for capturing articles, documentation, or any web content you want to include in your knowledge base.

        The system processes the webpage content asynchronously, cleaning and structuring the information for optimal search and retrieval. Use this when you need to add web content without manual copying and pasting.

        Parameters
        ----------
        web_url : str
            The URL of the webpage to scrape and index

        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional custom file ID for the scraped content. If not provided, a unique ID will be generated

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/scrape_webpage",
            method="POST",
            params={
                "web_url": web_url,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "file_id": file_id,
            },
            data={},
            headers={
                "content-type": "application/x-www-form-urlencoded",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_webpage(
        self,
        *,
        web_url: str,
        source_id: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SingleUploadData]:
        """
        Update web scraping content with fresh data from the source URL.

        This endpoint refreshes the content for an existing web scraping job. Provide the source ID of the webpage content you want to update, and the system will re-scrape the URL to capture any changes.

        The updated content gets processed asynchronously and re-indexed in your knowledge base. Use this to keep web content current when the source pages are frequently updated.

        Parameters
        ----------
        web_url : str
            The URL of the webpage to re-scrape

        source_id : str
            The file ID of the existing web scraping job to update

        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SingleUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/update_webpage",
            method="PATCH",
            params={
                "web_url": web_url,
                "source_id": source_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={},
            headers={
                "content-type": "application/x-www-form-urlencoded",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def batch_scrape_webpage(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[WebpageScrapeRequest],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchUploadData]:
        """
        Extract and index content from multiple web pages simultaneously.

        This endpoint initiates web scraping for multiple URLs at once, extracting the main content, text, and structure from each webpage. It's perfect for capturing multiple articles, documentation pages, or any web content you want to include in your knowledge base.

        The system processes all webpage content asynchronously, cleaning and structuring the information for optimal search and retrieval.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        request : typing.Sequence[WebpageScrapeRequest]

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchUploadData]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/batch_scrape_webpage",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[WebpageScrapeRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_source(
        self,
        *,
        tenant_id: str,
        source_ids: typing.Sequence[str],
        sub_tenant_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Remove documents and content from your knowledge base.

        This endpoint permanently deletes the specified sources from your knowledge base. Once deleted, the content will no longer be available for search or retrieval.

        Use this carefully as the action cannot be undone. The system will confirm successful deletion of each source ID you specify.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        source_ids : typing.Sequence[str]
            List of source IDs to delete

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/delete_source",
            method="DELETE",
            json={
                "tenant_id": tenant_id,
                "source_ids": source_ids,
                "sub_tenant_id": sub_tenant_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_memory(
        self,
        *,
        tenant_id: str,
        source_ids: typing.Sequence[str],
        sub_tenant_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Remove documents and content from your knowledge base.

        This endpoint permanently deletes the specified sources from your knowledge base. Once deleted, the content will no longer be available for search or retrieval.

        Use this carefully as the action cannot be undone. The system will confirm successful deletion of each source ID you specify.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        source_ids : typing.Sequence[str]
            List of source IDs to delete

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/delete_memory",
            method="DELETE",
            json={
                "tenant_id": tenant_id,
                "source_ids": source_ids,
                "sub_tenant_id": sub_tenant_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def verify_processing(
        self,
        *,
        file_id: str,
        tenant_id: typing.Optional[str] = None,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ProcessingStatus]:
        """
        Check the current processing status of your uploaded content.

        This endpoint allows you to monitor the progress of documents, text, or other content you've uploaded. Simply provide the file ID to see whether processing is complete, still in progress, or if any errors occurred.

        Use this to determine when your content is ready for search and retrieval, or to troubleshoot any processing issues.

        Parameters
        ----------
        file_id : str
            The file ID to check processing status for

        tenant_id : typing.Optional[str]
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ProcessingStatus]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "upload/verify_processing",
            method="POST",
            params={
                "file_id": file_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProcessingStatus,
                    parse_obj_as(
                        type_=ProcessingStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawUploadClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def batch_upload(
        self,
        *,
        tenant_id: str,
        files: typing.List[core.File],
        sub_tenant_id: typing.Optional[str] = None,
        file_ids: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchUploadData]:
        """
        Upload multiple documents simultaneously for efficient bulk processing.

        This endpoint allows you to upload several files at once, which is ideal for large document collections or periodic data imports. Each file gets processed asynchronously, and you can track the progress of individual files using their returned file IDs.

        The system automatically handles file parsing, content extraction, and indexing across all uploaded documents. You'll receive confirmation once all files are queued for processing.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        files : typing.List[core.File]
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_ids : typing.Optional[str]
            Optional JSON string array of file IDs for the uploaded content. If not provided or empty, will be generated automatically.

        tenant_metadata : typing.Optional[str]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"


        document_metadata : typing.Optional[str]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"



        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/batch_upload",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={
                "file_ids": file_ids,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def batch_update(
        self,
        *,
        tenant_id: str,
        files: typing.List[core.File],
        sub_tenant_id: typing.Optional[str] = None,
        source_ids: typing.Optional[typing.List[str]] = OMIT,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchUploadData]:
        """
        Update multiple existing documents with new content and metadata.

        Use this endpoint when you need to replace or modify several documents that are already in your knowledge base. Each file must correspond to an existing source ID, ensuring that updates are applied to the correct documents.

        The system processes updates asynchronously, allowing you to continue working while your documents are re-indexed. Track the progress using the returned file IDs to know when updates are complete.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        files : typing.List[core.File]
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        source_ids : typing.Optional[typing.List[str]]
            List of source IDs corresponding to the files being updated

        tenant_metadata : typing.Optional[str]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"


        document_metadata : typing.Optional[str]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"



        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/batch_update",
            method="PATCH",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={
                "source_ids": source_ids,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            files={
                "files": files,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_document(
        self,
        *,
        tenant_id: str,
        file: core.File,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Upload a single document for processing and indexing into your knowledge base.

        This endpoint accepts documents in various formats and processes them for search and retrieval. You can include custom metadata to help organize and categorize your content.

        The system extracts text content, processes it asynchronously, and makes it available for search queries. You can track the processing status using the returned file ID.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        file : core.File
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[str]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"


        document_metadata : typing.Optional[str]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"



        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/upload_document",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_document(
        self,
        *,
        source_id: str,
        tenant_id: str,
        file: core.File,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Replace an existing document with updated content.

        This endpoint allows you to update a specific document that's already in your knowledge base. Provide the source ID of the document you want to modify, along with the new file content.

        The system will process your update asynchronously and re-index the document with the new content. You can monitor the progress using the returned file ID.

        Parameters
        ----------
        source_id : str
            The source ID of the document to update

        tenant_id : str
            Unique identifier for the tenant/organization

        file : core.File
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        tenant_metadata : typing.Optional[str]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"


        document_metadata : typing.Optional[str]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"



        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/update_document",
            method="PATCH",
            params={
                "source_id": source_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_app_sources(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[SourceModel],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AppSourcesUploadData]:
        """
        Upload structured data from applications or APIs for indexing.

        This endpoint is designed for importing data from applications. If you are specifically using Cortex to provide search to an application, you should prefer this endpoint. It accepts structured source objects and allows you to clearly define contents of attachments

        The system processes each source asynchronously and makes the content available for search and retrieval. Use this when you need to integrate search and indexing from data in your applications into your knowledge base.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        request : typing.Sequence[SourceModel]

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AppSourcesUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/upload_app_sources",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[SourceModel], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AppSourcesUploadData,
                    parse_obj_as(
                        type_=AppSourcesUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_markdown(
        self,
        *,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Upload text or markdown content directly for processing.

        This endpoint accepts plain text or markdown-formatted content that you want to add to your knowledge base. It's perfect for notes, documentation, articles, or any text-based content you want to make searchable.

        You can include custom metadata to help organize and categorize your content. You can track the processing status using the returned file ID.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        content : str
            The text or markdown content to upload

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/upload_markdown",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "content": content,
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_text(
        self,
        *,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Upload text or markdown content directly for processing.

        This endpoint accepts plain text or markdown-formatted content that you want to add to your knowledge base. It's perfect for notes, documentation, articles, or any text-based content you want to make searchable.

        You can include custom metadata to help organize and categorize your content. You can track the processing status using the returned file ID.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        content : str
            The text or markdown content to upload

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/upload_text",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "content": content,
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_markdown(
        self,
        *,
        source_id: str,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Update existing text or markdown content with new information.

        This endpoint allows you to modify text or markdown content that's already in your knowledge base. Provide the source ID of the content you want to update, along with the new text.

        The system will reprocess and re-index the updated content asynchronously. Use this when you need to correct information, add details, or refresh existing documentation.

        Parameters
        ----------
        source_id : str
            The source ID of the document to update

        tenant_id : str
            Unique identifier for the tenant/organization

        content : str
            The text or markdown content to upload

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/update_markdown",
            method="PATCH",
            params={
                "source_id": source_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "content": content,
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_text(
        self,
        *,
        source_id: str,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Update existing text or markdown content with new information.

        This endpoint allows you to modify text or markdown content that's already in your knowledge base. Provide the source ID of the content you want to update, along with the new text.

        The system will reprocess and re-index the updated content asynchronously. Use this when you need to correct information, add details, or refresh existing documentation.

        Parameters
        ----------
        source_id : str
            The source ID of the document to update

        tenant_id : str
            Unique identifier for the tenant/organization

        content : str
            The text or markdown content to upload

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional file ID for the uploaded content. If not provided, will be generated automatically.

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing tenant-level document metadata (e.g., department, compliance_tag)

            Example: > "{"department":"Finance","compliance_tag":"GDPR"}"

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            JSON string containing document-specific metadata (e.g., title, author, file_id). If file_id is not provided, the system will generate an ID automatically.

            Example: > "{"title":"Q1 Report.pdf","author":"Alice Smith","file_id":"custom_file_123"}"


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/update_text",
            method="PATCH",
            params={
                "source_id": source_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "content": content,
                "file_id": file_id,
                "tenant_metadata": tenant_metadata,
                "document_metadata": document_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def batch_upload_markdown(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[MarkdownUploadRequest],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchUploadData]:
        """
        Upload multiple markdown/text documents simultaneously for efficient bulk processing.

        This endpoint allows you to upload several markdown or text contents at once. Each content item gets processed asynchronously, and you can track the progress using their returned file IDs.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        request : typing.Sequence[MarkdownUploadRequest]

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/batch_upload_markdown",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[MarkdownUploadRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def batch_upload_text(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[MarkdownUploadRequest],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchUploadData]:
        """
        Upload multiple markdown/text documents simultaneously for efficient bulk processing.

        This endpoint allows you to upload several markdown or text contents at once. Each content item gets processed asynchronously, and you can track the progress using their returned file IDs.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        request : typing.Sequence[MarkdownUploadRequest]

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/batch_upload_text",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[MarkdownUploadRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def upload_embeddings(
        self,
        *,
        tenant_id: str,
        embeddings: typing.Sequence[typing.Sequence[float]],
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Upload pre-computed embeddings for advanced similarity search.

        This endpoint accepts vector embeddings that you've generated externally, allowing you to integrate with custom embedding models or existing vector databases. The embeddings represent chunks of your content as numerical vectors.

        The system stores these embeddings and makes them available for semantic search and similarity matching. Use this when you want to leverage specialized embedding models or have existing vector representations.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        embeddings : typing.Sequence[typing.Sequence[float]]
            The embeddings of source you want to index

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            The Source ID of the target source you want to index

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/upload_embeddings",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "embeddings": embeddings,
                "file_id": file_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_embeddings(
        self,
        *,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        embeddings: typing.Optional[typing.Dict[str, typing.Sequence[float]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Update existing embeddings with new vector representations.

        This endpoint allows you to modify embeddings that are already stored in your knowledge base. Provide updated vector representations for specific chunks of content, identified by their chunk IDs.

        The system will replace the existing embeddings with your new ones, ensuring that similarity searches reflect the most current vector representations. Use this when you need to update embeddings due to model improvements or content changes.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        embeddings : typing.Optional[typing.Dict[str, typing.Sequence[float]]]
            The embeddings of source you want to index

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/update_embeddings",
            method="PATCH",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "embeddings": embeddings,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def scrape_webpage(
        self,
        *,
        web_url: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Extract and index content from web pages automatically.

        This endpoint initiates web scraping for the specified URL, extracting the main content, text, and structure from the webpage. It's perfect for capturing articles, documentation, or any web content you want to include in your knowledge base.

        The system processes the webpage content asynchronously, cleaning and structuring the information for optimal search and retrieval. Use this when you need to add web content without manual copying and pasting.

        Parameters
        ----------
        web_url : str
            The URL of the webpage to scrape and index

        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        file_id : typing.Optional[str]
            Optional custom file ID for the scraped content. If not provided, a unique ID will be generated

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/scrape_webpage",
            method="POST",
            params={
                "web_url": web_url,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "file_id": file_id,
            },
            data={},
            headers={
                "content-type": "application/x-www-form-urlencoded",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_webpage(
        self,
        *,
        web_url: str,
        source_id: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SingleUploadData]:
        """
        Update web scraping content with fresh data from the source URL.

        This endpoint refreshes the content for an existing web scraping job. Provide the source ID of the webpage content you want to update, and the system will re-scrape the URL to capture any changes.

        The updated content gets processed asynchronously and re-indexed in your knowledge base. Use this to keep web content current when the source pages are frequently updated.

        Parameters
        ----------
        web_url : str
            The URL of the webpage to re-scrape

        source_id : str
            The file ID of the existing web scraping job to update

        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SingleUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/update_webpage",
            method="PATCH",
            params={
                "web_url": web_url,
                "source_id": source_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            data={},
            headers={
                "content-type": "application/x-www-form-urlencoded",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SingleUploadData,
                    parse_obj_as(
                        type_=SingleUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def batch_scrape_webpage(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[WebpageScrapeRequest],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchUploadData]:
        """
        Extract and index content from multiple web pages simultaneously.

        This endpoint initiates web scraping for multiple URLs at once, extracting the main content, text, and structure from each webpage. It's perfect for capturing multiple articles, documentation pages, or any web content you want to include in your knowledge base.

        The system processes all webpage content asynchronously, cleaning and structuring the information for optimal search and retrieval.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        request : typing.Sequence[WebpageScrapeRequest]

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchUploadData]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/batch_scrape_webpage",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[WebpageScrapeRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUploadData,
                    parse_obj_as(
                        type_=BatchUploadData,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_source(
        self,
        *,
        tenant_id: str,
        source_ids: typing.Sequence[str],
        sub_tenant_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Remove documents and content from your knowledge base.

        This endpoint permanently deletes the specified sources from your knowledge base. Once deleted, the content will no longer be available for search or retrieval.

        Use this carefully as the action cannot be undone. The system will confirm successful deletion of each source ID you specify.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        source_ids : typing.Sequence[str]
            List of source IDs to delete

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/delete_source",
            method="DELETE",
            json={
                "tenant_id": tenant_id,
                "source_ids": source_ids,
                "sub_tenant_id": sub_tenant_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_memory(
        self,
        *,
        tenant_id: str,
        source_ids: typing.Sequence[str],
        sub_tenant_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Remove documents and content from your knowledge base.

        This endpoint permanently deletes the specified sources from your knowledge base. Once deleted, the content will no longer be available for search or retrieval.

        Use this carefully as the action cannot be undone. The system will confirm successful deletion of each source ID you specify.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        source_ids : typing.Sequence[str]
            List of source IDs to delete

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/delete_memory",
            method="DELETE",
            json={
                "tenant_id": tenant_id,
                "source_ids": source_ids,
                "sub_tenant_id": sub_tenant_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def verify_processing(
        self,
        *,
        file_id: str,
        tenant_id: typing.Optional[str] = None,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ProcessingStatus]:
        """
        Check the current processing status of your uploaded content.

        This endpoint allows you to monitor the progress of documents, text, or other content you've uploaded. Simply provide the file ID to see whether processing is complete, still in progress, or if any errors occurred.

        Use this to determine when your content is ready for search and retrieval, or to troubleshoot any processing issues.

        Parameters
        ----------
        file_id : str
            The file ID to check processing status for

        tenant_id : typing.Optional[str]
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ProcessingStatus]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "upload/verify_processing",
            method="POST",
            params={
                "file_id": file_id,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProcessingStatus,
                    parse_obj_as(
                        type_=ProcessingStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
