Metadata-Version: 2.4
Name: kbbqgraph
Version: 0.1.0
Summary: Fast low-level graph utilities for metabolomics pipelines (BBQGraph)
Author-email: Daniel Hitchcock <daniel.s.hitchcock@gmail.com>
License: MIT License
        
        Copyright (c) 2025 Daniel Hitchcock
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.
Project-URL: Repository, https://github.com/broadinstitute/kbbqgraph
Keywords: graph,metabolomics,ctypes,bbqgraph
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: C
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Operating System :: OS Independent
Classifier: License :: OSI Approved :: MIT License
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy
Dynamic: license-file

<h1>KBBQGraph - Barebones and Quick for k-partite graphs</h1>

This is a WIP for a memory-efficient replacement for NetworkX for a specific application.

I work with k-partite graphs when matching datasets, where each dataset is a partite. Most immediately, I need to handle 100s of partites each with 10,000's of nodes, and ~5,000 directed edges connecting each partite set. This quickly saturates NetworkX.

I also need efficient indexing based on partite number and feature number -- this is not offered by any other graphing library.

Someday, I would like to add some very specific homegrown k-partite clustering algorithms. These also assume one-to-one constraints when compressed to undirected, i.e. at most a node _u_ from partite _i_ can only be connected to one node from partite _j_.

License - Free to distribute and use as long as credit to the developers is given.
Also, if you make something better, please tell me.

In addition to the basic usage below, check out `compress`, `weakly_connected_components` and `find_cliques`.

```python
import networkx as nx
from kbbqgraph import KBBQGraph

# ------------------------------------------------------------
# Create a new graph
# ------------------------------------------------------------
g = KBBQGraph(isDiGraph=0, preAllocate=10, name="example")

# ------------------------------------------------------------
# Add nodes
# ------------------------------------------------------------
# Add nodes to “dataset/partite 0”
g.add_nodes(0, [0, 1, 2])

# Add nodes to “dataset/partite 1”
g.add_nodes(1, [0, 1])

# ------------------------------------------------------------
# Add edges (batched)
# ------------------------------------------------------------
# Each node is a (dataset, id) tuple, i.e. (partite, local_index)
source_nodes = [
    (0, 0),  # node 0 in dataset 0
    (0, 2),  # node 2 in dataset 0
]

target_nodes = [
    (1, 1),  # node 1 in dataset 1
    (1, 0),  # node 0 in dataset 1
]

weights = [1.0, 0.5]  # optional; can also pass None

g.add_edges(
    source_nodes=source_nodes,
    target_nodes=target_nodes,
    weights=weights,
    check_duplicates=True,
)

print("Nodes:", g.num_nodes)
print("Edges:", g.num_edges)

# ------------------------------------------------------------
# Convert to NetworkX
# ------------------------------------------------------------
nx_graph = g.to_networkx()

print("NetworkX edges (u, v, data):")
for u, v, data in nx_graph.edges(data=True):
    print(u, "→", v, "weight=", data.get("weight"))

```
