import os
from typing import (
    Annotated,
    Iterable,
    Iterator,
    Optional,
    Sequence,
    Tuple,
    Union,
    overload
)

import numpy
from numpy.typing import NDArray


class Tick:
    def __init__(self) -> None: ...

    def __repr__(self) -> str: ...

    def is_time_unit(self) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __eq__(self, arg: object, /) -> bool: ...

class Quarter:
    def __init__(self) -> None: ...

    def __repr__(self) -> str: ...

    def is_time_unit(self) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __eq__(self, arg: object, /) -> bool: ...

class Second:
    def __init__(self) -> None: ...

    def __repr__(self) -> str: ...

    def is_time_unit(self) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __eq__(self, arg: object, /) -> bool: ...

class NoteTick:
    @overload
    def __init__(self, other: NoteTick) -> None: ...

    @overload
    def __init__(self, time: int, duration: int, pitch: int, velocity: int = 0) -> None: ...

    @property
    def time(self) -> int: ...

    @time.setter
    def time(self, arg: int, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> NoteTick:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> NoteTick: ...

    def __copy__(self) -> NoteTick: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> NoteTick: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: NoteTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: NoteTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: NoteTick, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def start(self) -> int: ...

    @start.setter
    def start(self, arg: int, /) -> None: ...

    @property
    def duration(self) -> int: ...

    @duration.setter
    def duration(self, arg: int, /) -> None: ...

    @property
    def pitch(self) -> int: ...

    @pitch.setter
    def pitch(self, arg: int, /) -> None: ...

    @property
    def velocity(self) -> int: ...

    @velocity.setter
    def velocity(self, arg: int, /) -> None: ...

    @property
    def end(self) -> int: ...

    @end.setter
    def end(self, arg: int, /) -> None: ...

    def empty(self) -> bool: ...

    def ent_time(self) -> int: ...

    def shift_pitch(self, offset: int, inplace: bool = False) -> NoteTick:
        """Shift the pitch by offset"""

    def shift_velocity(self, offset: int, inplace: bool = False) -> NoteTick:
        """Shift the velocity by offset"""

class NoteTickList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: NoteTickList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[NoteTick], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[NoteTick]: ...

    @overload
    def __getitem__(self, arg: int, /) -> NoteTick: ...

    @overload
    def __getitem__(self, arg: slice, /) -> NoteTickList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: NoteTick, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: NoteTick, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> NoteTick:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: NoteTickList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: NoteTick, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: NoteTickList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> NoteTickList: ...

    def __copy__(self, deep: bool = True) -> NoteTickList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> NoteTickList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: NoteTickList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: NoteTickList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: NoteTick, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: NoteTick, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: NoteTick, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Tick: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> NoteTickList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> NoteTickList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> NoteTickList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.int8], dict(shape=(None,), order='C', device='cpu')], arg3: Annotated[NDArray[numpy.int8], dict(shape=(None,), order='C', device='cpu')], /) -> NoteTickList: ...

class NoteQuarter:
    @overload
    def __init__(self, other: NoteQuarter) -> None: ...

    @overload
    def __init__(self, time: float, duration: float, pitch: int, velocity: int = 0) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> NoteQuarter:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> NoteQuarter: ...

    def __copy__(self) -> NoteQuarter: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> NoteQuarter: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: NoteQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: NoteQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: NoteQuarter, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def start(self) -> float: ...

    @start.setter
    def start(self, arg: float, /) -> None: ...

    @property
    def duration(self) -> float: ...

    @duration.setter
    def duration(self, arg: float, /) -> None: ...

    @property
    def pitch(self) -> int: ...

    @pitch.setter
    def pitch(self, arg: int, /) -> None: ...

    @property
    def velocity(self) -> int: ...

    @velocity.setter
    def velocity(self, arg: int, /) -> None: ...

    @property
    def end(self) -> float: ...

    @end.setter
    def end(self, arg: float, /) -> None: ...

    def empty(self) -> bool: ...

    def ent_time(self) -> float: ...

    def shift_pitch(self, offset: int, inplace: bool = False) -> NoteQuarter:
        """Shift the pitch by offset"""

    def shift_velocity(self, offset: int, inplace: bool = False) -> NoteQuarter:
        """Shift the velocity by offset"""

class NoteQuarterList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: NoteQuarterList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[NoteQuarter], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[NoteQuarter]: ...

    @overload
    def __getitem__(self, arg: int, /) -> NoteQuarter: ...

    @overload
    def __getitem__(self, arg: slice, /) -> NoteQuarterList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: NoteQuarter, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: NoteQuarter, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> NoteQuarter:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: NoteQuarterList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: NoteQuarter, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: NoteQuarterList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> NoteQuarterList: ...

    def __copy__(self, deep: bool = True) -> NoteQuarterList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> NoteQuarterList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: NoteQuarterList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: NoteQuarterList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: NoteQuarter, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: NoteQuarter, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: NoteQuarter, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Quarter: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> NoteQuarterList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> NoteQuarterList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> NoteQuarterList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.int8], dict(shape=(None,), order='C', device='cpu')], arg3: Annotated[NDArray[numpy.int8], dict(shape=(None,), order='C', device='cpu')], /) -> NoteQuarterList: ...

class NoteSecond:
    @overload
    def __init__(self, other: NoteSecond) -> None: ...

    @overload
    def __init__(self, time: float, duration: float, pitch: int, velocity: int = 0) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def shift_time(self, offset: float, inplace: bool = False) -> NoteSecond:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> NoteSecond: ...

    def __copy__(self) -> NoteSecond: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> NoteSecond: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: NoteSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: NoteSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: NoteSecond, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def start(self) -> float: ...

    @start.setter
    def start(self, arg: float, /) -> None: ...

    @property
    def duration(self) -> float: ...

    @duration.setter
    def duration(self, arg: float, /) -> None: ...

    @property
    def pitch(self) -> int: ...

    @pitch.setter
    def pitch(self, arg: int, /) -> None: ...

    @property
    def velocity(self) -> int: ...

    @velocity.setter
    def velocity(self, arg: int, /) -> None: ...

    @property
    def end(self) -> float: ...

    @end.setter
    def end(self, arg: float, /) -> None: ...

    def empty(self) -> bool: ...

    def ent_time(self) -> float: ...

    def shift_pitch(self, offset: int, inplace: bool = False) -> NoteSecond:
        """Shift the pitch by offset"""

    def shift_velocity(self, offset: int, inplace: bool = False) -> NoteSecond:
        """Shift the velocity by offset"""

class NoteSecondList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: NoteSecondList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[NoteSecond], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[NoteSecond]: ...

    @overload
    def __getitem__(self, arg: int, /) -> NoteSecond: ...

    @overload
    def __getitem__(self, arg: slice, /) -> NoteSecondList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: NoteSecond, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: NoteSecond, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> NoteSecond:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: NoteSecondList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: NoteSecond, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: NoteSecondList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> NoteSecondList: ...

    def __copy__(self, deep: bool = True) -> NoteSecondList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> NoteSecondList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: NoteSecondList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: NoteSecondList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: NoteSecond, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: NoteSecond, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: NoteSecond, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Second: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> NoteSecondList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> NoteSecondList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> NoteSecondList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.int8], dict(shape=(None,), order='C', device='cpu')], arg3: Annotated[NDArray[numpy.int8], dict(shape=(None,), order='C', device='cpu')], /) -> NoteSecondList: ...

class KeySignatureTick:
    @overload
    def __init__(self, other: KeySignatureTick) -> None: ...

    @overload
    def __init__(self, time: int, key: int, tonality: int = 0) -> None: ...

    @property
    def time(self) -> int: ...

    @time.setter
    def time(self, arg: int, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> KeySignatureTick:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> KeySignatureTick: ...

    def __copy__(self) -> KeySignatureTick: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> KeySignatureTick: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: KeySignatureTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: KeySignatureTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: KeySignatureTick, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def key(self) -> int: ...

    @key.setter
    def key(self, arg: int, /) -> None: ...

    @property
    def tonality(self) -> int: ...

    @tonality.setter
    def tonality(self, arg: int, /) -> None: ...

class KeySignatureTickList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: KeySignatureTickList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[KeySignatureTick], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[KeySignatureTick]: ...

    @overload
    def __getitem__(self, arg: int, /) -> KeySignatureTick: ...

    @overload
    def __getitem__(self, arg: slice, /) -> KeySignatureTickList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: KeySignatureTick, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: KeySignatureTick, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> KeySignatureTick:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: KeySignatureTickList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: KeySignatureTick, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: KeySignatureTickList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> KeySignatureTickList: ...

    def __copy__(self, deep: bool = True) -> KeySignatureTickList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> KeySignatureTickList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: KeySignatureTickList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: KeySignatureTickList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: KeySignatureTick, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: KeySignatureTick, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: KeySignatureTick, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Tick: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> KeySignatureTickList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> KeySignatureTickList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> KeySignatureTickList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int8], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], /) -> KeySignatureTickList: ...

class KeySignatureQuarter:
    @overload
    def __init__(self, other: KeySignatureQuarter) -> None: ...

    @overload
    def __init__(self, time: float, key: int, tonality: int = 0) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> KeySignatureQuarter:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> KeySignatureQuarter: ...

    def __copy__(self) -> KeySignatureQuarter: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> KeySignatureQuarter: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: KeySignatureQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: KeySignatureQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: KeySignatureQuarter, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def key(self) -> int: ...

    @key.setter
    def key(self, arg: int, /) -> None: ...

    @property
    def tonality(self) -> int: ...

    @tonality.setter
    def tonality(self, arg: int, /) -> None: ...

class KeySignatureQuarterList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: KeySignatureQuarterList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[KeySignatureQuarter], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[KeySignatureQuarter]: ...

    @overload
    def __getitem__(self, arg: int, /) -> KeySignatureQuarter: ...

    @overload
    def __getitem__(self, arg: slice, /) -> KeySignatureQuarterList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: KeySignatureQuarter, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: KeySignatureQuarter, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> KeySignatureQuarter:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: KeySignatureQuarterList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: KeySignatureQuarter, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: KeySignatureQuarterList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> KeySignatureQuarterList: ...

    def __copy__(self, deep: bool = True) -> KeySignatureQuarterList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> KeySignatureQuarterList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: KeySignatureQuarterList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: KeySignatureQuarterList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: KeySignatureQuarter, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: KeySignatureQuarter, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: KeySignatureQuarter, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Quarter: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> KeySignatureQuarterList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> KeySignatureQuarterList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> KeySignatureQuarterList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int8], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], /) -> KeySignatureQuarterList: ...

class KeySignatureSecond:
    @overload
    def __init__(self, other: KeySignatureSecond) -> None: ...

    @overload
    def __init__(self, time: float, key: int, tonality: int = 0) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def shift_time(self, offset: float, inplace: bool = False) -> KeySignatureSecond:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> KeySignatureSecond: ...

    def __copy__(self) -> KeySignatureSecond: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> KeySignatureSecond: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: KeySignatureSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: KeySignatureSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: KeySignatureSecond, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def key(self) -> int: ...

    @key.setter
    def key(self, arg: int, /) -> None: ...

    @property
    def tonality(self) -> int: ...

    @tonality.setter
    def tonality(self, arg: int, /) -> None: ...

class KeySignatureSecondList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: KeySignatureSecondList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[KeySignatureSecond], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[KeySignatureSecond]: ...

    @overload
    def __getitem__(self, arg: int, /) -> KeySignatureSecond: ...

    @overload
    def __getitem__(self, arg: slice, /) -> KeySignatureSecondList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: KeySignatureSecond, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: KeySignatureSecond, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> KeySignatureSecond:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: KeySignatureSecondList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: KeySignatureSecond, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: KeySignatureSecondList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> KeySignatureSecondList: ...

    def __copy__(self, deep: bool = True) -> KeySignatureSecondList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> KeySignatureSecondList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: KeySignatureSecondList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: KeySignatureSecondList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: KeySignatureSecond, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: KeySignatureSecond, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: KeySignatureSecond, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Second: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> KeySignatureSecondList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> KeySignatureSecondList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> KeySignatureSecondList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int8], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], /) -> KeySignatureSecondList: ...

class TimeSignatureTick:
    @overload
    def __init__(self, other: TimeSignatureTick) -> None: ...

    @overload
    def __init__(self, time: int, numerator: int, denominator: int) -> None: ...

    @property
    def time(self) -> int: ...

    @time.setter
    def time(self, arg: int, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> TimeSignatureTick:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> TimeSignatureTick: ...

    def __copy__(self) -> TimeSignatureTick: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TimeSignatureTick: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: TimeSignatureTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TimeSignatureTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TimeSignatureTick, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def numerator(self) -> int: ...

    @numerator.setter
    def numerator(self, arg: int, /) -> None: ...

    @property
    def denominator(self) -> int: ...

    @denominator.setter
    def denominator(self, arg: int, /) -> None: ...

class TimeSignatureTickList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TimeSignatureTickList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TimeSignatureTick], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[TimeSignatureTick]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TimeSignatureTick: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TimeSignatureTickList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TimeSignatureTick, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TimeSignatureTick, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TimeSignatureTick:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TimeSignatureTickList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TimeSignatureTick, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TimeSignatureTickList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> TimeSignatureTickList: ...

    def __copy__(self, deep: bool = True) -> TimeSignatureTickList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TimeSignatureTickList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: TimeSignatureTickList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TimeSignatureTickList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: TimeSignatureTick, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TimeSignatureTick, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TimeSignatureTick, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Tick: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TimeSignatureTickList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> TimeSignatureTickList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> TimeSignatureTickList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], /) -> TimeSignatureTickList: ...

class TimeSignatureQuarter:
    @overload
    def __init__(self, other: TimeSignatureQuarter) -> None: ...

    @overload
    def __init__(self, time: float, numerator: int, denominator: int) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> TimeSignatureQuarter:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> TimeSignatureQuarter: ...

    def __copy__(self) -> TimeSignatureQuarter: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TimeSignatureQuarter: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: TimeSignatureQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TimeSignatureQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TimeSignatureQuarter, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def numerator(self) -> int: ...

    @numerator.setter
    def numerator(self, arg: int, /) -> None: ...

    @property
    def denominator(self) -> int: ...

    @denominator.setter
    def denominator(self, arg: int, /) -> None: ...

class TimeSignatureQuarterList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TimeSignatureQuarterList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TimeSignatureQuarter], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[TimeSignatureQuarter]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TimeSignatureQuarter: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TimeSignatureQuarterList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TimeSignatureQuarter, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TimeSignatureQuarter, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TimeSignatureQuarter:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TimeSignatureQuarterList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TimeSignatureQuarter, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TimeSignatureQuarterList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> TimeSignatureQuarterList: ...

    def __copy__(self, deep: bool = True) -> TimeSignatureQuarterList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TimeSignatureQuarterList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: TimeSignatureQuarterList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TimeSignatureQuarterList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: TimeSignatureQuarter, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TimeSignatureQuarter, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TimeSignatureQuarter, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Quarter: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TimeSignatureQuarterList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> TimeSignatureQuarterList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TimeSignatureQuarterList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], /) -> TimeSignatureQuarterList: ...

class TimeSignatureSecond:
    @overload
    def __init__(self, other: TimeSignatureSecond) -> None: ...

    @overload
    def __init__(self, time: float, numerator: int, denominator: int) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def shift_time(self, offset: float, inplace: bool = False) -> TimeSignatureSecond:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> TimeSignatureSecond: ...

    def __copy__(self) -> TimeSignatureSecond: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TimeSignatureSecond: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: TimeSignatureSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TimeSignatureSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TimeSignatureSecond, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def numerator(self) -> int: ...

    @numerator.setter
    def numerator(self, arg: int, /) -> None: ...

    @property
    def denominator(self) -> int: ...

    @denominator.setter
    def denominator(self, arg: int, /) -> None: ...

class TimeSignatureSecondList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TimeSignatureSecondList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TimeSignatureSecond], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[TimeSignatureSecond]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TimeSignatureSecond: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TimeSignatureSecondList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TimeSignatureSecond, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TimeSignatureSecond, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TimeSignatureSecond:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TimeSignatureSecondList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TimeSignatureSecond, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TimeSignatureSecondList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> TimeSignatureSecondList: ...

    def __copy__(self, deep: bool = True) -> TimeSignatureSecondList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TimeSignatureSecondList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: TimeSignatureSecondList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TimeSignatureSecondList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: TimeSignatureSecond, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TimeSignatureSecond, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TimeSignatureSecond, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Second: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TimeSignatureSecondList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> TimeSignatureSecondList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TimeSignatureSecondList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], /) -> TimeSignatureSecondList: ...

class TempoTick:
    @overload
    def __init__(self, other: TempoTick) -> None: ...

    @overload
    def __init__(self, time: int, qpm: Optional[float] = None, mspq: Optional[int] = None) -> None: ...

    @property
    def time(self) -> int: ...

    @time.setter
    def time(self, arg: int, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> TempoTick:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> TempoTick: ...

    def __copy__(self) -> TempoTick: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TempoTick: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: TempoTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TempoTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TempoTick, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def mspq(self) -> int: ...

    @mspq.setter
    def mspq(self, arg: int, /) -> None: ...

    @property
    def tempo(self) -> float: ...

    @tempo.setter
    def tempo(self, arg: float, /) -> None: ...

    @property
    def qpm(self) -> float: ...

    @qpm.setter
    def qpm(self, arg: float, /) -> None: ...

class TempoTickList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TempoTickList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TempoTick], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[TempoTick]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TempoTick: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TempoTickList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TempoTick, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TempoTick, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TempoTick:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TempoTickList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TempoTick, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TempoTickList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> TempoTickList: ...

    def __copy__(self, deep: bool = True) -> TempoTickList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TempoTickList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: TempoTickList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TempoTickList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: TempoTick, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TempoTick, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TempoTick, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Tick: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TempoTickList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> TempoTickList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> TempoTickList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], /) -> TempoTickList: ...

class TempoQuarter:
    @overload
    def __init__(self, other: TempoQuarter) -> None: ...

    @overload
    def __init__(self, time: float, qpm: Optional[float] = None, mspq: Optional[int] = None) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> TempoQuarter:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> TempoQuarter: ...

    def __copy__(self) -> TempoQuarter: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TempoQuarter: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: TempoQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TempoQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TempoQuarter, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def mspq(self) -> int: ...

    @mspq.setter
    def mspq(self, arg: int, /) -> None: ...

    @property
    def tempo(self) -> float: ...

    @tempo.setter
    def tempo(self, arg: float, /) -> None: ...

    @property
    def qpm(self) -> float: ...

    @qpm.setter
    def qpm(self, arg: float, /) -> None: ...

class TempoQuarterList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TempoQuarterList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TempoQuarter], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[TempoQuarter]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TempoQuarter: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TempoQuarterList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TempoQuarter, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TempoQuarter, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TempoQuarter:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TempoQuarterList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TempoQuarter, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TempoQuarterList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> TempoQuarterList: ...

    def __copy__(self, deep: bool = True) -> TempoQuarterList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TempoQuarterList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: TempoQuarterList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TempoQuarterList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: TempoQuarter, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TempoQuarter, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TempoQuarter, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Quarter: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TempoQuarterList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> TempoQuarterList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TempoQuarterList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], /) -> TempoQuarterList: ...

class TempoSecond:
    @overload
    def __init__(self, other: TempoSecond) -> None: ...

    @overload
    def __init__(self, time: float, qpm: Optional[float] = None, mspq: Optional[int] = None) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def shift_time(self, offset: float, inplace: bool = False) -> TempoSecond:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> TempoSecond: ...

    def __copy__(self) -> TempoSecond: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TempoSecond: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: TempoSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TempoSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TempoSecond, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def mspq(self) -> int: ...

    @mspq.setter
    def mspq(self, arg: int, /) -> None: ...

    @property
    def tempo(self) -> float: ...

    @tempo.setter
    def tempo(self, arg: float, /) -> None: ...

    @property
    def qpm(self) -> float: ...

    @qpm.setter
    def qpm(self, arg: float, /) -> None: ...

class TempoSecondList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TempoSecondList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TempoSecond], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[TempoSecond]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TempoSecond: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TempoSecondList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TempoSecond, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TempoSecond, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TempoSecond:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TempoSecondList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TempoSecond, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TempoSecondList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> TempoSecondList: ...

    def __copy__(self, deep: bool = True) -> TempoSecondList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TempoSecondList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: TempoSecondList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TempoSecondList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: TempoSecond, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TempoSecond, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TempoSecond, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Second: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TempoSecondList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> TempoSecondList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TempoSecondList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], /) -> TempoSecondList: ...

class ControlChangeTick:
    @overload
    def __init__(self, other: ControlChangeTick) -> None: ...

    @overload
    def __init__(self, time: int, number: int, value: int) -> None: ...

    @property
    def time(self) -> int: ...

    @time.setter
    def time(self, arg: int, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> ControlChangeTick:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> ControlChangeTick: ...

    def __copy__(self) -> ControlChangeTick: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> ControlChangeTick: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: ControlChangeTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ControlChangeTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ControlChangeTick, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def number(self) -> int: ...

    @number.setter
    def number(self, arg: int, /) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class ControlChangeTickList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: ControlChangeTickList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[ControlChangeTick], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[ControlChangeTick]: ...

    @overload
    def __getitem__(self, arg: int, /) -> ControlChangeTick: ...

    @overload
    def __getitem__(self, arg: slice, /) -> ControlChangeTickList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: ControlChangeTick, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: ControlChangeTick, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> ControlChangeTick:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: ControlChangeTickList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: ControlChangeTick, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: ControlChangeTickList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> ControlChangeTickList: ...

    def __copy__(self, deep: bool = True) -> ControlChangeTickList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> ControlChangeTickList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: ControlChangeTickList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ControlChangeTickList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: ControlChangeTick, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: ControlChangeTick, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: ControlChangeTick, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Tick: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> ControlChangeTickList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> ControlChangeTickList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> ControlChangeTickList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], /) -> ControlChangeTickList: ...

class ControlChangeQuarter:
    @overload
    def __init__(self, other: ControlChangeQuarter) -> None: ...

    @overload
    def __init__(self, time: float, number: int, value: int) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> ControlChangeQuarter:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> ControlChangeQuarter: ...

    def __copy__(self) -> ControlChangeQuarter: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> ControlChangeQuarter: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: ControlChangeQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ControlChangeQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ControlChangeQuarter, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def number(self) -> int: ...

    @number.setter
    def number(self, arg: int, /) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class ControlChangeQuarterList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: ControlChangeQuarterList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[ControlChangeQuarter], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[ControlChangeQuarter]: ...

    @overload
    def __getitem__(self, arg: int, /) -> ControlChangeQuarter: ...

    @overload
    def __getitem__(self, arg: slice, /) -> ControlChangeQuarterList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: ControlChangeQuarter, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: ControlChangeQuarter, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> ControlChangeQuarter:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: ControlChangeQuarterList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: ControlChangeQuarter, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: ControlChangeQuarterList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> ControlChangeQuarterList: ...

    def __copy__(self, deep: bool = True) -> ControlChangeQuarterList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> ControlChangeQuarterList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: ControlChangeQuarterList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ControlChangeQuarterList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: ControlChangeQuarter, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: ControlChangeQuarter, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: ControlChangeQuarter, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Quarter: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> ControlChangeQuarterList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> ControlChangeQuarterList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> ControlChangeQuarterList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], /) -> ControlChangeQuarterList: ...

class ControlChangeSecond:
    @overload
    def __init__(self, other: ControlChangeSecond) -> None: ...

    @overload
    def __init__(self, time: float, number: int, value: int) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def shift_time(self, offset: float, inplace: bool = False) -> ControlChangeSecond:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> ControlChangeSecond: ...

    def __copy__(self) -> ControlChangeSecond: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> ControlChangeSecond: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: ControlChangeSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ControlChangeSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ControlChangeSecond, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def number(self) -> int: ...

    @number.setter
    def number(self, arg: int, /) -> None: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class ControlChangeSecondList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: ControlChangeSecondList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[ControlChangeSecond], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[ControlChangeSecond]: ...

    @overload
    def __getitem__(self, arg: int, /) -> ControlChangeSecond: ...

    @overload
    def __getitem__(self, arg: slice, /) -> ControlChangeSecondList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: ControlChangeSecond, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: ControlChangeSecond, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> ControlChangeSecond:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: ControlChangeSecondList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: ControlChangeSecond, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: ControlChangeSecondList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> ControlChangeSecondList: ...

    def __copy__(self, deep: bool = True) -> ControlChangeSecondList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> ControlChangeSecondList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: ControlChangeSecondList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ControlChangeSecondList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: ControlChangeSecond, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: ControlChangeSecond, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: ControlChangeSecond, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Second: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> ControlChangeSecondList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> ControlChangeSecondList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> ControlChangeSecondList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], arg2: Annotated[NDArray[numpy.uint8], dict(shape=(None,), order='C', device='cpu')], /) -> ControlChangeSecondList: ...

class PedalTick:
    @overload
    def __init__(self, other: PedalTick) -> None: ...

    @overload
    def __init__(self, time: int, duration: int) -> None: ...

    @property
    def time(self) -> int: ...

    @time.setter
    def time(self, arg: int, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> PedalTick:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> PedalTick: ...

    def __copy__(self) -> PedalTick: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PedalTick: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: PedalTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PedalTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PedalTick, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def start(self) -> int: ...

    @start.setter
    def start(self, arg: int, /) -> None: ...

    @property
    def duration(self) -> int: ...

    @duration.setter
    def duration(self, arg: int, /) -> None: ...

    @property
    def end(self) -> int: ...

    @end.setter
    def end(self, arg: int, /) -> None: ...

class PedalTickList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: PedalTickList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[PedalTick], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[PedalTick]: ...

    @overload
    def __getitem__(self, arg: int, /) -> PedalTick: ...

    @overload
    def __getitem__(self, arg: slice, /) -> PedalTickList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: PedalTick, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: PedalTick, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> PedalTick:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: PedalTickList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: PedalTick, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: PedalTickList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> PedalTickList: ...

    def __copy__(self, deep: bool = True) -> PedalTickList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PedalTickList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: PedalTickList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PedalTickList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: PedalTick, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: PedalTick, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: PedalTick, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Tick: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> PedalTickList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> PedalTickList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> PedalTickList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], /) -> PedalTickList: ...

class PedalQuarter:
    @overload
    def __init__(self, other: PedalQuarter) -> None: ...

    @overload
    def __init__(self, time: float, duration: float) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> PedalQuarter:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> PedalQuarter: ...

    def __copy__(self) -> PedalQuarter: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PedalQuarter: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: PedalQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PedalQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PedalQuarter, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def start(self) -> float: ...

    @start.setter
    def start(self, arg: float, /) -> None: ...

    @property
    def duration(self) -> float: ...

    @duration.setter
    def duration(self, arg: float, /) -> None: ...

    @property
    def end(self) -> float: ...

    @end.setter
    def end(self, arg: float, /) -> None: ...

class PedalQuarterList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: PedalQuarterList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[PedalQuarter], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[PedalQuarter]: ...

    @overload
    def __getitem__(self, arg: int, /) -> PedalQuarter: ...

    @overload
    def __getitem__(self, arg: slice, /) -> PedalQuarterList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: PedalQuarter, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: PedalQuarter, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> PedalQuarter:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: PedalQuarterList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: PedalQuarter, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: PedalQuarterList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> PedalQuarterList: ...

    def __copy__(self, deep: bool = True) -> PedalQuarterList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PedalQuarterList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: PedalQuarterList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PedalQuarterList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: PedalQuarter, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: PedalQuarter, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: PedalQuarter, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Quarter: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> PedalQuarterList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> PedalQuarterList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> PedalQuarterList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], /) -> PedalQuarterList: ...

class PedalSecond:
    @overload
    def __init__(self, other: PedalSecond) -> None: ...

    @overload
    def __init__(self, time: float, duration: float) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def shift_time(self, offset: float, inplace: bool = False) -> PedalSecond:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> PedalSecond: ...

    def __copy__(self) -> PedalSecond: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PedalSecond: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: PedalSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PedalSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PedalSecond, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def start(self) -> float: ...

    @start.setter
    def start(self, arg: float, /) -> None: ...

    @property
    def duration(self) -> float: ...

    @duration.setter
    def duration(self, arg: float, /) -> None: ...

    @property
    def end(self) -> float: ...

    @end.setter
    def end(self, arg: float, /) -> None: ...

class PedalSecondList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: PedalSecondList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[PedalSecond], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[PedalSecond]: ...

    @overload
    def __getitem__(self, arg: int, /) -> PedalSecond: ...

    @overload
    def __getitem__(self, arg: slice, /) -> PedalSecondList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: PedalSecond, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: PedalSecond, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> PedalSecond:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: PedalSecondList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: PedalSecond, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: PedalSecondList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> PedalSecondList: ...

    def __copy__(self, deep: bool = True) -> PedalSecondList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PedalSecondList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: PedalSecondList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PedalSecondList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: PedalSecond, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: PedalSecond, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: PedalSecond, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Second: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> PedalSecondList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> PedalSecondList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> PedalSecondList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], /) -> PedalSecondList: ...

class PitchBendTick:
    @overload
    def __init__(self, other: PitchBendTick) -> None: ...

    @overload
    def __init__(self, time: int, value: int) -> None: ...

    @property
    def time(self) -> int: ...

    @time.setter
    def time(self, arg: int, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> PitchBendTick:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> PitchBendTick: ...

    def __copy__(self) -> PitchBendTick: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PitchBendTick: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: PitchBendTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PitchBendTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PitchBendTick, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class PitchBendTickList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: PitchBendTickList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[PitchBendTick], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[PitchBendTick]: ...

    @overload
    def __getitem__(self, arg: int, /) -> PitchBendTick: ...

    @overload
    def __getitem__(self, arg: slice, /) -> PitchBendTickList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: PitchBendTick, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: PitchBendTick, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> PitchBendTick:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: PitchBendTickList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: PitchBendTick, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: PitchBendTickList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> PitchBendTickList: ...

    def __copy__(self, deep: bool = True) -> PitchBendTickList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PitchBendTickList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: PitchBendTickList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PitchBendTickList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: PitchBendTick, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: PitchBendTick, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: PitchBendTick, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Tick: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> PitchBendTickList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> PitchBendTickList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> PitchBendTickList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], /) -> PitchBendTickList: ...

class PitchBendQuarter:
    @overload
    def __init__(self, other: PitchBendQuarter) -> None: ...

    @overload
    def __init__(self, time: float, value: int) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> PitchBendQuarter:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> PitchBendQuarter: ...

    def __copy__(self) -> PitchBendQuarter: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PitchBendQuarter: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: PitchBendQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PitchBendQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PitchBendQuarter, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class PitchBendQuarterList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: PitchBendQuarterList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[PitchBendQuarter], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[PitchBendQuarter]: ...

    @overload
    def __getitem__(self, arg: int, /) -> PitchBendQuarter: ...

    @overload
    def __getitem__(self, arg: slice, /) -> PitchBendQuarterList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: PitchBendQuarter, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: PitchBendQuarter, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> PitchBendQuarter:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: PitchBendQuarterList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: PitchBendQuarter, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: PitchBendQuarterList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> PitchBendQuarterList: ...

    def __copy__(self, deep: bool = True) -> PitchBendQuarterList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PitchBendQuarterList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: PitchBendQuarterList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PitchBendQuarterList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: PitchBendQuarter, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: PitchBendQuarter, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: PitchBendQuarter, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Quarter: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> PitchBendQuarterList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> PitchBendQuarterList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> PitchBendQuarterList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], /) -> PitchBendQuarterList: ...

class PitchBendSecond:
    @overload
    def __init__(self, other: PitchBendSecond) -> None: ...

    @overload
    def __init__(self, time: float, value: int) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def shift_time(self, offset: float, inplace: bool = False) -> PitchBendSecond:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> PitchBendSecond: ...

    def __copy__(self) -> PitchBendSecond: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PitchBendSecond: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: PitchBendSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PitchBendSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PitchBendSecond, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def value(self) -> int: ...

    @value.setter
    def value(self, arg: int, /) -> None: ...

class PitchBendSecondList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: PitchBendSecondList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[PitchBendSecond], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[PitchBendSecond]: ...

    @overload
    def __getitem__(self, arg: int, /) -> PitchBendSecond: ...

    @overload
    def __getitem__(self, arg: slice, /) -> PitchBendSecondList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: PitchBendSecond, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: PitchBendSecond, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> PitchBendSecond:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: PitchBendSecondList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: PitchBendSecond, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: PitchBendSecondList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> PitchBendSecondList: ...

    def __copy__(self, deep: bool = True) -> PitchBendSecondList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> PitchBendSecondList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: PitchBendSecondList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: PitchBendSecondList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: PitchBendSecond, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: PitchBendSecond, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: PitchBendSecond, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Second: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> PitchBendSecondList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> PitchBendSecondList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> PitchBendSecondList: ...

    def numpy(self) -> dict: ...

    @staticmethod
    def from_numpy(arg0: Annotated[NDArray[numpy.float32], dict(shape=(None,), order='C', device='cpu')], arg1: Annotated[NDArray[numpy.int32], dict(shape=(None,), order='C', device='cpu')], /) -> PitchBendSecondList: ...

class TextMetaTick:
    @overload
    def __init__(self, other: TextMetaTick) -> None: ...

    @overload
    def __init__(self, time: int, text: str) -> None: ...

    @property
    def time(self) -> int: ...

    @time.setter
    def time(self, arg: int, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> TextMetaTick:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> TextMetaTick: ...

    def __copy__(self) -> TextMetaTick: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TextMetaTick: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: TextMetaTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TextMetaTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TextMetaTick, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def text(self) -> str: ...

    @text.setter
    def text(self, arg: str, /) -> None: ...

class TextMetaTickList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TextMetaTickList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TextMetaTick], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[TextMetaTick]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TextMetaTick: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TextMetaTickList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TextMetaTick, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TextMetaTick, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TextMetaTick:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TextMetaTickList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TextMetaTick, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TextMetaTickList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> TextMetaTickList: ...

    def __copy__(self, deep: bool = True) -> TextMetaTickList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TextMetaTickList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: TextMetaTickList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TextMetaTickList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: TextMetaTick, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TextMetaTick, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TextMetaTick, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Tick: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TextMetaTickList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> TextMetaTickList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> TextMetaTickList: ...

    def numpy(self) -> None: ...

    @staticmethod
    def from_numpy() -> None: ...

class TextMetaQuarter:
    @overload
    def __init__(self, other: TextMetaQuarter) -> None: ...

    @overload
    def __init__(self, time: float, text: str) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> TextMetaQuarter:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> TextMetaQuarter: ...

    def __copy__(self) -> TextMetaQuarter: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TextMetaQuarter: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: TextMetaQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TextMetaQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TextMetaQuarter, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def text(self) -> str: ...

    @text.setter
    def text(self, arg: str, /) -> None: ...

class TextMetaQuarterList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TextMetaQuarterList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TextMetaQuarter], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[TextMetaQuarter]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TextMetaQuarter: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TextMetaQuarterList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TextMetaQuarter, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TextMetaQuarter, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TextMetaQuarter:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TextMetaQuarterList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TextMetaQuarter, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TextMetaQuarterList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> TextMetaQuarterList: ...

    def __copy__(self, deep: bool = True) -> TextMetaQuarterList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TextMetaQuarterList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: TextMetaQuarterList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TextMetaQuarterList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: TextMetaQuarter, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TextMetaQuarter, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TextMetaQuarter, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Quarter: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TextMetaQuarterList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> TextMetaQuarterList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TextMetaQuarterList: ...

    def numpy(self) -> None: ...

    @staticmethod
    def from_numpy() -> None: ...

class TextMetaSecond:
    @overload
    def __init__(self, other: TextMetaSecond) -> None: ...

    @overload
    def __init__(self, time: float, text: str) -> None: ...

    @property
    def time(self) -> float: ...

    @time.setter
    def time(self, arg: float, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def shift_time(self, offset: float, inplace: bool = False) -> TextMetaSecond:
        """Shift the event time by offset"""

    def copy(self, deep: bool = True) -> TextMetaSecond: ...

    def __copy__(self) -> TextMetaSecond: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TextMetaSecond: ...

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: TextMetaSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TextMetaSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TextMetaSecond, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

    @property
    def text(self) -> str: ...

    @text.setter
    def text(self, arg: str, /) -> None: ...

class TextMetaSecondList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TextMetaSecondList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TextMetaSecond], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __iter__(self) -> Iterator[TextMetaSecond]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TextMetaSecond: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TextMetaSecondList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TextMetaSecond, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TextMetaSecond, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TextMetaSecond:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TextMetaSecondList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TextMetaSecond, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TextMetaSecondList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def copy(self) -> TextMetaSecondList: ...

    def __copy__(self, deep: bool = True) -> TextMetaSecondList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TextMetaSecondList: ...

    def __use_count(self) -> int: ...

    @overload
    def __eq__(self, arg: TextMetaSecondList, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TextMetaSecondList, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: TextMetaSecond, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TextMetaSecond, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TextMetaSecond, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Second: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __repr__(self) -> str: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TextMetaSecondList: ...

    def filter(self, function: Optional[object] = None, inplace: bool = True) -> TextMetaSecondList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TextMetaSecondList: ...

    def numpy(self) -> None: ...

    @staticmethod
    def from_numpy() -> None: ...

class TrackTick:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, name: str, program: int = 0, is_drum: bool = False) -> None: ...

    @overload
    def __init__(self, other: TrackTick) -> None:
        """Copy constructor"""

    def copy(self, deep: bool = True) -> TrackTick: ...

    def __copy__(self) -> TrackTick: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TrackTick: ...

    def __repr__(self) -> str: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def __use_count(self) -> int: ...

    @property
    def notes(self) -> NoteTickList: ...

    @notes.setter
    def notes(self, arg: NoteTickList, /) -> None: ...

    @property
    def controls(self) -> ControlChangeTickList: ...

    @controls.setter
    def controls(self, arg: ControlChangeTickList, /) -> None: ...

    @property
    def pedals(self) -> PedalTickList: ...

    @pedals.setter
    def pedals(self, arg: PedalTickList, /) -> None: ...

    @property
    def pitch_bends(self) -> PitchBendTickList: ...

    @pitch_bends.setter
    def pitch_bends(self, arg: PitchBendTickList, /) -> None: ...

    @property
    def lyrics(self) -> TextMetaTickList: ...

    @lyrics.setter
    def lyrics(self, arg: TextMetaTickList, /) -> None: ...

    @property
    def is_drum(self) -> bool: ...

    @is_drum.setter
    def is_drum(self, arg: bool, /) -> None: ...

    @property
    def program(self) -> int: ...

    @program.setter
    def program(self, arg: int, /) -> None: ...

    @property
    def name(self) -> str: ...

    @name.setter
    def name(self, arg: str, /) -> None: ...

    @overload
    def __eq__(self, arg: TrackTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TrackTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    def end(self) -> int: ...

    def start(self) -> int: ...

    def note_num(self) -> int: ...

    def empty(self) -> bool: ...

    def clip(self, start: int, end: int, clip_end: bool = False, inplace: bool = False) -> TrackTick: ...

    def trim(self, start: int, end: int, min_overlap: int = 0, start_mode: str = 'remove', end_mode: str = 'remove', inplace: bool = False) -> TrackTick: ...

    def sort(self, reverse: bool = False, inplace: bool = True) -> TrackTick: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> TrackTick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> TrackTick: ...

    def shift_pitch(self, offset: int, inplace: bool = False) -> TrackTick: ...

    def shift_velocity(self, offset: int, inplace: bool = False) -> TrackTick: ...

    def pianoroll(self, modes: Sequence[str] = ['frame', 'onset'], pitch_range: Tuple[int, int] = (0, 128), encode_velocity: bool = False) -> NDArray[numpy.uint8]: ...

class TrackTickList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TrackTickList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TrackTick], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[TrackTick]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TrackTick: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TrackTickList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TrackTick, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TrackTick, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TrackTick:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TrackTickList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TrackTick, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TrackTickList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    @overload
    def __eq__(self, arg: TrackTickList, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: TrackTickList, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __contains__(self, arg: TrackTick, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TrackTick, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TrackTick, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Tick: ...

    def filter(self, function: object, inplace: bool = True) -> TrackTickList: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TrackTickList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> TrackTickList: ...

    def copy(self, deep: bool = True) -> TrackTickList: ...

    def __copy__(self) -> TrackTickList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TrackTickList: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

class TrackQuarter:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, name: str, program: int = 0, is_drum: bool = False) -> None: ...

    @overload
    def __init__(self, other: TrackQuarter) -> None:
        """Copy constructor"""

    def copy(self, deep: bool = True) -> TrackQuarter: ...

    def __copy__(self) -> TrackQuarter: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TrackQuarter: ...

    def __repr__(self) -> str: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def __use_count(self) -> int: ...

    @property
    def notes(self) -> NoteQuarterList: ...

    @notes.setter
    def notes(self, arg: NoteQuarterList, /) -> None: ...

    @property
    def controls(self) -> ControlChangeQuarterList: ...

    @controls.setter
    def controls(self, arg: ControlChangeQuarterList, /) -> None: ...

    @property
    def pedals(self) -> PedalQuarterList: ...

    @pedals.setter
    def pedals(self, arg: PedalQuarterList, /) -> None: ...

    @property
    def pitch_bends(self) -> PitchBendQuarterList: ...

    @pitch_bends.setter
    def pitch_bends(self, arg: PitchBendQuarterList, /) -> None: ...

    @property
    def lyrics(self) -> TextMetaQuarterList: ...

    @lyrics.setter
    def lyrics(self, arg: TextMetaQuarterList, /) -> None: ...

    @property
    def is_drum(self) -> bool: ...

    @is_drum.setter
    def is_drum(self, arg: bool, /) -> None: ...

    @property
    def program(self) -> int: ...

    @program.setter
    def program(self, arg: int, /) -> None: ...

    @property
    def name(self) -> str: ...

    @name.setter
    def name(self, arg: str, /) -> None: ...

    @overload
    def __eq__(self, arg: TrackQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TrackQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    def end(self) -> float: ...

    def start(self) -> float: ...

    def note_num(self) -> int: ...

    def empty(self) -> bool: ...

    def clip(self, start: float, end: float, clip_end: bool = False, inplace: bool = False) -> TrackQuarter: ...

    def trim(self, start: float, end: float, min_overlap: float = 0, start_mode: str = 'remove', end_mode: str = 'remove', inplace: bool = False) -> TrackQuarter: ...

    def sort(self, reverse: bool = False, inplace: bool = True) -> TrackQuarter: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TrackQuarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> TrackQuarter: ...

    def shift_pitch(self, offset: int, inplace: bool = False) -> TrackQuarter: ...

    def shift_velocity(self, offset: int, inplace: bool = False) -> TrackQuarter: ...

class TrackQuarterList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TrackQuarterList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TrackQuarter], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[TrackQuarter]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TrackQuarter: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TrackQuarterList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TrackQuarter, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TrackQuarter, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TrackQuarter:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TrackQuarterList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TrackQuarter, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TrackQuarterList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    @overload
    def __eq__(self, arg: TrackQuarterList, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: TrackQuarterList, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __contains__(self, arg: TrackQuarter, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TrackQuarter, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TrackQuarter, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Quarter: ...

    def filter(self, function: object, inplace: bool = True) -> TrackQuarterList: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TrackQuarterList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TrackQuarterList: ...

    def copy(self, deep: bool = True) -> TrackQuarterList: ...

    def __copy__(self) -> TrackQuarterList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TrackQuarterList: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

class TrackSecond:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, name: str, program: int = 0, is_drum: bool = False) -> None: ...

    @overload
    def __init__(self, other: TrackSecond) -> None:
        """Copy constructor"""

    def copy(self, deep: bool = True) -> TrackSecond: ...

    def __copy__(self) -> TrackSecond: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TrackSecond: ...

    def __repr__(self) -> str: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def __use_count(self) -> int: ...

    @property
    def notes(self) -> NoteSecondList: ...

    @notes.setter
    def notes(self, arg: NoteSecondList, /) -> None: ...

    @property
    def controls(self) -> ControlChangeSecondList: ...

    @controls.setter
    def controls(self, arg: ControlChangeSecondList, /) -> None: ...

    @property
    def pedals(self) -> PedalSecondList: ...

    @pedals.setter
    def pedals(self, arg: PedalSecondList, /) -> None: ...

    @property
    def pitch_bends(self) -> PitchBendSecondList: ...

    @pitch_bends.setter
    def pitch_bends(self, arg: PitchBendSecondList, /) -> None: ...

    @property
    def lyrics(self) -> TextMetaSecondList: ...

    @lyrics.setter
    def lyrics(self, arg: TextMetaSecondList, /) -> None: ...

    @property
    def is_drum(self) -> bool: ...

    @is_drum.setter
    def is_drum(self, arg: bool, /) -> None: ...

    @property
    def program(self) -> int: ...

    @program.setter
    def program(self, arg: int, /) -> None: ...

    @property
    def name(self) -> str: ...

    @name.setter
    def name(self, arg: str, /) -> None: ...

    @overload
    def __eq__(self, arg: TrackSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: TrackSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    def end(self) -> float: ...

    def start(self) -> float: ...

    def note_num(self) -> int: ...

    def empty(self) -> bool: ...

    def clip(self, start: float, end: float, clip_end: bool = False, inplace: bool = False) -> TrackSecond: ...

    def trim(self, start: float, end: float, min_overlap: float = 0, start_mode: str = 'remove', end_mode: str = 'remove', inplace: bool = False) -> TrackSecond: ...

    def sort(self, reverse: bool = False, inplace: bool = True) -> TrackSecond: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TrackSecond: ...

    def shift_time(self, offset: float, inplace: bool = False) -> TrackSecond: ...

    def shift_pitch(self, offset: int, inplace: bool = False) -> TrackSecond: ...

    def shift_velocity(self, offset: int, inplace: bool = False) -> TrackSecond: ...

class TrackSecondList:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: TrackSecondList) -> None:
        """Shallow Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[TrackSecond], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[TrackSecond]: ...

    @overload
    def __getitem__(self, arg: int, /) -> TrackSecond: ...

    @overload
    def __getitem__(self, arg: slice, /) -> TrackSecondList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: TrackSecond, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: TrackSecond, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> TrackSecond:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: TrackSecondList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: TrackSecond, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: TrackSecondList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    @overload
    def __eq__(self, arg: TrackSecondList, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    @overload
    def __ne__(self, arg: TrackSecondList, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: list, /) -> bool: ...

    @overload
    def __contains__(self, arg: TrackSecond, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: TrackSecond, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: TrackSecond, /) -> None:
        """Remove first occurrence of `arg`."""

    @property
    def ttype(self) -> Second: ...

    def filter(self, function: object, inplace: bool = True) -> TrackSecondList: ...

    def sort(self, key: Optional[object] = None, reverse: bool = False, inplace: bool = True) -> TrackSecondList: ...

    def is_sorted(self, key: Optional[object] = None, reverse: bool = False) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> TrackSecondList: ...

    def copy(self, deep: bool = True) -> TrackSecondList: ...

    def __copy__(self) -> TrackSecondList: ...

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> TrackSecondList: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    def __use_count(self) -> int: ...

class ScoreTick:
    @overload
    def __init__(self, tpq: int) -> None: ...

    @overload
    def __init__(self, other: ScoreTick) -> None:
        """Copy constructor"""

    @overload
    def __init__(self, path: Union[str, os.PathLike]) -> None:
        """Load from midi file"""

    def copy(self, deep: bool = True) -> ScoreTick: ...

    def __copy__(self) -> ScoreTick:
        """Shallow copy"""

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> ScoreTick:
        """Deep copy"""

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: ScoreTick, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ScoreTick, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    @staticmethod
    def from_file(path: Union[str, os.PathLike], format: Optional[str] = None) -> ScoreTick: ...

    @staticmethod
    def from_midi(data: bytes, sanitize_data: bool = False) -> ScoreTick:
        """Load from midi bytes with optional payload sanitization"""

    @staticmethod
    def from_abc(abc: str) -> ScoreTick:
        """Load from abc string"""

    def dump_midi(self, path: Union[str, os.PathLike]) -> None:
        """Dump to midi file"""

    def dumps_midi(self) -> bytes:
        """Dump to midi in memory(bytes)"""

    def dump_abc(self, path: Union[str, os.PathLike], warn: bool = False) -> None:
        """Dump to abc file"""

    def dumps_abc(self, warn: bool = False) -> str:
        """Dump to abc string"""

    @property
    def ticks_per_quarter(self) -> int: ...

    @ticks_per_quarter.setter
    def ticks_per_quarter(self, arg: int, /) -> None: ...

    @property
    def tpq(self) -> int: ...

    @tpq.setter
    def tpq(self, arg: int, /) -> None: ...

    @property
    def tracks(self) -> TrackTickList: ...

    @tracks.setter
    def tracks(self, arg: TrackTickList, /) -> None: ...

    @property
    def time_signatures(self) -> TimeSignatureTickList: ...

    @time_signatures.setter
    def time_signatures(self, arg: TimeSignatureTickList, /) -> None: ...

    @property
    def key_signatures(self) -> KeySignatureTickList: ...

    @key_signatures.setter
    def key_signatures(self, arg: KeySignatureTickList, /) -> None: ...

    @property
    def tempos(self) -> TempoTickList: ...

    @tempos.setter
    def tempos(self, arg: TempoTickList, /) -> None: ...

    @property
    def markers(self) -> TextMetaTickList: ...

    @markers.setter
    def markers(self, arg: TextMetaTickList, /) -> None: ...

    @property
    def ttype(self) -> Tick: ...

    def __use_count(self) -> int: ...

    def to(self, ttype: object, min_dur: Optional[object] = None) -> object:
        """Convert to another time unit"""

    def resample(self, tpq: int, min_dur: Optional[int] = None) -> ScoreTick:
        """Resample to another ticks per quarter"""

    def sort(self, reverse: bool = False, inplace: bool = True) -> ScoreTick: ...

    def clip(self, start: int, end: int, clip_end: bool = False, inplace: bool = False) -> ScoreTick: ...

    def trim(self, start: int, end: int, min_overlap: int = 0, start_mode: str = 'remove', end_mode: str = 'remove', inplace: bool = False) -> ScoreTick: ...

    def shift_time(self, offset: int, inplace: bool = False) -> ScoreTick: ...

    def shift_pitch(self, offset: int, inplace: bool = False) -> ScoreTick: ...

    def shift_velocity(self, offset: int, inplace: bool = False) -> ScoreTick: ...

    def start(self) -> int: ...

    def end(self) -> int: ...

    def note_num(self) -> int: ...

    def empty(self) -> bool: ...

    def adjust_time(self, original_times: Sequence[int], new_times: Sequence[int], inplace: bool = False) -> ScoreTick: ...

    def pianoroll(self, modes: Sequence[str] = ['frame', 'onset'], pitch_range: Tuple[int, int] = (0, 128), encode_velocity: bool = False) -> NDArray[numpy.uint8]: ...

class ScoreQuarter:
    @overload
    def __init__(self, tpq: int) -> None: ...

    @overload
    def __init__(self, other: ScoreQuarter) -> None:
        """Copy constructor"""

    @overload
    def __init__(self, path: Union[str, os.PathLike]) -> None:
        """Load from midi file"""

    def copy(self, deep: bool = True) -> ScoreQuarter: ...

    def __copy__(self) -> ScoreQuarter:
        """Shallow copy"""

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> ScoreQuarter:
        """Deep copy"""

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: ScoreQuarter, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ScoreQuarter, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    @staticmethod
    def from_file(path: Union[str, os.PathLike], format: Optional[str] = None) -> ScoreQuarter: ...

    @staticmethod
    def from_midi(data: bytes, sanitize_data: bool = False) -> ScoreQuarter:
        """Load from midi bytes with optional payload sanitization"""

    @staticmethod
    def from_abc(abc: str) -> ScoreQuarter:
        """Load from abc string"""

    def dump_midi(self, path: Union[str, os.PathLike]) -> None:
        """Dump to midi file"""

    def dumps_midi(self) -> bytes:
        """Dump to midi in memory(bytes)"""

    def dump_abc(self, path: Union[str, os.PathLike], warn: bool = False) -> None:
        """Dump to abc file"""

    def dumps_abc(self, warn: bool = False) -> str:
        """Dump to abc string"""

    @property
    def ticks_per_quarter(self) -> int: ...

    @ticks_per_quarter.setter
    def ticks_per_quarter(self, arg: int, /) -> None: ...

    @property
    def tpq(self) -> int: ...

    @tpq.setter
    def tpq(self, arg: int, /) -> None: ...

    @property
    def tracks(self) -> TrackQuarterList: ...

    @tracks.setter
    def tracks(self, arg: TrackQuarterList, /) -> None: ...

    @property
    def time_signatures(self) -> TimeSignatureQuarterList: ...

    @time_signatures.setter
    def time_signatures(self, arg: TimeSignatureQuarterList, /) -> None: ...

    @property
    def key_signatures(self) -> KeySignatureQuarterList: ...

    @key_signatures.setter
    def key_signatures(self, arg: KeySignatureQuarterList, /) -> None: ...

    @property
    def tempos(self) -> TempoQuarterList: ...

    @tempos.setter
    def tempos(self, arg: TempoQuarterList, /) -> None: ...

    @property
    def markers(self) -> TextMetaQuarterList: ...

    @markers.setter
    def markers(self, arg: TextMetaQuarterList, /) -> None: ...

    @property
    def ttype(self) -> Quarter: ...

    def __use_count(self) -> int: ...

    def to(self, ttype: object, min_dur: Optional[object] = None) -> object:
        """Convert to another time unit"""

    def resample(self, tpq: int, min_dur: Optional[float] = None) -> ScoreTick:
        """Resample to another ticks per quarter"""

    def sort(self, reverse: bool = False, inplace: bool = True) -> ScoreQuarter: ...

    def clip(self, start: float, end: float, clip_end: bool = False, inplace: bool = False) -> ScoreQuarter: ...

    def trim(self, start: float, end: float, min_overlap: float = 0, start_mode: str = 'remove', end_mode: str = 'remove', inplace: bool = False) -> ScoreQuarter: ...

    def shift_time(self, offset: float, inplace: bool = False) -> ScoreQuarter: ...

    def shift_pitch(self, offset: int, inplace: bool = False) -> ScoreQuarter: ...

    def shift_velocity(self, offset: int, inplace: bool = False) -> ScoreQuarter: ...

    def start(self) -> float: ...

    def end(self) -> float: ...

    def note_num(self) -> int: ...

    def empty(self) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> ScoreQuarter: ...

class ScoreSecond:
    @overload
    def __init__(self, tpq: int) -> None: ...

    @overload
    def __init__(self, other: ScoreSecond) -> None:
        """Copy constructor"""

    @overload
    def __init__(self, path: Union[str, os.PathLike]) -> None:
        """Load from midi file"""

    def copy(self, deep: bool = True) -> ScoreSecond: ...

    def __copy__(self) -> ScoreSecond:
        """Shallow copy"""

    def __deepcopy__(self, memo: Optional[object] = None, _nil: Optional[object] = None) -> ScoreSecond:
        """Deep copy"""

    def __repr__(self) -> str: ...

    @overload
    def __eq__(self, arg: ScoreSecond, /) -> bool: ...

    @overload
    def __eq__(self, arg: object, /) -> bool: ...

    @overload
    def __ne__(self, arg: ScoreSecond, /) -> bool: ...

    @overload
    def __ne__(self, arg: object, /) -> bool: ...

    def __getstate__(self) -> bytes: ...

    def __setstate__(self, arg: bytes, /) -> None: ...

    @staticmethod
    def from_file(path: Union[str, os.PathLike], format: Optional[str] = None) -> ScoreSecond: ...

    @staticmethod
    def from_midi(data: bytes, sanitize_data: bool = False) -> ScoreSecond:
        """Load from midi bytes with optional payload sanitization"""

    @staticmethod
    def from_abc(abc: str) -> ScoreSecond:
        """Load from abc string"""

    def dump_midi(self, path: Union[str, os.PathLike]) -> None:
        """Dump to midi file"""

    def dumps_midi(self) -> bytes:
        """Dump to midi in memory(bytes)"""

    def dump_abc(self, path: Union[str, os.PathLike], warn: bool = False) -> None:
        """Dump to abc file"""

    def dumps_abc(self, warn: bool = False) -> str:
        """Dump to abc string"""

    @property
    def ticks_per_quarter(self) -> int: ...

    @ticks_per_quarter.setter
    def ticks_per_quarter(self, arg: int, /) -> None: ...

    @property
    def tpq(self) -> int: ...

    @tpq.setter
    def tpq(self, arg: int, /) -> None: ...

    @property
    def tracks(self) -> TrackSecondList: ...

    @tracks.setter
    def tracks(self, arg: TrackSecondList, /) -> None: ...

    @property
    def time_signatures(self) -> TimeSignatureSecondList: ...

    @time_signatures.setter
    def time_signatures(self, arg: TimeSignatureSecondList, /) -> None: ...

    @property
    def key_signatures(self) -> KeySignatureSecondList: ...

    @key_signatures.setter
    def key_signatures(self, arg: KeySignatureSecondList, /) -> None: ...

    @property
    def tempos(self) -> TempoSecondList: ...

    @tempos.setter
    def tempos(self, arg: TempoSecondList, /) -> None: ...

    @property
    def markers(self) -> TextMetaSecondList: ...

    @markers.setter
    def markers(self, arg: TextMetaSecondList, /) -> None: ...

    @property
    def ttype(self) -> Second: ...

    def __use_count(self) -> int: ...

    def to(self, ttype: object, min_dur: Optional[object] = None) -> object:
        """Convert to another time unit"""

    def resample(self, tpq: int, min_dur: Optional[float] = None) -> ScoreTick:
        """Resample to another ticks per quarter"""

    def sort(self, reverse: bool = False, inplace: bool = True) -> ScoreSecond: ...

    def clip(self, start: float, end: float, clip_end: bool = False, inplace: bool = False) -> ScoreSecond: ...

    def trim(self, start: float, end: float, min_overlap: float = 0, start_mode: str = 'remove', end_mode: str = 'remove', inplace: bool = False) -> ScoreSecond: ...

    def shift_time(self, offset: float, inplace: bool = False) -> ScoreSecond: ...

    def shift_pitch(self, offset: int, inplace: bool = False) -> ScoreSecond: ...

    def shift_velocity(self, offset: int, inplace: bool = False) -> ScoreSecond: ...

    def start(self) -> float: ...

    def end(self) -> float: ...

    def note_num(self) -> int: ...

    def empty(self) -> bool: ...

    def adjust_time(self, original_times: Sequence[float], new_times: Sequence[float], inplace: bool = False) -> ScoreSecond: ...

class Synthesizer:
    @overload
    def __init__(self, sf_path: str, sample_rate: int, quality: int) -> None: ...

    @overload
    def __init__(self, sf_path: Union[str, os.PathLike], sample_rate: int, quality: int) -> None: ...

    @overload
    def render(self, score: ScoreTick, stereo: bool = True) -> Annotated[NDArray[numpy.float32], dict(shape=(None, None), order='F')]: ...

    @overload
    def render(self, score: ScoreQuarter, stereo: bool = True) -> Annotated[NDArray[numpy.float32], dict(shape=(None, None), order='F')]: ...

    @overload
    def render(self, score: ScoreSecond, stereo: bool = True) -> Annotated[NDArray[numpy.float32], dict(shape=(None, None), order='F')]: ...

def dump_wav(path: str, data: Annotated[NDArray[numpy.float32], dict(shape=(None, None), order='F', device='cpu')], sample_rate: int, use_int16: bool = True) -> None: ...
