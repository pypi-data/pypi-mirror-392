"""
Device synchronization with smart merge and preservation logic.

This module handles:
1. Fetching devices and scenes from Govee Cloud API
2. Preserving manual user changes (IPs, custom properties)
3. Detecting renamed devices/scenes
4. Generating output files with proper formatting
"""
import logging
import json
import re
from pathlib import Path
from typing import List, Optional, Dict, Any, Tuple
from datetime import datetime

from govee.models import Device, Scene, DIYScene
from govee.api.cloud import devices as cloud_devices
from govee.api.cloud import device_scenes as cloud_builtin_scenes
from govee.api.cloud import device_diy_scenes as cloud_diy_scenes
from govee.api.lan import discovery as lan_discovery

logger = logging.getLogger(__name__)

# Markers for autogenerated content (allows custom code outside markers)
START_MARKER = "# ===== AUTOGENERATED - DO NOT EDIT BELOW THIS LINE ====="
END_MARKER = "# ===== END AUTOGENERATED ====="


class DeviceSync:
    """
    Handles device/scene discovery and synchronization with smart preservation.
    
    Features:
    - Fetches devices and scenes from Govee Cloud API
    - Preserves manual changes (IP addresses, custom properties) from existing file
    - Detects renamed devices/scenes and provides refactoring suggestions
    - Supports custom code outside autogenerated markers
    - Multiple output formats (JSON, Python module)
    """
    
    def __init__(
        self,
        api_key: str,
        base_url: str = "https://openapi.api.govee.com/router/api/v1",
        timeout: float = 10.0
    ):
        """
        Initialize DeviceSync.
        
        Args:
            api_key: Govee API key
            base_url: Base URL for Govee Cloud API
            timeout: Request timeout in seconds
        """
        self.api_key = api_key
        self.base_url = base_url
        self.timeout = timeout
    
    def fetch_devices(
        self,
        filter_names: Optional[List[str]] = None
    ) -> List[Device]:
        """
        Fetch devices from Govee Cloud API.
        
        Args:
            filter_names: Optional list of device names to filter by.
                         If empty or None, fetches ALL devices.
        
        Returns:
            List of Device objects
        """
        logger.info("Fetching devices from Govee Cloud API...")
        
        response = cloud_devices.get_devices(
            api_key=self.api_key,
            base_url=self.base_url,
            timeout=self.timeout
        )

        # Handle both old and new API response formats
        if "data" in response:
            # New API format: data is a list of devices directly
            devices_data = response.get("data", [])
        else:
            # Old API format: data is in payload.devices
            devices_data = response.get("payload", {}).get("devices", [])
        devices = []
        
        for dev_data in devices_data:
            device_name = dev_data.get("deviceName", "")
            
            # Apply name filter if specified
            if filter_names and device_name not in filter_names:
                continue
            
            # Extract capabilities
            capabilities = []
            for cap in dev_data.get("capabilities", []):
                cap_type = cap.get("type", "")
                if cap_type.startswith("devices.capabilities."):
                    cap_name = cap_type.replace("devices.capabilities.", "")
                    capabilities.append(cap_name)
            
            device = Device(
                id=dev_data.get("device"),
                name=device_name,
                sku=dev_data.get("sku"),
                capabilities=capabilities,
                metadata={
                    "type": dev_data.get("type"),
                    "retrievable": dev_data.get("retrievable")
                }
            )
            devices.append(device)
        
        logger.info(f"Fetched {len(devices)} devices")
        return devices
    
    def fetch_diy_scenes(
        self,
        devices: List[Device],
        prefix_filter: Optional[str] = None
    ) -> List[DIYScene]:
        """
        Fetch DIY scenes for all devices.

        DIY Scenes are user-created/customizable scenes, as opposed to Govee's
        built-in default scenes which cannot be altered.

        Args:
            devices: List of devices to fetch DIY scenes for
            prefix_filter: Only include scenes with this prefix (e.g., "SC_")

        Returns:
            List of DIYScene objects
        """
        logger.info(f"Fetching DIY scenes for {len(devices)} devices...")
        
        scenes = []
        seen = set()  # Avoid duplicates
        
        for device in devices:
            try:
                device_scenes = cloud_diy_scenes.get_diy_scenes(
                    api_key=self.api_key,
                    device_id=device.id,
                    sku=device.sku,
                    base_url=self.base_url,
                    timeout=self.timeout
                )
                
                for scene_data in device_scenes:
                    scene_name = scene_data.get("name", "")
                    
                    # Apply prefix filter
                    if prefix_filter and not scene_name.startswith(prefix_filter):
                        continue
                    
                    scene_id = scene_data.get("id")
                    scene_key = (scene_name, scene_id, device.sku)
                    
                    if scene_key in seen:
                        continue
                    
                    seen.add(scene_key)
                    scene = DIYScene(
                        id=scene_id,
                        name=scene_name,
                        sku=device.sku
                    )
                    scenes.append(scene)
                    
            except Exception as e:
                # Check if this is a 400 error (device doesn't support DIY scenes)
                error_msg = str(e)
                if "400" in error_msg:
                    logger.debug(f"Device {device.name} does not support DIY scenes")
                else:
                    logger.warning(f"Failed to fetch scenes for {device.name}: {e}")
                continue
        
        logger.info(f"Fetched {len(scenes)} DIY scenes")
        return scenes

    def fetch_scenes(
        self,
        devices: List[Device],
        prefix_filter: Optional[str] = None
    ) -> List[Scene]:
        """
        Fetch built-in scenes for all devices.

        Built-in scenes are Govee's default scenes (like "Sunrise", "Sunset", "Aurora")
        that users can apply but cannot modify.

        Args:
            devices: List of devices to fetch scenes for
            prefix_filter: Only include scenes with this prefix (optional)

        Returns:
            List of Scene objects
        """
        logger.info(f"Fetching built-in scenes for {len(devices)} devices...")

        scenes = []
        seen = set()  # Avoid duplicates

        for device in devices:
            try:
                device_scenes = cloud_builtin_scenes.get_scenes(
                    api_key=self.api_key,
                    device_id=device.id,
                    sku=device.sku,
                    base_url=self.base_url,
                    timeout=self.timeout
                )

                for scene_data in device_scenes:
                    scene_name = scene_data.get("name", "")

                    # Apply prefix filter
                    if prefix_filter and not scene_name.startswith(prefix_filter):
                        continue

                    scene_value = scene_data.get("value")
                    scene_key = (scene_name, str(scene_value), device.sku)

                    if scene_key in seen:
                        continue

                    seen.add(scene_key)
                    scene = Scene(
                        name=scene_name,
                        value=scene_value,
                        sku=device.sku
                    )
                    scenes.append(scene)

            except Exception as e:
                # Check if this is a 400 error (device doesn't support scenes)
                error_msg = str(e)
                if "400" in error_msg:
                    logger.debug(f"Device {device.name} does not support scenes")
                else:
                    logger.warning(f"Failed to fetch scenes for {device.name}: {e}")
                continue

        logger.info(f"Fetched {len(scenes)} built-in scenes")
        return scenes

    def preserve_manual_changes(
        self,
        new_devices: List[Device],
        existing_file: Path
    ) -> List[Device]:
        """
        Preserve manual user changes from existing file.
        
        Preserves:
        - IP addresses
        - use_lan setting
        - Any custom metadata
        
        Args:
            new_devices: Newly fetched devices
            existing_file: Path to existing configuration file
        
        Returns:
            Devices with preserved manual changes applied
        """
        if not existing_file.exists():
            logger.info("No existing file found, skipping preservation")
            return new_devices
        
        logger.info(f"Preserving manual changes from {existing_file}")
        
        # Load existing devices
        with open(existing_file, "r") as f:
            existing_data = json.load(f)
        
        # Build map of existing devices by ID
        existing_map = {}
        for dev_data in existing_data.get("devices", []):
            dev_id = dev_data.get("id")
            if dev_id:
                existing_map[dev_id] = dev_data
        
        # Apply preserved values to new devices
        preserved_count = 0
        for device in new_devices:
            if device.id in existing_map:
                existing_dev = existing_map[device.id]

                # Preserve IP address
                if existing_dev.get("ip"):
                    device.ip = existing_dev["ip"]
                    preserved_count += 1

                # Preserve custom metadata (merge, don't overwrite)
                existing_metadata = existing_dev.get("metadata", {})
                for key, value in existing_metadata.items():
                    if key not in device.metadata:
                        device.metadata[key] = value
        
        logger.info(f"Preserved manual changes for {preserved_count} devices")
        return new_devices

    def discover_and_update_ips(
        self,
        devices: List[Device],
        timeout: float = 3.0,
        retries: int = 2
    ) -> List[Device]:
        """
        Discover devices on LAN and update their IP addresses.

        Args:
            devices: List of devices to update
            timeout: Discovery timeout in seconds
            retries: Number of discovery attempts

        Returns:
            Updated list of devices with IP addresses
        """
        logger.info("Discovering devices on local network...")

        try:
            # Get device IP mapping from LAN discovery
            ip_map = lan_discovery.get_device_ip_map(timeout=timeout, retries=retries)

            if not ip_map:
                logger.warning("No devices discovered on LAN")
                return devices

            # Update device IPs
            updated_count = 0
            for device in devices:
                if device.id in ip_map:
                    old_ip = device.ip
                    new_ip = ip_map[device.id]

                    if old_ip != new_ip:
                        device.ip = new_ip
                        updated_count += 1
                        logger.info(f"Updated {device.name}: {old_ip or 'None'} -> {new_ip}")
                    else:
                        logger.debug(f"IP unchanged for {device.name}: {new_ip}")

            logger.info(f"Discovered {len(ip_map)} device(s), updated {updated_count} IP address(es)")

        except Exception as e:
            logger.error(f"LAN discovery failed: {e}")
            logger.warning("Continuing without LAN discovery")

        return devices

    def detect_renamed_entities(
        self,
        new_devices: List[Device],
        new_scenes: List[Scene],
        new_diy_scenes: List[DIYScene],
        existing_file: Path
    ) -> Dict[str, List[Tuple[str, str]]]:
        """
        Detect renamed devices, scenes, and DIY scenes.

        Args:
            new_devices: Newly fetched devices
            new_scenes: Newly fetched built-in scenes
            new_diy_scenes: Newly fetched DIY scenes
            existing_file: Path to existing file

        Returns:
            Dict with keys 'devices', 'scenes', and 'diy_scenes', each containing list of (old_name, new_name) tuples
        """
        if not existing_file.exists():
            return {"devices": [], "scenes": [], "diy_scenes": []}
        
        logger.info("Detecting renamed devices and scenes...")
        
        with open(existing_file, "r") as f:
            existing_data = json.load(f)
        
        renamed_devices = []
        renamed_scenes = []
        
        # Check devices (match by ID, detect name change)
        existing_devices_by_id = {
            d.get("id"): d.get("name")
            for d in existing_data.get("devices", [])
            if d.get("id")
        }
        
        for device in new_devices:
            if device.id in existing_devices_by_id:
                old_name = existing_devices_by_id[device.id]
                if old_name != device.name:
                    renamed_devices.append((old_name, device.name))
        
        # Check scenes (match by ID, detect name change)
        existing_scenes_by_id = {
            (s.get("id"), s.get("sku")): s.get("name")
            for s in existing_data.get("scenes", [])
            if s.get("id") and s.get("sku")
        }
        
        for scene in new_scenes:
            key = (scene.id, scene.sku)
            if key in existing_scenes_by_id:
                old_name = existing_scenes_by_id[key]
                if old_name != scene.name:
                    renamed_scenes.append((old_name, scene.name))
        
        if renamed_devices:
            logger.warning(f"Detected {len(renamed_devices)} renamed devices")
        if renamed_scenes:
            logger.warning(f"Detected {len(renamed_scenes)} renamed scenes")

        # For now, just return empty lists for built-in scenes and DIY scenes
        # Full rename detection can be implemented later
        return {
            "devices": renamed_devices,
            "scenes": [],  # Built-in scenes rename detection not yet implemented
            "diy_scenes": renamed_scenes  # DIY scenes (was just "scenes" before)
        }
    
    def write_json_output(
        self,
        output_path: Path,
        devices: List[Device],
        scenes: List[Scene],
        diy_scenes: List[DIYScene],
        collections: Optional[Dict[str, List[str]]] = None
    ) -> None:
        """
        Write devices, scenes, and DIY scenes to JSON file.

        Args:
            output_path: Path to output file
            devices: List of devices
            scenes: List of built-in scenes
            diy_scenes: List of DIY scenes
            collections: Optional dict of collection_name -> [device_names]
        """
        logger.info(f"Writing JSON output to {output_path}")

        # Sort alphabetically by name
        sorted_devices = sorted(devices, key=lambda d: d.name.lower())
        sorted_scenes = sorted(scenes, key=lambda s: s.name.lower())
        sorted_diy_scenes = sorted(diy_scenes, key=lambda s: s.name.lower())

        data = {
            "metadata": {
                "version": "1.0.0",
                "synced_at": datetime.now().isoformat(),
                "total_devices": len(sorted_devices),
                "total_scenes": len(sorted_scenes),
                "total_diy_scenes": len(sorted_diy_scenes)
            },
            "devices": [d.to_dict() for d in sorted_devices],
            "scenes": [s.to_dict() for s in sorted_scenes],
            "diy_scenes": [s.to_dict() for s in sorted_diy_scenes],
            "collections": collections or {}
        }

        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, "w") as f:
            json.dump(data, f, indent=2)

        logger.info(f"Successfully wrote {len(sorted_devices)} devices and {len(sorted_diy_scenes)} DIY scenes to {output_path}")

    def _sanitize_identifier(self, name: str) -> str:
        """
        Convert a device/scene name to a valid Python identifier.

        Examples:
            "Ground2 Machine" -> "ground2_machine"
            "SC Bulb Cerebro" -> "sc_bulb_cerebro"
            "Garage-Left" -> "garage_left"
            "Backyard (New)" -> "backyard_new"
        """
        # Convert to lowercase
        identifier = name.lower()

        # Replace spaces, hyphens, and other non-alphanumeric chars with underscore
        identifier = re.sub(r'[^a-z0-9_]', '_', identifier)

        # Remove consecutive underscores
        identifier = re.sub(r'_+', '_', identifier)

        # Remove leading/trailing underscores
        identifier = identifier.strip('_')

        # Ensure it doesn't start with a digit
        if identifier and identifier[0].isdigit():
            identifier = f"device_{identifier}"

        return identifier

    def write_python_modules(
        self,
        output_dir: Path,
        devices: List[Device],
        scenes: List[Scene],
        diy_scenes: List[DIYScene]
    ) -> Dict[str, Path]:
        """
        Write devices, scenes, and DIY scenes to separate Python module files.

        This generates three files:
        - govee_devices.py: Device class instances as variables
        - govee_scenes.py: Scene class instances as variables (built-in scenes)
        - govee_diy_scenes.py: DIYScene class instances as variables (user-created scenes)

        Args:
            output_dir: Directory to write modules to
            devices: List of devices
            scenes: List of built-in scenes
            diy_scenes: List of DIY scenes

        Returns:
            Dict with keys 'devices', 'scenes', and 'diy_scenes' mapping to generated file paths
        """
        logger.info(f"Writing Python modules to {output_dir}")

        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        devices_file = output_dir / "govee_devices.py"
        scenes_file = output_dir / "govee_scenes.py"
        diy_scenes_file = output_dir / "govee_diy_scenes.py"

        # Sort alphabetically
        sorted_devices = sorted(devices, key=lambda d: d.name.lower())
        sorted_scenes = sorted(scenes, key=lambda s: s.name.lower())
        sorted_diy_scenes = sorted(diy_scenes, key=lambda s: s.name.lower())

        # Generate devices module
        devices_code = self._generate_devices_module(sorted_devices)
        with open(devices_file, "w") as f:
            f.write(devices_code)
        logger.info(f"Wrote {len(sorted_devices)} devices to {devices_file}")

        # Generate built-in scenes module
        scenes_code = self._generate_scenes_module(sorted_scenes)
        with open(scenes_file, "w") as f:
            f.write(scenes_code)
        logger.info(f"Wrote {len(sorted_scenes)} built-in scenes to {scenes_file}")

        # Generate DIY scenes module
        diy_scenes_code = self._generate_diy_scenes_module(sorted_diy_scenes)
        with open(diy_scenes_file, "w") as f:
            f.write(diy_scenes_code)
        logger.info(f"Wrote {len(sorted_diy_scenes)} DIY scenes to {diy_scenes_file}")

        return {
            "devices": devices_file,
            "scenes": scenes_file,
            "diy_scenes": diy_scenes_file
        }

    def _generate_devices_module(self, devices: List[Device]) -> str:
        """Generate Python code for devices module."""
        lines = []

        # Header
        lines.append('"""')
        lines.append("Auto-generated Govee device instances.")
        lines.append("")
        lines.append("Generated at: " + datetime.now().isoformat())
        lines.append("")
        lines.append("Usage:")
        lines.append("    from govee_devices import ground2_machine, bulb_cerebro")
        lines.append("    from govee.client import GoveeClient")
        lines.append("")
        lines.append("    client = GoveeClient(api_key='YOUR_KEY')")
        lines.append("    client.power(ground2_machine, True)")
        lines.append('"""')
        lines.append("")
        lines.append("from govee.models import Device")
        lines.append("")
        lines.append("")

        # Generate device instances
        seen_identifiers = set()
        device_map = []  # Track (identifier, device) for __all__

        for device in devices:
            identifier = self._sanitize_identifier(device.name)

            # Handle duplicate identifiers
            if identifier in seen_identifiers:
                suffix = 2
                while f"{identifier}_{suffix}" in seen_identifiers:
                    suffix += 1
                identifier = f"{identifier}_{suffix}"

            seen_identifiers.add(identifier)
            device_map.append((identifier, device))

            # Generate device instance
            lines.append(f"# {device.name}")
            lines.append(f"{identifier} = Device(")
            lines.append(f'    id="{device.id}",')
            lines.append(f'    name="{device.name}",')
            lines.append(f'    sku="{device.sku}",')

            if device.ip:
                lines.append(f'    ip="{device.ip}",')
            else:
                lines.append('    ip=None,')

            if device.capabilities:
                caps_str = ", ".join(f'"{c}"' for c in device.capabilities)
                lines.append(f'    capabilities=[{caps_str}],')
            else:
                lines.append('    capabilities=[],')

            if device.metadata:
                # Format metadata on one line if short, multiple lines if long
                metadata_str = str(device.metadata)
                if len(metadata_str) < 80:
                    lines.append(f'    metadata={metadata_str}')
                else:
                    lines.append('    metadata={')
                    for key, value in device.metadata.items():
                        if isinstance(value, str):
                            lines.append(f'        "{key}": "{value}",')
                        else:
                            lines.append(f'        "{key}": {value},')
                    lines.append('    }')

            lines.append(")")
            lines.append("")

        # Generate __all__ export list
        lines.append("")
        lines.append("# Export all devices")
        lines.append("__all__ = [")
        for identifier, _ in device_map:
            lines.append(f'    "{identifier}",')
        lines.append("]")
        lines.append("")

        # Generate helper dictionary for lookup
        lines.append("")
        lines.append("# Device lookup by name (case-insensitive)")
        lines.append("DEVICES_BY_NAME = {")
        for identifier, device in device_map:
            lines.append(f'    "{device.name}": {identifier},')
        lines.append("}")
        lines.append("")

        # Generate helper dictionary for lookup by ID
        lines.append("# Device lookup by ID")
        lines.append("DEVICES_BY_ID = {")
        for identifier, device in device_map:
            lines.append(f'    "{device.id}": {identifier},')
        lines.append("}")
        lines.append("")

        return "\n".join(lines)

    def _generate_scenes_module(self, scenes: List[Scene]) -> str:
        """Generate Python code for built-in scenes module."""
        lines = []

        # Header
        lines.append('"""')
        lines.append("Auto-generated Govee built-in scene instances.")
        lines.append("")
        lines.append("Built-in Scenes are Govee's default scenes (like 'Sunrise', 'Sunset', 'Aurora')")
        lines.append("that users can apply but cannot modify.")
        lines.append("")
        lines.append("Generated at: " + datetime.now().isoformat())
        lines.append("")
        lines.append("Usage:")
        lines.append("    from govee_scenes import sunrise")
        lines.append("    from govee_devices import ground2_machine")
        lines.append("    from govee.client import GoveeClient")
        lines.append("")
        lines.append("    client = GoveeClient(api_key='YOUR_KEY')")
        lines.append("    client.set_scene(ground2_machine, sunrise)")
        lines.append('"""')
        lines.append("")
        lines.append("from govee.models import Scene")
        lines.append("")
        lines.append("")

        # Generate scene instances
        seen_identifiers = set()
        scene_map = []  # Track (identifier, scene) for __all__

        for scene in scenes:
            identifier = self._sanitize_identifier(scene.name)

            # Handle duplicate identifiers
            if identifier in seen_identifiers:
                suffix = 2
                while f"{identifier}_{suffix}" in seen_identifiers:
                    suffix += 1
                identifier = f"{identifier}_{suffix}"

            seen_identifiers.add(identifier)
            scene_map.append((identifier, scene))

            # Generate scene instance
            lines.append(f"# {scene.name}")
            lines.append(f"{identifier} = Scene(")
            lines.append(f'    name="{scene.name}",')
            lines.append(f'    value={scene.value},')
            lines.append(f'    sku="{scene.sku}"')

            if scene.metadata:
                lines.append(f'    metadata={scene.metadata}')

            lines.append(")")
            lines.append("")

        # Generate __all__ export list
        lines.append("")
        lines.append("# Export all scenes")
        lines.append("__all__ = [")
        for identifier, _ in scene_map:
            lines.append(f'    "{identifier}",')
        lines.append("]")
        lines.append("")

        # Generate helper dictionary for lookup
        lines.append("")
        lines.append("# Scene lookup by name (case-insensitive)")
        lines.append("SCENES_BY_NAME = {")
        for identifier, scene in scene_map:
            lines.append(f'    "{scene.name.lower()}": {identifier},')
        lines.append("}")
        lines.append("")

        # Generate SKU lookup dictionary
        lines.append("# Scene lookup by SKU")
        lines.append("SCENES_BY_SKU = {}")
        lines.append("for scene in __all__:")
        lines.append("    scene_obj = globals()[scene]")
        lines.append("    if scene_obj.sku not in SCENES_BY_SKU:")
        lines.append("        SCENES_BY_SKU[scene_obj.sku] = []")
        lines.append("    SCENES_BY_SKU[scene_obj.sku].append(scene_obj)")
        lines.append("")

        return "\n".join(lines)

    def _generate_diy_scenes_module(self, diy_scenes: List[DIYScene]) -> str:
        """Generate Python code for DIY scenes module."""
        lines = []

        # Header
        lines.append('"""')
        lines.append("Auto-generated Govee DIY scene instances.")
        lines.append("")
        lines.append("DIY Scenes are user-created/customizable scenes, as opposed to Govee's")
        lines.append("built-in default scenes which cannot be altered.")
        lines.append("")
        lines.append("Generated at: " + datetime.now().isoformat())
        lines.append("")
        lines.append("Usage:")
        lines.append("    from govee_diy_scenes import sc_bulb_cerebro")
        lines.append("    from govee_devices import ground2_machine")
        lines.append("    from govee.client import GoveeClient")
        lines.append("")
        lines.append("    client = GoveeClient(api_key='YOUR_KEY')")
        lines.append("    client.set_scene(ground2_machine, sc_bulb_cerebro)")
        lines.append('"""')
        lines.append("")
        lines.append("from govee.models import DIYScene")
        lines.append("")
        lines.append("")

        # Generate DIY scene instances
        seen_identifiers = set()
        diy_scene_map = []  # Track (identifier, diy_scene) for __all__

        for diy_scene in diy_scenes:
            identifier = self._sanitize_identifier(diy_scene.name)

            # Handle duplicate identifiers
            if identifier in seen_identifiers:
                suffix = 2
                while f"{identifier}_{suffix}" in seen_identifiers:
                    suffix += 1
                identifier = f"{identifier}_{suffix}"

            seen_identifiers.add(identifier)
            diy_scene_map.append((identifier, diy_scene))

            # Generate DIY scene instance
            lines.append(f"# {diy_scene.name}")
            lines.append(f"{identifier} = DIYScene(")
            lines.append(f'    id={diy_scene.id},')
            lines.append(f'    name="{diy_scene.name}",')
            lines.append(f'    sku="{diy_scene.sku}"')

            if diy_scene.metadata:
                lines.append(f'    metadata={diy_scene.metadata}')

            lines.append(")")
            lines.append("")

        # Generate __all__ export list
        lines.append("")
        lines.append("# Export all DIY scenes")
        lines.append("__all__ = [")
        for identifier, _ in diy_scene_map:
            lines.append(f'    "{identifier}",')
        lines.append("]")
        lines.append("")

        # Generate helper dictionary for lookup
        lines.append("")
        lines.append("# DIY scene lookup by name (case-insensitive)")
        lines.append("DIY_SCENES_BY_NAME = {")
        for identifier, diy_scene in diy_scene_map:
            lines.append(f'    "{diy_scene.name}": {identifier},')
        lines.append("}")
        lines.append("")

        # Generate helper dictionary for lookup by ID and SKU
        lines.append("# DIY scene lookup by (ID, SKU) tuple")
        lines.append("DIY_SCENES_BY_ID = {")
        for identifier, diy_scene in diy_scene_map:
            lines.append(f'    ({diy_scene.id}, "{diy_scene.sku}"): {identifier},')
        lines.append("}")
        lines.append("")

        return "\n".join(lines)

    def sync_to_file(
        self,
        output_path: Path,
        filter_names: Optional[List[str]] = None,
        preserve_manual: bool = True,
        scene_prefix: Optional[str] = None,
        collections: Optional[Dict[str, List[str]]] = None,
        detect_renames: bool = True,
        discover_lan: bool = True,
        lan_timeout: float = 3.0,
        generate_python: bool = True,
        python_output_dir: Optional[Path] = None
    ) -> Dict[str, Any]:
        """
        Complete sync workflow: fetch, preserve, detect renames, discover IPs, write output.

        Args:
            output_path: Path to output file (for JSON, used for preservation detection)
            filter_names: Device names to filter (empty=all)
            preserve_manual: Preserve manual changes from existing file
            scene_prefix: Scene name prefix filter (e.g., "SC_")
            collections: Collection definitions
            detect_renames: Detect and report renamed entities
            discover_lan: Automatically discover device IPs on local network
            lan_timeout: Timeout for LAN discovery (seconds)
            generate_python: Generate Python module files (default: True)
            python_output_dir: Directory for Python modules (default: same as output_path parent)

        Returns:
            Dict with sync results and rename detection info
        """
        logger.info("Starting device sync...")

        # Step 1: Fetch devices
        devices = self.fetch_devices(filter_names=filter_names)

        # Step 2: Fetch built-in scenes
        scenes = self.fetch_scenes(devices, prefix_filter=scene_prefix)

        # Step 3: Fetch DIY scenes
        diy_scenes = self.fetch_diy_scenes(devices, prefix_filter=scene_prefix)

        # Step 4: Preserve manual changes (check both JSON and Python files)
        if preserve_manual:
            # Try to preserve from JSON first
            if output_path.exists():
                devices = self.preserve_manual_changes(devices, output_path)
            # Could also check Python modules for manual edits in the future

        # Step 5: Discover LAN IPs
        if discover_lan:
            devices = self.discover_and_update_ips(devices, timeout=lan_timeout, retries=2)

        # Step 6: Detect renames
        renames = {}
        if detect_renames and output_path.exists():
            renames = self.detect_renamed_entities(devices, scenes, diy_scenes, output_path)

        # Step 7: Write outputs
        # JSON output (kept for backwards compatibility and as backup)
        self.write_json_output(output_path, devices, scenes, diy_scenes, collections)

        # Python modules output (new primary format)
        python_files = {}
        if generate_python:
            if python_output_dir is None:
                python_output_dir = output_path.parent
            python_files = self.write_python_modules(python_output_dir, devices, scenes, diy_scenes)

        result = {
            "devices_count": len(devices),
            "scenes_count": len(scenes),
            "diy_scenes_count": len(diy_scenes),
            "renamed_devices": renames.get("devices", []),
            "renamed_scenes": renames.get("scenes", []),
            "renamed_diy_scenes": renames.get("diy_scenes", []),
            "output_path": str(output_path),
            "python_devices_file": str(python_files.get("devices", "")),
            "python_scenes_file": str(python_files.get("scenes", "")),
            "python_diy_scenes_file": str(python_files.get("diy_scenes", ""))
        }

        logger.info("Sync complete!")
        return result
