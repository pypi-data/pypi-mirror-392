# -*- coding: utf-8 -*-
#
# Copyright (C) GrimoireLab Contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

from __future__ import annotations

import logging
import typing

import rq.job
import structlog

if typing.TYPE_CHECKING:
    from typing import Any
    from logging import LogRecord
    from rq.types import FunctionReferenceType


logger = structlog.get_logger(__name__)


class GrimoireLabJob(rq.job.Job):
    """Abstract class to execute jobs for GrimoireLab.

    This class is a wrapper around the RQ job class to run jobs
    for GrimoireLab. It adds some extra functionality such as
    logging and progress handling. The log entries generated
    by the job can be accessed through the property `log`.

    To create an instance of this class, you must use the
    classmethod `create`. This method ensures that all the elements
    needed to run a job are properly set up.
    """

    # Default packages to log
    PACKAGES_TO_LOG = [__name__, "chronicler", "perceval", "rq"]

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._loggers = self.PACKAGES_TO_LOG
        self.meta["log"] = []
        self.meta["progress"] = None

    @classmethod
    def create(
        cls,
        func: FunctionReferenceType,
        loggers: list[str] | None = None,
        *args,
        **kwargs,
    ) -> GrimoireLabJob:
        """Creates a new GrimoireLabJob instance.

        :param loggers: list of packages or modules to log; by default,
            the job will log the messages generated by the packages
            set on `PACKAGES_TO_LOG`. This list will be overridden
            by any list passed as argument.
        """
        # Make sure meta parameters are initialized.
        # If not given, they will be overridden on the initialization
        # of the Job class parent.
        kwargs["meta"] = {
            "log": [],
            "progress": None,
        }
        job = super().create(func, *args, **kwargs)
        job._loggers = loggers if loggers else job.PACKAGES_TO_LOG

        return job

    @property
    def progress(self) -> Any:
        """Returns the progress of the job."""

        return self.meta.get("progress", None)

    @progress.setter
    def progress(self, value: Any) -> None:
        """Set the progress of the job."""

        self.meta["progress"] = value
        self.save_meta()

    @property
    def job_log(self) -> list[dict[str, Any]] | None:
        """Returns the log of the job."""

        return self.meta.get("log", [])

    def add_log(self, log: dict[str, Any]) -> None:
        """Add a log entry."""

        self.meta["log"].append(log)
        self.save_meta()

    def _add_log_handler(self):
        """Add the log handler to the job."""

        self._job_logger = JobLogHandler(self)

        for logger_name in self._loggers:
            logger_job = logging.getLogger(logger_name)
            logger_job.setLevel(logging.INFO)
            logger_job.addHandler(self._job_logger)

    def _remove_log_handler(self):
        """Remove the log handler from the job"""

        for logger_name in self._loggers:
            logger_job = logging.getLogger(logger_name)
            logger_job.removeHandler(self._job_logger)

    def _execute(self) -> Any:
        """Run the job."""

        try:
            self._add_log_handler()
            return super()._execute()
        except Exception as ex:
            logger.error("job exception", job_id=self.id, exc_info=ex)
            raise ex
        finally:
            self._remove_log_handler()


class JobLogHandler(logging.StreamHandler):
    """Handler class for the job logs.

    Log entries will be stored in the job metadata.

    :param job: job to store the logs
    """

    def __init__(self, job: GrimoireLabJob) -> None:
        logging.StreamHandler.__init__(self)
        self.job = job

    def emit(self, record: LogRecord) -> None:
        """Emit a log entry storing it in the job metadata.

        :param record: log record to emit
        """
        log = {
            "created": record.created,
            "msg": self.format(record),
            "module": record.module,
            "level": self.level,
        }
        self.job.add_log(log)
