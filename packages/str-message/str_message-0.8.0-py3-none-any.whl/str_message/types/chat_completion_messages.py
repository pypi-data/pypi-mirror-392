import abc
from typing import List, Literal, Optional, TypeAlias, Union

from pydantic import BaseModel, Field, TypeAdapter


class ChatCompletionContentPartText(BaseModel):
    text: str = Field(description="The text content.")
    type: Literal["text"] = Field(description="The type of the content part.")


class FileFile(BaseModel):
    file_data: Optional[str] = Field(
        default=None,
        description="The base64 encoded file data, used when passing the file to the model as a string.",  # noqa: E501
    )
    file_id: Optional[str] = Field(
        default=None,
        description="The ID of an uploaded file to use as input.",  # noqa: E501
    )
    filename: Optional[str] = Field(
        default=None,
        description="The name of the file, used when passing the file to the model as a string.",  # noqa: E501
    )


class File(BaseModel):
    file: FileFile
    type: Literal["file"] = Field(
        description="The type of the content part. Always `file`."
    )


class ImageURL(BaseModel):
    url: str = Field(
        description="Either a URL of the image or the base64 encoded image data."
    )
    detail: Optional[Literal["auto", "low", "high"]] = Field(
        default=None,
        description="Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision#low-or-high-fidelity-image-understanding).",  # noqa: E501
    )


class ChatCompletionContentPartImage(BaseModel):
    image_url: ImageURL
    type: Literal["image_url"] = Field(description="The type of the content part.")


class InputAudio(BaseModel):
    data: str = Field(description="Base64 encoded audio data.")
    format: Literal["wav", "mp3"] = Field(
        description='The format of the encoded audio data. Currently supports "wav" and "mp3".'  # noqa: E501
    )


class ChatCompletionContentPartInputAudio(BaseModel):
    input_audio: InputAudio
    type: Literal["input_audio"] = Field(
        description="The type of the content part. Always `input_audio`."
    )


class ChatCompletionContentPartRefusal(BaseModel):
    refusal: str = Field(description="The refusal message generated by the model.")
    type: Literal["refusal"] = Field(description="The type of the content part.")


class Function(BaseModel):
    arguments: str = Field(
        description="The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate eters not defined by your function schema. Validate the arguments in your code before calling your function."  # noqa: E501
    )
    name: str = Field(description="The name of the function to call.")


class ChatCompletionMessageFunctionToolCall(BaseModel):
    id: str = Field(description="The ID of the tool call.")
    function: Function = Field(description="The function that the model called.")
    type: Literal["function"] = Field(
        description="The type of the tool. Currently, only `function` is supported."
    )


class Custom(BaseModel):
    input: str = Field(
        description="The input for the custom tool call generated by the model."
    )
    name: str = Field(description="The name of the custom tool to call.")


class ChatCompletionMessageCustomToolCall(BaseModel):
    id: str = Field(description="The ID of the tool call.")
    custom: Custom = Field(description="The custom tool that the model called.")
    type: Literal["custom"] = Field(
        description="The type of the tool. Always `custom`."
    )


class Audio(BaseModel):
    id: str = Field(
        description="Unique identifier for a previous audio response from the model."
    )


class FunctionCall(BaseModel):
    arguments: str = Field(
        description="The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate eters not defined by your function schema. Validate the arguments in your code before calling your function."  # noqa: E501
    )
    name: str = Field(description="The name of the function to call.")


ChatCompletionContentPart: TypeAlias = Union[
    ChatCompletionContentPartText,
    ChatCompletionContentPartImage,
    ChatCompletionContentPartInputAudio,
    File,
]

ContentArrayOfContentPart: TypeAlias = Union[
    ChatCompletionContentPartText, ChatCompletionContentPartRefusal
]


ChatCompletionMessageToolCallUnion: TypeAlias = Union[
    ChatCompletionMessageFunctionToolCall, ChatCompletionMessageCustomToolCall
]


def chat_cmpl_content_to_str(
    content: Optional[Union[str, List[ContentArrayOfContentPart]]],
) -> str:
    from str_message import (
        CONTENT_AUDIO_EXPR,
        CONTENT_FILE_FILENAME_EXPR,
        CONTENT_FILE_ID_EXPR,
        CONTENT_FILE_URL_EXPR,
        CONTENT_IMAGE_URL_EXPR,
    )

    if content is None:
        return ""

    elif isinstance(content, str):
        return content

    elif isinstance(content, list):
        parts: list[str] = []
        for part in content:
            if isinstance(part, ChatCompletionContentPartText):
                parts.append(part.text)

            elif isinstance(part, ChatCompletionContentPartImage):
                parts.append(
                    CONTENT_IMAGE_URL_EXPR.format(image_url=part.image_url.url)
                )

            elif isinstance(part, ChatCompletionContentPartInputAudio):
                parts.append(
                    CONTENT_AUDIO_EXPR.format(input_audio=part.input_audio.data)
                )

            elif isinstance(part, File):
                if part.file.file_id:
                    parts.append(CONTENT_FILE_ID_EXPR.format(file_id=part.file.file_id))
                elif part.file.file_data:
                    parts.append(
                        CONTENT_FILE_URL_EXPR.format(file_data=part.file.file_data)
                    )
                elif part.file.filename:
                    parts.append(
                        CONTENT_FILE_FILENAME_EXPR.format(filename=part.file.filename)
                    )
                else:
                    raise ValueError(f"Unsupported file content: {part}")

            elif isinstance(part, ChatCompletionContentPartRefusal):
                parts.append(f"Refusal: {part.refusal}")

            else:
                raise ValueError(
                    f"Unsupported content part type: {type(part).__name__}"
                )

        return "\n\n".join(parts)

    else:
        raise ValueError(f"Unsupported content type: {type(content).__name__}")


# ---


class ChatCompletionMessageUtils(abc.ABC):
    content: Optional[Union[str, List[ContentArrayOfContentPart]]]

    def str_content(self) -> str:
        return chat_cmpl_content_to_str(self.content)


class ChatCompletionDeveloperMessage(BaseModel, ChatCompletionMessageUtils):
    content: Union[str, List[ChatCompletionContentPartText]] = Field(
        description="The contents of the developer message."
    )
    role: Literal["developer"] = Field(
        description="The role of the messages author, in this case `developer`."
    )
    name: Optional[str] = Field(
        default=None,
        description="An optional name for the participant. Provides the model information to differentiate between participants of the same role.",  # noqa: E501
    )


class ChatCompletionSystemMessage(BaseModel, ChatCompletionMessageUtils):
    content: Union[str, List[ChatCompletionContentPartText]] = Field(
        description="The contents of the system message."
    )
    role: Literal["system"] = Field(
        description="The role of the messages author, in this case `system`."
    )
    name: Optional[str] = Field(
        default=None,
        description="An optional name for the participant. Provides the model information to differentiate between participants of the same role.",  # noqa: E501
    )


class ChatCompletionUserMessage(BaseModel, ChatCompletionMessageUtils):
    content: Union[str, List[ChatCompletionContentPart]] = Field(
        description="The contents of the user message."
    )
    role: Literal["user"] = Field(
        description="The role of the messages author, in this case `user`."
    )
    name: Optional[str] = Field(
        default=None,
        description="An optional name for the participant. Provides the model information to differentiate between participants of the same role.",  # noqa: E501
    )


class ChatCompletionAssistantMessage(BaseModel, ChatCompletionMessageUtils):
    role: Literal["assistant"] = Field(
        description="The role of the messages author, in this case `assistant`."
    )
    audio: Optional[Audio] = Field(
        default=None,
        description="Data about a previous audio response from the model. [Learn more](https://platform.openai.com/docs/guides/audio).",  # noqa: E501
    )
    content: Optional[Union[str, List[ContentArrayOfContentPart]]] = Field(
        default=None,
        description="The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.",  # noqa: E501
    )
    function_call: Optional[FunctionCall] = Field(
        default=None,
        description="Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.",  # noqa: E501
    )
    name: Optional[str] = Field(
        default=None,
        description="An optional name for the participant. Provides the model information to differentiate between participants of the same role.",  # noqa: E501
    )
    refusal: Optional[str] = Field(
        default=None, description="The refusal message by the assistant."
    )
    tool_calls: Optional[List[ChatCompletionMessageToolCallUnion]] = Field(
        default=None,
        description="The tool calls generated by the model, such as function calls.",
    )


class ChatCompletionToolMessage(BaseModel, ChatCompletionMessageUtils):
    content: Union[str, List[ChatCompletionContentPartText]] = Field(
        description="The contents of the tool message."
    )
    role: Literal["tool"] = Field(
        description="The role of the messages author, in this case `tool`."
    )
    tool_call_id: str = Field(
        description="Tool call that this message is responding to."
    )


class ChatCompletionFunctionMessage(BaseModel, ChatCompletionMessageUtils):
    content: Optional[str] = Field(description="The contents of the function message.")
    name: str = Field(description="The name of the function to call.")
    role: Literal["function"] = Field(
        description="The role of the messages author, in this case `function`."
    )


ChatCompletionMessage = Union[
    ChatCompletionDeveloperMessage,
    ChatCompletionSystemMessage,
    ChatCompletionUserMessage,
    ChatCompletionAssistantMessage,
    ChatCompletionToolMessage,
    ChatCompletionFunctionMessage,
]
ChatCompletionMessageAdapter = TypeAdapter[ChatCompletionMessage](ChatCompletionMessage)
