import six
from typing import Dict, Optional, Union, Tuple
from six.moves.urllib.parse import urlencode
from urllib.parse import urljoin
import requests

from .version import __version__
from .exception import ApiException
from .response import Response


class Request:
    # Timeout in seconds
    _request_timeout: Union[Tuple[int, int], int] = 30

    def __init__(self, api_key, api_host ='http://api.example.com', user_agent='Api Python client'):
        '''
        Create Request client object

        :param api_key:
            String api key.
        :param api_host:
            server api host

        '''
        if not api_key:
            raise Exception("No set API KEY")

        self.api_host = api_host
        self.api_key = api_key
        self.user_agent = user_agent

        self.version = __version__

    def request(self, path: str, method: str, body: Union[bytes, Dict[str, str]] = {}, query_params: Dict[str, str]={}, headers: Dict[str, str]={}) -> Response:
        '''
        Send request to REST server

        :param path:
            REST path on server
        :param method:
            HTTP METHOD [GET,POST,PUT,DELETE]
        :param params:
            dictionary of parameters to send
        :param headers:
            dictionary of headers to send
        :return:
            RESTResponse object
        '''
        assert(isinstance(headers,dict))
        assert(isinstance(query_params,dict))

        headers['Authorization'] = 'Bearer '+self.api_key
        if 'Content-Type' not in headers:
            headers['Content-Type'] = 'application/json'
        headers['User-Agent'] = self.user_agent + ' ' + self.version
        headers['Accept-Encoding'] = 'gzip'

        #production url
        url = urljoin(self.api_host, path)

        return self.execute(method=method, url=url, headers=headers, body=body, query_params=query_params)

    def execute(
            self,
            method: str,
            url: str,
            query_params: Optional[Dict[str, str]]=None,
            headers: Optional[Dict[str, str]]=None,
            body: Optional[Union[bytes, Dict]] = None,
            post_params=None,
    ) -> Response:
        '''
        Execute raw request to server

        :param method:
            Http method
        :param url:
            Absolute url https://example.com
        :param query_params:
            Dict with with query params
        :param headers:
            Dict with headers
        :param body:
            Raw body for post query
        :param post_params:
            When send application/x-www-form query set this attribute
        :return: Response
        '''

        #get method
        method = method.upper()
        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',
                          'PATCH', 'OPTIONS']

        if post_params and body:
            raise ValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        #timeout
        timeout: Tuple[int, int] = (2, 5)
        if self._request_timeout is not None:
            if isinstance(self._request_timeout, (int, ) if six.PY3 else (int)):  # noqa: E501,F821
                timeout = (2, self._request_timeout)
            elif (isinstance(self._request_timeout, tuple) and
                  len(self._request_timeout) == 2):
                timeout = (self._request_timeout[0], self._request_timeout[1])

        #set default content type
        if 'Content-Type' not in headers:
            headers['Content-Type'] = 'application/json'

        #run request
        try:
            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:

                if query_params:
                    url += '?' + urlencode(query_params)

                if 'json' in headers['Content-Type']:
                    r = requests.request(
                        method, url,
                        json = body,
                        timeout=timeout,
                        headers=headers)
                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
                    r = requests.request(
                        method, url,
                        params=post_params,
                        timeout=timeout,
                        headers=headers)
                elif headers['Content-Type'] == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = requests.request(
                        method, url,
                        params=post_params,
                        timeout=timeout,
                        headers=headers)
                # Pass a `string` parameter directly in the body to support
                # other content types than Json when `body` argument is
                # provided in serialized form

                elif isinstance(body, bytes):
                    r = requests.request(
                        method, url,
                        data=body,
                        timeout=timeout,
                        headers=headers)
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For `GET`, `HEAD`
            else:
                r = requests.request(
                    method,
                    url,
                    params=query_params,
                    timeout=timeout,
                    headers=headers
                )

        except Exception as e:
            msg = "{0}\n{1}".format(type(e).__name__, str(e))
            raise ApiException(status=0, reason=msg)

        response = Response(r)

        if response.status_code == 404:
            raise ApiException('Error 404. Not found')

        if response.status_code == 401:
            raise ApiException("Error 401. Cant authorize. Check your api token")

        if response.status_code == 500:
            raise ApiException("Internal error")

        if not 200 <= response.status_code <= 400:
            raise ApiException(http_resp=response)

        return response

    def info(self) -> Response:
        ''''
        Get info about account. Return info about free requests etc.
        '''
        return self.request('info', 'GET', {})


