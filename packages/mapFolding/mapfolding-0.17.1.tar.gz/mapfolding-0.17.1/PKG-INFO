Metadata-Version: 2.4
Name: mapFolding
Version: 0.17.1
Summary: Map folding, meanders, stamp folding, semi-meanders. Experiment with algorithm transformations, and analyze computational states.
Author-email: Hunter Hogan <HunterHogan@pm.me>
License: CC-BY-NC-4.0
Project-URL: Donate, https://www.patreon.com/integrated
Project-URL: Homepage, https://github.com/hunterhogan/mapFolding
Project-URL: Issues, https://github.com/hunterhogan/mapFolding/issues
Project-URL: Repository, https://github.com/hunterhogan/mapFolding.git
Keywords: A000136,A000560,A000682,A001010,A001011,A001415,A001416,A001417,A001418,A005315,A005316,A007822,A178961,A195646,A223094,A259702,A301620,AST manipulation,JIT compilation,Numba optimization,OEIS,Python optimization,abstract syntax tree,algorithmic combinatorics,algorithmic optimization,arch configurations,automated code generation,bit-packed arrays,bitwise state machines,cache-efficient algorithms,closed meandric numbers,code generation,code optimization,code synthesis,code transformation,codon optimization,combinatorial computing,combinatorial enumeration,combinatorial geometry,combinatorial mathematics,combinatorial problem solver,combinatorics,computational combinatorics,computational geometry,crossing patterns,curve crossings,dataclass transformation,discrete mathematics,dynamic compilation,enumerative combinatorics,folding pattern enumeration,folding problems,high-performance computing,integer sequences,just-in-time compilation,kernel optimization,labeled stamp folding,low-level computation,map folding,mapFolding,mathematical algorithms,mathematical modeling,mathematical optimization,mathematical patterns,mathematical software,mathematical tool,mathematical visualization,meander enumeration,meanders,meandric systems,memory-efficient enumeration,metaprogramming,numerical algorithms,numerical computation,open meandric systems,paper folding mathematics,parallel computing,pattern recognition,performance optimization,permutation patterns,permutations,post-setup optimization,pyproject,scientific computing,semi-meanders,sequence analysis,sequence calculator,sequence enumeration,sequence explorer,sequence generation,source code analysis,stamp folding,symbolic computation,symmetric foldings,topological combinatorics,topological patterns,typed Python
Classifier: Development Status :: 4 - Beta
Classifier: Environment :: Console
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: Science/Research
Classifier: Natural Language :: English
Classifier: Operating System :: MacOS
Classifier: Operating System :: OS Independent
Classifier: Operating System :: POSIX :: Linux
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Topic :: Scientific/Engineering :: Information Analysis
Classifier: Topic :: Scientific/Engineering :: Mathematics
Classifier: Topic :: Software Development :: Code Generators
Classifier: Topic :: Software Development :: Compilers
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Software Development :: Pre-processors
Classifier: Typing :: Typed
Requires-Python: <3.14,>=3.12
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: astToolkit>=0.9.0
Requires-Dist: cytoolz
Requires-Dist: gmpy2
Requires-Dist: hunterMakesPy>=0.3.0
Requires-Dist: more_itertools
Requires-Dist: numpy
Requires-Dist: platformdirs
Provides-Extra: development
Requires-Dist: ipykernel; extra == "development"
Requires-Dist: ipywidgets; extra == "development"
Requires-Dist: memray; sys_platform == "linux" and extra == "development"
Requires-Dist: py-spy; extra == "development"
Requires-Dist: pyarrow-stubs; extra == "development"
Requires-Dist: setuptools-scm; extra == "development"
Provides-Extra: numba
Requires-Dist: numba; extra == "numba"
Requires-Dist: numba_progress; extra == "numba"
Provides-Extra: pandas
Requires-Dist: ortools; extra == "pandas"
Requires-Dist: pandas; extra == "pandas"
Requires-Dist: pyarrow; extra == "pandas"
Provides-Extra: sympy
Requires-Dist: sympy; extra == "sympy"
Provides-Extra: testing
Requires-Dist: numba; extra == "testing"
Requires-Dist: ortools; extra == "testing"
Requires-Dist: pandas; extra == "testing"
Requires-Dist: pyarrow; extra == "testing"
Requires-Dist: pytest-cov; extra == "testing"
Requires-Dist: pytest-env; extra == "testing"
Requires-Dist: pytest-xdist; extra == "testing"
Requires-Dist: pytest; extra == "testing"
Requires-Dist: sympy; extra == "testing"
Dynamic: license-file

# mapFolding

[![pip install mapFolding](https://img.shields.io/badge/pip%20install-mapFolding-gray.svg?colorB=3b434b)](https://pypi.org/project/mapFolding/)

Map folding, meanders, stamp folding, semi-meanders. Experiment with algorithm transformations and code optimization.

I don't know how to write a README.md. Furthermore, the package used to be focused on multidimensional map folding and tools for transforming the algorithm to experiment with optimizations or to explore the algorithm.

First, the tools for transforming algorithms became far more sophisticated and powerful than this package. So I moved them to [astToolkit](https://github.com/hunterhogan/astToolkit). But those got so sophisticated, that I create more than half of that package through another layer of meta-programming: [astToolFactory](https://github.com/hunterhogan/astToolFactory).

Second, when I finally understood the connections between map folding and meanders, I added meanders to this package, and applied my transformation tools to that algorithm.

I used a weaker form of this package to [compute new terms for OEIS A001415](https://oeis.org/A001415), "Number of ways of folding a 2 X n strip of stamps."
There are cool and powerful tools in here, but as of 2025 September 17, I am dissatisfied with the organization and documentation. It's annoying.

## Finding stuff

1. At the moment, almost every algorithm version eventually runs through "mapFolding/basecamp.py", so it's sort of an overview and you can work backwards to find more details.
2. The directory "mapFolding/algorithms" only has "handmade" algorithms. Therefore, most logic for most computations is based on something in that directory.
3. The directory "mapFolding/syntheticModules" has code that is generated by the transformation tools.
4. Transformation functions are in "mapFolding/someAssemblyRequired."
5. The directory "mapFolding/reference" has "reference" materials.
6. "mapFolding/tests" has the tests, and I have tried to make it easy for you to add _your_ versions of the algorithms to the tests. Is it actually easy? I'll say it this way: if you were to create your own subclass of `ast.AST` it would be impossible for you to add your subclass to all of the `ast` module tests with just a few lines of code. In contrast, it is possible to fully test your algorithm with in my tests by adding between three and 25 lines of code. So, yeah, it's easy.

## Math and programming

I'm not a mathematician. I don't have training in or professional experience as a programmer. I'm not stupid: I'm ignorant.

## My recovery

[![Static Badge](https://img.shields.io/badge/2011_August-Homeless_since-blue?style=flat)](https://HunterThinks.com/support)
[![YouTube Channel Subscribers](https://img.shields.io/youtube/channel/subscribers/UC3Gx7kz61009NbhpRtPP7tw)](https://www.youtube.com/@HunterHogan)

[![CC-BY-NC-4.0](https://raw.githubusercontent.com/hunterhogan/mapFolding/refs/heads/main/CC-BY-NC-4.0.png)](https://creativecommons.org/licenses/by-nc/4.0/)
