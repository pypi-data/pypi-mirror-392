# mapFolding

[![pip install mapFolding](https://img.shields.io/badge/pip%20install-mapFolding-gray.svg?colorB=3b434b)](https://pypi.org/project/mapFolding/)

Map folding, meanders, stamp folding, semi-meanders. Experiment with algorithm transformations and code optimization.

I don't know how to write a README.md. Furthermore, the package used to be focused on multidimensional map folding and tools for transforming the algorithm to experiment with optimizations or to explore the algorithm.

First, the tools for transforming algorithms became far more sophisticated and powerful than this package. So I moved them to [astToolkit](https://github.com/hunterhogan/astToolkit). But those got so sophisticated, that I create more than half of that package through another layer of meta-programming: [astToolFactory](https://github.com/hunterhogan/astToolFactory).

Second, when I finally understood the connections between map folding and meanders, I added meanders to this package, and applied my transformation tools to that algorithm.

I used a weaker form of this package to [compute new terms for OEIS A001415](https://oeis.org/A001415), "Number of ways of folding a 2 X n strip of stamps."
There are cool and powerful tools in here, but as of 2025 September 17, I am dissatisfied with the organization and documentation. It's annoying.

## Finding stuff

1. At the moment, almost every algorithm version eventually runs through "mapFolding/basecamp.py", so it's sort of an overview and you can work backwards to find more details.
2. The directory "mapFolding/algorithms" only has "handmade" algorithms. Therefore, most logic for most computations is based on something in that directory.
3. The directory "mapFolding/syntheticModules" has code that is generated by the transformation tools.
4. Transformation functions are in "mapFolding/someAssemblyRequired."
5. The directory "mapFolding/reference" has "reference" materials.
6. "mapFolding/tests" has the tests, and I have tried to make it easy for you to add _your_ versions of the algorithms to the tests. Is it actually easy? I'll say it this way: if you were to create your own subclass of `ast.AST` it would be impossible for you to add your subclass to all of the `ast` module tests with just a few lines of code. In contrast, it is possible to fully test your algorithm with in my tests by adding between three and 25 lines of code. So, yeah, it's easy.

## Math and programming

I'm not a mathematician. I don't have training in or professional experience as a programmer. I'm not stupid: I'm ignorant.

## My recovery

[![Static Badge](https://img.shields.io/badge/2011_August-Homeless_since-blue?style=flat)](https://HunterThinks.com/support)
[![YouTube Channel Subscribers](https://img.shields.io/youtube/channel/subscribers/UC3Gx7kz61009NbhpRtPP7tw)](https://www.youtube.com/@HunterHogan)

[![CC-BY-NC-4.0](https://raw.githubusercontent.com/hunterhogan/mapFolding/refs/heads/main/CC-BY-NC-4.0.png)](https://creativecommons.org/licenses/by-nc/4.0/)
