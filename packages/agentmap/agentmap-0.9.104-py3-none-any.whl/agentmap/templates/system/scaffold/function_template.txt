# Auto-generated edge function for {func_name}
# Generated by AgentMap GraphScaffoldService

from typing import Dict, Any, Union, List


def {func_name}(
    state: Dict[str, Any],
    success_node = {success_code},
    failure_node = {failure_code}
) -> Union[str, List[str]]:
    """
    Edge function for graph routing with flexible node configuration.

    Parallel execution: {has_parallel}

    Args:
        state: The current graph state dictionary
        success_node: Node(s) to route to on success (default: {success_node})
        failure_node: Node(s) to route to on failure (default: {failure_node})

    Returns:
        Union[str, List[str]]: Next node(s) to execute
            - str: Single node name for sequential execution
            - List[str]: Multiple node names for parallel execution

    Node: {node_name}
    Description: {description}
    Context: {context}

    Available fields in state:
{context_fields}

    Routing Logic:
    - Return success_node when conditions are met
    - Return failure_node when conditions fail
    - Can return any valid node name for complex routing
    - Lists trigger parallel execution (all nodes run concurrently)
    """
    try:
        # TODO: IMPLEMENT YOUR ROUTING LOGIC HERE

        # Access state fields for routing decisions
        last_action_success = state.get("last_action_success", True)
        error = state.get("error")

        # Example routing logic (REPLACE WITH YOUR IMPLEMENTATION):

        # Simple success/failure routing
        if error or not last_action_success:
            next_node = failure_node

            # Log routing decision
            if isinstance(next_node, list):
                print(f"[{func_name}] Routing to parallel failure targets: {{{{next_node}}}}")
            else:
                print(f"[{func_name}] Routing to failure: {{{{next_node}}}}")

            return next_node

        # Add your custom routing conditions here:
        #
        # Example: Route based on data content
        # if state.get("user_input", "").lower().startswith("combat"):
        #     return "CombatTurn"
        # elif state.get("user_input", "").lower().startswith("talk"):
        #     return "SocialEncounter"
        #
        # Example: Route based on processing results
        # result = state.get("{output_field}")
        # if result and result.get("confidence", 0) > 0.8:
        #     return success_node
        # else:
        #     return "NeedsReview"
        #
        # Example: Conditional routing with multiple outcomes
        # priority = state.get("priority", "normal")
        # if priority == "urgent":
        #     return "UrgentHandler"
        # elif priority == "low":
        #     return "BatchProcessor"

        # Default: route to success
        next_node = success_node

        # Log routing decision
        if isinstance(next_node, list):
            print(f"[{func_name}] Routing to parallel success targets: {{{{next_node}}}}")
        else:
            print(f"[{func_name}] Routing to success: {{{{next_node}}}}")

        return next_node

    except Exception as e:
        # Log error and route to failure node
        print(f"Error in {func_name}: {{{{e}}}}")

        # Optionally store error in state for debugging
        if isinstance(state, dict):
            state["routing_error"] = str(e)
            state["last_action_success"] = False

        return failure_node


# ===== ROUTING CONFIGURATION =====
# Success route: {success_node}
# Failure route: {failure_node}
# Parallel execution: {has_parallel}
#
# Routing patterns you can implement:
# 1. Simple Success/Failure: Check last_action_success flag
# 2. Content-Based: Route based on data content or type
# 3. Conditional: Multiple conditions with different outcomes
# 4. State-Based: Route based on accumulated state
# 5. Dynamic: Calculate route based on complex logic
# 6. Parallel: Return list of nodes for concurrent execution
#
# PARALLEL EXECUTION NOTES:
# - When returning a list, LangGraph executes all nodes concurrently
# - Each parallel node should write to a unique output field
# - LangGraph synchronizes state after all parallel nodes complete
# - State updates from parallel nodes are merged automatically
