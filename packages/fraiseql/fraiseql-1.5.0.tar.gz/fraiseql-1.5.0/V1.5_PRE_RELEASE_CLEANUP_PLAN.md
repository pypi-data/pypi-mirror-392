# FraiseQL v1.5 Pre-Release Cleanup Plan

**Status**: Planning Phase
**Target**: Clean up test infrastructure and cascade implementation before v1.5 release
**Date**: 2025-11-14

## Executive Summary

Before releasing v1.5, we need to address two key areas:
1. **Test Infrastructure Cleanup**: Remove outdated `_v2` suffixes from Rust pipeline test files
2. **Cascade Tests**: Complete implementation and enable skipped cascade tests

## Current State Analysis

### Rust Pipeline Naming Issues

**Problem**: Legacy `_v2` suffixes in test files create confusion and imply there are multiple versions when there's only one production implementation.

**Source Code** (Clean ✅):
- `src/fraiseql/core/rust_pipeline.py` - Main production module

**Test Files** (Needs Cleanup ❌):
- `tests/unit/core/test_rust_pipeline_v2.py` - Has `_v2` suffix (should be `test_rust_pipeline.py`)
- `tests/unit/core/test_rust_transformer_v2.py` - Has `_v2` suffix (should be `test_rust_transformer.py`)
- `tests/unit/core/test_rust_pipeline_schema_type.py` - Clean name ✅

**Skipped Tests in test_rust_pipeline_v2.py**:
- Line 117: `test_build_graphql_response_with_projection` - Field projection not implemented in schema-aware path
- Line 197: `test_build_graphql_response_with_nested_object_aliases` - Schema registry singleton issue

### Cascade Implementation Status

**Source Code** (Complete ✅):
- `src/fraiseql/mutations/mutation_decorator.py` - Has `enable_cascade` parameter
- `src/fraiseql/mutations/cascade_selections.py` - Field selection parser for cascade data
- `src/fraiseql/mutations/types.py` - Cascade type definitions

**Test Files** (Incomplete ❌):
- `tests/integration/test_graphql_cascade.py` - Contains 9 test functions, mostly stubbed
- `tests/fixtures/cascade/conftest.py` - Basic fixtures defined but incomplete

**Test Status**:
- `test_cascade_end_to_end` - Fully defined but needs database setup
- `test_cascade_with_error_response` - Fully defined but needs database setup
- `test_cascade_large_payload` - Stubbed (async, needs implementation)
- `test_cascade_disabled_by_default` - Stubbed (no assertions)
- `test_cascade_malformed_data_handling` - Stubbed (no implementation)
- `test_apollo_client_cascade_integration` - Defined with mocks ✅
- `test_cascade_data_validation` - Defined with validation function ✅

## Implementation Plan

### Phase 1: Rust Pipeline Test Cleanup

**Objective**: Remove `_v2` suffixes and address skipped tests

#### Phase 1.1: Rename Test Files

**Tasks**:
1. Rename `tests/unit/core/test_rust_pipeline_v2.py` → `test_rust_pipeline.py`
2. Rename `tests/unit/core/test_rust_transformer_v2.py` → `test_rust_transformer.py`
3. Update any import references in other test files
4. Update test documentation/comments that reference `_v2`

**Files to Check for References**:
- `pyproject.toml` - Test configurations
- `CHANGELOG.md` - Historical references
- `dev/releases/*.md` - Release plans
- Documentation files in `docs/rust/`

**Commands**:
```bash
# Rename test files
git mv tests/unit/core/test_rust_pipeline_v2.py tests/unit/core/test_rust_pipeline.py
git mv tests/unit/core/test_rust_transformer_v2.py tests/unit/core/test_rust_transformer.py

# Find any references to update
grep -r "test_rust_pipeline_v2" --include="*.py" --include="*.md"
grep -r "test_rust_transformer_v2" --include="*.py" --include="*.md"
```

#### Phase 1.2: Address Skipped Tests

**Test 1**: `test_build_graphql_response_with_projection` (Line 117)

**Skip Reason**: "Field projection with field_paths not implemented in schema-aware path"

**Options**:
- Option A: Keep skipped with updated comment explaining this is a known limitation
- Option B: Remove test entirely if feature won't be implemented
- Option C: Implement field projection in fraiseql_rs

**Recommendation**: Option A - Keep skipped with clear documentation that `field_selections` with aliases should be used instead of `field_paths` for projection.

**Action**:
```python
@pytest.mark.skip(
    reason="Legacy field_paths projection not supported in schema-aware pipeline. "
    "Use field_selections with aliases instead. See docs/rust/RUST_FIELD_PROJECTION.md"
)
```

---

**Test 2**: `test_build_graphql_response_with_nested_object_aliases` (Line 197)

**Skip Reason**: "Schema registry singleton - only one initialization per process"

**Root Cause**: `init_schema_registry` fixture runs at module scope but can only be initialized once per process. When tests run in parallel or in same session, the second initialization fails.

**Options**:
- Option A: Change fixture to handle "already initialized" as success
- Option B: Use test isolation (run test in separate process)
- Option C: Add schema registry reset capability for tests

**Recommendation**: Option A + improve fixture

**Action**:
```python
# In test file, update fixture to be more permissive
@pytest.fixture(scope="module", autouse=True)
def init_schema_registry() -> None:
    """Initialize schema registry for tests that need it."""
    schema_ir = {...}

    try:
        result = fraiseql_rs.initialize_schema_registry(json.dumps(schema_ir))
        print(f"Schema registry initialization result: {result}")
    except RuntimeError as e:
        # Registry already initialized - this is OK in test sessions
        if "already initialized" in str(e):
            print("Schema registry already initialized (expected in test session)")
            return  # Success - proceed with test
        else:
            raise  # Different error - fail
```

**Then unskip the test** and add pytest isolation marker:
```python
@pytest.mark.forked  # Run in isolated process if needed
def test_build_graphql_response_with_nested_object_aliases() -> None:
    """Test field selections with nested object aliases."""
    # ... rest of test
```

### Phase 2: Cascade Test Implementation

**Objective**: Complete cascade test implementation and enable all tests

#### Phase 2.1: Database Setup and Fixtures

**Current Issues**:
- `cascade_app` fixture uses hardcoded database URL
- No actual database schema setup in fixtures
- Tests need `tb_user` and `tb_post` tables (referenced in test_graphql_cascade.py)

**Actions**:

1. **Update conftest.py to use proper database setup**:
```python
# tests/fixtures/cascade/conftest.py

@pytest_asyncio.fixture
async def cascade_db_schema(db_connection):
    """Set up cascade test database schema."""
    await db_connection.execute("""
        CREATE TABLE IF NOT EXISTS tb_user (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            post_count INTEGER DEFAULT 0
        );

        CREATE TABLE IF NOT EXISTS tb_post (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            content TEXT,
            author_id TEXT REFERENCES tb_user(id)
        );

        -- PostgreSQL function for cascade mutation
        CREATE OR REPLACE FUNCTION create_post(
            p_title TEXT,
            p_content TEXT,
            p_author_id TEXT
        ) RETURNS JSONB AS $$
        DECLARE
            v_post_id TEXT;
            v_cascade JSONB;
        BEGIN
            -- Validate input
            IF p_title = '' THEN
                RETURN jsonb_build_object(
                    'code', 'VALIDATION_ERROR',
                    'message', 'Title cannot be empty'
                );
            END IF;

            -- Check if user exists
            IF NOT EXISTS (SELECT 1 FROM tb_user WHERE id = p_author_id) THEN
                RETURN jsonb_build_object(
                    'code', 'VALIDATION_ERROR',
                    'message', 'Author not found'
                );
            END IF;

            -- Create post
            v_post_id := 'post-' || gen_random_uuid()::text;

            INSERT INTO tb_post (id, title, content, author_id)
            VALUES (v_post_id, p_title, p_content, p_author_id);

            -- Update user post count
            UPDATE tb_user
            SET post_count = post_count + 1
            WHERE id = p_author_id;

            -- Build cascade data
            v_cascade := jsonb_build_object(
                'updated', jsonb_build_array(
                    jsonb_build_object(
                        '__typename', 'Post',
                        'id', v_post_id,
                        'operation', 'CREATED',
                        'entity', jsonb_build_object(
                            'id', v_post_id,
                            'title', p_title,
                            'content', p_content,
                            'author_id', p_author_id
                        )
                    ),
                    jsonb_build_object(
                        '__typename', 'User',
                        'id', p_author_id,
                        'operation', 'UPDATED',
                        'entity', (
                            SELECT jsonb_build_object(
                                'id', id,
                                'name', name,
                                'post_count', post_count
                            )
                            FROM tb_user WHERE id = p_author_id
                        )
                    )
                ),
                'deleted', jsonb_build_array(),
                'invalidations', jsonb_build_array(
                    jsonb_build_object(
                        'queryName', 'posts',
                        'strategy', 'INVALIDATE',
                        'scope', 'PREFIX'
                    )
                ),
                'metadata', jsonb_build_object(
                    'timestamp', NOW()::text,
                    'affectedCount', 2
                )
            );

            -- Return success with cascade
            RETURN jsonb_build_object(
                'id', v_post_id,
                'message', 'Post created successfully',
                '_cascade', v_cascade
            );
        END;
        $$ LANGUAGE plpgsql;
    """)

    yield

    # Cleanup
    await db_connection.execute("""
        DROP FUNCTION IF EXISTS create_post;
        DROP TABLE IF EXISTS tb_post;
        DROP TABLE IF EXISTS tb_user;
    """)


@pytest_asyncio.fixture
async def cascade_app(cascade_db_schema, db_connection) -> AsyncGenerator[FastAPI, None]:
    """FastAPI app configured with cascade mutations."""
    app = create_fraiseql_app(
        types=[CreatePostInput, Post, User, CreatePostSuccess, CreatePostError],
        database_url=db_connection.info.dsn,  # Use actual test DB
    )

    yield app
```

2. **Connect to existing database fixtures** - Use `db_connection` from `tests/fixtures/database/database_conftest.py`

#### Phase 2.2: Complete Stubbed Tests

**Test 1**: `test_cascade_large_payload` (Line 194)

**Current State**: Stubbed async test with TODO comment

**Implementation**:
```python
@pytest.mark.asyncio
async def test_cascade_large_payload(cascade_client, cascade_db_schema, db_connection):
    """Test cascade with multiple entities and operations."""
    # Create multiple users and posts for complex cascade
    await db_connection.execute("""
        INSERT INTO tb_user (id, name, post_count)
        VALUES
            ('user-1', 'User 1', 0),
            ('user-2', 'User 2', 0),
            ('user-3', 'User 3', 0)
    """)

    # Create posts from different users
    mutation_query = """
    mutation CreatePost($input: CreatePostInput!) {
        createPost(input: $input) {
            id
            cascade {
                updated { __typename id operation }
                metadata { affectedCount }
            }
        }
    }
    """

    # Create multiple posts
    for i in range(1, 4):
        variables = {
            "input": {
                "title": f"Post {i}",
                "content": f"Content {i}",
                "author_id": f"user-{i}"
            }
        }

        response = cascade_client.post(
            "/graphql",
            json={"query": mutation_query, "variables": variables}
        )

        assert response.status_code == 200
        data = response.json()
        assert "data" in data

        cascade = data["data"]["createPost"]["cascade"]
        assert cascade["metadata"]["affectedCount"] == 2  # Post + User
```

---

**Test 2**: `test_cascade_disabled_by_default` (Line 209)

**Current State**: Decorator defined but no assertions

**Implementation**:
```python
def test_cascade_disabled_by_default(db_connection):
    """Test that cascade is not included when enable_cascade=False."""
    from fraiseql import FraiseQL
    from fraiseql.mutations import mutation

    # Define mutation with cascade disabled
    @mutation(enable_cascade=False)
    class CreatePostNoCascade:
        input: CreatePostInput
        success: CreatePostSuccess
        error: CreatePostError

    # Build GraphQL schema
    app = FraiseQL(
        types=[CreatePostInput, CreatePostSuccess, CreatePostError, Post],
        mutations=[CreatePostNoCascade],
        database_url=db_connection.info.dsn
    )

    # Check GraphQL schema
    schema_str = str(app.schema)

    # The CreatePostSuccess type should NOT have cascade field
    # when enable_cascade=False
    assert "cascade" not in schema_str.lower() or \
           "CreatePostNoCascadeSuccess" not in schema_str

    # Verify mutation definition
    mutation_def = next(
        (m for m in app.mutations if m.name == "CreatePostNoCascade"),
        None
    )
    assert mutation_def is not None
    assert mutation_def.enable_cascade is False
```

---

**Test 3**: `test_cascade_malformed_data_handling` (Line 222)

**Current State**: Only docstring, no implementation

**Implementation**:
```python
def test_cascade_malformed_data_handling(cascade_client, cascade_db_schema, db_connection):
    """Test handling of malformed cascade data from PostgreSQL."""
    # Create a function that returns malformed cascade JSON
    await db_connection.execute("""
        CREATE OR REPLACE FUNCTION create_post_malformed(
            p_title TEXT,
            p_content TEXT,
            p_author_id TEXT
        ) RETURNS JSONB AS $$
        BEGIN
            -- Return malformed cascade (missing required fields)
            RETURN jsonb_build_object(
                'id', 'post-123',
                'message', 'Post created',
                '_cascade', jsonb_build_object(
                    'updated', 'not-an-array',  -- Invalid: should be array
                    'invalidations', null       -- Invalid: should be array
                )
            );
        END;
        $$ LANGUAGE plpgsql;
    """)

    mutation_query = """
    mutation CreatePost($input: CreatePostInput!) {
        createPost(input: $input) {
            id
            cascade {
                updated
                invalidations
            }
        }
    }
    """

    variables = {
        "input": {"title": "Test", "content": "Test", "author_id": "user-1"}
    }

    response = cascade_client.post(
        "/graphql",
        json={"query": mutation_query, "variables": variables}
    )

    # Should not crash - should return error or omit cascade
    assert response.status_code == 200
    data = response.json()

    # Either cascade is omitted or an error is returned
    assert "data" in data or "errors" in data

    # If cascade is present, it should be null or properly structured
    if "data" in data and data["data"]["createPost"]:
        cascade = data["data"]["createPost"].get("cascade")
        if cascade is not None:
            # Should have proper structure despite malformed input
            assert isinstance(cascade.get("updated", []), list)
```

#### Phase 2.3: Integration with Existing Infrastructure

**Required Changes**:

1. **Ensure mutation resolver handles cascade**: Check `src/fraiseql/mutations/mutation_decorator.py` resolver code

2. **Verify cascade type generation**: Check `src/fraiseql/mutations/types.py` generates proper GraphQL types

3. **Test with real PostgreSQL functions**: Ensure `_cascade` field in function return is properly parsed

### Phase 3: Test Suite Verification

**Objective**: Ensure all changes integrate properly and don't break existing tests

#### Phase 3.1: Run Test Subsets

```bash
# Test renamed pipeline files
pytest tests/unit/core/test_rust_pipeline.py -v
pytest tests/unit/core/test_rust_transformer.py -v

# Test cascade implementation
pytest tests/integration/test_graphql_cascade.py -v

# Run all unit tests
pytest tests/unit/ -v

# Run all integration tests
pytest tests/integration/ -v
```

#### Phase 3.2: Full Test Suite

```bash
# Run complete test suite
pytest --tb=short -v

# Check coverage
pytest --cov=src/fraiseql --cov-report=term-missing

# Run with specific markers
pytest -m "not slow" -v
```

#### Phase 3.3: CI/CD Verification

**Files to Check**:
- `.github/workflows/*.yml` - CI configurations
- `pyproject.toml` - Test configurations

**Verify**:
- All test paths updated
- No references to `_v2` test files
- Cascade tests included in appropriate test suites

## Success Criteria

### Phase 1 Success Criteria
- [ ] `test_rust_pipeline_v2.py` renamed to `test_rust_pipeline.py`
- [ ] `test_rust_transformer_v2.py` renamed to `test_rust_transformer.py`
- [ ] No references to `_v2` test files remain in codebase
- [ ] Skipped tests either unskipped with fixes or documented with clear skip reasons
- [ ] All unit tests pass: `pytest tests/unit/core/test_rust_*.py -v`

### Phase 2 Success Criteria
- [ ] Database fixtures properly set up for cascade tests
- [ ] PostgreSQL `create_post` function implemented with cascade return
- [ ] All 9 cascade tests fully implemented (no stubs)
- [ ] `test_cascade_end_to_end` passes
- [ ] `test_cascade_with_error_response` passes
- [ ] `test_cascade_large_payload` passes
- [ ] `test_cascade_disabled_by_default` passes
- [ ] `test_cascade_malformed_data_handling` passes
- [ ] Mock-based tests pass (Apollo client integration, data validation)

### Phase 3 Success Criteria
- [ ] Full test suite passes: `pytest --tb=short`
- [ ] No new test failures introduced
- [ ] Code coverage maintained or improved
- [ ] CI/CD pipelines pass
- [ ] Documentation updated (if needed)

## Risk Assessment

### Low Risk
- Renaming test files (git tracks renames)
- Updating skip messages
- Implementing stubbed tests

### Medium Risk
- Unskipping tests that were skipped for valid reasons
- Schema registry singleton handling
- Database fixture integration

### High Risk
- Changes to cascade implementation in source code (if needed)
- PostgreSQL function complexity
- Test flakiness due to database state

## Rollback Plan

If issues arise:

1. **Phase 1 Rollback**:
   ```bash
   git mv tests/unit/core/test_rust_pipeline.py tests/unit/core/test_rust_pipeline_v2.py
   git mv tests/unit/core/test_rust_transformer.py tests/unit/core/test_rust_transformer_v2.py
   git restore tests/unit/core/test_rust_pipeline_v2.py
   git restore tests/unit/core/test_rust_transformer_v2.py
   ```

2. **Phase 2 Rollback**:
   - Re-skip newly unskipped tests
   - Remove new test implementations
   - Restore fixtures to previous state

3. **Full Rollback**:
   ```bash
   git reset --hard HEAD~N  # Where N is number of commits
   ```

## Timeline Estimate

- **Phase 1**: 2-3 hours
  - File renaming: 30 minutes
  - Reference updates: 30 minutes
  - Test fixes: 1-2 hours

- **Phase 2**: 4-6 hours
  - Database fixtures: 2 hours
  - Test implementation: 2-3 hours
  - Integration: 1 hour

- **Phase 3**: 1-2 hours
  - Test runs: 30 minutes
  - CI/CD verification: 30 minutes
  - Documentation: 30 minutes

**Total**: 7-11 hours

## Next Steps

1. Review and approve this plan
2. Create feature branch: `feat/v1.5-pre-release-cleanup`
3. Execute Phase 1
4. Execute Phase 2
5. Execute Phase 3
6. Create PR with detailed changelog
7. Merge after CI/CD passes

## References

- [Rust Pipeline Implementation Guide](docs/rust/RUST_PIPELINE_IMPLEMENTATION_GUIDE.md)
- [Mutation Decorator Documentation](src/fraiseql/mutations/mutation_decorator.py)
- [Cascade Selections Parser](src/fraiseql/mutations/cascade_selections.py)
- [Test Fixtures](tests/fixtures/)

---

*This plan follows the FraiseQL development methodology with phased approach and comprehensive testing.*
