# Migration Guide: v1.0.0-alpha5

> Concise migration reference for v1.0.0-alpha4 → v1.0.0-alpha5

**Status**: Pre-release
**Breaking Changes**: 13 changes across Pile, Flow, Progression, protocols

---

## Quick Reference

| Component | Change | Migration |
|-----------|--------|-----------|
| **Pile.item_type/strict_type** | Frozen fields | Set at init: `Pile(item_type=T, strict_type=True)` |
| **Pile.include/exclude** | Return semantics | True = guaranteed state (not action taken) |
| **Pile.items** | Property → method | `pile.items()` not `pile.items` |
| **Pile.keys()** | Generator → iterator | No change needed |
| **Pile async methods** | Removed | Use sync: `pile.add()` not `await pile.add_async()` |
| **Pile.to_list** | Removed | Use `list(pile)` |
| **Progression.**init**** | Removed custom init | No change needed (field validator handles it) |
| **Progression validation** | Stricter | Ensure valid UUIDs only |
| **Progression.**bool**** | Added | Use `if not prog:` instead of `if len(prog) == 0:` |
| **Progression.pop/popleft** | IndexError → NotFoundError, `default` param added | Update exception handling or use `default` |
| **Flow.**init**** | New progressions param | `Flow(progressions=[...])` |
| **Flow validation** | Referential integrity | Progression UUIDs must exist in items |
| **Flow.add_item** | Parameter rename | `progressions` not `progression_ids` |
| **Flow.remove_item** | Always removes from progressions | Remove `remove_from_progressions` param |
| **@implements()** | Strict enforcement | Define methods in class body |
| **Adaptable protocols** | Split read/write | Use `AdapterRegisterable` for registry ops |

---

## Pile Changes

### 1. Frozen Type Configuration

```python
# Before: pile.item_type = {Node}
# After:  Pile(item_type=Node, strict_type=True)
```

### 2. include/exclude Return Semantics

```python
# Before: True = action taken (added/removed)
# After:  True = guaranteed state (in pile / not in pile)
if pile.include(item):  # Idempotent - True both times
    process(item)
```

### 3. Dict-like Iteration

```python
# Before: pile.items → MappingProxyType
# After:  pile.items() → iterator of (uuid, item) tuples
# Also:   pile.keys() → iterator, pile.values() → iterator
for uuid, item in pile.items():
    process(uuid, item)
```

### 4. Removed Async Methods

```python
# Before: await pile.add_async(item)
# After:  pile.add(item)  # Synchronous (CPU-bound)
```

### 5. Removed to_list() Method

```python
# Before: pile.to_list()
# After:  list(pile)
```

---

## Progression Changes

### 6. Custom **init** Removed

Field validators now handle UUID coercion. No migration needed unless relying on silent invalid item dropping.

```python
# Now raises ValidationError for invalid items:
Progression(order=[uuid1, "invalid"])  # ValidationError
```

### 7. **bool**() Protocol Added

```python
# Before: if len(prog) == 0:
# After:  if not prog:
```

### 8. IndexError → NotFoundError + pop(default=...) Parameter

**Exception Change:**

```python
# Before: except IndexError
# After:  except NotFoundError
from lionherd_core.errors import NotFoundError
```

**New default Parameter (Graceful Handling):**

```python
# Before:
try:
    item = prog.pop(0)
except IndexError:
    item = None

# After (Option 1 - with default):
item = prog.pop(0, default=None)  # Returns None if empty, no exception

# After (Option 2 - with NotFoundError):
try:
    item = prog.pop(0)
except NotFoundError:
    item = None
```

---

## Flow Changes

### 9. Constructor Redesign

```python
# Before: flow.add_progression(prog)
# After:  Flow(progressions=[prog])
```

### 10. Referential Integrity Validation

Progression UUIDs must exist in items pile at construction.

```python
# Raises NotFoundError if progression contains non-existent UUIDs
flow = Flow(items=[item1, item2], progressions=[prog])
```

### 11. add_item Parameter Renamed

```python
# Before: flow.add_item(item, progression_ids="pending")
# After:  flow.add_item(item, progressions="pending")
```

### 12. remove_item Always Removes from Progressions

```python
# Before: flow.remove_item(id, remove_from_progressions=False)
# After:  flow.remove_item(id)  # Always removes from pile AND progressions
```

---

## Protocol Changes

### 13. @implements() Strict Enforcement

Must define protocol methods in class body (not inherited).

```python
# Before: @implements(Serializable) on class inheriting to_dict()
# After:  Define to_dict() in class or call super().to_dict()

@implements(Serializable)
class MyClass(Parent):
    def to_dict(self, **kwargs):
        return super().to_dict(**kwargs)  # Explicit definition
```

### 14. Adaptable Protocol Split

`Adaptable` (read-only) split from `AdapterRegisterable` (read/write).

```python
# Read-only: @implements(Adaptable)
# Registry ops: @implements(Adaptable, AdapterRegisterable)
```

---

## Testing Recommendations

Run tests after migration to catch:

- Frozen field mutations → ValidationError
- include/exclude logic inversions
- Missing async→sync conversions
- IndexError→NotFoundError exception handling
- Missing protocol method definitions

```bash
pytest tests/ -v
```

---

## FAQ

**Q: Why frozen fields?**
A: Prevent runtime type confusion. Configuration changes after init invalidate existing items.

**Q: Why change include/exclude semantics?**
A: Idempotent operations should return final state (guaranteed membership), not action taken.

**Q: Why remove async methods?**
A: Pile operations are CPU-bound (dict/list ops). Async overhead adds latency without benefit.

**Q: Why strict @implements()?**
A: Prevent false protocol compliance from inherited methods. Classes must explicitly implement protocols.

**Q: Can I keep old code working?**
A: No - these are breaking changes. Migration required for alpha5+.

---

_See full [CHANGELOG](../../CHANGELOG.md) for complete release notes and rationale._
