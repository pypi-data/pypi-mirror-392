# This file was generated by Nuitka

# Stubs included by default
from __future__ import annotations
from pyproj import CRS, Transformer
from typing import Any, List, Optional, Tuple, Union
from typing_extensions import Self
import numpy
import warnings

def normalize_angle(angle: float) -> float:
    ...

def _normalize_order(order: str) -> str:
    ...

def _euler_to_rotation_matrix_by_order(roll: float, pitch: float, yaw: float, order: str) -> np.ndarray:
    ...

def _rotation_matrix_to_euler_by_order(R: np.ndarray, order: str) -> Tuple[float, float, float]:
    ...

def geosun_euler_to_rotation_matrix(roll: float, pitch: float, yaw: float, order: str) -> np.ndarray:
    ...

def rotation_matrix_to_geosun_euler(R: np.ndarray, order: str) -> Tuple[float, float, float]:
    ...

def standard_euler_to_rotation_matrix(roll: float, pitch: float, yaw: float, order: str) -> np.ndarray:
    ...

def rotation_matrix_to_standard_euler(R: np.ndarray, order: str) -> Tuple[float, float, float]:
    ...

def rotation_matrix_to_quaternion(R: np.ndarray) -> np.ndarray:
    ...

def quaternion_to_rotation_matrix(q: Union[list, np.ndarray]) -> np.ndarray:
    ...

def rotation_matrix_to_axis_angle(R: np.ndarray) -> Tuple[np.ndarray, float]:
    ...

def axis_angle_to_rotation_matrix(axis: np.ndarray, angle: float) -> np.ndarray:
    ...

def geosun_euler_to_quaternion(roll: float, pitch: float, yaw: float, order: str) -> np.ndarray:
    ...

def quaternion_to_geosun_euler(q: Union[list, np.ndarray], order: str) -> Tuple[float, float, float]:
    ...

def geosun_euler_to_axis_angle(roll: float, pitch: float, yaw: float, order: str) -> Tuple[np.ndarray, float]:
    ...

def axis_angle_to_geosun_euler(axis: np.ndarray, angle: float, order: str) -> Tuple[float, float, float]:
    ...

def standard_euler_to_quaternion(roll: float, pitch: float, yaw: float, order: str) -> np.ndarray:
    ...

def quaternion_to_standard_euler(q: Union[list, np.ndarray], order: str) -> Tuple[float, float, float]:
    ...

def standard_euler_to_axis_angle(roll: float, pitch: float, yaw: float, order: str) -> Tuple[np.ndarray, float]:
    ...

def axis_angle_to_standard_euler(axis: np.ndarray, angle: float, order: str) -> Tuple[float, float, float]:
    ...

class ExtrinsicParam:
    def __init__(self: Self, euler: Optional[Union[list, np.ndarray]], translation: Optional[Union[list, np.ndarray]], rotation_matrix: Optional[np.ndarray], axis_angle: Optional[Tuple[np.ndarray, float]], quaternion: Optional[Union[list, np.ndarray]], euler_type: str, euler_order: str) -> None: ...
    @classmethod
    def from_homogeneous_matrix(cls, T: np.ndarray, euler_order: str) -> 'ExtrinsicParam': ...
    def __matmul__(self: Self, other: 'ExtrinsicParam') -> 'ExtrinsicParam': ...
    def inverse(self: Self) -> 'ExtrinsicParam': ...
    def transform_point(self: Self, point: Union[list, np.ndarray]) -> np.ndarray: ...
    def inverse_transform_point(self: Self, point: Union[list, np.ndarray]) -> np.ndarray: ...
    def get_homogeneous_matrix(self: Self) -> np.ndarray: ...
    def get_axis_angle(self: Self) -> Tuple[np.ndarray, float]: ...
    def get_axis_angle_degrees(self: Self) -> Tuple[np.ndarray, float]: ...
    def get_quaternion(self: Self) -> np.ndarray: ...
    def get_geosun_euler(self: Self, order: Optional[str]) -> np.ndarray: ...
    def get_standard_euler(self: Self, order: Optional[str]) -> np.ndarray: ...
    def __repr__(self: Self) -> str: ...

class CoordinateConverter:
    def __init__(self: Self, central_meridian: float, ellipsoid: str, datum: str, projection_type: str, false_easting: float, false_northing: float) -> None: ...
    def enh_to_ecef(self: Self, enh_point: Union[list, np.ndarray]) -> np.ndarray: ...
    def ecef_to_enh(self: Self, ecef_point: Union[list, np.ndarray]) -> np.ndarray: ...

def interpolate_pos(pos_data: List[Tuple], gps_time: float, euler_type: str, euler_order: str) -> ExtrinsicParam:
    ...

def enh_to_lidar(enh_point: np.ndarray, gps_time: float, lidar_to_imu: ExtrinsicParam, pos_data: List[Tuple], converter: CoordinateConverter, euler_type: str, euler_order: str) -> np.ndarray:
    ...

def lidar_to_enh(lidar_point: np.ndarray, gps_time: float, lidar_to_imu: ExtrinsicParam, pos_data: List[Tuple], converter: CoordinateConverter, euler_type: str, euler_order: str) -> np.ndarray:
    ...


__name__ = ...



# Modules used internally, to allow implicit dependencies to be seen:
import numpy
import pyproj
import typing
import warnings